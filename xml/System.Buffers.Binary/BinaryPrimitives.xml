<Type Name="BinaryPrimitives" FullName="System.Buffers.Binary.BinaryPrimitives">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f59ffbb92a40fe77eb8c36cd019c72866de825f3" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102085100" /></Metadata><TypeSignature Language="C#" Value="public static class BinaryPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BinaryPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.Binary.BinaryPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryPrimitives" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryPrimitives abstract sealed" />
  <TypeSignature Language="F#" Value="type BinaryPrimitives = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="9bf21-101">将字节读取为具有特定字节序的基元。</span><span class="sxs-lookup"><span data-stu-id="9bf21-101">Reads bytes as primitives with specific endianness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-102">如果需要读取特定的字节序，请使用这些帮助程序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-102">Use these helpers when you need to read specific endianness.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleBigEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-103">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-103">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-104">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-104">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-105">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-105">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-106">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-106">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-107"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-107"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-108">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-108">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-109">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-109">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-110">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-110">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-111">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-111">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-112"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-112"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16BigEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-113">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-113">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-114">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-114">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-115">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-115">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-116">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-116">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-117"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-117"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-118">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-118">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-119">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-119">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-120">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-120">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-121">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-121">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-122"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-122"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32BigEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-123">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-123">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-124">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-124">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-125">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-125">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-126">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-126">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-127"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-127"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-128">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-128">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-129">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-129">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-130">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-130">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-131">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-131">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-132"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-132"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64BigEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-133">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-133">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-134">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-134">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-135">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-135">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-136">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-136">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-137"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-137"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-138">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-138">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-139">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-139">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-140">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-140">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-141">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-141">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-142"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-142"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleBigEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-143">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-143">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-144">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-144">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-145">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-145">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-146">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-146">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-147"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-147"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleLittleEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-148">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-148">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-149">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-149">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-150">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-150">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-151">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-151">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-152"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-152"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16BigEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-153">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-153">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-154">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-154">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-155">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-155">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-156">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-156">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-157"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-157"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-158">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-158">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-159">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-159">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-160">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-160">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-161">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-161">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-162"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-162"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32BigEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-163">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="9bf21-163">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-164">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-164">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-165">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-165">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-166">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-166">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-167"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-167"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-168">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-168">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-169">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-169">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-170">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-170">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-171">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-171">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-172"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-172"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64BigEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-173">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-173">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-174">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-174">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-175">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-175">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-176">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-176">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-177"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-177"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-178">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-178">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="9bf21-179">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-179">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-180">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-180">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-181">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-181">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-182"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-182"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static byte ReverseEndianness (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReverseEndianness(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReverseEndianness(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : byte -&gt; byte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-183">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-183">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-184">对指定 <see cref="T:System.Byte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.Byte" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-184">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Byte" /> value, which effectively does nothing for a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="9bf21-185">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-185">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-186">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="9bf21-186">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static short ReverseEndianness (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReverseEndianness(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReverseEndianness(short value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int16 -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-187">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-187">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-188">对指定 <see cref="T:System.Int16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-188">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int16" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-189">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-189">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static int ReverseEndianness (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReverseEndianness(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReverseEndianness(int value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-190">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-190">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-191">对指定 <see cref="T:System.Int32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-191">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int32" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-192">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-192">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static long ReverseEndianness (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReverseEndianness(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReverseEndianness(long value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int64 -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-193">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-193">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-194">对指定 <see cref="T:System.Int64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-194">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int64" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-195">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-195">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static sbyte ReverseEndianness (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ReverseEndianness(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ReverseEndianness(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : sbyte -&gt; sbyte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-196">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-196">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-197">对指定 <see cref="T:System.SByte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.SByte" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-197">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.SByte" /> value, which effectively does nothing for an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="9bf21-198">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-198">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-199">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="9bf21-199">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ushort ReverseEndianness (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReverseEndianness(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReverseEndianness(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint16 -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-200">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-200">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-201">对指定 <see cref="T:System.UInt16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-201">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt16" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-202">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-202">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static uint ReverseEndianness (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReverseEndianness(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReverseEndianness(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint32 -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-203">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-203">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-204">对指定 <see cref="T:System.UInt32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-204">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt32" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-205">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-205">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ulong ReverseEndianness (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReverseEndianness(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReverseEndianness(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint64 -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9bf21-206">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-206">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="9bf21-207">对指定 <see cref="T:System.UInt64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-207">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt64" /> value.</span></span></summary>
        <returns><span data-ttu-id="9bf21-208">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-208">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-209">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-209">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-210">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-210">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-211">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-211">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-212">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-212"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-213">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-213">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-214">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-214">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-215">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-215">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-216">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-216">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-217">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-217"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-218">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-218">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-219">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-219">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-220">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-220">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-221">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-221">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-222">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-222"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-223">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-223">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-224">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-224">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-225">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-225">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-226">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-226">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-227">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-227"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-228">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-228">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-229">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-229">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-230">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-230">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-231">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-231">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-232">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-232"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-233">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-233">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-234">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-234">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-235">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-235">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-236">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-236">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-237">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-237"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-238">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-238">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-239">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-239">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-240">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-240">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-241">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-241">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-242">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-242"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-243">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-243">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-244">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-244">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-245">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-245">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-246">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-246">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-247">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-247"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-248">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-248">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-249">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-249">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-250">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-250">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-251">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-251">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-252">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-252"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-253">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-253">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-254">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-254">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-255">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-255">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-256">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-256">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-257">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-257"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-258">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-258">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-259">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-259">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-260">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-260">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-261">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-261">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-262">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-262"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-263">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-263">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-264">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-264">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-265">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-265">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-266">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-266">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-267">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-267"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-268">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-268">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-269">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-269">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-270">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-270">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-271">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-271">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-272">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-272"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-273">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-273">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-274">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-274">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-275">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-275">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-276">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-276">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-277">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-277"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-278">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-278">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-279">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-279">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-280">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-280">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-281">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-281">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-282">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-282"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-283">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-283">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="9bf21-284">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-284">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-285">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="9bf21-285">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="9bf21-286">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="9bf21-286">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-287">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-287"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-288">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-288">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleBigEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-289">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-289">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-290">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-290">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-291">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-291">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-292">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-292"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-293">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-293">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleLittleEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-294">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-294">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-295">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-295">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-296">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-296">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-297">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-297"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-298">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-298">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16BigEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-299">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-299">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-300">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-300">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-301">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-301">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-302">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-302"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-303">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-303">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16LittleEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-304">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-304">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-305">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-305">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-306">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-306">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-307">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-307"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-308">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-308">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32BigEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-309">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-309">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-310">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-310">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-311">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-311">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-312">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-312"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-313">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-313">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32LittleEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-314">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-314">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-315">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-315">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-316">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-316">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-317">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-317"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-318">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-318">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64BigEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-319">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-319">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-320">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-320">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-321">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-321">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-322">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-322"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-323">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-323">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64LittleEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-324">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-324">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-325">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-325">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-326">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-326">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-327">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-327"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-328">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-328">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleBigEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-329">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-329">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-330">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-330">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-331">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-331">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-332">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-332"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-333">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-333">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleLittleEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-334">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-334">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-335">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-335">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-336">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-336">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-337">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-337"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-338">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-338">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16BigEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-339">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-339">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-340">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-340">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-341">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-341">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-342">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-342"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-343">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-343">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-344">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-344">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-345">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-345">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-346">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-346">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-347">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-347"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-348">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-348">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-349">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-349">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-350">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-350">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-351">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-351">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-352">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-352"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-353">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-353">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-354">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-354">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-355">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-355">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-356">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-356">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-357">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-357"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-358">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-358">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64BigEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-359">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-359">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-360">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-360">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-361">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-361">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-362">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-362"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-363">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-363">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-364">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-364">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-365">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-365">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-366">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-366">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="9bf21-367">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-367"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-368">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-368">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleBigEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-369">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-369">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-370">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-370">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-371">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-371">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-372">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-372">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-373"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-373"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleLittleEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-374">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-374">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-375">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-375">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-376">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-376">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-377">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-377">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-378"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-378"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16BigEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-379">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-379">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-380">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-380">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-381">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-381">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-382">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-382">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-383"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-383"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16LittleEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-384">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-384">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-385">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-385">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-386">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-386">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-387">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-387">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-388"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-388"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32BigEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-389">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-389">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-390">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-390">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-391">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-391">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-392">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-392">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-393"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-393"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32LittleEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-394">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-394">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-395">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-395">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-396">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-396">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-397">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-397">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-398"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-398"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64BigEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-399">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-399">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-400">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-400">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-401">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-401">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-402">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-402">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-403"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-403"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64LittleEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-404">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-404">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-405">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-405">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-406">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-406">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-407">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-407">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-408"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-408"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleBigEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-409">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-409">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-410">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-410">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-411">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-411">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-412">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-412">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-413"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-413"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleLittleEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-414">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-414">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-415">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-415">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-416">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-416">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-417">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-417">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-418"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-418"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16BigEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-419">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-419">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-420">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-420">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-421">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-421">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-422">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-422">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-423"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-423"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-424">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-424">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-425">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-425">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-426">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-426">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-427">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-427">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-428"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-428"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-429">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-429">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-430">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-430">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-431">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-431">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-432">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-432">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-433"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-433"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-434">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-434">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-435">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-435">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-436">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-436">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-437">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-437">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-438"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-438"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64BigEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-439">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-439">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-440">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-440">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-441">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-441">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-442">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-442">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-443"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-443"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="9bf21-444">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-444">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="9bf21-445">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="9bf21-445">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="9bf21-446">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="9bf21-446">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9bf21-447">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="9bf21-447">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9bf21-448"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="9bf21-448"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
