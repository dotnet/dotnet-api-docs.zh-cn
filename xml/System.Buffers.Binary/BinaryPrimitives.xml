<Type Name="BinaryPrimitives" FullName="System.Buffers.Binary.BinaryPrimitives">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19acb47cc96e0a5dfa0fa2365375f761ade2befa" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89897447" /></Metadata><TypeSignature Language="C#" Value="public static class BinaryPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BinaryPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.Binary.BinaryPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryPrimitives" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryPrimitives abstract sealed" />
  <TypeSignature Language="F#" Value="type BinaryPrimitives = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3bb0b-101">将字节读取为具有特定字节序的基元。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-101">Reads bytes as primitives with specific endianness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-102">对于本机格式，为 MemoryExtensions;应使用。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-102">For native formats, MemoryExtensions.Read{T}; should be used.</span></span>
<span data-ttu-id="3bb0b-103">需要读取特定的 endinanness 时，请使用这些帮助程序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-103">Use these helpers when you need to read specific endinanness.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleBigEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-104">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-104">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-105">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-105">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-106">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-106">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-107">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-107">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-108"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-108"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-109">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-109">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-110">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-110">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-111">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-111">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-112">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-112">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-113"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-113"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16BigEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-114">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-114">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-115">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-115">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-116">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-116">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-117">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-117">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-118"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-118"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-119">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-119">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-120">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-120">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-121">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-121">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-122">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-122">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-123"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-123"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32BigEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-124">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-124">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-125">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-125">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-126">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-126">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-127">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-127">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-128"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-128"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-129">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-129">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-130">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-130">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-131">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-131">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-132">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-132">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-133"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-133"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64BigEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-134">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-134">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-135">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-135">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-136">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-136">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-137">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-137">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-138"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-138"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-139">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-139">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-140">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-140">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-141">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-141">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-142">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-142">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-143"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-143"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleBigEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-144">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-144">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-145">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-145">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-146">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-146">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-147">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-147">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-148"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-148"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleLittleEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-149">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-149">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-150">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-150">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-151">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-151">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-152">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-152">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-153"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-153"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16BigEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-154">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-154">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-155">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-155">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-156">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-156">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-157">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-157">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-158"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-158"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-159">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-159">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-160">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-160">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-161">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-161">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-162">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-162">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-163"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-163"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32BigEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-164">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-164">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-165">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-165">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-166">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-166">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-167">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-167">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-168"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-168"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-169">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-169">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-170">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-170">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-171">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-171">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-172">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-172">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-173"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-173"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64BigEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-174">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-174">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-175">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-175">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-176">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-176">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-177">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-177">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-178"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-178"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-179">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-179">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="3bb0b-180">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-180">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-181">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-181">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-182">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-182">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-183"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-183"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static byte ReverseEndianness (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReverseEndianness(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReverseEndianness(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : byte -&gt; byte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-184">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-184">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-185">对指定 <see cref="T:System.Byte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.Byte" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-185">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Byte" /> value, which effectively does nothing for a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-186">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-186">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-187">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-187">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static short ReverseEndianness (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReverseEndianness(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReverseEndianness(short value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int16 -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-188">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-188">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-189">对指定 <see cref="T:System.Int16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-189">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int16" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-190">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-190">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static int ReverseEndianness (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReverseEndianness(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReverseEndianness(int value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-191">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-191">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-192">对指定 <see cref="T:System.Int32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-192">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int32" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-193">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-193">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static long ReverseEndianness (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReverseEndianness(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReverseEndianness(long value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int64 -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-194">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-194">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-195">对指定 <see cref="T:System.Int64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-195">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int64" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-196">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-196">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static sbyte ReverseEndianness (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ReverseEndianness(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ReverseEndianness(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : sbyte -&gt; sbyte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-197">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-197">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-198">对指定 <see cref="T:System.SByte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.SByte" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-198">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.SByte" /> value, which effectively does nothing for an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-199">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-199">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-200">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-200">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ushort ReverseEndianness (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReverseEndianness(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReverseEndianness(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint16 -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-201">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-201">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-202">对指定 <see cref="T:System.UInt16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-202">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt16" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-203">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-203">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static uint ReverseEndianness (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReverseEndianness(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReverseEndianness(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint32 -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-204">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-204">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-205">对指定 <see cref="T:System.UInt32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-205">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt32" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-206">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-206">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ulong ReverseEndianness (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReverseEndianness(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReverseEndianness(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint64 -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3bb0b-207">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-207">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="3bb0b-208">对指定 <see cref="T:System.UInt64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-208">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt64" /> value.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-209">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-209">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-210">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-210">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-211">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-211">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-212">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-212">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-213">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-213"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-214">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-214">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-215">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-215">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-216">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-216">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-217">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-217">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-218">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-218"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-219">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-219">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-220">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-220">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-221">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-221">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-222">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-222">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-223">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-223"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-224">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-224">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-225">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-225">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-226">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-226">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-227">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-227">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-228">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-228"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-229">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-229">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-230">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-230">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-231">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-231">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-232">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-232">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-233">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-233"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-234">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-234">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-235">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-235">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-236">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-236">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-237">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-237">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-238">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-238"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-239">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-239">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-240">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-240">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-241">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-241">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-242">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-242">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-243">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-243"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-244">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-244">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-245">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-245">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-246">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-246">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-247">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-247">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-248">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-248"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-249">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-249">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-250">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-250">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-251">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-251">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-252">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-252">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-253">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-253"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-254">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-254">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-255">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-255">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-256">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-256">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-257">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-257">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-258">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-258"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-259">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-259">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-260">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-260">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-261">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-261">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-262">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-262">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-263">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-263"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-264">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-264">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-265">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-265">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-266">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-266">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-267">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-267">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-268">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-268"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-269">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-269">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-270">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-270">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-271">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-271">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-272">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-272">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-273">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-273"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-274">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-274">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-275">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-275">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-276">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-276">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-277">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-277">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-278">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-278"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-279">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-279">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-280">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-280">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-281">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-281">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-282">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-282">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-283">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-283"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-284">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-284">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3bb0b-285">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-285">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-286">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-286">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="3bb0b-287">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-287">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-288">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-288"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-289">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-289">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleBigEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-290">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-290">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-291">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-291">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-292">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-292">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-293">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-293"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-294">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-294">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleLittleEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-295">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-295">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-296">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-296">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-297">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-297">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-298">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-298"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-299">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-299">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16BigEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-300">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-300">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-301">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-301">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-302">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-302">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-303">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-303"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-304">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-304">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16LittleEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-305">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-305">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-306">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-306">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-307">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-307">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-308">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-308"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-309">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-309">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32BigEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-310">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-310">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-311">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-311">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-312">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-312">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-313">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-313"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-314">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-314">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32LittleEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-315">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-315">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-316">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-316">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-317">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-317">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-318">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-318"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-319">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-319">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64BigEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-320">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-320">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-321">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-321">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-322">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-322">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-323">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-323"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-324">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-324">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64LittleEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-325">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-325">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-326">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-326">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-327">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-327">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-328">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-328"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-329">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-329">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleBigEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-330">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-330">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-331">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-331">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-332">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-332">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-333">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-333"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-334">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-334">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleLittleEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-335">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-335">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-336">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-336">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-337">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-337">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-338">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-338"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-339">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-339">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16BigEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-340">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-340">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-341">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-341">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-342">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-342">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-343">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-343"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-344">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-344">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-345">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-345">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-346">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-346">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-347">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-347">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-348">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-348"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-349">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-349">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-350">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-350">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-351">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-351">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-352">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-352">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-353">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-353"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-354">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-354">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-355">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-355">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-356">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-356">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-357">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-357">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-358">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-358"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-359">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-359">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64BigEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-360">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-360">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-361">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-361">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-362">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-362">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-363">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-363"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-364">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-364">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-365">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-365">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-366">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-366">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-367">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-367">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="3bb0b-368">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-368"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-369">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-369">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleBigEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-370">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-370">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-371">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-371">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-372">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-372">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-373">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-373">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-374"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-374"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleLittleEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-375">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-375">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-376">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-376">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-377">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-377">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-378">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-378">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-379"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-379"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16BigEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-380">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-380">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-381">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-381">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-382">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-382">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-383">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-383">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-384"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-384"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16LittleEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-385">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-385">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-386">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-386">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-387">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-387">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-388">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-388">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-389"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-389"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32BigEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-390">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-390">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-391">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-391">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-392">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-392">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-393">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-393">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-394"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-394"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32LittleEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-395">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-395">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-396">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-396">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-397">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-397">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-398">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-398">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-399"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-399"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64BigEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-400">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-400">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-401">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-401">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-402">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-402">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-403">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-403">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-404"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-404"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64LittleEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-405">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-405">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-406">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-406">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-407">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-407">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-408">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-408">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-409"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-409"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleBigEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-410">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-410">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-411">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-411">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-412">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-412">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-413">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-413">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-414"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-414"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleLittleEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-415">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-415">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-416">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-416">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-417">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-417">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-418">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-418">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-419"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-419"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16BigEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-420">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-420">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-421">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-421">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-422">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-422">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-423">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-423">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-424"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-424"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-425">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-425">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-426">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-426">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-427">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-427">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-428">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-428">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-429"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-429"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-430">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-430">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-431">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-431">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-432">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-432">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-433">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-433">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-434"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-434"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-435">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-435">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-436">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-436">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-437">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-437">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-438">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-438">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-439"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-439"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64BigEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-440">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-440">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-441">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-441">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-442">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-442">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-443">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-443">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-444"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-444"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3bb0b-445">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-445">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="3bb0b-446">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-446">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="3bb0b-447">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-447">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="3bb0b-448">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-448">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3bb0b-449"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="3bb0b-449"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
