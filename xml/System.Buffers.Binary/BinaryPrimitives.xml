<Type Name="BinaryPrimitives" FullName="System.Buffers.Binary.BinaryPrimitives">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19acb47cc96e0a5dfa0fa2365375f761ade2befa" /><Meta Name="ms.sourcegitcommit" Value="1617f40ee47f4336ea7edb156fc31f853fadd853" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/13/2020" /><Meta Name="ms.locfileid" Value="88188362" /></Metadata><TypeSignature Language="C#" Value="public static class BinaryPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BinaryPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.Binary.BinaryPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryPrimitives" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryPrimitives abstract sealed" />
  <TypeSignature Language="F#" Value="type BinaryPrimitives = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="75088-101">将字节读取为具有特定字节序的基元。</span><span class="sxs-lookup"><span data-stu-id="75088-101">Reads bytes as primitives with specific endianness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-102">对于本机格式，为 MemoryExtensions;应使用。</span><span class="sxs-lookup"><span data-stu-id="75088-102">For native formats, MemoryExtensions.Read{T}; should be used.</span></span>
<span data-ttu-id="75088-103">需要读取特定的 endinanness 时，请使用这些帮助程序。</span><span class="sxs-lookup"><span data-stu-id="75088-103">Use these helpers when you need to read specific endinanness.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleBigEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-104">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-104">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-105">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-105">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-106">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-106">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-107">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-107">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-108"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="75088-108"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-109">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-109">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-110">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-110">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-111">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-111">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-112">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-112">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-113"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="75088-113"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16BigEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-114">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-114">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-115">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-115">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-116">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-116">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-117">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-117">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-118"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-118"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-119">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-119">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-120">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-120">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-121">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-121">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-122">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-122">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-123"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-123"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32BigEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-124">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-124">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-125">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-125">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-126">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-126">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-127">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-127">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-128"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-128"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-129">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-129">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-130">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-130">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-131">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-131">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-132">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-132">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-133"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-133"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64BigEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-134">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-134">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-135">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-135">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-136">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-136">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-137">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-137">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-138"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-138"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-139">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-139">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-140">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-140">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-141">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-141">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-142">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-142">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-143"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-143"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleBigEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-144">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-144">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-145">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-145">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-146">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-146">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-147">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-147">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-148"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="75088-148"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleLittleEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-149">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-149">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-150">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-150">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-151">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-151">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-152">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-152">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-153"><paramref name="source" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="75088-153"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16BigEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-154">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-154">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-155">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-155">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-156">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-156">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-157">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-157">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-158"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-158"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-159">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-159">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-160">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-160">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-161">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-161">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-162">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-162">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-163"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-163"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32BigEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-164">要读取的只读跨度。</span><span class="sxs-lookup"><span data-stu-id="75088-164">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="75088-165">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-165">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-166">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-166">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-167">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-167">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-168"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-168"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-169">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-169">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="75088-170">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-170">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-171">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-171">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-172">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-172">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-173"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-173"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64BigEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-174">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-174">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="75088-175">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-175">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-176">大字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-176">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-177">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-177">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-178"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-178"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-179">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-179">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="75088-180">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-180">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-181">小字节序值。</span><span class="sxs-lookup"><span data-stu-id="75088-181">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-182">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-182">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-183"><paramref name="source" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-183"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static byte ReverseEndianness (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReverseEndianness(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReverseEndianness(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : byte -&gt; byte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-184">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-184">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-185">对指定 <see cref="T:System.Byte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.Byte" />。</span><span class="sxs-lookup"><span data-stu-id="75088-185">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Byte" /> value, which effectively does nothing for a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="75088-186">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="75088-186">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-187">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="75088-187">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static short ReverseEndianness (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReverseEndianness(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReverseEndianness(short value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int16 -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-188">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-188">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-189">对指定 <see cref="T:System.Int16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-189">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int16" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-190">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-190">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static int ReverseEndianness (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReverseEndianness(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReverseEndianness(int value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-191">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-191">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-192">对指定 <see cref="T:System.Int32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-192">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int32" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-193">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-193">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static long ReverseEndianness (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReverseEndianness(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReverseEndianness(long value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int64 -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-194">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-194">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-195">对指定 <see cref="T:System.Int64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-195">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int64" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-196">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-196">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static sbyte ReverseEndianness (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ReverseEndianness(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ReverseEndianness(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : sbyte -&gt; sbyte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-197">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-197">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-198">对指定 <see cref="T:System.SByte" /> 值执行字节序交换，以反转基元值，这不会影响 <see cref="T:System.SByte" />。</span><span class="sxs-lookup"><span data-stu-id="75088-198">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.SByte" /> value, which effectively does nothing for an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="75088-199">未修改的传入值。</span><span class="sxs-lookup"><span data-stu-id="75088-199">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-200">此方法实际上不会执行任何操作，只是为了保持一致性而添加的。</span><span class="sxs-lookup"><span data-stu-id="75088-200">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ushort ReverseEndianness (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReverseEndianness(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReverseEndianness(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint16 -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-201">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-201">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-202">对指定 <see cref="T:System.UInt16" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-202">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt16" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-203">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-203">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static uint ReverseEndianness (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReverseEndianness(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReverseEndianness(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint32 -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-204">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-204">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-205">对指定 <see cref="T:System.UInt32" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-205">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt32" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-206">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-206">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ulong ReverseEndianness (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReverseEndianness(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReverseEndianness(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint64 -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="75088-207">要反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-207">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="75088-208">对指定 <see cref="T:System.UInt64" /> 值执行字节序交换，以反转基元值。</span><span class="sxs-lookup"><span data-stu-id="75088-208">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt64" /> value.</span></span></summary>
        <returns><span data-ttu-id="75088-209">已反转的值。</span><span class="sxs-lookup"><span data-stu-id="75088-209">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-210">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-210">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-211">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="75088-211">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-212">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-212">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-213">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-213"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-214">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-214">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-215">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-215">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-216">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="75088-216">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-217">从字节只读范围的开头，将 <see cref="T:System.Double" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-217">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-218">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-218"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-219">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-219">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-220">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-220">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-221">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-221">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-222">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-222">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-223">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-223"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-224">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-224">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-225">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-225">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-226">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-226">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-227">从字节只读范围的开头，将 <see cref="T:System.Int16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-227">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-228">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-228"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-229">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-229">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-230">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-230">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-231">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-231">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-232">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-232">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-233">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-233"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-234">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-234">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-235">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-235">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-236">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-236">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-237">从字节只读范围的开头，将 <see cref="T:System.Int32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-237">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-238">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-238"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-239">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-239">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-240">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-240">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-241">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-241">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-242">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-242">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-243">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-243"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-244">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-244">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-245">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-245">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-246">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-246">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-247">从字节只读范围的开头，将 <see cref="T:System.Int64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-247">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-248">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-248"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-249">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-249">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-250">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-250">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-251">此方法返回时，将包含作为 big endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="75088-251">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-252">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-252">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-253">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-253"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-254">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-254">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-255">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-255">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-256">此方法返回时，将包含作为 little endian 从字节只读范围中读取的值。</span><span class="sxs-lookup"><span data-stu-id="75088-256">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-257">从字节只读范围的开头，将 <see cref="T:System.Single" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-257">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-258">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-258"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-259">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-259">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-260">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-260">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-261">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-261">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-262">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-262">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-263">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-263"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-264">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-264">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-265">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-265">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-266">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-266">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-267">从字节只读范围的开头，将 <see cref="T:System.UInt16" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-267">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-268">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-268"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-269">从跨度的开头精确读取2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-269">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-270">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-270">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-271">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-271">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-272">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-272">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-273">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-273"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-274">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-274">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-275">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-275">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-276">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-276">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-277">从字节只读范围的开头，将 <see cref="T:System.UInt32" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-277">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-278">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-278"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-279">从跨度的开头精确读取4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-279">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-280">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-280">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-281">此方法返回时，值作为大字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-281">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="75088-282">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为大字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-282">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-283">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-283"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-284">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-284">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="75088-285">要读取的字节只读范围。</span><span class="sxs-lookup"><span data-stu-id="75088-285">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="75088-286">此方法返回时，值作为小字节序从字节只读范围中读取。</span><span class="sxs-lookup"><span data-stu-id="75088-286">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="75088-287">从字节只读范围的开头，将 <see cref="T:System.UInt64" /> 读取为小字节序。</span><span class="sxs-lookup"><span data-stu-id="75088-287">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-288">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-288"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-289">从跨度的开头精确读取8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-289">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleBigEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-290">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-290">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-291">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-291">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-292">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-292">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-293">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-293"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-294">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-294">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleLittleEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-295">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-295">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-296">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-296">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-297">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-297">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-298">如果范围足够大，可以包含 <see cref="T:System.Double" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-298"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-299">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-299">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16BigEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-300">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-300">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-301">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-301">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-302">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-302">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-303">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-303"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-304">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-304">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16LittleEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-305">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-305">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-306">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-306">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-307">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-307">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-308">如果范围足够大，可以包含 <see cref="T:System.Int16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-308"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-309">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-309">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32BigEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-310">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-310">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-311">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-311">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-312">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-312">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-313">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-313"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-314">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-314">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32LittleEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-315">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-315">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-316">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-316">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-317">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-317">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-318">如果范围足够大，可以包含 <see cref="T:System.Int32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-318"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-319">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-319">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64BigEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-320">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-320">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-321">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-321">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-322">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-322">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-323">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-323"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-324">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-324">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64LittleEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-325">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-325">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-326">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-326">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-327">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-327">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-328">如果范围足够大，可以包含 <see cref="T:System.Int64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-328"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-329">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-329">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleBigEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-330">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-330">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-331">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-331">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-332">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-332">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-333">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-333"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-334">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-334">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleLittleEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-335">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-335">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-336">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-336">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-337">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-337">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-338">如果范围足够大，可以包含 <see cref="T:System.Single" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-338"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-339">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-339">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16BigEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-340">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-340">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-341">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-341">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-342">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-342">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-343">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-343"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-344">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-344">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-345">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-345">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-346">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-346">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-347">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-347">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-348">如果范围足够大，可以包含 <see cref="T:System.UInt16" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-348"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-349">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-349">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-350">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-350">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-351">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-351">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-352">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-352">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-353">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-353"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-354">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-354">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-355">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-355">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-356">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-356">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-357">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-357">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-358">如果范围足够大，可以包含 <see cref="T:System.UInt32" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-358"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-359">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-359">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64BigEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-360">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-360">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-361">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-361">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-362">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-362">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="75088-363">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-363"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-364">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-364">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-365">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-365">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-366">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-366">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-367">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-367">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="75088-368">如果范围足够大，可以包含 <see cref="T:System.UInt64" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75088-368"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-369">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-369">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleBigEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-370">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-370">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-371">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-371">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-372">将 <see cref="T:System.Double" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-372">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-373">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-373">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-374"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="75088-374"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleLittleEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-375">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-375">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-376">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-376">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-377">将 <see cref="T:System.Double" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-377">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-378">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-378">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-379"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Double" />。</span><span class="sxs-lookup"><span data-stu-id="75088-379"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16BigEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-380">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-380">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-381">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-381">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-382">将 <see cref="T:System.Int16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-382">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-383">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-383">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-384"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-384"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16LittleEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-385">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-385">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-386">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-386">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-387">将 <see cref="T:System.Int16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-387">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-388">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-388">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-389"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-389"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32BigEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-390">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-390">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-391">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-391">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-392">将 <see cref="T:System.Int32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-392">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-393">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-393">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-394"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-394"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32LittleEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-395">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-395">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-396">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-396">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-397">将 <see cref="T:System.Int32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-397">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-398">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-398">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-399"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-399"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64BigEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-400">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-400">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-401">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-401">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-402">将 <see cref="T:System.Int64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-402">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-403">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-403">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-404"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-404"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64LittleEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-405">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-405">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-406">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-406">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-407">将 <see cref="T:System.Int64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-407">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-408">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-408">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-409"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Int64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-409"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleBigEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-410">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-410">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-411">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-411">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-412">将 <see cref="T:System.Single" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-412">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-413">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-413">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-414"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="75088-414"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleLittleEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-415">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-415">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-416">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-416">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-417">将 <see cref="T:System.Single" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-417">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-418">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-418">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-419"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.Single" />。</span><span class="sxs-lookup"><span data-stu-id="75088-419"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16BigEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-420">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-420">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-421">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-421">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-422">将 <see cref="T:System.UInt16" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-422">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-423">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-423">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-424"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-424"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-425">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-425">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-426">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-426">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-427">将 <see cref="T:System.UInt16" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-427">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-428">正好向范围的开头写入2个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-428">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-429"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt16" />。</span><span class="sxs-lookup"><span data-stu-id="75088-429"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-430">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-430">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-431">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-431">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-432">将 <see cref="T:System.UInt32" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-432">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-433">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-433">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-434"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-434"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-435">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-435">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-436">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-436">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-437">将 <see cref="T:System.UInt32" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-437">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-438">正好向范围的开头写入4个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-438">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-439"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt32" />。</span><span class="sxs-lookup"><span data-stu-id="75088-439"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64BigEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-440">要以大字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-440">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-441">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-441">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-442">将 <see cref="T:System.UInt64" /> 以大字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-442">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-443">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-443">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-444"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-444"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="75088-445">要以小字节序形式写入值的字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-445">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="75088-446">要写入到字节范围内的值。</span><span class="sxs-lookup"><span data-stu-id="75088-446">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="75088-447">将 <see cref="T:System.UInt64" /> 以小字节序形式写入字节范围。</span><span class="sxs-lookup"><span data-stu-id="75088-447">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="75088-448">正好向范围的开头写入8个字节。</span><span class="sxs-lookup"><span data-stu-id="75088-448">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75088-449"><paramref name="destination" /> 太小，无法包含 <see cref="T:System.UInt64" />。</span><span class="sxs-lookup"><span data-stu-id="75088-449"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
