<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f5af96f2fec7a21ce7ba30d57271b3ead3a36f5b" /><Meta Name="ms.sourcegitcommit" Value="13a6cb6fba7e05947f15d8d6cc802703ae9c21d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/18/2020" /><Meta Name="ms.locfileid" Value="90798819" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Numerics" FromVersion="4.0.0.0" To="System.Runtime.Numerics" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="53cad-101">表示一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-102">复数是包含实数部分和虚数部分的数字。</span><span class="sxs-lookup"><span data-stu-id="53cad-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="53cad-103">复数 z 通常采用 z = x + yi 形式编写，其中 *x* 和 *y* 为实数，而 *i* 是具有属性 *i*<sup>2</sup> =-1 的虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="53cad-104">复数的实部由 *x*表示，复数的虚部是由 *y*表示的。</span><span class="sxs-lookup"><span data-stu-id="53cad-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="53cad-105">在 <xref:System.Numerics.Complex> 实例化和操作复数时，类型使用笛卡尔坐标系统 (real，虚部) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="53cad-106">复数可以表示为二维坐标系统中的一个点，这称为复杂平面。</span><span class="sxs-lookup"><span data-stu-id="53cad-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="53cad-107">复数的实部定位在水平) 轴 (x 轴上，而虚部定位在 y 轴上， (垂直轴) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="53cad-108">还可以通过使用极坐标系统基于其绝对值来表示复杂平面中的任何点。</span><span class="sxs-lookup"><span data-stu-id="53cad-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="53cad-109">在极坐标中，点的特征是两个数字：</span><span class="sxs-lookup"><span data-stu-id="53cad-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="53cad-110">其量值，它是原点 (的距离为，0，0，或者 x 轴和 y 轴相交的点) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="53cad-111">其阶段，它是实轴与从原点绘制到点之间的直线之间的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="53cad-112">实例化复数</span><span class="sxs-lookup"><span data-stu-id="53cad-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="53cad-113">可以通过以下方式之一将值分配给复数：</span><span class="sxs-lookup"><span data-stu-id="53cad-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="53cad-114">通过 <xref:System.Double> 向其构造函数传递两个值。</span><span class="sxs-lookup"><span data-stu-id="53cad-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="53cad-115">第一个值表示复数的实部，第二个值表示其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="53cad-116">这些值表示复数在二维笛卡尔坐标系统中的位置。</span><span class="sxs-lookup"><span data-stu-id="53cad-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="53cad-117">通过调用 `Shared` Visual Basic) 方法中的静态 (<xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> 从其极坐标创建复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="53cad-118">通过将 <xref:System.Byte> 、、、、、、、、 <xref:System.SByte> <xref:System.Int16> <xref:System.UInt16> <xref:System.Int32> <xref:System.UInt32> <xref:System.Int64> <xref:System.UInt64> <xref:System.Single> 或值分配 <xref:System.Double> 给 <xref:System.Numerics.Complex> 对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53cad-119">值变成复数的实部，其虚部等于0。</span><span class="sxs-lookup"><span data-stu-id="53cad-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="53cad-120">通过在 c # 中强制转换 () 或将 (转换 Visual Basic) 将 <xref:System.Decimal> 或 <xref:System.Numerics.BigInteger> 值转换为 <xref:System.Numerics.Complex> 对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53cad-121">值变成复数的实部，其虚部等于0。</span><span class="sxs-lookup"><span data-stu-id="53cad-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="53cad-122">通过将方法或运算符返回的复数赋给 <xref:System.Numerics.Complex> 对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53cad-123">例如， <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> 是一个静态方法，它返回一个复数，该复数是两个复数的和， <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> 运算符添加两个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="53cad-124">下面的示例演示了向复数赋值的五种方法中的每一种。</span><span class="sxs-lookup"><span data-stu-id="53cad-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="53cad-125">带有复数的操作</span><span class="sxs-lookup"><span data-stu-id="53cad-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="53cad-126"><xref:System.Numerics.Complex>.NET Framework 中的结构包括提供以下功能的成员：</span><span class="sxs-lookup"><span data-stu-id="53cad-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="53cad-127">用于比较两个复数以确定它们是否相等的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="53cad-128">用于对复数执行算术运算的运算符。</span><span class="sxs-lookup"><span data-stu-id="53cad-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="53cad-129"><xref:System.Numerics.Complex> 使用运算符可以对复数执行加法、减法、乘法、除法和一元求反运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="53cad-130">用于对复数执行其他数字运算的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="53cad-131">除了四个基本算术运算外，还可以将一个复数升高到指定的幂，查找复数的平方根，并获取复数的绝对值。</span><span class="sxs-lookup"><span data-stu-id="53cad-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="53cad-132">用于对复数执行三角函数运算的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="53cad-133">例如，您可以计算由复数表示的角度的正切值。</span><span class="sxs-lookup"><span data-stu-id="53cad-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="53cad-134">请注意，由于 <xref:System.Numerics.Complex.Real%2A> 和  <xref:System.Numerics.Complex.Imaginary%2A> 属性是只读的，因此不能修改现有对象的值 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="53cad-135">对数字执行操作的所有方法 <xref:System.Numerics.Complex> （如果其返回值为类型 <xref:System.Numerics.Complex> ）将返回新 <xref:System.Numerics.Complex> 数字。</span><span class="sxs-lookup"><span data-stu-id="53cad-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="53cad-136">精度和复数</span><span class="sxs-lookup"><span data-stu-id="53cad-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="53cad-137">复数的实部和虚部用两个双精度浮点值表示。</span><span class="sxs-lookup"><span data-stu-id="53cad-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="53cad-138">这意味着， <xref:System.Numerics.Complex> 值（如双精度浮点值）可能会因数字运算而丢失精度。</span><span class="sxs-lookup"><span data-stu-id="53cad-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="53cad-139">这意味着，如果这两个值之间的差比较导致精度损失，则这两个值的相等比较 <xref:System.Numerics.Complex> 可能会失败。</span><span class="sxs-lookup"><span data-stu-id="53cad-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="53cad-140">有关详细信息，请参阅 <xref:System.Double>。</span><span class="sxs-lookup"><span data-stu-id="53cad-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="53cad-141">例如，对某个数字的对数执行幂运算应返回原始数字。</span><span class="sxs-lookup"><span data-stu-id="53cad-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="53cad-142">但是，在某些情况下，浮点值的精度损失可能会导致两个值之间的差异，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="53cad-143">同样，下面的示例（计算数字的平方根 <xref:System.Numerics.Complex> ）在 .NET Framework 的32位和 IA64 版本上生成的结果略有不同。</span><span class="sxs-lookup"><span data-stu-id="53cad-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="53cad-144">复数、无穷和 NaN</span><span class="sxs-lookup"><span data-stu-id="53cad-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="53cad-145">复数的实部和虚部用 <xref:System.Double> 值表示。</span><span class="sxs-lookup"><span data-stu-id="53cad-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="53cad-146">除了从 <xref:System.Double.MinValue?displayProperty=nameWithType> 到以外 <xref:System.Double.MaxValue?displayProperty=nameWithType> ，复数的实部或虚部可以具有值 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 、 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>、 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 和 <xref:System.Double.NaN?displayProperty=nameWithType> 均传播到任何算术或三角函数操作中。</span><span class="sxs-lookup"><span data-stu-id="53cad-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="53cad-148">在下面的示例中，除法运算将 <xref:System.Numerics.Complex.Zero> 生成一个复数，该复数的实部和虚部均为两者 <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-149">因此，使用此值执行乘法还会生成一个实部和虚部为的复数 <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-150">同样，执行溢出类型范围的乘法会 <xref:System.Double> 生成一个复数，其中实部为 <xref:System.Double.NaN?displayProperty=nameWithType> ，虚部为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-151">随后使用此复数执行除法运算将返回实部为 <xref:System.Double.NaN?displayProperty=nameWithType> ，其虚部为的复数 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="53cad-152">使用无效或溢出数据类型范围的复数运算 <xref:System.Double> 不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="53cad-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="53cad-153">相反，它们会 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType> 在以下条件下返回、或：</span><span class="sxs-lookup"><span data-stu-id="53cad-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="53cad-154">正数除以零的除法运算返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53cad-155">溢出数据类型上限的任何操作都将 <xref:System.Double> 返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53cad-156">负数除以零的除法运算返回 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53cad-157">溢出数据类型下限的任何操作都将 <xref:System.Double> 返回 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53cad-158">零除以零的除法运算返回 <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53cad-159">对值为、或的操作数执行的任何操作都将 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType> 返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 、 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NaN?displayProperty=nameWithType> ，具体取决于特定的操作。</span><span class="sxs-lookup"><span data-stu-id="53cad-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="53cad-160">请注意，这适用于方法所执行的任何中间计算。</span><span class="sxs-lookup"><span data-stu-id="53cad-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="53cad-161">例如，的乘法 `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` 使用公式 (ac-bd) + (ad + bc) i。</span><span class="sxs-lookup"><span data-stu-id="53cad-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="53cad-162">乘法运算产生的实分量计算表达式 9e308 \* 2.5-9e308 \* 3.5。</span><span class="sxs-lookup"><span data-stu-id="53cad-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="53cad-163">此表达式中的每个中间乘法都返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ，尝试从返回的中减去 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="53cad-164">设置复数格式</span><span class="sxs-lookup"><span data-stu-id="53cad-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="53cad-165">默认情况下，复数的字符串表示形式采用 `(` *实* `,` *虚部* `)` ，其中*real*和*虚部*是 <xref:System.Double> 构成复数实部和虚部部分的值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="53cad-166">方法的某些重载 <xref:System.Numerics.Complex.ToString%2A> 允许自定义这些值的字符串表示形式 <xref:System.Double> ，以反映特定区域性的格式设置约定，或显示为标准或自定义数字格式字符串定义的特定格式。</span><span class="sxs-lookup"><span data-stu-id="53cad-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="53cad-167"> (有关详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。 ) </span><span class="sxs-lookup"><span data-stu-id="53cad-167">(For more information, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).)</span></span>  
  
 <span data-ttu-id="53cad-168">表达复数的字符串表示形式的一种更常见方法是使用 a + bi 形式，其中 a 是复数的实部，b 是复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="53cad-169">在电气工程中，复数最常表示为 + bj。</span><span class="sxs-lookup"><span data-stu-id="53cad-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="53cad-170">您可以使用以下两种形式之一返回复数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="53cad-171">为此，请通过实现和接口定义自定义格式提供程序 <xref:System.ICustomFormatter> <xref:System.IFormatProvider> ，然后调用 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="53cad-172">下面的示例定义了一个 `ComplexFormatter` 类，该类将一个以 + bi 或 + bj 形式的字符串表示的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="53cad-173">然后，下面的示例使用此自定义格式化程序显示复数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="53cad-174">复数的实部。</span><span class="sxs-lookup"><span data-stu-id="53cad-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="53cad-175">复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-176">使用指定的实数值和虚数值初始化 <see cref="T:System.Numerics.Complex" /> 结构的新实例。</span><span class="sxs-lookup"><span data-stu-id="53cad-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-177">`real`如果或 `imaginary` 参数是需要显式强制转换为的数据类型，则可能会丢失精度 <xref:System.Double> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-178">下面的示例实例化两个复数，然后将它们用作加法、减法、乘法和除法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-179">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-180">获取复数的绝对值（或量值）。</span><span class="sxs-lookup"><span data-stu-id="53cad-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-181"><paramref name="value" /> 的绝对值。</span><span class="sxs-lookup"><span data-stu-id="53cad-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-182">复数的绝对值等效于其 <xref:System.Numerics.Complex.Magnitude%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="53cad-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="53cad-183">复数 a + bi 的绝对值计算如下：</span><span class="sxs-lookup"><span data-stu-id="53cad-183">The absolute value of a complex number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="53cad-184">如果 b = 0，则结果为。</span><span class="sxs-lookup"><span data-stu-id="53cad-184">If b = 0, the result is a.</span></span>  
  
-   <span data-ttu-id="53cad-185">如果 > b，则结果为 \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> (1 + b<sup>2</sup>/a<sup>2</sup>) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-185">If a > b, the result is a \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="53cad-186">如果 b > a，则结果为 b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> (1 + a<sup>2</sup>/b<sup>2</sup>) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="53cad-187">如果绝对值的计算导致溢出，则方法返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-188">如果 <xref:System.Numerics.Complex.Real%2A> 或 <xref:System.Numerics.Complex.Imaginary%2A> 属性为，而 <xref:System.Double.NaN?displayProperty=nameWithType> 另一个属性既不是 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 也不是 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> ，则该方法返回 <xref:System.Double.NaN?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-189">下面的示例计算复数的绝对值，并说明它等效于属性的值 <xref:System.Numerics.Complex.Magnitude%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-190">表示余弦的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="53cad-191">返回表示指定复数的反余弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-192">以弧度为单位的角度，它表示 <paramref name="value" /> 的反余弦。</span><span class="sxs-lookup"><span data-stu-id="53cad-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-193"><xref:System.Numerics.Complex.Acos%2A>复数的方法与实数的方法相对应 <xref:System.Math.Acos%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-194"><xref:System.Numerics.Complex.Acos%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="53cad-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53cad-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="53cad-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="53cad-196">下面的示例演示 <xref:System.Numerics.Complex.Acos%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="53cad-197">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Acos%2A> 到方法将 <xref:System.Numerics.Complex.Cos%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <Docs>
        <summary><span data-ttu-id="53cad-198">将一个指定数字与另一个指定数字相加，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-198">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="53cad-199"><xref:System.Numerics.Complex.Add%2A>方法允许执行涉及复数的加法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-199">The <xref:System.Numerics.Complex.Add%2A> methods allow performing addition operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="53cad-200">如果方法调用导致实部或虚部溢出，则组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-200">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53cad-201">不支持自定义运算符的语言可以使用 <xref:System.Numerics.Complex.Add%2A> 方法来执行包含复数的加法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-201">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  

 <span data-ttu-id="53cad-202"><xref:System.Numerics.Complex.Add%2A>接收一个 double 的方法比接收两个复数的方法更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-202">The <xref:System.Numerics.Complex.Add%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>
  
## Examples  

 <span data-ttu-id="53cad-203">下面的示例阐释了包含复数的加法。</span><span class="sxs-lookup"><span data-stu-id="53cad-203">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-204">要相加的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-204">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-205">要相加的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-205">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="53cad-206">将一个双精度实数与一个复数相加，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-206">Adds a double-precision real number to a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-207"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="53cad-207">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="53cad-208">添加实数 (可以将其视为复数 a + 0 i) ，复数 (c + di) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-208">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="53cad-209"> (+ c) + di</span><span class="sxs-lookup"><span data-stu-id="53cad-209">(a + c) + di</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-210">要相加的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-210">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-211">要相加的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-211">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="53cad-212">将一个复数与一个双精度实数相加，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-212">Adds a complex number to a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-213"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="53cad-213">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="53cad-214">添加一个复数 (+ bi) 和一个实数 (可视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-214">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-215"> (+ c) + bi</span><span class="sxs-lookup"><span data-stu-id="53cad-215">(a + c) + bi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-216">要相加的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-216">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-217">要相加的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-217">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="53cad-218">将两个复数相加，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-218">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-219"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="53cad-219">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-220">加法复数、+ bi 和第二复数 c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-220">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53cad-221"> (+ c) + (b + d) i。</span><span class="sxs-lookup"><span data-stu-id="53cad-221">(a + c) + (b + d)i.</span></span>  

  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-222">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-222">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-223">返回表示指定复数的反正弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-223">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-224">表示 <paramref name="value" /> 的反正弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-224">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-225"><xref:System.Numerics.Complex.Asin%2A>复数的方法与实数的方法相对应 <xref:System.Math.Asin%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-225">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-226"><xref:System.Numerics.Complex.Asin%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="53cad-226">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53cad-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A> (<xref:System.Numerics.Complex.ImaginaryOne> \* 值 + <xref:System.Numerics.Complex.Sqrt%2A> (<xref:System.Numerics.Complex.One> 值 \* 值) # A3</span><span class="sxs-lookup"><span data-stu-id="53cad-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="53cad-228">下面的示例演示 <xref:System.Numerics.Complex.Asin%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-228">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="53cad-229">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Asin%2A> 到方法将 <xref:System.Numerics.Complex.Sin%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-229">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-230">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-230">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-231">返回表示指定复数的反正切的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-231">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-232">表示 <paramref name="value" /> 的反正切值的角度。</span><span class="sxs-lookup"><span data-stu-id="53cad-232">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-233"><xref:System.Numerics.Complex.Atan%2A>复数的方法与实数的方法相对应 <xref:System.Math.Atan%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-233">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-234"><xref:System.Numerics.Complex.Atan%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="53cad-234">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53cad-235"> (<xref:System.Numerics.Complex.ImaginaryOne> /new Complex (2.0、0.0) # A3\ * (<xref:System.Numerics.Complex.Log%2A> (<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne>\ * 值) - <xref:System.Numerics.Complex.Log%2A> (<xref:System.Numerics.Complex.One> + ImaginaryOne\ * 值) # A9</span><span class="sxs-lookup"><span data-stu-id="53cad-235">(<xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value))</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="53cad-236">下面的示例演示 <xref:System.Numerics.Complex.Atan%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-236">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="53cad-237">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Atan%2A> 到方法将 <xref:System.Numerics.Complex.Tan%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-237">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-238">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-238">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-239">计算复数的共轭，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-239">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-240"><paramref name="value" /> 的共轭。</span><span class="sxs-lookup"><span data-stu-id="53cad-240">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-241">复数的共轭反转虚部的符号;也就是说，它将一元求反应用于虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-241">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="53cad-242">如果 + bi 是复数，则其共轭法为-bi。</span><span class="sxs-lookup"><span data-stu-id="53cad-242">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-243">下面的示例显示两个复数的共轭。</span><span class="sxs-lookup"><span data-stu-id="53cad-243">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-244">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-244">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-245">返回指定复数的余弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-245">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-246"><paramref name="value" /> 的余弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-246">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-247"><xref:System.Numerics.Complex.Cos%2A>复数的方法与实数的方法相对应 <xref:System.Math.Cos%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-247">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-248"><xref:System.Numerics.Complex.Cos%2A>方法使用以下公式来计算复数 a + bi 的余弦：</span><span class="sxs-lookup"><span data-stu-id="53cad-248">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53cad-249"> ( ()  ()  ( ()  () <xref:System.Math.Cos%2A> <xref:System.Math.Cosh%2A> <xref:System.Math.Sin%2A> <xref:System.Math.Sinh%2A> # A10 # A11</span><span class="sxs-lookup"><span data-stu-id="53cad-249">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-250">下面的示例演示 <xref:System.Numerics.Complex.Acos%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-250">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="53cad-251">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Acos%2A> 到方法将 <xref:System.Numerics.Complex.Cos%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-251">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-252">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-252">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-253">返回指定复数的双曲余弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-253">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-254"><paramref name="value" /> 的双曲余弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-254">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-255"><xref:System.Numerics.Complex.Cosh%2A>复数的方法与实数的方法相对应 <xref:System.Math.Cosh%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-255">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-256"><xref:System.Numerics.Complex.Cosh%2A>方法使用以下公式来计算复数 a + bi 的双曲余弦值：</span><span class="sxs-lookup"><span data-stu-id="53cad-256">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53cad-257"> ( ()  ()  ()  () <xref:System.Math.Cosh%2A> <xref:System.Math.Cos%2A> <xref:System.Math.Sinh%2A> <xref:System.Math.Sin%2A> # A9</span><span class="sxs-lookup"><span data-stu-id="53cad-257">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <Docs>
        <summary><span data-ttu-id="53cad-258">将一个指定数字除以另一个指定数字，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-258">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="53cad-259"><xref:System.Numerics.Complex.Divide%2A>方法允许执行涉及复数的除法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-259">The <xref:System.Numerics.Complex.Divide%2A> methods allow performing division operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="53cad-260">如果商的计算导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-260">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53cad-261"><xref:System.Numerics.Complex.Divide%2A>方法可用于不支持自定义运算符的语言。</span><span class="sxs-lookup"><span data-stu-id="53cad-261">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="53cad-262">其行为与使用除法运算符的除法相同。</span><span class="sxs-lookup"><span data-stu-id="53cad-262">Its behavior is identical to division using the division operator.</span></span>  

 <span data-ttu-id="53cad-263"><xref:System.Numerics.Complex.Divide%2A>接收一个 double 的方法比接收两个复数的方法更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-263">The <xref:System.Numerics.Complex.Divide%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>

## Examples  
 <span data-ttu-id="53cad-264">下面的示例将一个复数除以复数数组中的每个元素。</span><span class="sxs-lookup"><span data-stu-id="53cad-264">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
   
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="53cad-265">要作为被除数的双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-265">The double-precision real number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="53cad-266">要作为除数的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-266">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-267">将一个双精度实数除以一个复数，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-267">Divides one double-precision real number by a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-268">相除后的商。</span><span class="sxs-lookup"><span data-stu-id="53cad-268">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="53cad-269">实数的相除 (可以视为复数 a + 0 i) ，而 (c + di) 的复数采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-269">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

 <span data-ttu-id="53cad-270"> (ac/ (c<sup>2</sup> + d<sup>2</sup>) # A3 + (ad/ (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="53cad-270">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="53cad-271">要作为被除数的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-271">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="53cad-272">要作为除数的双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-272">The double-precision real number to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-273">将一个复数除以一个双精度实数，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-273">Divides one complex number by a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-274">相除后的商。</span><span class="sxs-lookup"><span data-stu-id="53cad-274">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="53cad-275">复数的相除 (+ bi) 和实数 (，可以视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-275">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

 <span data-ttu-id="53cad-276"> (ac/c<sup>2</sup>) + (bc/c<sup>2</sup>) </span><span class="sxs-lookup"><span data-stu-id="53cad-276">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="53cad-277">要作为被除数的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-277">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="53cad-278">要作为除数的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-278">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-279">用一个复数除另一个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-279">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-280">相除后的商。</span><span class="sxs-lookup"><span data-stu-id="53cad-280">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-281">复数的相除，+ bi 除以第二个复数，number，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-281">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53cad-282"> ( # B1 ac + bd) / (c<sup>2</sup> + d<sup>2</sup>) # A5 + ( # B7 bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) </span><span class="sxs-lookup"><span data-stu-id="53cad-282">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
    
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-283">返回一个值，该值指示两个复数是否相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-283">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-284">要比较的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-284">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="53cad-285">返回一个值，该值指示当前实例与指定的复数是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-285">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="53cad-286">如果此复数与 <paramref name="value" /> 具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-286"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-287"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法提供结构的 <xref:System.IEquatable%601> 实现 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-287">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="53cad-288">它的执行方式略好于 <xref:System.Numerics.Complex.Equals%28System.Object%29> 方法，因为它不需要将其参数转换为复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-288">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="53cad-289">如果两个复数的实部相等并且其虚部相等，则这两个复数相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-289">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53cad-290"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="53cad-290">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="53cad-291"><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />请谨慎使用方法，因为它们的实部和虚部的精度不同，所以有两个明显等效的值可能被视为不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-291">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="53cad-292">下面的示例报告 <c> (3.33333、0.142857) </c> 和 <c> (10/3，1/7) </c> 不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-292">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="53cad-293">[！ code-csharp[system.web. Equals # 4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)][！ code-vb[system.web. Equals # 4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="53cad-293">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="53cad-294">一种建议的方法是定义两个值之间的差异的可接受边距 (例如，其中一个值为实部和虚部) 的 .01%，而不是比较值是否相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-294">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="53cad-295">如果这两个值之差的绝对值小于或等于该边距，则差异可能是由于精度的不同而造成的，因此，这些值可能是相等的。</span><span class="sxs-lookup"><span data-stu-id="53cad-295">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="53cad-296">下面的示例使用此方法来比较前面的代码示例发现不相等的两个复杂值。</span><span class="sxs-lookup"><span data-stu-id="53cad-296">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="53cad-297">它会查找两个相等的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-297">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="53cad-298">[！ code-csharp[system.web. Equals # 5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)][！ code-vb[system.web. Equals # 5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="53cad-298">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="53cad-299">要比较的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-299">The object to compare.</span></span></param>
        <summary><span data-ttu-id="53cad-300">返回一个值，该值指示当前实例与指定的对象是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-300">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="53cad-301">如果 <paramref name="obj" /> 参数是一个 <see cref="T:System.Numerics.Complex" /> 对象或是一个能够隐式转换为 <see cref="T:System.Numerics.Complex" /> 对象的类型，并且其值等于当前 <see cref="T:System.Numerics.Complex" /> 对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-301"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-302">如果两个复数的实部相等并且其虚部相等，则这两个复数相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-302">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53cad-303"><xref:System.Numerics.Complex.Equals%28System.Object%29>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="53cad-303">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="53cad-304">如果 `obj` 参数不是 <xref:System.Numerics.Complex> 对象，但它是为其定义了隐式转换的数据类型，则 <xref:System.Numerics.Complex.Equals%28System.Object%29> 方法将转换 `obj` 为一个对象，该对象的 <xref:System.Numerics.Complex> 实部等于 `obj` 并且其虚部等于零，然后再执行比较。</span><span class="sxs-lookup"><span data-stu-id="53cad-304">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="53cad-305">下面的示例通过发现复数和双精度浮点值相等来对此进行了说明。</span><span class="sxs-lookup"><span data-stu-id="53cad-305">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="53cad-306"><see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />请谨慎使用方法，因为它们的实部和虚部的精度不同，所以有两个明显等效的值可能被视为不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-306">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="53cad-307">如果在 <paramref name="obj" /> 执行比较之前必须将转换为，则此问题可能是突出的 <see cref="T:System.Double" /> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-307">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="53cad-308">下面的示例比较一个复数，该复数的实际成分与该值相等 <see cref="T:System.Single" /> <see cref="T:System.Single" /> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-308">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="53cad-309">如输出所示，相等性比较返回 <see langword="False" /> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-309">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="53cad-310">[！ code-csharp ...[# 8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)][！ code-vb[system.web. Equals # 8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="53cad-310">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="53cad-311">一种建议的方法是定义两个值之间的差异的可接受边距 (例如，其中一个值为实部和虚部) 的 .01%，而不是比较值是否相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-311">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="53cad-312">如果这两个值之差的绝对值小于或等于该边距，则差异可能是由于精度的不同而造成的，因此，这些值可能是相等的。</span><span class="sxs-lookup"><span data-stu-id="53cad-312">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="53cad-313">下面的示例使用此方法来比较前面的代码示例发现的两个值是否不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-313">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="53cad-314">它现在会发现它们是相等的。</span><span class="sxs-lookup"><span data-stu-id="53cad-314">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="53cad-315">[！ code-csharp[system.web. Equals # 7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)][！ code-vb[system.web. Equals # 7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="53cad-315">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-316">指定幂的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-316">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="53cad-317">返回 <see langword="e" /> 的由一个复数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-317">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-318">数字 <see langword="e" /> 的 <paramref name="value" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-318">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-319">使用 <xref:System.Numerics.Complex.Pow%2A> 方法计算其他底数的幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-319">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="53cad-320"><xref:System.Numerics.Complex.Exp%2A>复数的方法与实数的方法相对应 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-320">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="53cad-321"><xref:System.Numerics.Complex.Exp%2A> 是的逆 <xref:System.Numerics.Complex.Log%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-321"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-322">下面的示例演示 <xref:System.Numerics.Complex.Exp%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-322">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="53cad-323">其中显示，由于缺少 <xref:System.Double> 数据类型的精度，将方法返回的值传递 <xref:System.Numerics.Complex.Log%2A> 给方法会 <xref:System.Numerics.Complex.Exp%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-323">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="53cad-324">量值，它是从原点（x 轴与 y 轴的交点）到数字的距离。</span><span class="sxs-lookup"><span data-stu-id="53cad-324">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="53cad-325">相位，它是直线相对于水平轴的角度，以弧度为单位。</span><span class="sxs-lookup"><span data-stu-id="53cad-325">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="53cad-326">从点的极坐标创建复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-326">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="53cad-327">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-327">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-328"><xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法基于其极坐标实例化复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-328">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="53cad-329">因为在复杂平面上存在多个点的表示形式，所以方法的返回值 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 将规范化。</span><span class="sxs-lookup"><span data-stu-id="53cad-329">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="53cad-330">此量的值规范化为正数，而阶段则规范化为范围内的值 <xref:System.Math.PI> <xref:System.Math.PI> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-330">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="53cad-331">因此， <xref:System.Numerics.Complex.Phase%2A> <xref:System.Numerics.Complex.Magnitude%2A> 生成的复数的和属性的值不能等于和参数的原始值 `magnitude` `phase` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-331">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="53cad-332">若要将参数的值从度转换为弧度 `phase` ，请将它乘以 <xref:System.Math.PI?displayProperty=nameWithType> /180。</span><span class="sxs-lookup"><span data-stu-id="53cad-332">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-333">下面的示例使用 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 方法基于其极坐标来实例化复数，并显示其 <xref:System.Numerics.Complex.Magnitude%2A> 和属性的值 <xref:System.Numerics.Complex.Phase%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-333">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="53cad-334">返回当前 <see cref="T:System.Numerics.Complex" /> 对象的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="53cad-334">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="53cad-335">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="53cad-335">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-336">获取当前 <see cref="T:System.Numerics.Complex" /> 对象的虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-336">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="53cad-337">复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-337">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-338">如果给定复数 a + bi，则该 <xref:System.Numerics.Complex.Imaginary%2A> 属性返回 b 的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-338">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-339">下面的示例实例化一个 <xref:System.Numerics.Complex> 对象数组，并以 a + bi 的形式显示每个对象的实部和虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-339">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-340">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数等于零，虚数等于一。</span><span class="sxs-lookup"><span data-stu-id="53cad-340">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="53cad-341">下面的示例 <xref:System.Numerics.Complex> 使用属性将值实例化 <xref:System.Numerics.Complex.ImaginaryOne> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-341">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="53cad-342">然后，它会将此值与另一个值进行比较，方法是调用 <xref:System.Numerics.Complex> 构造函数，该构造函数的实部等于零，虚部为一个。</span><span class="sxs-lookup"><span data-stu-id="53cad-342">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="53cad-343">如示例中的输出所示，这两个值相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-343">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-344">用复数表示无穷大。</span><span class="sxs-lookup"><span data-stu-id="53cad-344">Represents infinity as a complex number.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-345">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-345">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-346">确定指定的复数是否是有限的。</span><span class="sxs-lookup"><span data-stu-id="53cad-346">Determines whether the specified complex number is finite.</span></span></summary>
        <returns><span data-ttu-id="53cad-347">如果实部和虚部都是有限的（零、次正规数或正规数），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-347"><see langword="true" /> if both, the real and imaginary parts are finite (zero, subnormal or normal); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-348">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-348">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-349">返回一个值，该值指示指定复数的计算结果是否为无穷大。</span><span class="sxs-lookup"><span data-stu-id="53cad-349">Returns a value indicating whether the specified complex number evaluates to infinity.</span></span></summary>
        <returns><span data-ttu-id="53cad-350">如果实部或虚部为 <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-350"><see langword="true" /> if either, the real or imaginary part are <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-351">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-351">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-352">返回一个值，该值指示指定的复数实例是否不为数值 (NaN)。</span><span class="sxs-lookup"><span data-stu-id="53cad-352">Returns a value that indicates whether the specified complex instance is not a number (NaN).</span></span></summary>
        <returns><span data-ttu-id="53cad-353">如果指定值既不是有限的也不是无限的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-353"><see langword="true" /> if the specified value is not finite nor infinite; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-354">返回一个复数的对数。</span><span class="sxs-lookup"><span data-stu-id="53cad-354">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-355">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-355">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-356">返回指定复数的自然对数（底为 <see langword="e" />）。</span><span class="sxs-lookup"><span data-stu-id="53cad-356">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-357"><paramref name="value" /> 的自然对数（底为 <see langword="e" />）。</span><span class="sxs-lookup"><span data-stu-id="53cad-357">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-358"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29>复数的方法与实数的方法相对应 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-358">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-359">下面的示例演示 <xref:System.Numerics.Complex.Log%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-359">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="53cad-360">其中显示，由于缺少 <xref:System.Double> 数据类型的精度，将方法返回的值传递 <xref:System.Numerics.Complex.Log%2A> 给方法会 <xref:System.Numerics.Complex.Exp%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-360">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-361">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-361">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="53cad-362">对数的底。</span><span class="sxs-lookup"><span data-stu-id="53cad-362">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="53cad-363">返回指定复数在使用指定底时的对数。</span><span class="sxs-lookup"><span data-stu-id="53cad-363">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="53cad-364"><paramref name="value" /> 的对数（底为 <paramref name="baseValue" />）。</span><span class="sxs-lookup"><span data-stu-id="53cad-364">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-365"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29>复数的方法与实数的方法相对应 <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-365">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-366">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-366">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-367">返回指定复数以 10 为底的对数。</span><span class="sxs-lookup"><span data-stu-id="53cad-367">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-368"><paramref name="value" /> 的以 10 为底的对数。</span><span class="sxs-lookup"><span data-stu-id="53cad-368">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-369"><xref:System.Numerics.Complex.Log10%2A>复数的方法与实数的方法相对应 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-369">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-370">获取复数的量值（或绝对值）。</span><span class="sxs-lookup"><span data-stu-id="53cad-370">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="53cad-371">当前实例的量值。</span><span class="sxs-lookup"><span data-stu-id="53cad-371">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-372"><xref:System.Numerics.Complex.Magnitude%2A>属性等效于复数的绝对值。</span><span class="sxs-lookup"><span data-stu-id="53cad-372">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="53cad-373">它指定原点坐标系统中 x 轴与 y 轴的交点 (与原点的距离) 到由复数表示的二维点。</span><span class="sxs-lookup"><span data-stu-id="53cad-373">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="53cad-374">计算绝对值的方法如下：</span><span class="sxs-lookup"><span data-stu-id="53cad-374">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="53cad-375">&#124; + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> (\* a + b \* b) </span><span class="sxs-lookup"><span data-stu-id="53cad-375">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="53cad-376">如果绝对值的计算导致溢出，则此属性返回 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-376">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53cad-377"><xref:System.Numerics.Complex.Magnitude%2A>和 <xref:System.Numerics.Complex.Phase%2A> 属性定义表示极坐标系统中的复数的点的位置。</span><span class="sxs-lookup"><span data-stu-id="53cad-377">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="53cad-378">可以通过调用方法，基于其极坐标而不是笛卡尔坐标来实例化复数 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-378">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-379">下面的示例计算复数的绝对值，并说明它等效于属性的值 <xref:System.Numerics.Complex.Magnitude%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-379">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <Docs>
        <summary><span data-ttu-id="53cad-380">将一个指定数字乘以另一个指定数字，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-380">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-381"><xref:System.Numerics.Complex.Multiply%2A>方法允许执行涉及复数的乘法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-381">The <xref:System.Numerics.Complex.Multiply%2A> methods allow performing multiplication operations that involve complex numbers.</span></span>

<span data-ttu-id="53cad-382">如果乘法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-382">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
 
<span data-ttu-id="53cad-383"><xref:System.Numerics.Complex.Multiply%2A>方法是为不支持自定义运算符的语言实现的。</span><span class="sxs-lookup"><span data-stu-id="53cad-383">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="53cad-384">它的行为与使用乘法运算符的乘法相同。</span><span class="sxs-lookup"><span data-stu-id="53cad-384">Its behavior is identical to multiplication using the multiplication operator.</span></span>  

  
## Examples  

<span data-ttu-id="53cad-385">下面的示例将一个复数与一个复数数组中的每个元素进行比较。</span><span class="sxs-lookup"><span data-stu-id="53cad-385">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
[!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
[!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-386">要相乘的双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-386">The double-precision real number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-387">要相乘的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-387">The complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-388">返回一个双精度实数与一个复数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-388">Returns the product of a double-precision real number and a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-389"><paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-389">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="53cad-390">实数的乘法 (可以视为复数 a + 0 i) ，而 (c + di) 的复数采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-390">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>
 
 <span data-ttu-id="53cad-391">ac + adi</span><span class="sxs-lookup"><span data-stu-id="53cad-391">ac + adi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-392">要相乘的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-392">The complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-393">要相乘的双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-393">The double-precision real number to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-394">返回一个复数与一个双精度实数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-394">Returns the product of a complex number and a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="53cad-395"><paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-395">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-396">复数的乘法 (+ bi) 和实数 (，可以视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-396">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-397">ac + bci</span><span class="sxs-lookup"><span data-stu-id="53cad-397">ac + bci</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-398">要相乘的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-398">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-399">要相乘的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-399">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-400">返回两个复数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-400">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="53cad-401"><paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-401">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-402">复数、+ bi 和第二复数（c + di）的乘法采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-402">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53cad-403"> (ac-bd) + (ad + bc) </span><span class="sxs-lookup"><span data-stu-id="53cad-403">(ac - bd) + (ad + bc)i</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-404">表示一个不为数值 (NaN) 的复数实例。</span><span class="sxs-lookup"><span data-stu-id="53cad-404">Represents a complex instance that is not a number (NaN).</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-405">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-405">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-406">返回指定复数的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="53cad-406">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-407"><paramref name="value" /> 参数的 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-407">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-408">复数的加法逆元是在将 <xref:System.Numerics.Complex.Zero> 其添加到原始复数时产生值的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-408">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number.</span></span> <span data-ttu-id="53cad-409">此方法返回一个复数，其中，原始复数的实部和虚部均乘以-1。</span><span class="sxs-lookup"><span data-stu-id="53cad-409">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="53cad-410"><xref:System.Numerics.Complex.Negate%2A>方法是为不支持自定义运算符的语言实现的。</span><span class="sxs-lookup"><span data-stu-id="53cad-410">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="53cad-411">它的行为等同于使用一元求反运算符的求反 <xref:System.Numerics.Complex.op_UnaryNegation%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-411">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-412">下面的示例获取复数数组中每个元素的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="53cad-412">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-413">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数等于一，虚数等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-413">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="53cad-414">下面的示例 <xref:System.Numerics.Complex> 使用属性将值实例化 <xref:System.Numerics.Complex.One> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-414">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="53cad-415">然后，它会将此值与另一个值进行比较，方法是调用 <xref:System.Numerics.Complex> 构造函数，该构造函数的实部为1，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-415">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="53cad-416">如示例中的输出所示，这两个值相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-416">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <Docs>
        <summary><span data-ttu-id="53cad-417">将一个指定数字与另一个指定数字相加，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-417">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-418"><xref:System.Numerics.Complex.op_Addition%2A>运算符允许执行涉及复数的加法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-418">The <xref:System.Numerics.Complex.op_Addition%2A> operator allows performing addition operations that involve complex numbers.</span></span> <span data-ttu-id="53cad-419">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-419">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
[!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]

<span data-ttu-id="53cad-420">如果加法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-420">If the addition results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="53cad-421">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Add%2A> 等效的方法组。</span><span class="sxs-lookup"><span data-stu-id="53cad-421">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="53cad-422"><xref:System.Numerics.Complex.op_Addition%2A>接收一个 double 的运算符比接收两个复数的运算符更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-422">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="53cad-423">下面的示例阐释了包含复数的加法：</span><span class="sxs-lookup"><span data-stu-id="53cad-423">The following example illustrates addition with complex numbers:</span></span>

[!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
[!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-424">要相加的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-424">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-425">要相加的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-425">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="53cad-426">将一个双精度实数与一个复数相加。</span><span class="sxs-lookup"><span data-stu-id="53cad-426">Adds a double-precision real number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-427"><paramref name="left" /> 与 <paramref name="right" /> 之和（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-427">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-428">添加实数 (可以将其视为复数 a + 0 i) ，复数 (c + di) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-428">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="53cad-429"> (+ c) + di</span><span class="sxs-lookup"><span data-stu-id="53cad-429">(a + c) + di</span></span>

<span data-ttu-id="53cad-430">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-430">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-431">要相加的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-431">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-432">要相加的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-432">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="53cad-433">将一个复数与一个双精度实数相加。</span><span class="sxs-lookup"><span data-stu-id="53cad-433">Adds a complex number to a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="53cad-434"><paramref name="left" /> 与 <paramref name="right" /> 之和（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-434">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-435">添加一个复数 (+ bi) 和一个实数 (可视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-435">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-436"> (+ c) + bi</span><span class="sxs-lookup"><span data-stu-id="53cad-436">(a + c) + bi</span></span>

<span data-ttu-id="53cad-437">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-437">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-438">要相加的第一个复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-438">The first complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-439">要相加的第二个复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-439">The second complex value to add.</span></span></param>
        <summary><span data-ttu-id="53cad-440">将两个复数相加。</span><span class="sxs-lookup"><span data-stu-id="53cad-440">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="53cad-441"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="53cad-441">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-442">加法复数、+ bi 和第二复数 c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-442">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="53cad-443"> (+ c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="53cad-443">(a + c) + (b + d)i</span></span>

<span data-ttu-id="53cad-444">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-444">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Division">
      <Docs>
        <summary><span data-ttu-id="53cad-445">将一个指定数字除以另一个指定数字，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-445">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-446"><xref:System.Numerics.Complex.op_Division%2A>运算符允许执行涉及复数的除法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-446">The <xref:System.Numerics.Complex.op_Division%2A> operator allows performing division operations that involve complex numbers.</span></span> <span data-ttu-id="53cad-447">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-447">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
[!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]

<span data-ttu-id="53cad-448">如果除法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-448">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="53cad-449">不支持自定义运算符和运算符重载的语言可以改为调用 <xref:System.Numerics.Complex.Divide%2A> 等效的方法组。</span><span class="sxs-lookup"><span data-stu-id="53cad-449">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> equivalent group of method instead.</span></span>

<span data-ttu-id="53cad-450"><xref:System.Numerics.Complex.op_Division%2A>接收一个 double 的运算符比接收两个复数的运算符更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-450">The <xref:System.Numerics.Complex.op_Division%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-451">要作为被除数的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-451">The double-precision real value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-452">要作为除数的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-452">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-453">将一个指定双精度实数除以一个指定复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-453">Divides a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-454"><paramref name="left" /> 除以 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-454">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-455">实数的相除 (可以视为复数 a + 0 i) ，而 (c + di) 的复数采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-455">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="53cad-456"> (ac/ (c<sup>2</sup> + d<sup>2</sup>) # A3 + (ad/ (c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="53cad-456">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="53cad-457">不支持自定义运算符和运算符重载的语言可以改为调用 <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-457">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-458">要作为被除数的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-458">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-459">要作为除数的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-459">The double-precision real value to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-460">将一个指定复数除以一个指定双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-460">Divides a specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="53cad-461"><paramref name="left" /> 除以 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-461">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-462">复数的相除 (+ bi) 和实数 (，可以视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-462">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-463"> (ac/c<sup>2</sup>) + (bc/c<sup>2</sup>) </span><span class="sxs-lookup"><span data-stu-id="53cad-463">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

<span data-ttu-id="53cad-464">不支持自定义运算符和运算符重载的语言可以改为调用 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-464">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-465">要作为被除数的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-465">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-466">要作为除数的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-466">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="53cad-467">用一个指定复数除另一个指定复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-467">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-468"><paramref name="left" /> 除以 <paramref name="right" /> 的结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-468">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-469">复数、+ bi 和第二复数的除以 c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-469">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="53cad-470"> ( # B1 ac + bd) / (c<sup>2</sup> + d<sup>2</sup>) # A5 + ( # B7 bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) </span><span class="sxs-lookup"><span data-stu-id="53cad-470">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="53cad-471">不支持自定义运算符和运算符重载的语言可以改为调用 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-471">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-472">要比较的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-472">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-473">要比较的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-473">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="53cad-474">返回一个值，该值指示两个复数是否相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-474">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="53cad-475">如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-475"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-476"><xref:System.Numerics.Complex.op_Equality%2A>方法定义了值的相等运算符的运算 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-476">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="53cad-477">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-477">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="53cad-478">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-478">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="53cad-479">如果两个复数的实部相等并且其虚部相等，则这两个复数相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-479">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53cad-480"><xref:System.Numerics.Complex.op_Equality%2A>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="53cad-480">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="53cad-481">请注意，由于精度差异，两个明显等效的复数可以视为不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-481">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="53cad-482">有关详细信息和可能的解决方法，请参阅 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-482">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="53cad-483">此运算符的等效方法是 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53cad-483">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-484">定义 <see cref="T:System.Numerics.Complex" /> 对象与其他类型之间的显式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-484">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-485">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-485">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-486">定义从 <see cref="T:System.Decimal" /> 值到复数的显式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-486">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-487">一个复数，其实部等于 <paramref name="value" />，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-487">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-488">显式转换运算符定义可转换为对象的类型 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-488">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53cad-489">语言编译器不会自动执行此转换，因为这可能会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="53cad-489">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="53cad-490">相反，它们仅在 c # 中 (转换运算符 ) 或 (如 `CType` 使用 Visual Basic) 时才执行转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-490">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="53cad-491">否则，它们会显示编译器错误。</span><span class="sxs-lookup"><span data-stu-id="53cad-491">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="53cad-492"><xref:System.Decimal>值到复数实部的转换可能会导致精度损失 <xref:System.Double> ，这是因为，它是复数属性的类型 <xref:System.Numerics.Complex.Real%2A> ，其有效位数少于 <xref:System.Decimal> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-492">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="53cad-493">下面的示例演示了 <xref:System.Decimal> 值到值的显式转换 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-493">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-494">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-494">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-495">定义从 <see cref="T:System.Numerics.BigInteger" /> 值到复数的显式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-495">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-496">一个复数，其实部等于 <paramref name="value" />，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-496">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-497">显式转换运算符定义可转换为对象的类型 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-497">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53cad-498">语言编译器不会自动执行此转换，因为这可能会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="53cad-498">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="53cad-499">相反，它们仅在 c # 中 (转换运算符 ) 或 (如 `CType` 使用 Visual Basic) 时才执行转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-499">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="53cad-500">否则，它们会显示编译器错误。</span><span class="sxs-lookup"><span data-stu-id="53cad-500">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="53cad-501"><xref:System.Numerics.BigInteger>值到复数实部的转换可能会导致精度损失 <xref:System.Double> ，这是因为，它是复数属性的类型 <xref:System.Numerics.Complex.Real%2A> ，其有效位数少于 <xref:System.Numerics.BigInteger> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-501">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="53cad-502">如果转换失败 <xref:System.Numerics.BigInteger> ，因为值超出了类型的范围 <xref:System.Double> ，则操作不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-502">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="53cad-503">如果 `value` 小于 <xref:System.Double.MinValue> ，则结果为具有 <xref:System.Numerics.Complex.Real%2A> 等于的属性值的复数 <xref:System.Double.NegativeInfinity> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-503">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="53cad-504">如果 `value` 大于，则 <xref:System.Double.MaxValue> 结果为具有 <xref:System.Numerics.Complex.Real%2A> 等于的属性值的复数 <xref:System.Double.PositiveInfinity> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-504">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="53cad-505">下面的示例演示了 <xref:System.Numerics.BigInteger> 值到值的显式转换 <xref:System.Numerics.Complex> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-505">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-506">定义 <see cref="T:System.Numerics.Complex" /> 对象与其他类型之间的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-506">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-507">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-507">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-508">定义从无符号字节到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-508">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-509">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-509">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-510">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-510">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-511">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-511">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-512">此重载使编译器能够处理从 <xref:System.Byte> 值到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-512">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-513">请注意，转换的结果是一个复数，其实部等于 <xref:System.Byte> 值，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-513">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-514">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-514">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-515">定义从双精度浮点数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-515">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-516">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-516">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-517">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-517">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-518">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-518">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-519">此重载使编译器能够处理从 <xref:System.Double> 值到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-519">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-520">请注意，转换的结果是一个复数，其实部等于 <xref:System.Double> 值，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-520">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-521">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-521">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-522">定义从 16 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-522">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-523">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-523">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-524">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-524">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-525">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-525">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-526">此重载使编译器能够处理从16位带符号整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-526">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-527">请注意，转换的结果是一个复数，其实数部分等于有符号16位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-527">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-528">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-528">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-529">定义从 32 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-529">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-530">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-530">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-531">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-531">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-532">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-532">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-533">此重载使编译器能够处理从带符号32位整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-533">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-534">请注意，转换的结果是一个复数，其实数部分等于有符号32位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-534">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-535">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-535">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-536">定义从 64 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-536">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-537">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-537">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-538">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-538">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-539">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-539">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-540">此重载使编译器能够处理从带符号64位整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-540">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-541">请注意，转换的结果是一个复数，其实数部分等于有符号64位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-541">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-542">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-542">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-543">定义从带符号字节到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-543">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="53cad-544">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="53cad-544">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="53cad-545">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-545">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-546">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-546">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-547">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-547">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-548">此重载使编译器能够处理从带符号字节到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-548">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-549">请注意，转换的结果是一个复数，其实数部分等于有符号字节，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-549">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-550">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-550">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-551">定义从单精度浮点数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-551">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-552">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-552">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-553">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-553">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-554">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-554">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-555">此重载使编译器能够处理从 <xref:System.Single> 值到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-555">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-556">请注意，转换的结果是一个复数，其实部等于 <xref:System.Single> 值，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-556">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-557">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-557">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-558">定义从 16 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-558">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="53cad-559">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="53cad-559">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="53cad-560">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-560">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-561">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-561">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-562">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-562">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-563">此重载使编译器能够处理从16位无符号整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-563">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-564">请注意，转换的结果是一个复数，其实数部分等于无符号16位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-564">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-565">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-565">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-566">定义从 32 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-566">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="53cad-567">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="53cad-567">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="53cad-568">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-568">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-569">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-569">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-570">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-570">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-571">此重载使编译器能够处理从无符号32位整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-571">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-572">请注意，转换的结果是一个复数，其实数部分等于无符号32位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-572">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-573">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-573">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-574">定义从 64 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="53cad-574">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="53cad-575">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="53cad-575">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="53cad-576">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-576">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-577">运算符的重载 <xref:System.Numerics.Complex.op_Implicit%2A> 定义了这样的类型：编译器无需显式转换运算符即可自动将对象转换为 <xref:System.Numerics.Complex> c # 中的 (，) 或者在 Visual Basic) 中 (调用转换函数。</span><span class="sxs-lookup"><span data-stu-id="53cad-577">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53cad-578">它们是不涉及数据丢失的扩大转换，不会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-578">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53cad-579">此重载使编译器能够处理从无符号64位整数到复数的转换，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="53cad-579">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53cad-580">请注意，转换的结果是一个复数，其实数部分等于无符号64位整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-580">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-581">要比较的第一个值。</span><span class="sxs-lookup"><span data-stu-id="53cad-581">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-582">要比较的第二个值。</span><span class="sxs-lookup"><span data-stu-id="53cad-582">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="53cad-583">返回一个值，该值指示两个复数是否不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-583">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="53cad-584">如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="53cad-584"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-585"><xref:System.Numerics.Complex.op_Equality%2A>方法为复数定义不相等运算符的运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-585">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="53cad-586">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-586">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="53cad-587">不支持自定义运算符的语言可以通过调用 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法并反转其值来测试是否不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-587">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="53cad-588">请注意，由于精度差异，两个明显等效的复数可以视为不相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-588">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="53cad-589">一种可能的解决方法是实现一个比较方法，该方法 `true` 仅在复数的两个实部和虚部的差超过特定的阈值时才返回 (例如，其中一个复数的实部或虚部的值的 .01%) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-589">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="53cad-590">有关更多信息，请参见 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-590">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary><span data-ttu-id="53cad-591">将一个指定数字乘以另一个指定数字，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-591">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-592"><xref:System.Numerics.Complex.op_Multiply%2A>运算符允许执行涉及复数的乘法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-592">The <xref:System.Numerics.Complex.op_Multiply%2A> operator allows performing multiplication operations that involve complex numbers.</span></span> <span data-ttu-id="53cad-593">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-593">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
[!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]

<span data-ttu-id="53cad-594">如果乘法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-594">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="53cad-595">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Multiply%2A> 等效的方法组。</span><span class="sxs-lookup"><span data-stu-id="53cad-595">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="53cad-596"><xref:System.Numerics.Complex.op_Multiply%2A>接收一个 double 的运算符比接收两个复数的运算符更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-596">The <xref:System.Numerics.Complex.op_Multiply%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-597">要相乘的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-597">The double-precision real value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-598">要相乘的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-598">The complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-599">将一个指定双精度实数乘以一个指定复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-599">Multiplies a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-600"><paramref name="left" /> 与 <paramref name="right" /> 的乘积（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-600">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-601">实数的乘法 (可以视为复数 a + 0 i) ，而 (c + di) 的复数采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-601">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="53cad-602">ac + adi</span><span class="sxs-lookup"><span data-stu-id="53cad-602">ac + adi</span></span>

<span data-ttu-id="53cad-603">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-603">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>


          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-604">要相乘的复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-604">The complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-605">要相乘的双精度实数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-605">The double-precision real value to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-606">将一个指定复数乘以一个指定双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-606">Multiplies the specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="53cad-607"><paramref name="left" /> 与 <paramref name="right" /> 的乘积（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-607">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-608">复数的乘法 (+ bi) 和实数 (，可以视为复数 c + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-608">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-609">ac + bci</span><span class="sxs-lookup"><span data-stu-id="53cad-609">ac + bci</span></span>

<span data-ttu-id="53cad-610">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-610">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-611">要相乘的第一个复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-611">The first complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="53cad-612">要相乘的第二个复值。</span><span class="sxs-lookup"><span data-stu-id="53cad-612">The second complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="53cad-613">将两个指定复数相乘。</span><span class="sxs-lookup"><span data-stu-id="53cad-613">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="53cad-614"><paramref name="left" /> 与 <paramref name="right" /> 的乘积。</span><span class="sxs-lookup"><span data-stu-id="53cad-614">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-615">复数、+ bi 和第二复数（c + di）的乘法采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-615">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="53cad-616"> (ac-bd) + (ad + bc) </span><span class="sxs-lookup"><span data-stu-id="53cad-616">(ac - bd) + (ad + bc)i</span></span>

<span data-ttu-id="53cad-617">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-617">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <Docs>
        <summary><span data-ttu-id="53cad-618">一个指定数减另一个指定数，其中至少有一个是复数，另一个可以是双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-618">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-619"><xref:System.Numerics.Complex.op_Subtraction%2A>运算符允许执行涉及复数的减法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-619">The <xref:System.Numerics.Complex.op_Subtraction%2A> operator allows performing subtraction operations that involve complex numbers.</span></span> <span data-ttu-id="53cad-620">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-620">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
[!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]

<span data-ttu-id="53cad-621">如果减法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-621">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="53cad-622">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Subtract%2A> 等效的方法组。</span><span class="sxs-lookup"><span data-stu-id="53cad-622">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="53cad-623"><xref:System.Numerics.Complex.op_Addition%2A>接收一个 double 的运算符比接收两个复数的运算符更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-623">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-624">要被减的双精度实数值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-624">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-625">要减去的复值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-625">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-626">一个双精度实数减一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-626">Subtracts a complex number from a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="53cad-627"><paramref name="left" /> 减 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-627">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-628">复数 (c + di) 与实 (之间的减法，可视为复数 a + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-628">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-629"> (c) -di</span><span class="sxs-lookup"><span data-stu-id="53cad-629">(a - c) - di</span></span>

<span data-ttu-id="53cad-630">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-630">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-631">要被减的复值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-631">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-632">要减去的双精度实数值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-632">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-633">一个复数减一个双精度实数。</span><span class="sxs-lookup"><span data-stu-id="53cad-633">Subtracts a double-precision real number from a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-634"><paramref name="left" /> 减 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-634">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-635">实数的减 (可以视为复数 c + 0 i， (+ bi) 的复数) ，其形式如下：</span><span class="sxs-lookup"><span data-stu-id="53cad-635">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="53cad-636"> (c) + bi</span><span class="sxs-lookup"><span data-stu-id="53cad-636">(a - c) + bi</span></span>

<span data-ttu-id="53cad-637">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-637">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-638">要从中减去的值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-638">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-639">要减去的值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-639">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-640">从一个复数中减去另一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-640">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-641"><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-641">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-642">复数 c + di 与其他复数 a + bi 的减法运算采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-642">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="53cad-643"> (c) + (b) i</span><span class="sxs-lookup"><span data-stu-id="53cad-643">(a - c) + (b - d)i</span></span>

<span data-ttu-id="53cad-644">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-644">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-645">要求反的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-645">The value to negate.</span></span></param>
        <summary><span data-ttu-id="53cad-646">返回指定复数的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="53cad-646">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-647"><paramref name="value" /> 参数的 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-647">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-648"><xref:System.Numerics.Complex.op_UnaryNegation%2A>方法为复数定义一元求反 (加法反) 运算符的运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-648">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="53cad-649">它可以实现如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="53cad-649">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="53cad-650">如果生成的复数 <xref:System.Numerics.Complex.Zero> 添加到原始复数，则会生成值。</span><span class="sxs-lookup"><span data-stu-id="53cad-650">The resulting complex number produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number.</span></span> <span data-ttu-id="53cad-651">不支持自定义运算符的语言可以改为调用 <xref:System.Numerics.Complex.Negate%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-651">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="53cad-652">此运算符的等效方法是 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53cad-652">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-653">获取复数的相位。</span><span class="sxs-lookup"><span data-stu-id="53cad-653">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="53cad-654">复数的相位（以弧度为单位）。</span><span class="sxs-lookup"><span data-stu-id="53cad-654">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-655">对于复数 a + bi，阶段计算为 <xref:System.Math.Atan2%2A?displayProperty=nameWithType> (b，) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-655">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="53cad-656">您可以通过它在复杂平面上的笛卡尔坐标或其极坐标来标识复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-656">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="53cad-657">复数 (参数) 的值是从原点点绘制的直线的角度， (从 x 轴和 y 轴) 到复数所表示的点之间的直线点。</span><span class="sxs-lookup"><span data-stu-id="53cad-657">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="53cad-658">属性) 表示的 (量 <xref:System.Numerics.Complex.Magnitude%2A> 是从原点到由复数表示的点之间的距离。</span><span class="sxs-lookup"><span data-stu-id="53cad-658">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="53cad-659">可以通过调用方法，基于其极坐标而不是笛卡尔坐标来实例化复数 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-659">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="53cad-660">若要将阶段从弧度转换为度，请将它乘以 180/ <xref:System.Math.PI?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-660">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-661">下面的示例使用 <xref:System.Numerics.Complex.FromPolarCoordinates%2A> 方法基于其极坐标来实例化复数，并显示其 <xref:System.Numerics.Complex.Magnitude%2A> 和属性的值 <xref:System.Numerics.Complex.Phase%2A> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-661">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-662">返回指定复数的指定次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-662">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-663">要对其求幂的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-663">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="53cad-664">指定幂的双精度浮点数。</span><span class="sxs-lookup"><span data-stu-id="53cad-664">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="53cad-665">返回指定复数的由双精度浮点数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-665">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="53cad-666">复数 <paramref name="value" /> 的 <paramref name="power" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-666">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-667">如果 `value` 为 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>，则此方法返回 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="53cad-667">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-668">对于其他值，如果 `power` 为0，则方法返回 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> ，如果 `power` 为1，则返回 `value` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-668">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="53cad-669">此方法对应于 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 基元数值类型的方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-669">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-670">下面的示例说明了使用复数和值范围从-1 到10的指数的幂运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-670">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-671">要对其求幂的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-671">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="53cad-672">指定幂的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-672">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="53cad-673">返回指定复数的由复数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-673">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-674">复数 <paramref name="value" /> 的 <paramref name="power" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="53cad-674">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-675">获取当前 <see cref="T:System.Numerics.Complex" /> 对象的实部。</span><span class="sxs-lookup"><span data-stu-id="53cad-675">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="53cad-676">复数的实部。</span><span class="sxs-lookup"><span data-stu-id="53cad-676">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-677">如果给定复数 a + bi，则 <xref:System.Numerics.Complex.Real%2A> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="53cad-677">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-678">下面的示例实例化一个 <xref:System.Numerics.Complex> 对象数组，并以 a + bi 的形式显示每个对象的实部和虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-678">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-679">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-679">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-680">返回复数的乘法倒数。</span><span class="sxs-lookup"><span data-stu-id="53cad-680">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-681"><paramref name="value" /> 的倒数。</span><span class="sxs-lookup"><span data-stu-id="53cad-681">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-682">Number *x* 的倒数或乘法倒数是数字 *y* ，其中 *x* 乘以 *y* 将生成1。</span><span class="sxs-lookup"><span data-stu-id="53cad-682">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="53cad-683">复数的倒数是 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> 两个数字相乘时产生的复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-683">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="53cad-684">如果复数由 + bi 表示，则其倒数由表达式 a/ (a<sup>2</sup>+ b<sup>2</sup>) +-b/ (a<sup>2</sup> + b<sup>2</sup>) 表示。</span><span class="sxs-lookup"><span data-stu-id="53cad-684">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="53cad-685">如果 value 为 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> ，则该方法返回 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-685">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53cad-686">否则，它将返回表达式的结果 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-686">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-687">下面的示例使用 <xref:System.Numerics.Complex.Reciprocal%2A> 方法来计算若干复数的倒数值。</span><span class="sxs-lookup"><span data-stu-id="53cad-687">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="53cad-688">它还说明复数与其倒数相乘的结果是 <xref:System.Numerics.Complex.One?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-688">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-689">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-689">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-690">返回指定复数的正弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-690">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-691"><paramref name="value" /> 的正弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-691">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-692"><xref:System.Numerics.Complex.Sin%2A>复数的方法与实数的方法相对应 <xref:System.Math.Sin%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-692">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-693"><xref:System.Numerics.Complex.Sin%2A>方法使用以下公式来计算复数 a + bi 的正弦值：</span><span class="sxs-lookup"><span data-stu-id="53cad-693">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53cad-694"> ( ()  ()  ()  () <xref:System.Math.Sin%2A> <xref:System.Math.Cosh%2A> <xref:System.Math.Cos%2A> <xref:System.Math.Sinh%2A> # A9</span><span class="sxs-lookup"><span data-stu-id="53cad-694">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-695">下面的示例演示 <xref:System.Numerics.Complex.Sin%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-695">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="53cad-696">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Asin%2A> 到方法将 <xref:System.Numerics.Complex.Sin%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-696">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-697">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-697">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-698">返回指定复数的双曲正弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-698">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-699"><paramref name="value" /> 的双曲正弦值。</span><span class="sxs-lookup"><span data-stu-id="53cad-699">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-700"><xref:System.Numerics.Complex.Sinh%2A>复数的方法与实数的方法相对应 <xref:System.Math.Sinh%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-700">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-701"><xref:System.Numerics.Complex.Sinh%2A>方法使用以下公式来计算复数 a + bi 的双曲正弦值：</span><span class="sxs-lookup"><span data-stu-id="53cad-701">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53cad-702"> ( ()  ()  ()  () <xref:System.Math.Sinh%2A> <xref:System.Math.Cos%2A> <xref:System.Math.Cosh%2A> <xref:System.Math.Sin%2A> # A9</span><span class="sxs-lookup"><span data-stu-id="53cad-702">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-703">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-703">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-704">返回指定复数的平方根。</span><span class="sxs-lookup"><span data-stu-id="53cad-704">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-705"><paramref name="value" /> 的平方根。</span><span class="sxs-lookup"><span data-stu-id="53cad-705">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-706">`value`使用以下公式计算复数的平方根：</span><span class="sxs-lookup"><span data-stu-id="53cad-706">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="53cad-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>)  ( (<xref:System.Math.Sqrt%2A?displayProperty=nameWithType> `value` 。 <xref:System.Numerics.Complex.Magnitude%2A> `value` <xref:System.Numerics.Complex.Phase%2A>/2.0) </span><span class="sxs-lookup"><span data-stu-id="53cad-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="53cad-708"><xref:System.Numerics.Complex.Sqrt%2A>复数的方法与实数的方法相对应 <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-708">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <Docs>
        <summary><span data-ttu-id="53cad-709">一个指定数减另一个指定数（其中至少有一个是复数，另一个可以是双精度实数），并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-709">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number, and returns the result.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-710"><xref:System.Numerics.Complex.Subtract%2A>方法允许包含复数的减法运算。</span><span class="sxs-lookup"><span data-stu-id="53cad-710">The <xref:System.Numerics.Complex.Subtract%2A> method allows subtraction operations that involve complex numbers.</span></span>

<span data-ttu-id="53cad-711">如果减法导致实部或虚部溢出，则该组件的值为 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 或 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-711">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="53cad-712">支持自定义运算符的语言也可使用 <xref:System.Numerics.Complex.op_Subtraction%2A> 等效的运算符组。</span><span class="sxs-lookup"><span data-stu-id="53cad-712">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%2A> equivalent group of operators too.</span></span>

<span data-ttu-id="53cad-713"><xref:System.Numerics.Complex.Subtract%2A>接收一个 double 的方法比接收两个复数的方法更有效。</span><span class="sxs-lookup"><span data-stu-id="53cad-713">The <xref:System.Numerics.Complex.Subtract%2A> methods that receive one double are more efficient than the method that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="53cad-714">下面的示例从一个复数中减去一个数组中的每个复数：</span><span class="sxs-lookup"><span data-stu-id="53cad-714">The following example subtracts each complex number in an array from a complex number:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
[!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-715">要被减的双精度实数值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-715">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-716">要减去的复值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-716">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-717">一个双精度实数减一个复数，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-717">Subtracts one complex number from a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-718"><paramref name="left" /> 减 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-718">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-719">复数 (c + di) 与实 (之间的减法，可视为复数 a + 0 i) 采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-719">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="53cad-720"> (c) -di</span><span class="sxs-lookup"><span data-stu-id="53cad-720">(a - c) - di</span></span>

<span data-ttu-id="53cad-721">支持自定义运算符的语言也可使用 <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效运算符。</span><span class="sxs-lookup"><span data-stu-id="53cad-721">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-722">要被减的复值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-722">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-723">要减去的双精度实数值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-723">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-724">一个复数减一个双精度实数，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-724">Subtracts one double-precision real number from a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-725"><paramref name="left" /> 减 <paramref name="right" /> 所得的结果（为复数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-725">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-726">实数的减 (可以视为复数 c + 0 i， (+ bi) 的复数) ，其形式如下：</span><span class="sxs-lookup"><span data-stu-id="53cad-726">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="53cad-727"> (c) + bi</span><span class="sxs-lookup"><span data-stu-id="53cad-727">(a - c) + bi</span></span>

<span data-ttu-id="53cad-728">支持自定义运算符的语言也可使用 <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> 等效运算符。</span><span class="sxs-lookup"><span data-stu-id="53cad-728">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="53cad-729">要从中减去的值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-729">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="53cad-730">要减去的值（减数）。</span><span class="sxs-lookup"><span data-stu-id="53cad-730">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="53cad-731">从一个复数中减去另一个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-731">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="53cad-732"><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</span><span class="sxs-lookup"><span data-stu-id="53cad-732">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="53cad-733">复数 c + di 与其他复数 a + bi 的减法运算采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="53cad-733">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="53cad-734"> (c) + (b) i</span><span class="sxs-lookup"><span data-stu-id="53cad-734">(a - c) + (b - d)i</span></span>

<span data-ttu-id="53cad-735">支持自定义运算符的语言也可使用 <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> 等效运算符。</span><span class="sxs-lookup"><span data-stu-id="53cad-735">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-736">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-736">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-737">返回指定复数的正切值。</span><span class="sxs-lookup"><span data-stu-id="53cad-737">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-738"><paramref name="value" /> 的正切值。</span><span class="sxs-lookup"><span data-stu-id="53cad-738">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-739"><xref:System.Numerics.Complex.Tan%2A>复数的方法与实数的方法相对应 <xref:System.Math.Tan%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-739">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-740"><xref:System.Numerics.Complex.Tan%2A>方法使用以下公式来计算复数的正切值 `value` ：</span><span class="sxs-lookup"><span data-stu-id="53cad-740">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="53cad-741"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="53cad-741"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-742">下面的示例演示 <xref:System.Numerics.Complex.Tan%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="53cad-742">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="53cad-743">其中显示，将方法返回的值传递 <xref:System.Numerics.Complex.Atan%2A> 到方法将 <xref:System.Numerics.Complex.Tan%2A> 返回原始 <xref:System.Numerics.Complex> 值。</span><span class="sxs-lookup"><span data-stu-id="53cad-743">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="53cad-744">一个复数。</span><span class="sxs-lookup"><span data-stu-id="53cad-744">A complex number.</span></span></param>
        <summary><span data-ttu-id="53cad-745">返回指定复数的双曲正切值。</span><span class="sxs-lookup"><span data-stu-id="53cad-745">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="53cad-746"><paramref name="value" /> 的双曲正切值。</span><span class="sxs-lookup"><span data-stu-id="53cad-746">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-747"><xref:System.Numerics.Complex.Tanh%2A>复数的方法与实数的方法相对应 <xref:System.Math.Tanh%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-747">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53cad-748"><xref:System.Numerics.Complex.Tanh%2A>方法使用以下公式来计算复数的双曲正切值 `value` ：</span><span class="sxs-lookup"><span data-stu-id="53cad-748">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="53cad-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="53cad-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53cad-750">将复数的值转换为其等效的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-750">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="53cad-751">将当前复数的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-751">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="53cad-752">当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-752">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-753">复数的默认字符串表示形式以 a b 的形式显示数字， `(` *a* `,` *b* `)` 其中*a*是复数的实部，而*b*是其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-753">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53cad-754">使用常规格式说明符来设置和*b* *的格式* ( "G" ) 和当前系统区域性的约定。</span><span class="sxs-lookup"><span data-stu-id="53cad-754">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-755">下面的示例显示了若干复数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-755">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="53cad-756">输出使用英语美国 ( "en-us" ) 区域性的格式约定，在此示例中，为当前系统区域性。</span><span class="sxs-lookup"><span data-stu-id="53cad-756">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="53cad-757">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-757">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="53cad-758">使用指定的区域性特定格式设置信息，将当前复数的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-758">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="53cad-759">由 <paramref name="provider" /> 指定的当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-759">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-760">此方法返回的复数的字符串表示形式使用其笛卡尔坐标形式显示数字 `(` *a* `,` *b* `)` ，其中*a*是复数的实部， *b*是其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-760">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53cad-761">使用常规格式说明符来设置和*b* *的格式* ( "G" ) 和定义的区域性的约定 `provider` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-761">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="53cad-762">`provider`参数是一个 <xref:System.IFormatProvider> 实现。</span><span class="sxs-lookup"><span data-stu-id="53cad-762">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="53cad-763">其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回一个 <xref:System.Globalization.NumberFormatInfo> 对象，该对象提供有关返回的字符串中的实数和虚数格式的区域性特定信息。</span><span class="sxs-lookup"><span data-stu-id="53cad-763">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="53cad-764">如果 `provider` 为 `null` ，则使用当前区域性的对象设置返回的字符串的格式 <xref:System.Globalization.NumberFormatInfo> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-764">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="53cad-765">`provider`参数可以是以下项之一：</span><span class="sxs-lookup"><span data-stu-id="53cad-765">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="53cad-766">一个 <xref:System.Globalization.CultureInfo> 对象，该对象表示提供格式设置信息的区域性</span><span class="sxs-lookup"><span data-stu-id="53cad-766">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="53cad-767"><xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-767">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="53cad-768">一个实现接口的自定义对象 <xref:System.IFormatProvider> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-768">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="53cad-769">其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-769">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-770">下面的示例显示了若干复数的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-770">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="53cad-771">结果使用英语美国的格式设置约定 ( "en-us" ) 和法语-法国 ( "fr" ) 区域性。</span><span class="sxs-lookup"><span data-stu-id="53cad-771">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="53cad-772">标准或自定义的数值格式字符串。</span><span class="sxs-lookup"><span data-stu-id="53cad-772">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="53cad-773">通过对当前复数的实部和虚部使用指定格式，将它的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-773">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="53cad-774">当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-774">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-775">此方法返回的复数的字符串表示形式使用其笛卡尔坐标形式显示数字 `(` *a* `,` *b* `)` ，其中*a*是复数的实部， *b*是其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-775">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53cad-776">使用指定的格式字符串设置和*b* *的*格式 `format` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-776">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="53cad-777">`format`参数可以是任何有效的标准数值格式说明符，也可以是自定义数字格式说明符的任意组合。</span><span class="sxs-lookup"><span data-stu-id="53cad-777">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="53cad-778">如果 `format` 等于 <xref:System.String.Empty?displayProperty=nameWithType> 或为，则 `null` 复数的实部和虚部用常规格式说明符格式 ( "G" ) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-778">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="53cad-779">如果 `format` 是其他任何值，则该方法将引发 <xref:System.FormatException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-779">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="53cad-780">.NET Framework 提供丰富的格式设置支持，请参阅以下主题中的更详细说明：</span><span class="sxs-lookup"><span data-stu-id="53cad-780">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="53cad-781">有关数字格式字符串的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="53cad-781">For more information about numeric format strings, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span>  
  
-   <span data-ttu-id="53cad-782">有关 .NET Framework 中的格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。</span><span class="sxs-lookup"><span data-stu-id="53cad-782">For more information about formatting in the .NET Framework, see [Formatting Types](/dotnet/standard/base-types/formatting-types).</span></span>  
  
 <span data-ttu-id="53cad-783">返回字符串的格式由 <xref:System.Globalization.NumberFormatInfo> 当前区域性的对象确定。</span><span class="sxs-lookup"><span data-stu-id="53cad-783">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="53cad-784">根据 `format` 参数，此对象控制输出字符串中的符号，如负号、组分隔符和小数点符号。</span><span class="sxs-lookup"><span data-stu-id="53cad-784">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="53cad-785">若要为当前区域性以外的区域性提供格式设置信息，请调用 <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="53cad-785">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-786">下面的示例初始化复数，并使用多个标准格式字符串显示它。</span><span class="sxs-lookup"><span data-stu-id="53cad-786">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="53cad-787"><paramref name="format" /> 不是有效的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="53cad-787"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="53cad-788">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="53cad-788">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="53cad-789">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="53cad-789">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberSignature Language="C#" Value="public string? ToString (string format, IFormatProvider provider);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="53cad-790">标准或自定义的数值格式字符串。</span><span class="sxs-lookup"><span data-stu-id="53cad-790">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="53cad-791">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-791">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="53cad-792">通过对当前复数的实部和虚部使用指定格式和区域性特定格式信息，将它的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-792">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="53cad-793">由 <paramref name="format" /> 和 <paramref name="provider" /> 指定的当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="53cad-793">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-794">此方法返回的复数的字符串表示形式使用其笛卡尔坐标形式显示数字 `(` *a* `,` *b* `)` ，其中*a*是复数的实部， *b*是其虚部。</span><span class="sxs-lookup"><span data-stu-id="53cad-794">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53cad-795">使用指定的格式字符串设置和*b* *的*格式 `format` 。</span><span class="sxs-lookup"><span data-stu-id="53cad-795">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="53cad-796">`format`参数可以是任何有效的标准数值格式说明符，也可以是自定义数字格式说明符的任意组合。</span><span class="sxs-lookup"><span data-stu-id="53cad-796">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="53cad-797">如果 `format` 等于 <xref:System.String.Empty?displayProperty=nameWithType> 或为，则 `null` 复数的实部和虚部用常规格式说明符格式 ( "G" ) 。</span><span class="sxs-lookup"><span data-stu-id="53cad-797">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="53cad-798">如果 `format` 是其他任何值，则该方法将引发 <xref:System.FormatException> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-798">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="53cad-799">.NET Framework 提供丰富的格式设置支持，请参阅以下主题中的更详细说明：</span><span class="sxs-lookup"><span data-stu-id="53cad-799">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="53cad-800">有关数字格式字符串的详细信息，请参阅 [标准数字格式字符串](/dotnet/standard/base-types/standard-numeric-format-strings) 和 [自定义数字格式字符串](/dotnet/standard/base-types/custom-numeric-format-strings)。</span><span class="sxs-lookup"><span data-stu-id="53cad-800">For more information about numeric format strings, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).</span></span>  
  
-   <span data-ttu-id="53cad-801">有关 .NET Framework 中的格式设置的详细信息，请参阅 [格式设置类型](/dotnet/standard/base-types/formatting-types)。</span><span class="sxs-lookup"><span data-stu-id="53cad-801">For more information about formatting in the .NET Framework, see [Formatting Types](/dotnet/standard/base-types/formatting-types).</span></span>  
  
 <span data-ttu-id="53cad-802">`provider`参数是一个 <xref:System.IFormatProvider> 实现。</span><span class="sxs-lookup"><span data-stu-id="53cad-802">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="53cad-803">其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回一个 <xref:System.Globalization.NumberFormatInfo> 对象，该对象提供有关返回的字符串中的实数和虚数格式的区域性特定信息。</span><span class="sxs-lookup"><span data-stu-id="53cad-803">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="53cad-804">根据 `format` 参数，此对象控制输出字符串中的符号，如负号、组分隔符和小数点符号。</span><span class="sxs-lookup"><span data-stu-id="53cad-804">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="53cad-805">如果 `provider` 为 `null` ，则使用当前区域性的对象设置返回的字符串的格式 <xref:System.Globalization.NumberFormatInfo> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-805">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="53cad-806">`provider`参数可以是以下项之一：</span><span class="sxs-lookup"><span data-stu-id="53cad-806">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="53cad-807">一个 <xref:System.Globalization.CultureInfo> 对象，该对象表示提供格式设置信息的区域性</span><span class="sxs-lookup"><span data-stu-id="53cad-807">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="53cad-808"><xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-808">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="53cad-809">一个实现接口的自定义对象 <xref:System.IFormatProvider> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-809">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="53cad-810">其 <xref:System.IFormatProvider.GetFormat%2A> 方法返回 <xref:System.Globalization.NumberFormatInfo> 提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="53cad-810">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-811">下面的示例创建一个复数数组，并使用多个标准格式字符串以及 <xref:System.Globalization.CultureInfo> 表示英语美国 ( "en-us" ) 和法语-法国 ( "fr" ) 区域性的对象来显示每个数字。</span><span class="sxs-lookup"><span data-stu-id="53cad-811">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="53cad-812"><paramref name="format" /> 不是有效的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="53cad-812"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings"><span data-ttu-id="53cad-813">标准数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="53cad-813">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings"><span data-ttu-id="53cad-814">自定义数字格式字符串</span><span class="sxs-lookup"><span data-stu-id="53cad-814">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53cad-815">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数和虚数都等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-815">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53cad-816"><xref:System.Numerics.Complex.Zero>属性最常用于比较 <xref:System.Numerics.Complex> 值为零。</span><span class="sxs-lookup"><span data-stu-id="53cad-816">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53cad-817">下面的示例 <xref:System.Numerics.Complex> 使用属性将值实例化 <xref:System.Numerics.Complex.Zero> 。</span><span class="sxs-lookup"><span data-stu-id="53cad-817">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="53cad-818">然后，它会将此值与另一个值进行比较，此值是通过调用 <xref:System.Numerics.Complex> 构造函数，而实部等于零，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="53cad-818">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="53cad-819">如示例中的输出所示，这两个值相等。</span><span class="sxs-lookup"><span data-stu-id="53cad-819">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
