<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6898985feb555ba855378ee9d755e01d5100b39" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89890047" /></Metadata><TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IParserAccessor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IParserAccessor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IDataBindingsAccessor, IDisposable, IParserAccessor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IParserAccessor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IDataBindingsAccessor" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DefaultProperty("ID")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultProperty("ID")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.DesignerCategory("Code")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerCategory("Code")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName Language="C#">[System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.Bindable(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(true)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName Language="C#">[System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义由所有 ASP.NET 服务器控件共享的属性、方法和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 这是开发自定义 ASP.NET 服务器控件时派生自的主类。 <xref:System.Web.UI.Control> 没有 (UI) 特定功能的任何用户界面。 如果要创作的控件不具有 UI，或者合并了呈现其自己的 UI 的其他控件，请从派生 <xref:System.Web.UI.Control> 。 如果要创作一个具有 UI 的控件，则可以从 <xref:System.Web.UI.WebControls.WebControl> 或命名空间中的任何控件派生， <xref:System.Web.UI.WebControls> 该命名空间为自定义控件提供相应的起始点。

 <xref:System.Web.UI.Control>类是所有 ASP.NET 服务器控件（包括自定义控件、用户控件和页）的基类。 ASP.NET 页是类的实例 <xref:System.Web.UI.Page> ，该类继承自 <xref:System.Web.UI.Control> 类，并处理对具有 .aspx 扩展名的文件的请求。

 <xref:System.Web.UI.Control>类可以直接或间接地用作你的 Web 应用程序的用户界面的一部分，因此应进行仔细检查以确保编写安全代码和确保应用程序安全的最佳做法。

 有关这些主题的常规信息，请参阅 [Web 应用程序安全威胁概述](https://docs.microsoft.com/previous-versions/f13d73y6(v=vs.140))、 [安全策略最佳实践](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/sa4se9bc(v=vs.100))和 [主要安全概念](/dotnet/standard/security/key-security-concepts)。 有关更具体的信息，请参阅 [保护标准控件](https://docs.microsoft.com/previous-versions/aspnet/ms178270(v=vs.100))的安全、 [如何：显示安全错误消息](https://docs.microsoft.com/previous-versions/aspnet/994a1482(v=vs.100))、 [如何：通过将 HTML 编码应用于字符串来保护 Web 应用程序中的脚本攻击](https://docs.microsoft.com/previous-versions/aspnet/a2a4yykt(v=vs.100))，以及 [验证控件简介](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85))。



## Examples
 下面的示例演示一个派生自类的自定义服务器控件 <xref:System.Web.UI.Control> 。 `InnerContent`类将重写 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 方法，检查该类是否在页上有任何子控件，并确定控件的第一个子级是否为文本控件。 如果同时满足这两个条件，则重写的方法将 \<H2> 消息：、文本控件的内容和 \</H2> Web 窗体页的结束标记写入 HTML 字符串。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]

 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/zt27tfhy(v=vs.100)">开发自定义 ASP.NET 服务器控件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.Control" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的浏览器特定适配器。</summary>
        <value>该控件的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。 如果目标浏览器不需要适配器，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以从 Web 请求信息的各种设备和浏览器中使用 ASP.NET 网页。 <xref:System.Web.UI.Control.Adapter%2A>属性返回在 <xref:System.Web.UI.Adapters.ControlAdapter> 请求设备或浏览器的屏幕上呈现控件的对象。

 有关适配器的详细信息，请参阅 [自适应控制行为的体系结构概述](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">自适应控制行为的体系结构概述</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub AddedControl (control As Control, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">已添加的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="index"><see cref="P:System.Web.UI.Control.Controls" /> 集合中的控件索引。</param>
        <summary>在子控件添加到 <see cref="T:System.Web.UI.Control" /> 对象的 <see cref="P:System.Web.UI.Control.Controls" /> 集合后调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在将 <xref:System.Web.UI.Control.AddedControl%2A> 控件添加到集合之后立即调用方法 <xref:System.Web.UI.Control.Controls%2A> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> 是一个 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控件。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">一个 <see cref="T:System.Object" />，表示已经过分析的元素。</param>
        <summary>通知服务器控件，分析了一个元素（XML 或 HTML），并将该元素添加到服务器控件的 <see cref="T:System.Web.UI.ControlCollection" /> 对象中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 除非重写，否则此方法会自动将 <xref:System.Web.UI.LiteralControl> 对象添加到服务器控件的 <xref:System.Web.UI.ControlCollection> 对象。 此集合可以通过 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> 属性访问。



## Examples
 下面的示例是一个自定义服务器控件，该控件使用 <xref:System.Web.UI.Control.AddParsedSubObject%2A> 方法来确定在此控件的开始标记和结束标记之间声明的元素是否为 <xref:System.Web.UI.WebControls.TextBox> Web 服务器控件。 如果是，则将其添加到 <xref:System.Collections.ArrayList> 对象 `items` 。 调用重写的 <xref:System.Web.UI.Control.CreateChildControls%2A> 方法时，它会循环访问， <xref:System.Collections.ArrayList> 并将其中的每个对象添加到 <xref:System.Web.UI.ControlCollection> 自定义服务器控件的。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplyStyleSheetSkin (page As Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">包含控件的 <see cref="T:System.Web.UI.Page" />。</param>
        <summary>将页样式表中定义的样式属性应用到控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> 方法基于在主题目录中定义的外观属性来设置控件的样式属性。 应用的外观是控件的默认外观或属性中指定的外观 <xref:System.Web.UI.Control.SkinID%2A> 。 此 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> 方法由 ASP.NET 调用，用于放置在页面上的声明性控件。 您必须在 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> 运行时以编程方式在运行时对创建的任何控件调用方法，才能将样式表的外观应用于控件。 主题外观会自动应用。 有关主题和级联样式表之间的差异的详细信息，请参阅 [ASP.NET 主题和外观](https://docs.microsoft.com/previous-versions/aspnet/ykzx33wh(v=vs.100))。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经应用了样式表。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含该控件的 <see cref="T:System.Web.UI.Page" /> 或 <see cref="T:System.Web.UI.UserControl" /> 对象的应用程序相对虚拟目录。</summary>
        <value>包含该控件的页或用户控件的应用程序相对虚拟目录。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>属性包含指向包含当前控件的页面或用户控件的应用程序相对路径。 例如，如果网页位于 `http://www.contoso.com/application/subdirectory` ，则 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> 属性返回 "~/subdirectory"。

 若要返回虚拟路径 ( "application/子目录" ) ，请使用 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 属性。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">写入跟踪数据的对象。</param>
        <param name="traceObject">跟踪对象。</param>
        <summary>开始输出数据的设计时追踪。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含该控件的数据绑定的控件。</summary>
        <value>包含该控件的数据绑定的 <see cref="T:System.Web.UI.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.BindingContainer%2A>属性包含对 <xref:System.Web.UI.Control> 对象的引用，该对象包含当前控件的数据绑定信息。

 <xref:System.Web.UI.Control.BindingContainer%2A> <xref:System.Web.UI.Control.NamingContainer%2A> 除了控件是模板的一部分时，属性与属性相同。 在这种情况下， <xref:System.Web.UI.Control.BindingContainer%2A> 属性设置为 <xref:System.Web.UI.Control> 定义模板的。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">控件的父级的标识符。</param>
        <param name="calcViewState">指示是否计算视图状态大小的布尔值。</param>
        <summary>收集有关服务器控件的信息并将该信息发送到 <see cref="P:System.Web.UI.Page.Trace" /> 属性，在启用页的跟踪功能时将显示该属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此属性收集页面的 UI 层次结构所需的信息，并将其传递给页面的[ &lt; 跟踪 &gt; ](/dotnet/framework/configure-apps/file-schema/trace-debug/trace-element)属性。 为页或应用程序启用跟踪时，此信息显示在 `Control Tree` 跟踪输出的部分中。 页面的跟踪输出将追加到页面的末尾;尽管可以从跟踪查看器中查看应用程序的跟踪输出 (trace axd 文件，) 该文件存储在应用程序的根目录中。 有关跟踪的详细信息，请参阅 [ASP.NET 跟踪概述](https://docs.microsoft.com/previous-versions/aspnet/bb386420(v=vs.100))。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已创建服务器控件的子控件。</summary>
        <value>如果已创建子控件则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例演示如何重写 <xref:System.Web.UI.Control.OnDataBinding%2A> 自定义控件的方法 <xref:System.Web.UI.WebControls.Repeater> 。 若要确保在再次进行数据绑定之前不会创建子控件，则在 <xref:System.Web.UI.Control.ChildControlsCreated%2A> `true` <xref:System.Web.UI.WebControls.RepeaterItem> 创建对象并将其添加到控件的对象之后，属性将设置为 <xref:System.Web.UI.ControlCollection> 。

 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]

 下面的示例演示如何在网页中使用自定义 repeater 控件。

 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将缓存的 <see cref="P:System.Web.UI.Control.ClientID" /> 值设置为 <see langword="null" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除服务器控件的子控件的控件状态信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.ClearChildControlState%2A>当创建新的子控件（如在模板化数据绑定服务器控件中对子控件进行数据绑定时），将使用方法来重写写入父控件的控件状态的子控件状态信息。 <xref:System.Web.UI.Control.ClearChildControlState%2A>在调用方法之前调用方法为空的子控件可 <xref:System.Web.UI.Control.SaveControlState%2A> 减少必须存储或传输的控件状态信息的大小。

 当重新创建对象的子控件时 <xref:System.Web.UI.Control> ，请使用 <xref:System.Web.UI.Control.ClearChildControlState%2A> 方法清除子控件状态，以便不会无意中将其应用于新控件。

 若要清除子控件状态和视图状态，请使用 <xref:System.Web.UI.Control.ClearChildState%2A> 方法。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除服务器控件的所有子控件的视图状态和控件状态信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.ClearChildState%2A>方法清除子控件的所有视图状态和控件状态信息。 它等效于调用 <xref:System.Web.UI.Control.ClearChildViewState%2A> 方法和 <xref:System.Web.UI.Control.ClearChildControlState%2A> 方法。

 当重新创建对象的子控件时 <xref:System.Web.UI.Control> ，请使用 <xref:System.Web.UI.Control.ClearChildState%2A> 方法清除子状态，以便不会无意中将其应用于新控件。



## Examples
 下面的代码示例演示如何为 <xref:System.Web.UI.Control.OnDataBinding%2A> 模板化数据绑定控件重写方法。 如果填充了控件绑定到的数据源，则 <xref:System.Web.UI.ControlCollection> 使用方法清空控件的集合， <xref:System.Web.UI.ControlCollection.Clear%2A> 并 <xref:System.Web.UI.Control.ClearChildState%2A> 使用方法删除已为子控件保存的任何状态信息。

 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除服务器控件的所有子控件的视图状态信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 当你在 <xref:System.Web.UI.Control.DataBind%2A> 开发模板化数据绑定服务器控件时重写方法时，通常使用此方法。 如果不调用此方法，则可以将子控件视图状态信息写入父服务器控件，仅在绑定数据时重写。

 重新创建的子控件时 <xref:System.Web.UI.Control> ，请使用 <xref:System.Web.UI.Control.ClearChildViewState%2A> 方法清除子视图状态，以便不会无意中将其应用于新控件。

 有关使用此方法的详细信息，请参阅 [如何：创建模板化 ASP.NET 用户控件](https://docs.microsoft.com/previous-versions/aspnet/36574bf6(v=vs.100))。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/36574bf6(v=vs.100)">如何：创建模板化用户控件</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前控件实例和任何子控件的 <see cref="P:System.Web.UI.Control.ClientIDMode" /> 属性设置为 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 ASP.NET 生成的 HTML 标记的控件 ID。</summary>
        <value>由 ASP.NET 生成的 HTML 标记的控件 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 当 Web 服务器控件呈现为 HTML 元素时， `id` html 元素的属性将设置为属性的值 <xref:System.Web.UI.Control.ClientID%2A> 。 <xref:System.Web.UI.Control.ClientID%2A>该值通常用于通过使用方法访问客户端脚本中的 HTML 元素 `document.getElementById` 。 该 ID 还经常用在 CSS 规则中来指定要样式的元素。 例如，以下 CSS 样式规则选择 `span` `id` 属性值为的所有元素 `ProductIDLabel` ，并将其 `background-color` 属性设置为 `white` ：

```
span#ProductIDLabel { background-color: white; }
```

 ASP.NET 提供了多个用于生成 <xref:System.Web.UI.Control.ClientID%2A> 属性值的算法。 可以通过设置控件的属性来选择要用于控件的算法 <xref:System.Web.UI.Control.ClientIDMode%2A> 。 算法由 <xref:System.Web.UI.ClientIDMode> 下表中列出的枚举值标识。

|值|说明|
|-----------|-----------------|
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 值是通过串联每个父命名容器的 <xref:System.Web.UI.Control.ID%2A> 值生成的，这些父命名容器都具有控件的 <xref:System.Web.UI.Control.ID%2A> 值。 在呈现控件的多个实例的数据绑定方案中，将在控件的 <xref:System.Web.UI.Control.ID%2A> 值的前面插入递增的值。 各部分之间用下划线字符 (_) 分隔。 此算法用于早于 ASP.NET 4 的 ASP.NET 版本。|
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 值设置为 <xref:System.Web.UI.Control.ID%2A> 属性的值。 如果控件是命名容器，则该控件将用作其所包含的任何控件的命名容器的顶层。|
|<xref:System.Web.UI.ClientIDMode.Predictable>|对于数据绑定控件中的控件使用此算法。 <xref:System.Web.UI.Control.ClientID%2A> 值是通过串联每个父命名容器的 <xref:System.Web.UI.Control.ClientID%2A> 值生成的，这些父命名容器都具有控件的<xref:System.Web.UI.Control.ID%2A> 值。 如果控件是生成多个行的数据绑定控件，则在末尾添加 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 属性中指定的数据字段的值。 对于 <xref:System.Web.UI.WebControls.GridView> 控件，可以指定多个数据字段。 如果该 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 属性为空白，则在末尾添加顺序号，而不是数据字段值。 各部分之间用下划线字符 (_) 分隔。|
|<xref:System.Web.UI.ClientIDMode.Inherit>|控件继承其 <xref:System.Web.UI.Control.NamingContainer%2A> 控件的 <xref:System.Web.UI.ClientIDMode> 设置。|

 页的的默认值为 <xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.ClientIDMode.Predictable> 。 控件的默认值为 <xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.ClientIDMode.Inherit> 。 由于控件的默认值为 <xref:System.Web.UI.ClientIDMode.Inherit> ，因此默认生成模式为 <xref:System.Web.UI.ClientIDMode.Predictable> 。  (但是，如果使用 Visual Studio 将 Web 项目从早期版本转换为 ASP.NET 4，则 Visual Studio 会自动将该站点的默认值设置为 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config 文件中。 ) 

 有关详细信息，请参阅 [ASP.NET Web 服务器控件标识](https://docs.microsoft.com/previous-versions/1d04y8ss(v=vs.140))。



## Examples
 下面的示例演示在母版页的内容页内的 Web 用户控件。 用户控件包含 <xref:System.Web.UI.WebControls.DropDownList> 控件和 <xref:System.Web.UI.WebControls.Label> 控件。 控件中显示的文本由 <xref:System.Web.UI.WebControls.Label> 用户从控件中选择的值确定 <xref:System.Web.UI.WebControls.DropDownList> 。 文本值是通过客户端脚本设置的，因此，网页不必回发到服务器即可设置此值。 若要获取对在客户端脚本中为控件呈现的 HTML 元素的引用 <xref:System.Web.UI.WebControls.Label> ，必须知道控件的属性的值 <xref:System.Web.UI.Control.ClientID%2A> 。 但是，因为用户控件可以放在网页中的任何位置，所以无法事先知道哪些命名容器将包含这些控件。 为了确保 <xref:System.Web.UI.Control.ClientID%2A> 该值与 <xref:System.Web.UI.Control.ID%2A> 值相同，代码将 <xref:System.Web.UI.Control.ClientIDMode%2A> 值设置为 <xref:System.Web.UI.WebControls.ValidatorDisplay.Static> 。

 下面的示例演示用户控件。

 [!code-aspx-csharp[System.Web.UI.ClientIDMode#1](~/samples/snippets/common/VS_Snippets_WebNet/system.web.ui.clientidmode/common/seasons.ascx)]

 下面的示例显示包含用户控件的内容页。

 [!code-aspx-csharp[System.Web.UI.ClientIDMode#2](~/samples/snippets/common/VS_Snippets_WebNet/system.web.ui.clientidmode/common/seasons.aspx)]

 下面的示例演示包含内容页的母版页。

 [!code-aspx-csharp[System.Web.UI.ClientIDMode#3](~/samples/snippets/common/VS_Snippets_WebNet/system.web.ui.clientidmode/common/seasons.master)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/1d04y8ss(v=vs.140)">ASP.NET 控件标识</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd410598(v=vs.140)">如何：按 ID 从 JavaScript 访问控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd381611(v=vs.140)">演练：使数据绑定控件更易于从 JavaScript 访问</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd483476(v=vs.140)">演练：使位于 Web 用户控件中的控件更易于从 JavaScript 访问</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/3hc29e2a(v=vs.100)">ASP.NET 网页中的客户端脚本</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于生成 <see cref="P:System.Web.UI.Control.ClientID" /> 属性值的算法。</summary>
        <value>一个值，指示如何生成 <see cref="P:System.Web.UI.Control.ClientID" /> 属性。 默认值为 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 提供了多个用于生成 <xref:System.Web.UI.Control.ClientID%2A> 属性值的算法。 可以通过设置控件的属性来选择要用于控件的算法 <xref:System.Web.UI.Control.ClientIDMode%2A> 。 算法由 <xref:System.Web.UI.ClientIDMode> 下表中列出的枚举值标识。

|值|说明|
|-----------|-----------------|
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 值是通过串联每个父命名容器的 <xref:System.Web.UI.Control.ID%2A> 值生成的，这些父命名容器都具有控件的 <xref:System.Web.UI.Control.ID%2A> 值。 在呈现控件的多个实例的数据绑定方案中，将在控件的 <xref:System.Web.UI.Control.ID%2A> 值的前面插入递增的值。 各部分之间用下划线字符 (_) 分隔。 此算法用于早于 ASP.NET 4 的 ASP.NET 版本。|
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 值设置为 <xref:System.Web.UI.Control.ID%2A> 属性的值。 如果控件是命名容器，则该控件将用作其所包含的任何控件的命名容器的顶层。|
|<xref:System.Web.UI.ClientIDMode.Predictable>|对于数据绑定控件中的控件使用此算法。 <xref:System.Web.UI.Control.ClientID%2A> 值是通过串联每个父命名容器的 <xref:System.Web.UI.Control.ClientID%2A> 值生成的，这些父命名容器都具有控件的<xref:System.Web.UI.Control.ID%2A> 值。 如果控件是生成多个行的数据绑定控件，则在末尾添加 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 属性中指定的数据字段的值。 对于 <xref:System.Web.UI.WebControls.GridView> 控件，可以指定多个数据字段。 如果该 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 属性为空白，则在末尾添加顺序号，而不是数据字段值。 此数字从零开始，每一行递增1。 各部分之间用下划线字符 (_) 分隔。|
|<xref:System.Web.UI.ClientIDMode.Inherit>|控件继承其 <xref:System.Web.UI.Control.NamingContainer%2A> 控件的 <xref:System.Web.UI.ClientIDMode> 设置。|

 页的的默认值为 <xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.ClientIDMode.Predictable> 。 控件的默认值为 <xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.ClientIDMode.Inherit> 。 由于控件的默认值为 <xref:System.Web.UI.ClientIDMode.Inherit> ，因此默认生成模式为 <xref:System.Web.UI.ClientIDMode.Predictable> 。  (但是，如果使用 Visual Studio 将 Web 项目从早期版本转换为 ASP.NET 4，则 Visual Studio 会自动将该站点的默认值设置为 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config 文件中。 ) 

 有关详细信息，请参阅 [ASP.NET Web 服务器控件标识](https://docs.microsoft.com/previous-versions/1d04y8ss(v=vs.140))。



## Examples

下面的示例演示 <xref:System.Web.UI.WebControls.Label> 控件中包含的控件 <xref:System.Web.UI.WebControls.ListView> 。 在 <xref:System.Web.UI.WebControls.ListView> 控件上，将 <xref:System.Web.UI.Control.ClientIDMode%2A> 属性设置为 <xref:System.Web.UI.ClientIDMode.Predictable> ，并将 <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> 属性设置为 `ProductID` 。 在呈现的 HTML 中，这会创建三个 `span` 对应于三个控件的元素 `ProductIDLabel` 。 当页面运行时，将 `id` 元素的属性 `span` 设置为以下值：

- `ListView1_ProductIDLabel_1`
- `ListView1_ProductIDLabel_34`
- `ListView1_ProductIDLabel_43`

[!code-aspx-csharp[System.Web.UI.ClientIDMode#11](~/samples/snippets/common/VS_Snippets_WebNet/system.web.ui.clientidmode/common/predictable.aspx#11)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/1d04y8ss(v=vs.140)">ASP.NET 控件标识</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd410598(v=vs.140)">如何：按 ID 从 JavaScript 访问控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd381611(v=vs.140)">演练：使数据绑定控件更易于从 JavaScript 访问</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd483476(v=vs.140)">演练：使位于 Web 用户控件中的控件更易于从 JavaScript 访问</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个字符值，该值表示 <see cref="P:System.Web.UI.Control.ClientID" /> 属性中使用的分隔符字符。</summary>
        <value>始终返回下划线字符 (_)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.ClientID%2A>值是通过串联 <xref:System.Web.UI.Control.ID%2A> 控件的值和 <xref:System.Web.UI.Control.UniqueID%2A> 其父控件的值生成的。 生成的属性的每个部分 <xref:System.Web.UI.Control.ID%2A> 都由 <xref:System.Web.UI.Control.ClientIDSeparator%2A> 属性值分隔。 该值始终返回下划线 (_) 。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected virtual System.Web.HttpContext Context { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property Context As HttpContext" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>为当前 Web 请求获取与服务器控件关联的 <see cref="T:System.Web.HttpContext" /> 对象。</summary>
        <value>与当前请求关联的指定 <see cref="T:System.Web.HttpContext" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性使您可以访问 <xref:System.Web.HttpContext> 当前 Web 请求的对象。 对象提供的属性访问、、 <xref:System.Web.HttpContext.Application%2A> <xref:System.Web.HttpContext.Session%2A> <xref:System.Web.HttpContext.Request%2A> <xref:System.Web.HttpContext.Response%2A> 和其他对象，这些对象包含有关当前 HTTP 请求的信息。 它还提供了一些方法，可用于获取配置信息并为请求设置或清除错误。



## Examples
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.ControlCollection" /> 对象，该对象表示 UI 层次结构中的指定服务器控件的子控件。</summary>
        <value>指定服务器控件的子控件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 ASP.NET 页上，如果在服务器控件的开始标记和结束标记之间以声明方式添加控件，则 ASP.NET 会自动将控件添加到包含服务器控件的 <xref:System.Web.UI.ControlCollection> 。 未在服务器上处理的任何 HTML 标记或文本字符串都将被视为 <xref:System.Web.UI.LiteralControl> 对象。 这些将添加到集合中，如其他服务器控件。

 <xref:System.Web.UI.Control.Controls%2A>属性允许你以编程方式访问 <xref:System.Web.UI.ControlCollection> 任何服务器控件的类的实例。 您可以向集合添加控件、从集合中移除控件或循环访问集合中的服务器控件。



## Examples
 下面的示例演示如何通过属性将子控件添加到服务器控件的 <xref:System.Web.UI.ControlCollection> 对象 <xref:System.Web.UI.Control.Controls%2A> 。

 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>重写 <see cref="P:System.Web.UI.Control.Controls" /> 属性时，请确保调用 <see cref="M:System.Web.UI.Control.EnsureChildControls" /> 方法。 此外，如果计划以编程方式将控件添加到控件集合，请考虑在重写的方法中添加控件 <see cref="M:System.Web.UI.Control.CreateChildControls" /> 。</para></block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected virtual void CreateChildControls ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateChildControls() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateChildControls ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateChildControls();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 ASP.NET 页框架调用，以通知服务器控件在准备回发或呈现时使用基于撰写的实现来创建其所包含任何子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 开发复合服务器控件或模板化服务器控件时，必须重写此方法。 重写方法的控件 <xref:System.Web.UI.Control.CreateChildControls%2A> 应实现 <xref:System.Web.UI.INamingContainer> 接口，以避免命名冲突。

 有关详细信息，请参阅 [Web 服务器控件模板](https://docs.microsoft.com/previous-versions/aspnet/h59db326(v=vs.100)) 和 [开发自定义 ASP.NET 服务器控件](https://docs.microsoft.com/previous-versions/aspnet/zt27tfhy(v=vs.100))。



## Examples
 下面的示例演示方法的重写版本 <xref:System.Web.UI.Control.CreateChildControls%2A> 。 在此实现中，复合控件将显示一个控件，该 <xref:System.Web.UI.WebControls.TextBox> 控件包含在呈现 HTML 的两个文本控件中。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/zt27tfhy(v=vs.100)">开发自定义 ASP.NET 服务器控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/h59db326(v=vs.100)">ASP.NET Web 服务器控件模板</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个新 <see cref="T:System.Web.UI.ControlCollection" /> 对象来保存服务器控件的子控件（包括文本控件和服务器控件）。</summary>
        <returns>一个 <see cref="T:System.Web.UI.ControlCollection" /> 对象，用于包含当前服务器控件的子服务器控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果已创建派生自类的集合对象，请在自定义服务器控件中重写此方法 <xref:System.Web.UI.ControlCollection> 。 然后，你可以在此方法的重写中实例化此集合类。



## Examples
 下面的代码示例重写 <xref:System.Web.UI.Control.CreateControlCollection%2A> 方法以创建类的实例 `CustomControlCollection` ，该类继承自 <xref:System.Web.UI.ControlCollection> 类。

 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]

 下面的代码示例使用 <xref:System.Web.UI.Control.CreateControlCollection%2A> 方法的自定义服务器控件重写中的方法 <xref:System.Web.UI.Control.CreateChildControls%2A> 。 创建新的集合，然后用两个子控件（和）填充 `firstControl` `secondControl` 。

 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据源绑定到调用的服务器控件及其所有子控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将数据源绑定到调用的服务器控件及其所有子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用此方法可将数据从源绑定到服务器控件。 此方法通常在通过数据库查询检索数据集之后使用。 大多数控件会自动执行数据绑定，这意味着您通常不需要显式调用此方法。

 当您创建自定义模板化数据绑定控件时，通常会重写此方法。 有关详细信息，请参阅 [如何：创建模板化 ASP.NET 用户控件](https://docs.microsoft.com/previous-versions/aspnet/36574bf6(v=vs.100)) 和 [开发自定义数据绑定 Web 服务器控件](https://docs.microsoft.com/previous-versions/aspnet/ms366539(v=vs.100))。 在服务器控件上调用时，此方法解析服务器控件及其任何子控件中的所有数据绑定表达式。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.DataBind%2A> 自定义 ASP.NET 服务器控件中的方法。 首先调用基 <xref:System.Web.UI.Control.OnDataBinding%2A> 方法，然后使用 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> 方法删除所有子控件，并使用 <xref:System.Web.UI.Control.ClearChildViewState%2A> 方法删除这些子控件的任何已保存的视图状态设置。 最后，将 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 属性设置为， `true` 并指示控件通过方法跟踪对新创建的控件的视图状态所做的任何更改 <xref:System.Web.UI.Control.TrackViewState%2A> 。 这是将数据绑定到控件以确保新数据不会与以前的方法调用存储的数据发生冲突的常用技术 <xref:System.Web.UI.Control.DataBind%2A> 。

 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/zt27tfhy(v=vs.100)">开发自定义 ASP.NET 服务器控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期概述</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">如果引发 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>将数据源绑定到调用的服务器控件及其所有子控件，同时可以选择引发 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>当自定义控件重写 <xref:System.Web.UI.Control.DataBind%2A> 方法并实现接口时，请使用方法 <xref:System.Web.UI.IDataItemContainer> 。 在此方案中，自定义控件调用 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 方法，并 `raiseOnDataBinding` 将设置为， `false` 以确保调用基类的 <xref:System.Web.UI.Control.DataBind%2A> 方法。

 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>方法调用 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 方法，并 `raiseOnDataBinding` 将设置为 `true` 。

> [!NOTE]
>  如果调用的 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 方法 `raiseOnDataBinding` 设置为，则 `false` 会使任何子控件都与方法进行数据绑定 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> 。

 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期概述</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将数据源绑定到服务器控件的子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.UI.Control.DataBindChildren%2A> 方法可将数据源绑定到服务器控件的子控件。

> [!NOTE]
>  在服务器控件上调用时，此方法不会将数据绑定到控件。 若要绑定服务器控件及其所有子控件，请调用 <xref:System.Web.UI.Control.DataBind%2A> 方法。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/zt27tfhy(v=vs.100)">开发自定义 ASP.NET 服务器控件</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当服务器控件绑定到数据源时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此事件通知服务器控件执行已为其编写的任何数据绑定逻辑。



## Examples
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果命名容器实现 <see cref="T:System.Web.UI.IDataItemContainer" />，则获取对命名容器的引用。</summary>
        <value>命名容器。 在实现 <see cref="T:System.Web.UI.IDataItemContainer" /> 的命名容器的层次结构中，此属性返回位于层次结构顶部的命名容器，或者，如果当前 <see cref="T:System.Web.UI.Control" /> 对象不在实现 <see cref="T:System.Web.UI.IDataItemContainer" /> 的命名容器中，则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果命名容器实现 <see cref="T:System.Web.UI.IDataKeysControl" />，则获取对命名容器的引用。</summary>
        <value>命名容器。 在实现 <see cref="T:System.Web.UI.IDataKeysControl" /> 的命名容器的层次结构中，该属性返回位于层次结构顶部的命名容器，或者，如果当前 <see cref="T:System.Web.UI.Control" /> 对象不在实现 <see cref="T:System.Web.UI.IDataKeysControl" /> 的命名容器中，则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否正在使用设计图面上的一个控件。</summary>
        <value>如果设计器中正在使用控件，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.DesignMode%2A>属性返回 `true` 以指示该控件正在设计器的上下文中使用。 当设计时行为不同于运行时行为时，您的自定义控件可以使用此属性。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/wxh45wzs(v=vs.100)">ASP.NET 控件设计器概述</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使服务器控件得以在从内存中释放之前执行最后的清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在完成使用 <xref:System.Web.UI.Control.Dispose%2A> 后，应调用 <xref:System.Web.UI.Control>。 <xref:System.Web.UI.Control.Dispose%2A> 方法使 <xref:System.Web.UI.Control> 处于不可用状态。 调用此方法后，必须释放对控件的所有引用，以便可以通过垃圾回收来回收其占用的内存。



## Examples
 下面的代码示例重写 <xref:System.Web.UI.Control.Dispose%2A> 方法以关闭 <xref:System.Web.UI.HtmlTextWriter> 与控件关联的对象，并对 <xref:System.Web.UI.Control.Dispose%2A> <xref:System.Web.UI.WebControls.Button> 名为的控件调用方法 `myButton` 。 如果在 <xref:System.Exception> 调用此版本的方法时引发 <xref:System.Web.UI.Control.Dispose%2A> ，则该控件将向当前对象写入一条消息 <xref:System.Web.HttpResponse> 。

 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IComponent.Disposed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从内存释放服务器控件时发生，这是请求 ASP.NET 页时服务器控件生存期的最后阶段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 需要大量处理器时间的资源（例如数据库连接）应随此事件一起发布。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示主题是否应用于该控件。</summary>
        <value>如果使用主题，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.EnableTheming%2A>属性指示是否为指定控件启用主题。 当 <xref:System.Web.UI.Control.EnableTheming%2A> 属性为时 `true` ，将在应用程序的主题目录中搜索要应用的控件外观。 如果主题目录中不存在特定控件的外观，则不会应用外观。

 当 <xref:System.Web.UI.Control.EnableTheming%2A> 属性为时 `false` ，不会搜索主题目录，也 <xref:System.Web.UI.Control.SkinID%2A> 不会使用属性的内容。

 可以在页、容器或控件级别启用主题。 控件可以重写 <xref:System.Web.UI.Control.EnableTheming%2A> 由其父控件或由包含页设置的值。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="Page_PreInit" /> 事件已发生。

- 或 -

已将该控件添加到 <see langword="Controls" /> 集合中。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ykzx33wh(v=vs.100)">ASP.NET 主题概述</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务器控件是否向发出请求的客户端保持自己的视图状态以及它所包含的任何子控件的视图状态。</summary>
        <value>如果服务器控件保持其视图状态，则否 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 视图状态使服务器控件能够跨 HTTP 请求维护其状态。 如果满足以下所有条件，则会启用控件的视图状态：

-   <xref:System.Web.UI.Control.EnableViewState%2A>页的属性设置为 `true` 。

-   <xref:System.Web.UI.Control.EnableViewState%2A>控件的属性设置为 `true` 。

-   <xref:System.Web.UI.Control.ViewStateMode%2A>将控件的属性设置为 <xref:System.Web.UI.ViewStateMode.Enabled> 或继承 <xref:System.Web.UI.ViewStateMode.Enabled> 设置。

 有关更多信息，请参见 <xref:System.Web.UI.Control.ViewStateMode%2A> 属性。

 服务器控件的视图状态是其所有属性值的累计。 为了跨 HTTP 请求保留这些值，ASP.NET 使用类的实例 <xref:System.Web.UI.StateBag> 来存储属性值。 然后，在处理后续请求时，这些值将作为变量传递给隐藏的字段。 有关视图状态的详细信息，请参阅 [ASP.NET 视图状态概述](https://docs.microsoft.com/previous-versions/aspnet/bb386448(v=vs.100))。

 在某些情况下，需要禁用视图状态，尤其是为了提高应用程序性能。 例如，如果要将数据库请求加载到服务器控件中，请将此属性设置为 `false` 。 如果不这样做，则会浪费处理器时间，将视图状态加载到仅被数据库查询重写的服务器控件中。 如果 <xref:System.Web.UI.Control.EnableViewState%2A> 为 `false` ，则可以使用控件状态保存特定于控件的属性信息，并且不能像视图状态属性那样关闭。 有关控件状态和视图状态之间的差异的详细信息，请参阅 [控件状态与视图状态示例](https://docs.microsoft.com/previous-versions/aspnet/1whwt1k7(v=vs.100))。

 有关如何以声明方式为 ASP.NET 页启用或禁用视图状态的信息，请参阅[ \@ 页](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))。



## Examples
 下面的示例将 <xref:System.Web.UI.Control.EnableViewState%2A> 属性设置为 `false` 。

 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状态管理概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/1whwt1k7(v=vs.100)">控件状态与视图状态示例</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">写入跟踪数据的对象。</param>
        <param name="traceObject">跟踪对象。</param>
        <summary>结束输出数据的设计时追踪。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确定服务器控件是否包含子控件。 如果不包含，则创建子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法首先检查属性的当前值 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 。 如果此值为 `false` ，则 <xref:System.Web.UI.Control.CreateChildControls%2A> 调用方法。

 <xref:System.Web.UI.Control.EnsureChildControls%2A>方法通常用在复合控件中，复合控件是使用子控件作为部分或全部功能的控件。 <xref:System.Web.UI.Control.EnsureChildControls%2A>调用方法是为了确保已创建子控件并准备好处理输入、执行数据绑定或执行其他任务。

 <xref:System.Web.UI.WebControls.GridView>控件是复合控件的一个示例。 它创建、、、和控件等子控件 <xref:System.Web.UI.WebControls.Table> <xref:System.Web.UI.WebControls.TableRow> <xref:System.Web.UI.WebControls.TableCell> <xref:System.Web.UI.WebControls.Label> <xref:System.Web.UI.WebControls.TextBox> ，这些控件用于呈现生成的 HTML 表 <xref:System.Web.UI.WebControls.GridView> 。

 在大多数情况下，自定义服务器控件开发人员不必重写此方法。 如果确实要重写此方法，请使用类似于默认行为的方式。



## Examples
 下面的示例使用 <xref:System.Web.UI.Control.EnsureChildControls%2A> 方法确保当前服务器控件具有子控件。 然后，它获取或设置 <xref:System.Web.UI.WebControls.TextBox.Text%2A> <xref:System.Web.UI.WebControls.TextBox> 当前服务器控件的对象中的子 Web 控件的属性 <xref:System.Web.UI.ControlCollection> 。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为尚未分配标识符的控件创建标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.EnsureID%2A>方法为包含在另一个控件中的控件生成标识符。 仅为没有为属性分配值的控件生成标识符 <xref:System.Web.UI.Control.ID%2A> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的事件处理程序委托列表。 此属性为只读。</summary>
        <value>事件处理程序委托的列表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性的类型为 <xref:System.ComponentModel.EventHandlerList> ，它使用线性搜索算法查找委托列表中的项。 线性搜索算法在处理大量条目时效率低下。 因此，当您有一个较大的列表时，查找具有此属性的条目的速度会很慢。



## Examples
 下面的示例创建一个名为的事件， `Click` 该事件 <xref:System.ComponentModel.EventHandlerList> 在从页中调用事件时在控件的集合中添加和移除处理程序。

 > [!NOTE]
 > 此示例优化了控件在控件所维护的列表中添加和删除事件的方式。 如果创建自定义控件并要定义事件，请使用类似于下面的代码。 此方法可在 c # 中使用，但不能在 Visual Basic 中使用。

 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在当前的命名容器中搜索指定的服务器控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要查找的控件的标识符。</param>
        <summary>在当前的命名容器中搜索带指定 <paramref name="id" /> 参数的服务器控件。</summary>
        <returns>指定的控件，如果指定的控件不存在则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.UI.Control.FindControl%2A> 从代码隐藏页中的函数访问控件，以访问位于另一个容器内的控件，或者用于访问调用方无法直接访问目标控件的其他情况下的控件。 仅当指定容器直接包含控件时，此方法才会找到控件;也就是说，该方法不在控件内的控件层次结构中进行搜索。 有关如何在不知道控件的即时容器的情况下查找控件的信息，请参阅 [如何：按 ID 访问服务器控件](https://docs.microsoft.com/previous-versions/aspnet/y81z8326(v=vs.100))。



## Examples
 下面的示例定义了一个 `Button1_Click` 事件处理程序。 在调用时，此处理程序使用 <xref:System.Web.UI.Control.FindControl%2A> 方法在 <xref:System.Web.UI.Control.ID%2A> `TextBox2` 包含页上查找属性为的控件。 如果找到了该控件，则使用属性确定其父控件， <xref:System.Web.UI.Control.Parent%2A> 并将父控件的 <xref:System.Web.UI.Control.ID%2A> 写入页面。 如果 `TextBox2` 找不到，则将 "找不到控制" 写入页面。

> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))。

 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/y81z8326(v=vs.100)">如何：按 ID 访问服务器控件</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">要查找的控件的标识符。</param>
        <param name="pathOffset">页面控件层次结构上到达命名容器所需的控件的数量。</param>
        <summary>使用指定的 <paramref name="id" /> 和 <paramref name="pathOffset" /> 参数（该参数有助于搜索）中指定的整数在当前命名容器中搜索服务器控件。 不应重写此版本的 <see cref="Overload:System.Web.UI.Control.FindControl" /> 方法。</summary>
        <returns>指定的控件，如果指定的控件不存在则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为控件设置输入焦点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.UI.Control.Focus%2A> 方法将网页的初始焦点设置到控件。 将在浏览器中打开该控件并选定控件。

 <xref:System.Web.UI.Control.Focus%2A>方法导致在呈现的页面上发出对页面焦点脚本的调用。 如果该页不包含具有与在其 `ID` 上调用该方法的控件匹配的 HTML 特性的控件 <xref:System.Web.UI.Control.Focus%2A> ，则将不会设置页焦点。 例如，在用户控件上设置焦点，而不是将焦点设置到用户控件的子控件上时，就会发生这种情况。 在此方案中，可以使用 <xref:System.Web.UI.Control.FindControl%2A> 方法查找用户控件的子控件并调用其 <xref:System.Web.UI.Control.Focus%2A> 方法。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取控件的设计时数据。</summary>
        <returns>包含控件的设计时数据的 <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.GetDesignModeState%2A>方法返回控件的设计时数据。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.Control.GetDesignModeState" />默认情况下，该方法返回 <see langword="null" /> 。 必须重写此方法，以提供控件需要的设计时数据。</para></block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与一组路由参数对应的 URL，以及（可选）与路由名称对应的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 方法。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">路由参数。</param>
        <summary>获取与一组路由参数对应的 URL。</summary>
        <returns>与指定路由参数对应的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 方法。 此方法使用构造函数将传入的对象转换 `routeParameters` 为 <xref:System.Web.Routing.RouteValueDictionary> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。



## Examples
 下面的示例演示如何调用 <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> 方法来获取具有名为和的参数的路由的 URL `productid` `category` 。 此示例假设您已创建了一个 <xref:System.Web.UI.WebControls.HyperLink> 名为的控件 `HyperLink1` 。

```vb
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(
  New With {.productid = "1", .category = "widgets"})
```

```csharp
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">路由参数。</param>
        <summary>获取与一组路由参数对应的 URL。</summary>
        <returns>与指定路由参数对应的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 方法。



## Examples
 下面的示例演示如何调用此方法以获取具有名为和的参数的路由的 URL `productid` `category` 。 此示例假设您已创建了一个 <xref:System.Web.UI.WebControls.HyperLink> 名为的控件 `HyperLink1` 。

```vb
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeParameters">路由参数。</param>
        <summary>获取与一组路由参数以及某个路由名称对应的 URL。</summary>
        <returns>与指定路由参数和路由名称对应的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 方法。 此方法使用构造函数将传入的对象转换 `routeParameters` 为 <xref:System.Web.Routing.RouteValueDictionary> 对象 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 。



## Examples
 下面的示例演示如何调用此方法以获取名为的路由的 URL， `Product` 并具有名为和的参数 `productid` `category` 。 此示例假设您已创建了一个 <xref:System.Web.UI.WebControls.HyperLink> 名为的控件 `HyperLink1` 。

```vb
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",
  New With {.productid = "1", .category = "widgets"})
```

```csharp
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",
  new { productid = "1", category = "widgets" });
```

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">路由的名称。</param>
        <param name="routeParameters">路由参数。</param>
        <summary>获取与一组路由参数以及某个路由名称对应的 URL。</summary>
        <returns>与指定路由参数和路由名称对应的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 提供此方法是为了便于编码。 它等效于调用 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 方法。



## Examples
 下面的示例演示如何调用此方法以获取名为的路由的 URL， `Product` 并具有名为和的参数 `productid` `category` 。 此示例假设您已创建了一个 <xref:System.Web.UI.WebControls.HyperLink> 名为的控件 `HyperLink1` 。

```vb
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",
  new RouteValueDictionary {productId="1", category="widgets"})
```

```csharp
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",
  (new RouteValueDictionary {productId="1", category="widgets"});
```

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUniqueIDRelativeTo (control As Control) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">位于命名容器内的控件。</param>
        <summary>返回指定控件的 <see cref="P:System.Web.UI.Control.UniqueID" /> 属性的前缀部分。</summary>
        <returns>指定控件的 <see cref="P:System.Web.UI.Control.UniqueID" /> 属性的前缀部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.UniqueID%2A>控件的属性是通过将前缀添加到控件的属性来生成的 <xref:System.Web.UI.Control.ID%2A> 。 前缀由 <xref:System.Web.UI.Control.UniqueID%2A> 与分隔符连接的控件的命名容器的属性组成。 如果命名容器是页面，则没有前缀。 此方法返回前缀字符串。 如果没有前缀字符串，则它将返回 <xref:System.Web.UI.Control.UniqueID%2A> 控件的值。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> 的 <see cref="P:System.Web.UI.Control.NamingContainer" /> 属性为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前服务器控件的子控件是否具有任何已保存的视图状态设置。</summary>
        <value>如果有任何子控件具有已保存的视图状态信息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 您可以 <xref:System.Web.UI.Control.ClearChildViewState%2A> 通过使用此属性来验证服务器控件的所有子控件是否存储视图状态信息，从而避免不必要的方法调用。



## Examples
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确定服务器控件是否包含任何子控件。</summary>
        <returns>如果控件包含其他控件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 由于此方法只是确定是否存在任何子控件，因此它可以通过允许避免不必要的属性调用来提高性能 <xref:System.Web.UI.ControlCollection.Count%2A> 。 对此属性的调用需要 <xref:System.Web.UI.ControlCollection> 实例化对象。 如果没有子级，则创建此对象会浪费服务器资源。



## Examples
 下面的示例使用 <xref:System.Web.UI.Control.HasControls%2A> 方法来确定在使用 <xref:System.Web.UI.ControlCollection.Count%2A> 属性循环访问对象之前是否存在任何控件 <xref:System.Web.UI.ControlCollection> 。

 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.Control.HasControls" />应只重写此方法以更改元数据特性，例如 <see cref="T:System.ComponentModel.EditorBrowsableAttribute" /> 。 有关使用特性的详细信息，请参阅 [特性](/dotnet/standard/attributes/)。</para></block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示是否为控件或任何子控件注册事件。</summary>
        <returns>如果注册事件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.MergableProperty(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.MergableProperty(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.ParenthesizePropertyName(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.ParenthesizePropertyName(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Filterable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Filterable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置分配给服务器控件的编程标识符。</summary>
        <value>分配给控件的编程标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在服务器控件上设置此属性可提供对服务器控件的属性、事件和方法的编程访问。 Web 开发人员可以通过 <xref:System.Web.UI.Control.ID%2A> 在 ASP.NET 服务器控件的开始标记中声明特性来设置此属性。

 如果未以声明方式或编程方式为服务器控件指定此属性，则可以通过其父控件的属性获取对该控件的引用 <xref:System.Web.UI.Control.Controls%2A> 。

> [!NOTE]
>  只有字母数字字符和下划线字符 ( _ ) 的组合是此属性的有效值。 包括空格或其他无效字符将导致 ASP.NET 页分析器错误。



## Examples
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于分隔控件标识符的字符。</summary>
        <value>分隔符字符。 默认为“$”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 属性中包含的字符 <xref:System.Web.UI.Control.IdSeparator%2A> 用于分隔子控件的控件标识符。 ID 分隔符字符将追加到 <xref:System.Web.UI.Control.ID%2A> 属性。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当服务器控件初始化时发生；初始化是控件生存期的第一步。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 服务器控件应执行创建和设置实例所需的任何初始化步骤。 此事件内不能使用视图状态信息;尚未填充。 不应在此事件期间访问另一个服务器控件，而不管它是此控件的子控件还是父控件。 不一定要创建其他服务器控件并准备好进行访问。 有关服务器控件事件的详细信息，请参阅 [ASP.NET Web 窗体服务器控件事件模型](https://docs.microsoft.com/previous-versions/aspnet/y3bwdsh3(v=vs.100))。



## Examples
 下面的示例将自定义事件处理程序分配 `Calendar_Init` 给 `Init` 控件的事件 <xref:System.Web.UI.WebControls.Calendar> 。

 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该控件中包含的控件是否具有控件状态。</summary>
        <value>如果该控件的子级不使用控件状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确定服务器控件是否只包含文字内容。</summary>
        <returns>如果服务器控件只包含文本内容，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法返回时 `true` ，服务器控件的集合保存单个文本控件。



## Examples
 下面的示例检查包含服务器控件的页是否已回发。 如果有，它会调用 <xref:System.Web.UI.Control.IsLiteralContent%2A> 方法来确定控件是只包含文字内容还是包含对其他服务器控件的父控件。 如果它仅包含文本内容， <xref:System.Web.UI.Control.UniqueID%2A> 则表示该内容的的属性将 <xref:System.Web.UI.LiteralControl> 写入响应中。

 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，用于指示服务器控件是否会将更改保存到其视图状态中。</summary>
        <value>如果控件标记为保存其状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关使用此属性的示例自定义服务器控件，请参阅 [模板服务器控件示例](https://docs.microsoft.com/previous-versions/aspnet/ms178657(v=vs.100))



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.DataBind%2A> 自定义 ASP.NET 服务器控件中的方法。 首先调用基 <xref:System.Web.UI.Control.OnDataBinding%2A> 方法，然后使用 `ControlCollection` 对象。 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> 方法删除所有子控件，并将 <xref:System.Web.UI.Control.ClearChildViewState%2A> 方法删除这些子控件的任何已保存的视图状态设置。 最后，将 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 属性设置为 `true` 。 然后，控件使用 <xref:System.Web.UI.Control.IsTrackingViewState%2A> 属性来确定是否为控件启用了视图状态更改跟踪。 如果未启用，则 <xref:System.Web.UI.Control.TrackViewState%2A> 调用方法。

 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为该控件启用了视图状态。</summary>
        <value>如果为控件启用了视图状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以在页、容器或控件级别启用视图状态。 当在页或容器级别禁用视图状态时，将为该页或容器包含的所有控件禁用视图状态。 <xref:System.Web.UI.Control.IsViewStateEnabled%2A>属性指示页面、容器或控件是否启用了视图状态。

 <xref:System.Web.UI.Control.EnableViewState%2A>属性和 <xref:System.Web.UI.Control.IsViewStateEnabled%2A> 属性可能不同。 例如，如果 <xref:System.Web.UI.Page> 包含控件的包含禁用视图状态，则 <xref:System.Web.UI.Control.EnableViewState%2A> 属性为时，属性可以为 `true` <xref:System.Web.UI.Control.IsViewStateEnabled%2A> `false` 。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>页面开发人员将设置 <see cref="P:System.Web.UI.Control.EnableViewState" /> 属性和 <see cref="P:System.Web.UI.Control.ViewStateMode" /> 属性，以指示它们是否与控件一起使用视图状态。 使用 <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> 代码中的属性和 <see cref="P:System.Web.UI.Control.ViewStateMode" /> 属性来确定是否为控件以及所有容器启用了视图状态。</para></block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当服务器控件加载到 <see cref="T:System.Web.UI.Page" /> 对象中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 通知服务器控件执行任何设置为在每个页面请求上进行的处理步骤。 您可以通过此事件访问视图状态信息和 Web 窗体发布数据。 您还可以访问页的控件层次结构中的其他服务器控件。

> [!NOTE]
>  如果在事件期间在控件中设置了自定义模板 `Page_Load` ，则自定义模板中子控件的文本值将会丢失。 出现这种情况是因为已经加载了窗体值。



## Examples
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="savedState">表示要还原的控件状态的 <see cref="T:System.Object" />。</param>
        <summary>从 <see cref="M:System.Web.UI.Control.SaveControlState" /> 方法保存的上一个页请求还原控件状态信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果需要指定自定义服务器控件如何还原其控件状态，请重写此方法。 有关详细信息，请参阅 [ASP.NET 状态管理概述](https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100))。



## Examples
 下面的代码示例将重写 <xref:System.Web.UI.Control.LoadControlState%2A> 自定义 ASP.NET 控件中的方法。 调用此方法时，它将确定是否之前为控件保存了控件状态，如果是，则将内部属性设置 `currentIndex` 为保存的值。

 <xref:System.Web.UI.Control.OnInit%2A>重写方法以对调用 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 方法， <xref:System.Web.UI.Control.Page%2A> 以指示自定义控件使用控件状态。

 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">表示要还原的控件状态的 <see cref="T:System.Object" />。</param>
        <summary>从用 <see cref="M:System.Web.UI.Control.SaveViewState" /> 方法保存的上一个页面请求还原视图状态信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法主要由 .NET Framework 基础结构使用，不应在代码中直接使用。 不过，控件开发人员可以重写此方法，以指定自定义服务器控件如何还原其视图状态。 有关详细信息，请参阅 [ASP.NET 状态管理概述](https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100))。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.LoadViewState%2A> 自定义 ASP.NET 服务器控件的方法。 它创建一个 <xref:System.Object> 数组来包含参数中传递的视图状态信息 `savedState` ，然后 <xref:System.Web.UI.Control.LoadViewState%2A> 为数组的第一个索引位置调用方法的基实现。 它将存储在接下来两个索引位置的值分别分配给名为 `UserText` 和 `PasswordText` 的变量。

 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示控件是否通过 <see cref="P:System.Web.UI.Control.ID" /> 而不是索引参与加载其视图状态。</summary>
        <value>如果控件通过 <see cref="P:System.Web.UI.Control.ID" /> 加载其视图状态，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认情况下，当父控件将视图状态加载到它创建的子控件中时，它会通过父控件的集合中每个子控件的位置来执行此项 <xref:System.Web.UI.Control.Controls%2A> 。 最初应用视图状态时，可能尚未创建所有子控件。 在这种情况下，将保存尚未创建的控件的视图状态，并在以后创建子控件时应用该视图状态。

 若要让父控件将视图状态应用到其子控件，必须满足两个条件：

-   在回发时，父控件必须按与上一个请求完全相同的顺序创建子控件，以便控件的顺序保持一致。

-   回发之后，必须将创建的任何子控件添加到父控件的集合的末尾 <xref:System.Web.UI.Control.Controls%2A> 。

 如果不满足这两个条件，例如创建子控件延迟，则父控件可以使用加载视图状态 <xref:System.Web.UI.Control.ID%2A> 。 若要将 <xref:System.Web.UI.Control.LoadViewStateByID%2A> 属性设置为 `true` ，请使用 <xref:System.Web.UI.ViewStateModeByIdAttribute> 父控件的元数据特性。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected string MapPathSecure (string virtualPath);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance string MapPathSecure(string virtualPath) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MapPathSecure (virtualPath As String) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相对 URL 或相对于根的 URL。</param>
        <summary>检索虚拟路径（绝对的或相对的）映射到的物理路径。</summary>
        <returns>请求文件的物理路径。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法只能由有权读取文件的服务器控件和作为完全信任的 .dll 文件的一部分（如 System.Web.dll）使用。 这有助于防止安全漏洞。



## Examples
 下面的示例使用 <xref:System.Web.UI.Control.MapPathSecure%2A> 方法获取包含或对象的虚拟目录的物理路径 <xref:System.Web.UI.Page> <xref:System.Web.UI.UserControl> 。

 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> 为 <see langword="null" /> 或空字符串 ("")。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对服务器控件的命名容器的引用，此引用创建唯一的命名空间，以区分具有相同 <see cref="P:System.Web.UI.Control.ID" /> 属性值的服务器控件。</summary>
        <value>服务器控件的命名容器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET Web 应用程序中的每一页都包含一个控件层次结构。 此层次结构不依赖于控件是否生成向用户显示的 UI。 给定控件的命名容器是实现接口的层次结构中其上方的父控件 <xref:System.Web.UI.INamingContainer> 。 实现此接口的服务器控件为其子服务器控件的属性值创建唯一的命名空间 <xref:System.Web.UI.Control.ID%2A> 。 可以使用 <xref:System.Web.UI.Control.NamingContainer%2A> 命名容器的子控件的属性来获取对其父容器的引用。

 将 Web 服务器控件绑定到数据（如 <xref:System.Web.UI.WebControls.Repeater> 和服务器控件）时，为服务器控件创建唯一的命名空间非常重要 <xref:System.Web.UI.WebControls.DataList> 。 当数据源中的多个条目创建的服务器控件的多个实例是重复控件的子控件时，命名容器可确保这些子控件的每个实例都具有 <xref:System.Web.UI.Control.UniqueID%2A> 不冲突的属性值。 页面的默认命名容器是 <xref:System.Web.UI.Page> 请求该页面时生成的类的实例。

 <xref:System.Web.UI.Control.ClientID%2A>属性包含在 HTML 标记中呈现为元素的特性的值 `id` 。 根据您分配给该属性的值 <xref:System.Web.UI.Control.ClientIDMode%2A> ，为该属性生成的值 <xref:System.Web.UI.Control.ClientID%2A> 可能包括对象的 ID <xref:System.Web.UI.Control.NamingContainer%2A> 。 如果将设置 <xref:System.Web.UI.Control.ClientIDMode%2A> 为 <xref:System.Web.UI.ClientIDMode.Static> ，则 <xref:System.Web.UI.Control.ClientID%2A> 该值不包括对象的 ID <xref:System.Web.UI.Control.NamingContainer%2A> 。 当你将设置 <xref:System.Web.UI.Control.ClientIDMode%2A> 为 <xref:System.Web.UI.ClientIDMode.AutoID> 或时 <xref:System.Web.UI.ClientIDMode.Predictable> ， <xref:System.Web.UI.Control.ClientID%2A> 值将包括来自对象的 ID <xref:System.Web.UI.Control.NamingContainer%2A> 。 有关详细信息，请参阅 [ASP.NET Web 服务器控件标识](https://docs.microsoft.com/previous-versions/1d04y8ss(v=vs.140))。



## Examples
 下面的示例演示如何使用 <xref:System.Web.UI.Control.NamingContainer%2A> 属性。

 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="args">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>确定服务器控件的事件是否沿页的 UI 服务器控件层次结构向上传递。</summary>
        <returns>如果事件已被取消，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 服务器控件（例如 <xref:System.Web.UI.WebControls.Repeater> ） <xref:System.Web.UI.WebControls.DataList> 和 <xref:System.Web.UI.WebControls.GridView> Web 控件可以包含引发事件的子控件。 例如，控件中的每一行 <xref:System.Web.UI.WebControls.GridView> 都可以包含一个或多个由模板动态创建的按钮。 嵌套控件中的事件是 "冒泡" 的，而不是每个按钮单独引发事件，也就是说，它们被发送到命名容器。 命名容器进而引发 <xref:System.Web.UI.WebControls.GridView.RowCommand> 用参数值调用的泛型事件。 这些值允许您确定引发原始事件的单个控件。 通过响应此单个事件，你可以避免为子控件编写单独的事件处理方法。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 自定义 ASP.NET 服务器控件中的方法 `ParentControl` 。 当的子控件调用方法时，将调用此方法 `ParentControl` <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 。 发生这种情况时，类会将 `ParentControl` 两个字符串写入包含 ASP.NET 页，第一个声明 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 已调用方法，第二个字符串标识方法的源代码管理 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 。

 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法通知服务器控件执行任何逻辑，以便绑定与它关联的数据。

 如果要处理 <xref:System.Web.UI.Control.DataBinding> 事件，则应重写此事件处理方法。 这可确保调用附加到事件的所有委托 <xref:System.Web.UI.Control.DataBinding> 。



## Examples
 下面的示例演示如何重写 <xref:System.Web.UI.Control.OnDataBinding%2A> 方法，以便从数据源向父控件添加子控件。

 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期概述</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected virtual void OnInit (EventArgs e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInit (e As EventArgs)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInit(EventArgs ^ e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 调用此方法来引发 <xref:System.Web.UI.Control.Init> 事件。 如果要开发自定义控件，则可以重写此方法，以便提供其他处理。 如果重写此方法，请调用基控件的 <xref:System.Web.UI.Control.OnInit%2A> 方法以通知订阅者事件。



## Examples
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Load" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 调用此方法来引发 <xref:System.Web.UI.Control.Load> 事件。 如果要开发自定义控件，则可以重写此方法，以便提供其他处理。 如果重写此方法，请调用基控件的 <xref:System.Web.UI.Control.OnLoad%2A> 方法以通知订阅者事件。



## Examples
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRender (EventArgs e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRender (e As EventArgs)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRender(EventArgs ^ e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 调用此方法来引发 <xref:System.Web.UI.Control.PreRender> 事件。 如果要开发自定义控件，则可以重写此方法，以便提供其他处理。 如果重写此方法，请调用基控件的 <xref:System.Web.UI.Control.OnPreRender%2A> 方法以通知订阅者事件。



## Examples
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected virtual void OnUnload (EventArgs e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnload (e As EventArgs)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnload(EventArgs ^ e);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Unload" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 调用此方法来引发 <xref:System.Web.UI.Control.Unload> 事件。 如果要开发自定义控件，则可以重写此方法，以便提供其他处理。 如果重写此方法，请调用基控件的 <xref:System.Web.UI.Control.OnUnload%2A> 方法以通知订阅者事件。



## Examples
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">所需文件的路径。</param>
        <summary>获取用于读取文件的 <see cref="T:System.IO.Stream" />。</summary>
        <returns>引用所需文件的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.OpenFile%2A>方法返回一个 <xref:System.IO.Stream> 对象，该对象可用于读取参数中指定的文件的内容 `path` 。 Path 参数可以是不带协议的相对或根 URL (例如 "~/mySite/myFile.txt) 或物理路径，本地 (" c:\mySite\myFile.txt ") 或 UNC (" \\\myServer\myFile.txt ") 。

 <xref:System.Web.UI.Control.OpenFile%2A>方法使用文件访问安全性来控制对指定文件的访问。 如果当前 ASP.NET 用户无权访问该文件，则不会打开该文件，并 <xref:System.Web.HttpException> 引发异常以指示访问被拒绝。 如果 `path` 参数指定了相对路径，则异常不包含有关所请求文件的物理路径的信息。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">对指定文件的访问被拒绝。</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对包含服务器控件的 <see cref="T:System.Web.UI.Page" /> 实例的引用。</summary>
        <value>包含服务器控件的 <see cref="T:System.Web.UI.Page" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性的值反映包含服务器控件的 .aspx 文件的名称。



## Examples
 下面的示例将会重写 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 方法。 它使用 <xref:System.Web.UI.Page> 属性访问 <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> 属性，并确定包含此控件的页是第一次加载还是为回发的结果。

 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该控件为 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控件。</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对页 UI 层次结构中服务器控件的父控件的引用。</summary>
        <value>对服务器控件的父控件的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每次请求页面时，将生成该页面上的服务器控件的层次结构。 此属性允许您确定该层次结构中当前服务器控件的父控件，并对其进行编程。



## Examples
 下面的示例将页上的一个新 <xref:System.Web.UI.Control> 对象设置 `myControl1` 为方法调用中指定的控件 <xref:System.Web.UI.Control.FindControl%2A> 。 如果调用返回了一个控件，则该代码使用 <xref:System.Web.UI.Control.Parent%2A> 属性来标识包含的控件 `myControl1` 。 如果父控件存在，则字符串 "文本框的父项" 将与 <xref:System.Web.UI.Control.ID%2A> 父控件的属性连接，并写入到中 <xref:System.Web.UI.Control.Page%2A> 。 如果找不到父控件，则写入字符串 "找不到控制"。

 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在加载 <see cref="T:System.Web.UI.Control" /> 对象之后、呈现之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用此事件来执行任何更新，然后将服务器控件呈现到页面。 在此事件中，可以保存服务器控件的视图状态更改。 在呈现阶段中所做的更改将不会保存。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件源。</param>
        <param name="args">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>将所有事件源及其信息分配给控件的父级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 服务器控件（例如 <xref:System.Web.UI.WebControls.Repeater> ） <xref:System.Web.UI.WebControls.DataList> 和 <xref:System.Web.UI.WebControls.GridView> Web 控件可以包含引发事件的子控件。 例如，控件中的每一行 <xref:System.Web.UI.WebControls.GridView> 都可以包含一个或多个由模板动态创建的按钮。 嵌套控件中的事件是 "冒泡" 的，而不是每个按钮单独引发事件，也就是说，它们被发送到控件的父级。 父对象进而引发 <xref:System.Web.UI.WebControls.GridView.RowCommand> 用参数值调用的泛型事件。 这些值允许您确定引发原始事件的单个控件。 通过响应此单个事件，你可以避免为子控件编写单独的事件处理方法。

 虽然您不能重写此方法，但您的创作控件可以通过重写方法来处理或引发冒泡事件 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 。



## Examples
 下面的代码示例演示如何创建自定义类， `ChildControl` 重写方法， <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> 以调用 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 将 <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> 事件发送到其父 ASP.NET 服务器控件的方法。 用户单击包含实例的 ASP.NET 页面中的按钮时 `ChildControl` ，它会 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 在包含实例的父控件上引发方法， `ChildControl` 并将字符串 "ChildControl 类 OnClick 方法称为" 写入页面。

 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RemovedControl (control As Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">已被移除的 <see cref="T:System.Web.UI.Control" />。</param>
        <summary>从 <see cref="T:System.Web.UI.Control" /> 对象的 <see cref="P:System.Web.UI.Control.Controls" /> 集合移除子控件后调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 <xref:System.Web.UI.Control.RemovedControl%2A> 从集合中移除控件后立即调用方法 <xref:System.Web.UI.Control.Controls%2A> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该控件为 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控件。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected virtual void Render (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Render (writer As HtmlTextWriter)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于接收服务器控件内容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象。</param>
        <summary>将服务器控件内容发送到给定的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象，该对象可编写将在客户端呈现的内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 开发自定义服务器控件时，可以重写此方法，以生成 ASP.NET 页的内容。



## Examples
 下面的代码示例演示如何重写 <xref:System.Web.UI.Control.Render%2A> 方法。 <xref:System.Web.UI.Control.HasControls%2A>方法用于确定服务器控件是否具有存储在其对象中的任何子控件 <xref:System.Web.UI.ControlCollection> ，该控件可通过 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> 属性访问。 如果 <xref:System.Web.UI.Control.HasControls%2A> 返回 true，并且集合中的第一个服务器控件是文本文本，则文本文本将追加到 HTML 字符串。

 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">接收呈现的内容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象。</param>
        <summary>将服务器控件子级的内容输出到提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象，该对象可写入要在客户端上呈现的内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法通知 ASP.NET 在页面上呈现 (ASP) 代码的任何活动服务器页。 如果该页不存在任何 ASP 代码，则此方法将呈现服务器控件的任何子控件。 此方法由 <xref:System.Web.UI.Control.Render%2A> 方法调用。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.RenderChildren%2A> 自定义服务器控件中的方法。 它确定当前控件在其对象中是否有任何子控件 <xref:System.Web.UI.ControlCollection> 。 如果它存在，则使用 <xref:System.Web.UI.ControlCollection.Count%2A> 属性来循环访问集合。 在遇到每个子控件时，它使用 <xref:System.Web.UI.Control.RenderControl%2A> 方法将父控件及其所有子控件呈现给包含页。

 然后，重写的 <xref:System.Web.UI.Control.Render%2A> 方法调用重写的 <xref:System.Web.UI.Control.RenderChildren%2A> 方法。

 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>输出服务器控件内容，并存储有关此控件的跟踪信息（如果已启用跟踪）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public void RenderControl (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenderControl (writer As HtmlTextWriter)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">接收控件内容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象。</param>
        <summary>将服务器控件内容输出到所提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象，如果启用了跟踪，则还将存储有关该控件的跟踪信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果服务器控件的 <xref:System.Web.UI.Control.Visible%2A> 属性设置为，则 `true` 此方法将确定是否为该页启用跟踪。 如果是这样，它将存储与控件相关联的跟踪信息，并将服务器控件内容呈现到页面。

 此方法在呈现期间由页面自动调用，但可由自定义控件开发人员重写。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.RenderChildren%2A> 自定义服务器控件中的方法。 它确定当前控件在其对象中是否有任何子控件 <xref:System.Web.UI.ControlCollection> 。 如果它存在，则使用 <xref:System.Web.UI.ControlCollection.Count%2A> 属性来循环访问集合。 在遇到每个子控件时，它使用 <xref:System.Web.UI.Control.RenderControl%2A> 方法将子控件及其所有子控件呈现给包含页。 <xref:System.Web.UI.XhtmlTextWriter>传递给此方法的对象由方法实例化 <xref:System.Web.UI.Page.Render%2A> 。

 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">接收控件内容的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter">定义呈现的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</param>
        <summary>使用提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象将服务器控件内容输出到提供的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 可以从 Web 请求信息的各种设备和浏览器中使用 ASP.NET 网页。 <xref:System.Web.UI.Control.Adapter%2A>属性返回在 <xref:System.Web.UI.Adapters.ControlAdapter> 请求设备或浏览器的屏幕上呈现控件的对象。

 有关适配器的详细信息，请参阅 [自适应控制行为的体系结构概述](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))。

 如果服务器控件的 <xref:System.Web.UI.Control.Visible%2A> 属性设置为 `true` 并为该页启用了跟踪，则将捕获与该控件关联的跟踪信息。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>重写 <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> 自定义控件中的方法时，调用基类方法以确保正确捕获跟踪信息。</para></block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">自适应控制行为的体系结构概述</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指定呈现的 HTML 将与之兼容的 ASP.NET 版本。</summary>
        <value>呈现的 HTML 将与之兼容的 ASP.NET 版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 将此属性设置为 `controlRenderingCompatibilityVersion` `pages` Web.config 文件中元素的属性的值。 如果 `controlRenderingCompatibilityVersion` 未在 Web.config 文件中设置属性，则默认值为 ASP.NET 的当前版本。

> [!CAUTION]
>  此属性有一个公共 set 访问器，但 set 访问器支持 .NET Framework 基础结构，不应在代码中直接使用。 如果您在代码中设置此值，则效果是不可预知的。

 每个版本的 ASP.NET 可能会以不同于早期版本的方式呈现 HTML。 例如，在 ASP.NET 3.5 中，如果 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> 控件的属性 <xref:System.Web.UI.WebControls.Label> 为，则 `false` 默认情况下，ASP.NET 将呈现 `span` 其 `disabled` 特性设置为 "disabled" 的元素。 在 ASP.NET 4 中，默认情况下， `span` 元素使用级联样式表 (CSS) `class` 特性而不是属性进行呈现 `disabled` 。 这使您可以指定控件的禁用外观，并避免呈现无效的 HTML。  (在 HTML 4.0 和 XHTML 1.1 中， `span` 元素不支持 `disabled` 特性。 ) 

 如果 HTML 呈现发生更改，则 Web 应用程序可能包含无法正常工作的代码。 若要避免此问题，可以 `controlRenderingCompatibilityVersion` `pages` 在 Web.config 文件中设置元素的属性，以指示要保持与兼容的早期版本。 例如，如果将 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 属性设置为，则 `3.5` 已禁用的 <xref:System.Web.UI.WebControls.Label> 控件将呈现一个 `disabled` 属性，而不是一个 CSS 类。

> [!NOTE]
>  此属性可以设置为的最早版本是 `3.5` 。

 为了保持向后兼容性，当你使用 Visual Studio 将 Web 项目从早期版本升级到 ASP.NET 4 时，Visual Studio 会自动将 `controlRenderingCompatibilityVersion` Web.config 文件中的属性设置为 `3.5` 。 如果希望升级的网站使用 ASP.NET 4 中引入的算法呈现 HTML，则可以更改或删除该 `controlRenderingCompatibilityVersion` 属性。

 大多数情况下，此属性控制的行为是自动的，无需 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 在代码中检查属性。 但是，如果你正在编程自定义控件，则可能必须包含用于根据此属性的设置更改控件行为的代码。 例如，ASP.NET 4 的自定义控件可能由 <xref:System.Web.UI.WebControls.Label> 控件组成，自定义控件可以通过生成更改类的 JavaScript 代码来指定控件的禁用外观 `aspNetDisabled` 。 如果 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 为 `4.0` 或更高版本，则此操作将按预期方式工作。 但是，若要在为时获得相同的效果 <xref:System.Web.UI.Control.RenderingCompatibility%2A> `3.5` ，当属性为时，自定义控件的代码必须将控件的 `CssClass` 属性设置为 "aspNetDisabled" <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> `false` 。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取负责呈现指定控件的控件适配器。</summary>
        <returns>将呈现控件的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET 网页可在各种设备上查看，这些设备能够从 Web 请求页面。 <xref:System.Web.UI.Control.ResolveAdapter%2A>方法返回控件适配器，该适配器负责在请求 ASP.NET 页的特定浏览器或设备上呈现控件。

 返回的特定适配器类型取决于所呈现类的派生类型 <xref:System.Web.UI.Control> 。

 有关适配器的详细信息，请参阅 [自适应控制行为的体系结构概述](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">相对于当前页的 URL。</param>
        <summary>获取浏览器可以使用的 URL。</summary>
        <returns>适合用于浏览器的指定资源的完全限定 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 方法可返回适合客户端访问 Web 服务器上的资源（例如图像文件、其他页面的链接等）的 URL 字符串。

> [!NOTE]
>  此方法返回的 URL 是相对于包含实例化控件的源文件的文件夹的相对路径。 继承此属性的控件（如 <xref:System.Web.UI.UserControl> 和 <xref:System.Web.UI.MasterPage> ）将返回相对于控件的完全限定的 URL。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">与 <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> 属性相关联的 URL。</param>
        <summary>将 URL 转换为在请求客户端可用的 URL。</summary>
        <returns>转换后的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果 `relativeUrl` 参数包含绝对 url，则返回的 url 保持不变。 如果 `relativeUrl` 参数包含相对 url，则会将该 url 更改为对当前请求路径正确的相对 url，以便浏览器可以解析 URL。

 例如，考虑以下方案：

-   客户端已请求一个 ASP.NET 页，其中包含一个用户控件，该控件包含一个与之关联的图像。

-   ASP.NET 页位于/Store/page1.aspx。

-   用户控件位于/Store/UserControls/UC1.ascx。

-   映像文件位于/UserControls/Images/Image1.jpg。

 如果用户控件传递图像的相对路径 (也就是说，/Store/UserControls/Images/Image1.jpg) <xref:System.Web.UI.Control.ResolveUrl%2A> 方法，则方法将返回值/Images/Image1.jpg。

 此方法使用 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 属性解析为绝对 URL。 返回的 URL 供客户端使用。

 有关网站中的资源路径的详细信息，请参阅 [ASP.NET Web 项目路径](https://docs.microsoft.com/previous-versions/aspnet/ms178116(v=vs.100))。

> [!NOTE]
>  仅对于移动网页，如果应用程序依赖于无 cookie 的会话，或者可能接收到需要无 cookie 会话的移动浏览器发出的请求，则在路径中使用波形符 ( " \~ " ) 会导致无意中创建新会话，并可能会丢失会话数据。 若要设置具有路径（如 " \~ / *path"*）的属性，请在将 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> \~ / 其分配给属性之前，通过使用参数（如 "*path"* ）调用来解析路径。



## Examples
 下面的示例创建一个 <xref:System.Web.UI.WebControls.Image> Web 服务器控件对象，并使用 <xref:System.Web.UI.Control.ResolveUrl%2A> 方法设置图像的路径，该图像由 <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> 属性存储。

 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">当 <paramref name="relativeUrl" /> 参数包含 <see langword="null" /> 时发生。</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178116(v=vs.100)">ASP.NET 网站路径</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存将页面回发到服务器之后发生的所有服务器控件状态更改。</summary>
        <returns>返回服务器控件的当前状态。 如果没有与该控件关联的状态，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用 <xref:System.Web.UI.Control.SaveControlState%2A> 方法可保存特定控件操作所需的状态信息。 此控件状态数据与控件的视图状态数据分开存储。

 使用控件状态的自定义控件必须在 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> <xref:System.Web.UI.Control.Page%2A> 保存控件状态之前对调用方法。



## Examples
 下面的代码示例将重写 <xref:System.Web.UI.Control.SaveControlState%2A> 自定义 ASP.NET 控件中的方法。 调用此方法时，它将确定内部属性是否 `currentIndex` 设置为非默认值，如果是，则将该值保存到控件状态。

 <xref:System.Web.UI.Control.OnInit%2A>重写方法以对调用 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 方法， <xref:System.Web.UI.Control.Page%2A> 以指示自定义控件使用控件状态。

 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>保存控件状态时，字符串对象将作为存储在 HTML 元素中的变量返回给客户端 <see langword="HIDDEN" /> 。 重写此方法以提取要在控件中使用的状态信息。

控件状态适用于少量的关键数据，如页索引或关键字。 对于大量数据，使用控件状态会对页性能产生不利影响。 有关详细信息，请参阅 [ASP.NET 状态管理概述](https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100))。</para></block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状态管理概述</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存将页面回发到服务器之后发生的所有服务器控件视图状态更改。</summary>
        <returns>返回服务器控件的当前视图状态。 如果没有与该控件关联的视图状态，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 视图状态是服务器控件属性的值的累计。 这些值自动置于服务器控件的 <xref:System.Web.UI.Control.ViewState%2A> 属性中，该属性是类的实例 <xref:System.Web.UI.StateBag> 。 然后，将此属性的值保存到服务器控件生命周期的保存状态阶段之后的字符串对象。 有关详细信息，请参阅 [ASP.NET 页生命周期概述](https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100))。

 保存视图状态时，此字符串对象将作为存储在 HTML 元素中的变量返回给客户端 `HIDDEN` 。 使用自定义视图状态创作自定义服务器控件时，可以使用和方法显式管理视图状态 <xref:System.Web.UI.Control.SaveViewState%2A> <xref:System.Web.UI.Control.LoadViewState%2A> 。 有关详细信息，请参阅 [ASP.NET 状态管理概述](https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100))。 有关实现自定义会话状态提供程序的信息，请参阅 [实现会话状态存储提供程序](https://docs.microsoft.com/previous-versions/aspnet/ms178587(v=vs.100))。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.SaveViewState%2A> 自定义 ASP.NET 服务器控件中的方法。 调用此方法时，它将确定控件是否有任何子控件，以及包含对象是否 <xref:System.Web.UI.Page> 为回发的结果。 如果两者都为 true，则它会将 <xref:System.Web.UI.WebControls.Label.Text%2A> <xref:System.Web.UI.WebControls.Label> Web 服务器控件的属性更改为读取 `Custom Control Has Saved State` 。 然后，它将控件的视图状态另存为一个名为的对象数组 `allStates` 。

 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状态管理概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178587(v=vs.100)">实现会话状态存储提供程序</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">包含控件的设计时数据的 <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>为控件设置设计时数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.SetDesignModeState%2A>方法保存控件的设计时数据。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>必须重写此方法以保存控件需要的设计时数据。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetRenderMethodDelegate (renderMethod As RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">传递给委托以便呈现服务器控件所需的信息。</param>
        <summary>分配事件处理程序委托，以将服务器控件及其内容呈现到父控件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法仅为实现目的提供;切勿直接调用它。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为呈现数据的设计时追踪设置跟踪数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">跟踪数据键。</param>
        <param name="traceDataValue">跟踪数据值。</param>
        <summary>使用跟踪数据键和跟踪数据值，为呈现数据的设计时追踪设置跟踪数据。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataKey" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="tracedObject">跟踪对象。</param>
        <param name="traceDataKey">跟踪数据键。</param>
        <param name="traceDataValue">跟踪数据值。</param>
        <summary>使用跟踪对象、跟踪数据键和跟踪数据值，为呈现数据的设计时追踪设置跟踪数据。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取容器信息，该容器在呈现于设计图面上时承载当前控件。</summary>
        <value>一个 <see cref="T:System.ComponentModel.ISite" />，包含承载控件的容器的信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 站点将对象绑定 <xref:System.ComponentModel.Component> 到 <xref:System.ComponentModel.Container> 对象，并启用这两个对象之间的通信。 它还为容器提供了管理其组件的方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该控件为 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控件。</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Filterable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Filterable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于控件的外观。</summary>
        <value>要应用于控件外观的名称。 默认值为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 控件的可用外观包含在主题目录中的一个或多个外观文件中。 <xref:System.Web.UI.Control.SkinID%2A>属性指定要应用于控件的外观。 外观特定于特定控件;不能在不同类型的控件之间共享外观设置。

 如果未设置 <xref:System.Web.UI.Control.SkinID%2A> 属性，控件将使用默认外观（如果已定义）。 例如，如果为控件定义了没有 ID 的外观 <xref:System.Web.UI.WebControls.Image> ，则该外观适用于 <xref:System.Web.UI.WebControls.Image> 未按 ID 显式引用外观且未设置为禁用主题的所有控件。 如果为控件定义了具有 ID 的外观 <xref:System.Web.UI.WebControls.Image> ，则该外观仅适用于 <xref:System.Web.UI.WebControls.Image> 其 <xref:System.Web.UI.Control.SkinID%2A> 属性设置为该 id 的控件。

 如果主题目录中的外观文件不包含具有指定属性的外观，则 <xref:System.Web.UI.Control.SkinID%2A> <xref:System.ArgumentException> 在运行时将引发异常。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经应用了样式表。

- 或 -

<see langword="Page_PreInit" /> 事件已发生。

- 或 -

已将该控件添加到 <see langword="Controls" /> 集合中。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ykzx33wh(v=vs.100)">ASP.NET 主题概述</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IControlBuilderAccessor.ControlBuilder : System.Web.UI.ControlBuilder" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />。</summary>
        <value>为生成控件的 <see cref="T:System.Web.UI.ControlBuilder" />；否则，如果没有使用生成器，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IControlBuilderAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.IControlDesignerAccessor.GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.System.Web.UI.IControlDesignerAccessor.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.System.Web.UI.IControlDesignerAccessor.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />。</summary>
        <returns>控件状态的 <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IControlDesignerAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.IControlDesignerAccessor.SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.System.Web.UI.IControlDesignerAccessor.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.System.Web.UI.IControlDesignerAccessor.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">包含控件的设计时数据的 <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IControlDesignerAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.IControlDesignerAccessor.SetOwnerControl : System.Web.UI.Control -&gt; unit&#xA;override this.System.Web.UI.IControlDesignerAccessor.SetOwnerControl : System.Web.UI.Control -&gt; unit" Usage="control.System.Web.UI.IControlDesignerAccessor.SetOwnerControl owner" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="owner">控件的所有者。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IControlDesignerAccessor> 接口时使用。

 <xref:System.Web.UI.IControlDesignerAccessor>控件设计器使用此接口对控件执行设计时操作。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" /> 设置为当前控件。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IControlDesignerAccessor.UserData : System.Collections.IDictionary" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />。</summary>
        <value>包含控件信息的 <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IControlDesignerAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IDataBindingsAccessor.DataBindings : System.Web.UI.DataBindingCollection" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />。</summary>
        <value>数据绑定集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IDataBindingsAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IDataBindingsAccessor.HasDataBindings : bool" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />。</summary>
        <value>如果控件包含数据绑定逻辑，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IDataBindingsAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IExpressionsAccessor.Expressions : System.Web.UI.ExpressionBindingCollection" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />。</summary>
        <value>一个 <see cref="T:System.Web.UI.ExpressionBindingCollection" />，其中包含表示控件的属性和表达式的 <see cref="T:System.Web.UI.ExpressionBinding" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IExpressionsAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.IExpressionsAccessor.HasExpressions : bool" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />。</summary>
        <value>如果控件通过表达式设置属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IExpressionsAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.IParserAccessor.AddParsedSubObject : obj -&gt; unit&#xA;override this.System.Web.UI.IParserAccessor.AddParsedSubObject : obj -&gt; unit" Usage="control.System.Web.UI.IParserAccessor.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要添加的对象。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员的实现。 它只能在 <xref:System.Web.UI.Control> 实例被强制转换为 <xref:System.Web.UI.IParserAccessor> 接口时使用。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Bindable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含该控件的模板的引用。</summary>
        <value>包含该控件的 <see cref="T:System.Web.UI.TemplateControl" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 当 <xref:System.Web.UI.Control> 实例是控件模板的一部分时， <xref:System.Web.UI.Control.TemplateControl%2A> 属性包含对包含控件的引用。 有关详细信息，请参阅 <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> 文档。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含当前服务器控件的 <see cref="T:System.Web.UI.Page" /> 或 <see cref="T:System.Web.UI.UserControl" /> 的虚拟目录。</summary>
        <value>包含服务器控件的页或用户控件的虚拟目录。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A>属性指定包含当前控件的页面或用户控件的路径。 例如，如果网页位于 `http://www.contoso.com/application/subdirectory` ，则 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 属性将返回 "application/子目录"。

 若要返回应用程序相对虚拟路径 ( "~/subdirectory" ) ，请使用 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> 属性。



## Examples
 下面的示例使用 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 两次属性。 第一次在方法调用中使用它 <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> 来获取控件所在目录的路径。 第二次是在 <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> 方法调用中，获取该目录中包含的所有文件的列表。

 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致跟踪服务器控件的视图状态的更改，以便这些更改可以存储到服务器控件的 <see cref="T:System.Web.UI.StateBag" /> 对象中。 通过 <see cref="P:System.Web.UI.Control.ViewState" /> 属性可访问此对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在 <xref:System.Web.UI.Control.Init> 服务器控件的生命周期中，事件结束时，将自动调用此方法。

 在开发模板化数据绑定控件时调用此方法。 此方法警报 ASP.NET 监视对服务器控件的视图状态所做的更改，这在重写方法时是必需的 <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> 。



## Examples
 下面的示例重写 <xref:System.Web.UI.Control.DataBind%2A> 自定义 ASP.NET 服务器控件中的方法。 首先调用基 <xref:System.Web.UI.Control.OnDataBinding%2A> 方法，然后使用 <xref:System.Web.UI.ControlCollection.Clear%2A> 方法删除所有子控件，并使用 <xref:System.Web.UI.Control.ClearChildViewState%2A> 方法删除这些子控件的任何已保存的视图状态设置。 最后，将 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 属性设置为 `true` 。 然后，控件使用 <xref:System.Web.UI.Control.IsTrackingViewState%2A> 属性来确定是否为控件启用了视图状态更改跟踪。 如果未启用，则 <xref:System.Web.UI.Control.TrackViewState%2A> 调用方法。

 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务器控件的唯一的、以分层形式限定的标识符。</summary>
        <value>服务器控件的完全限定标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此属性与属性的不同之处在于 <xref:System.Web.UI.Control.ID%2A> ， <xref:System.Web.UI.Control.UniqueID%2A> 属性包括服务器控件的命名容器的标识符。 当处理页面请求时，将自动生成此标识符。

 此属性在区分包含在重复的数据绑定服务器控件中的服务器控件时尤为重要。 重复控件（为、、 <xref:System.Web.UI.WebControls.Repeater> 、 <xref:System.Web.UI.WebControls.DataList> <xref:System.Web.UI.WebControls.DetailsView> <xref:System.Web.UI.WebControls.FormView> 和 <xref:System.Web.UI.WebControls.GridView> Web 服务器控件） (或您创建的任何自定义服务器控件，这些控件在数据绑定) 时包含重复功能，用作其子控件的命名容器。 这意味着，它为其子控件创建唯一的命名空间，使其 <xref:System.Web.UI.Control.ID%2A> 属性值不会发生冲突。

 例如，如果 <xref:System.Web.UI.WebControls.Label> 在服务器控件中包括 ASP.NET Web 服务器控件 <xref:System.Web.UI.WebControls.Repeater> ，并将的属性值分配给控件，则将指定 <xref:System.Web.UI.WebControls.Label> <xref:System.Web.UI.Control.ID%2A> `MyLabel` <xref:System.Web.UI.WebControls.Repeater> 为 <xref:System.Web.UI.Control.ID%2A> `MyRepeater` 。 如果将数据绑定到 <xref:System.Web.UI.WebControls.Repeater> <xref:System.Collections.ArrayList> 具有三个条目的对象，则 <xref:System.Web.UI.Control.UniqueID%2A> 服务器控件的每个实例的结果属性为 <xref:System.Web.UI.WebControls.Label> `MyRepeater$ctl00$MyLabel` 、 `MyRepeater$ctl01$MyLabel` 和 `MyRepeater$ctl02$MyLabel` 。



## Examples
 下面的示例创建一个 <xref:System.Collections.ArrayList> 对象，并使用三个文本字符串填充该对象，然后将 <xref:System.Web.UI.WebControls.Repeater> Web 服务器控件绑定到 <xref:System.Collections.ArrayList> 加载该页面时中的数据。 此代码获取 <xref:System.Web.UI.Control.UniqueID%2A> 在数据绑定过程中生成的每个子控件的属性。 此代码生成三个版本的 <xref:System.Web.UI.WebControls.Label> 控件，并将其 `UniqueID` 属性值写入页面。

 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当服务器控件从内存中卸载时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 在卸载实例之前，服务器控件必须在控件生命周期的此阶段中执行任何最终清理，例如关闭文件、数据库连接和丢弃对象。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178472(v=vs.100)">ASP.NET 页生命周期简介</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示控件是否检查来自浏览器的客户端输入是否具有潜在危险值的值。</summary>
        <value>确定控制器是否检查客户输入的值。 值可以包括 <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> 和 <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />。 默认值是 <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />，这意味着控件从其父级获取值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关请求验证的详细信息，请参阅 <xref:System.Web.UnvalidatedRequestValues> 。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取状态信息的字典，这些信息使您可以在同一页的多个请求间保存和还原服务器控件的视图状态。</summary>
        <value>包含服务器控件视图状态信息的 <see cref="T:System.Web.UI.StateBag" /> 类的实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 服务器控件的视图状态是其所有属性值的累计。 为了跨 HTTP 请求保留这些值，ASP.NET 服务器控件使用此属性（类的实例 <xref:System.Web.UI.StateBag> ）来存储属性值。 然后，在处理后续请求时，这些值将作为变量传递给 HTML 隐藏输入元素。 有关保存服务器控件视图状态的详细信息，请参阅 [ASP.NET 状态管理概述](https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100))。

 默认情况下，将为所有服务器控件启用视图状态，但在某些情况下，你将需要禁用该状态。 有关详细信息，请参阅 [ASP.NET 性能概述](https://docs.microsoft.com/previous-versions/aspnet/cc668225(v=vs.100))。

 有关字典以及如何使用它们的信息，请参阅 [集合和数据结构](/dotnet/standard/collections/)。



## Examples
 下面的示例演示如何实现一个 `Text` 属性，该属性存储和检索其控件的属性中的值 <xref:System.Web.UI.Control.ViewState%2A> 。

 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状态管理概述</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.StateBag" /> 对象是否不区分大小写。</summary>
        <value>如果 <see cref="T:System.Web.UI.StateBag" /> 实例不区分大小写，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果创建的自定义服务器控件在不考虑大小写的情况下保存其视图状态，请重写此方法。 当你这样做时，如果多个对象具有相同的键，但大小写不同，则可以存储在 <xref:System.Web.UI.StateBag> 与属性关联的中 <xref:System.Web.UI.Control.ViewState%2A> 。



## Examples
 下面的示例演示如何重写 <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> 要返回的属性 `true` 。

 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Web.UI.Themeable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.Themeable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此控件的视图状态模式。</summary>
        <value>此控件的视图状态模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 即使为页禁用了视图状态，也可以使用 <xref:System.Web.UI.Control.ViewStateMode%2A> 属性为单个控件启用视图状态。 有关视图状态和控件状态的详细信息，请参阅 <xref:System.Web.UI.Control.EnableViewState%2A> 属性。

 若要禁用页面的视图状态，并为该页上的特定控件启用该视图状态，请将 <xref:System.Web.UI.Control.EnableViewState%2A> 页面和控件的属性设置为 `true` ，将 <xref:System.Web.UI.Control.ViewStateMode%2A> 页面的属性设置为 <xref:System.Web.UI.ViewStateMode.Disabled> ，并将控件的 <xref:System.Web.UI.Control.ViewStateMode%2A> 属性设置为 <xref:System.Web.UI.ViewStateMode.Enabled> 。

 页的属性的默认值 <xref:System.Web.UI.Control.ViewStateMode%2A> 为 <xref:System.Web.UI.ViewStateMode.Enabled> 。 <xref:System.Web.UI.Control.ViewStateMode%2A>页面中 Web 服务器控件的属性的默认值为 <xref:System.Web.UI.ViewStateMode.Inherit> 。 因此，如果不在页面或控件级别设置此属性，则属性的值将 <xref:System.Web.UI.Control.EnableViewState%2A> 确定视图状态行为。

 <xref:System.Web.UI.Control.ViewStateMode%2A>仅当属性设置为时，页面或控件的属性才有效果 <xref:System.Web.UI.Control.EnableViewState%2A> `true` 。 如果将 <xref:System.Web.UI.Control.EnableViewState%2A> 属性设置为 `false` ，则即使将属性设置为，也会关闭视图状态 <xref:System.Web.UI.Control.ViewStateMode%2A> <xref:System.Web.UI.ViewStateMode.Enabled> 。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">尝试将此属性设置为 <see cref="T:System.Web.UI.ViewStateMode" /> 枚举值以外的值。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状态管理概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb386448(v%3dvs.100)">ASP.NET 视图状态概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cteh3e77(v=vs.100)">控制视图状态</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Bindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Bindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务器控件是否作为 UI 呈现在页上。</summary>
        <value>如果控件在页上可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果此属性为 `false` ，则不会呈现服务器控件。 组织页面布局时，应考虑到这一点。

> [!NOTE]
>  如果未呈现容器控件，则即使将单个控件的属性设置为，也不会呈现它包含的任何控件 <xref:System.Web.UI.Control.Visible%2A> `true` 。 在这种情况下， `false` <xref:System.Web.UI.Control.Visible%2A> 即使已将属性显式设置为，单独的控件也会返回 `true` 。  (也就是说，如果 `Visible` 父控件的属性设置为 `false` ，则子控件将继承该设置，并且该设置优先于任何本地设置。 ) 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
