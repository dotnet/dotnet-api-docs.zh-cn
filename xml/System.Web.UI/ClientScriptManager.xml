<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8f00b9419cbdf4362b38561cc07fd2f0d4832c4b" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83949362" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>在 Web 应用程序中定义用于管理客户端脚本的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> 类用于管理客户端脚本并将其添加到 Web 应用程序。 可以从 <xref:System.Web.UI.Page> 对象的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 类的引用。  
  
 可以通过在页的 HTML 标记中包含脚本，以声明方式向网页添加客户端脚本。 但是，在某些情况下，需要动态添加客户端脚本。 若要动态添加脚本，请使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法、<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法、<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法或 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 方法，具体取决于你希望何时以及如何添加脚本。 有关详细信息，请参阅[如何：将客户端脚本动态添加到 ASP.NET 网页](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)。  
  
 <xref:System.Web.UI.ClientScriptManager> 类 <xref:System.String> 和 <xref:System.Type>的键唯一标识脚本。 具有相同键和类型的脚本被视为重复的。 使用脚本类型有助于避免混淆不同用户控件中可能正在页面上使用的类似脚本。  
  
 如果需要在不执行回发的情况下从客户端运行服务器代码，则可以使用 <xref:System.Web.UI.ClientScriptManager> 类来调用客户端回调。 这称为对服务器执行带外回拨。 在客户端回调中，客户端脚本函数将异步请求发送到 ASP.NET 网页。 网页运行其正常生命周期的修改版本来处理回调。 使用 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法可获取对客户端函数的引用，在调用该函数时，将启动对服务器事件的客户端回调。 有关详细信息，请参阅[实现无回发的客户端回调](https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100))。  
  
> [!NOTE]
>  脚本回调将无法在不支持文档对象模型（DOM）的旧浏览器中运行，并且它们要求在客户端上启用 ECMAScript。 若要检查浏览器是否支持回调，请使用 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 属性，该属性可通过 ASP.NET 内部 <xref:System.Web.HttpContext.Request%2A> 对象的 <xref:System.Web.HttpRequest.Browser%2A> 属性进行访问。  
  
 使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法和 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> 方法来定义客户端回发事件。 这些方法启用客户端脚本函数（在调用时），以使服务器回发到页面。 客户端回发事件不同于客户端回调，因为网页完成了正常生命周期来处理客户端回发事件。  
  
> [!NOTE]
>  如果使用 <xref:System.Web.UI.WebControls.Button> 控件并且 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 属性设置为 `false`，则可以使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法返回 <xref:System.Web.UI.WebControls.Button> 控件的客户端回发事件。  
  
 <xref:System.Web.UI.WebControls.Button> 控件、<xref:System.Web.UI.WebControls.ImageButton> 控件和 <xref:System.Web.UI.WebControls.LinkButton> 控件的 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> 属性可用于运行客户端脚本。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 在页中定义了两个客户端脚本： `PopupScript`，这会在加载页面时显示一条警报消息，还 `ButtonClickScript`，用于定义 HTML 按钮 `onClick` 事件的客户端处理程序。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/3hc29e2a(v=vs.100)">ASP.NET 网页中的客户端脚本</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本和上下文。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> 方法执行对服务器的带外回调，该服务器是页的正常生命周期的修改版本。 有关详细信息，请参阅[实现无回发的客户端回调](https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100))。  
  
> [!NOTE]
>  当浏览器是 Microsoft Internet Explorer （5.0 版或更高版本）时，脚本回调机制是通过 Microsoft XmlHttp COM 对象实现的，并且需要将浏览器设置为运行 ActiveX 控件。 对于其他浏览器，使用浏览器的本地文档对象模型（DOM）的 XMLHttpRequest。 若要检查浏览器是否支持客户端回调，请使用 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 属性。 若要检查浏览器是否支持 XML over HTTP，请使用 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> 属性。 这两个属性都可以通过内部 ASP.NET <xref:System.Web.HttpContext.Request%2A> 对象的 <xref:System.Web.HttpRequest.Browser%2A> 属性进行访问。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 重载使用 XML over HTTP 来同步执行回调。 在回调方案中同步发送数据时，同步回调会立即返回，而不会阻止浏览器。 在浏览器中，不能同时执行两个同步回调回调。 如果在当前挂起一个同步回调时激发另一个同步回调，则第二个同步回调将取消第一个回调，并且只有第二个回调返回。  
  
 若要以异步方式发送数据，请使用采用 `useAsync` 参数的重载之一，这是控制此行为的布尔值。 在异步方案中，可以有多个挂起的回调;但是，不能保证它们返回的顺序与启动顺序一致。  
  
 此外，<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的此重载不指定任何客户端函数来处理 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法生成的错误条件的情况。 若要指定客户端错误回调处理程序，请使用采用 `clientErrorCallback` 参数的重载之一。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> 方法 `argument` 参数采用一个可选的字符串，并返回一个字符串。 若要传入或接收多个值，请分别连接输入或返回字符串中的值。  
  
> [!NOTE]
>  避免在脚本回调操作期间需要更新的页或控件属性的实现中使用视图状态。 如果属性在页面请求后仍然存在，则可以使用会话状态。  
  
   
  
## Examples  
 下面的代码示例演示如何在递增整数的客户端回调方案中使用 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的两个重载。  
  
 将显示两个回调机制：它们之间的区别在于 `context` 参数的用法。 `ReceiveServerData1` 客户端回调函数是使用 `context` 参数提供的。 与此相反，`ReceiveServerData2` 客户端回调函数在页上的 `<script>` 块中定义。 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法是增加传递给它的值的服务器处理程序，并且 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> 方法以字符串的形式返回递增的值。 如果 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法返回错误，则调用 `ProcessCallBackError` 客户端函数。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本、上下文和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的此重载需要一个 `useAsync` 参数，该参数允许您通过将值设置为 `true`来异步执行客户端回调。 此方法的重载版本不需要 `useAsync` 参数将默认值设置为 `false`。  
  
 有关此方法的详细信息，请参阅重载 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的备注。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" /> 的名称。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的一个参数 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="clientErrorCallback">客户端事件处理程序的名称，该处理程序在服务器端事件处理程序出现错误时接收结果。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的目标、参数、客户端脚本、上下文、错误处理程序和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的此重载采用 `target` string 参数，而不是 <xref:System.Web.UI.Control> 参数。 如果希望回调返回到包含控件的 <xref:System.Web.UI.Control.UniqueID%2A> 的字符串以外的其他内容，请使用此重载。  
  
 此外，<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的此重载需要 `useAsync` 和 `clientErrorCallback` 参数。 `useAsync` 参数允许您通过将值设置为 `true`来异步执行客户端回调。 此方法的重载版本不需要 `useAsync` 参数将默认值设置为 `false`。 `clientErrorCallback` 参数允许您定义在服务器处理程序（<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法）返回错误的情况下调用的客户端函数的名称。 此方法的重载版本不需要 `clientErrorCallback` 参数将值设置为 null。  
  
 有关此方法的详细信息，请参阅重载 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的备注。  
  
   
  
## Examples  
 下面的代码示例演示如何在递增整数的客户端回调方案中使用 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的两个重载。  
  
 将显示两个回调机制：它们之间的区别在于 `context` 参数的用法。 `ReceiveServerData1` 客户端回调函数是使用 `context` 参数提供的。 与此相反，`ReceiveServerData2` 客户端回调函数在页上的 `<script>` 块中定义。 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法是增加传递给它的值的服务器处理程序，并且 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> 方法以字符串的形式返回递增的值。 如果 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法返回错误，则调用客户端函数 `ProcessCallBackError`。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理客户端回调的服务器 <see cref="T:System.Web.UI.Control" />。 该控件必须实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口并提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">从客户端脚本传递给服务器的 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法的参数。</param>
        <param name="clientCallback">一个客户端事件处理程序的名称，该处理程序接收成功的服务器事件的结果。</param>
        <param name="context">启动回调之前在客户端计算的客户端脚本。 脚本的结果传回客户端事件处理程序。</param>
        <param name="clientErrorCallback">客户端事件处理程序的名称，该处理程序在服务器端事件处理程序出现错误时接收结果。</param>
        <param name="useAsync"><see langword="true" /> 表示异步执行回调；<see langword="false" /> 表示同步执行回调。</param>
        <summary>获取一个对客户端函数的引用；调用该函数时，将启动一个对服务器事件的客户端回调。 此重载方法的客户端函数包含指定的控件、参数、客户端脚本、上下文、错误处理程序和布尔值。</summary>
        <returns>调用客户端回调的客户端函数的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的此重载需要 `useAsync` 和 `clientErrorCallback` 参数。 `useAsync` 参数允许您通过将值设置为 `true`来异步执行客户端回调。 此方法的重载版本不需要 `useAsync` 参数将默认值设置为 `false`。 如果服务器处理程序（<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 方法）返回错误，则 `clientErrorCallback` 参数允许您定义调用的客户端函数的名称。 此方法的重载版本不需要 `clientErrorCallback` 参数将值设置为 null。  
  
 有关此方法的详细信息，请参阅重载 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 方法的备注。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未实现 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 接口。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个引用，并将 <see langword="javascript:" /> 追加到引用的开始处，用于在客户端事件中回发到服务器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackClientHyperlink (control As Control, argument As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">处理回发的服务器控件。</param>
        <param name="argument">传递给服务器控件的参数。</param>
        <summary>获取一个引用，并在其开头附加 <see langword="javascript:" />，可以在客户端事件中使用该引用，并将该引用与指定的事件参数一起使用，以便回发到指定控件的服务器。</summary>
        <returns>一个字符串，表示对包含目标控件的 ID 和事件参数的回发函数的 JavaScript 调用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法要求处理回发的控件实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。 若要实现 <xref:System.Web.UI.Page>的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> 方法。 自定义控件 `MyControl`实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。 当单击页面上的 HTML 定位点元素时，将调用自定义控件的 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下面的代码示例与上面的代码示例具有相同的功能，不同之处在于 <xref:System.Web.UI.Page> 类实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackClientHyperlink (control As Control, argument As String, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">处理回发的服务器控件。</param>
        <param name="argument">传递给服务器控件的参数。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册回发事件；<see langword="false" /> 表示不为验证注册回发事件。</param>
        <summary>获取一个引用，并在其开头附加 <see langword="javascript:" />，该引用可用于在客户端事件中回发到指定控件的服务器，回发时使用指定的事件参数和一个指示是否为事件验证注册该回发的布尔值。</summary>
        <returns>一个字符串，表示对包含目标控件的 ID 和事件参数的回发函数的 JavaScript 调用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法要求处理回发的控件实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。 若要实现 <xref:System.Web.UI.Page>的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">定义回发的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 由指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 实例定义的字符串。</summary>
        <returns>一个字符串，当被视为客户端脚本时，它将启动客户端回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现 <xref:System.Web.UI.Page>的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 属性 `false`时，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法可与 <xref:System.Web.UI.WebControls.Button> 控件结合使用。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法返回 <xref:System.Web.UI.WebControls.Button> 控件的客户端回发事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> 参数为 <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (control As Control, argument As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">在服务器上处理回发的服务器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">要传递给处理回发的控件的可选参数字符串。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 该引用字符串由处理回发的指定控件和一个附加事件信息的字符串参数定义。</summary>
        <returns>一个字符串，将其视为客户端脚本时，将启动回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现 <xref:System.Web.UI.Page>的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 属性 `false`时，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法可与 <xref:System.Web.UI.WebControls.Button> 控件结合使用。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法返回 <xref:System.Web.UI.WebControls.Button> 控件的客户端回发事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法。 自定义控件 `MyControl`实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。 当单击页面上的按钮时，将调用自定义控件的 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下面的代码示例与上面的代码示例具有相同的功能，不同之处在于 <xref:System.Web.UI.Page> 类实现 <xref:System.Web.UI.IPostBackEventHandler> 接口。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">定义回发的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册事件引用；否则为 <see langword="false" />。</param>
        <summary>返回一个可以在客户端事件中使用的字符串，以便回发到服务器。 由指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 对象定义的字符串。 可选择为验证注册事件引用。</summary>
        <returns>一个字符串，当被视为客户端脚本时，它将启动客户端回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现 <xref:System.Web.UI.Page> 对象的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 属性 `false`时，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法可与 <xref:System.Web.UI.WebControls.Button> 控件结合使用。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法返回 <xref:System.Web.UI.WebControls.Button> 控件的客户端回发事件。  
  
 如果 `true``registerForEventValidation`，则 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> 方法会调用 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> 方法，以便使用唯一控件 ID （表示生成事件的客户端控件）为验证注册事件引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (control As Control, argument As String, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">在服务器上处理回发的服务器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">传递给 <paramref name="control" /> 的可选参数的字符串。</param>
        <param name="registerForEventValidation"><see langword="true" /> 表示为验证注册事件引用；否则为 <see langword="false" />。</param>
        <summary>返回一个在客户端事件中使用的字符串，以便回发到服务器。 该引用字符串由处理回发的指定控件和一个附加事件信息的字符串参数定义。 可选择为验证注册事件引用。</summary>
        <returns>一个字符串，将其视为客户端脚本时，将启动回发。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要实现 <xref:System.Web.UI.Page>的 <xref:System.Web.UI.IPostBackEventHandler> 接口，请使用指令。  
  
 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 属性 `false`时，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法可与 <xref:System.Web.UI.WebControls.Button> 控件结合使用。 在此方案中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 方法返回 <xref:System.Web.UI.WebControls.Button> 控件的客户端回发事件。  
  
 如果 `registerForEventValidation` 为 true，则 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> 方法将使用唯一控件 ID （表示生成事件的客户端控件）为验证注册事件引用，以便进行验证。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">ASP.NET 页中没有回发的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWebResourceUrl (type As Type, resourceName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">资源的类型。</param>
        <param name="resourceName">程序集中资源的完全限定名称。</param>
        <summary>获取对程序集内资源的 URL 引用。</summary>
        <returns>对资源的 URL 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 方法返回对嵌入在程序集中的资源的 URL 引用。 返回的引用未进行 URL 编码。 资源可以是脚本文件、图像或任何静态文件。 基于将访问资源的对象指定类型。  
  
 用页注册的 Web 资源由其类型和名称唯一标识。 只能向页面注册一个具有给定类型和名称对的资源。 尝试注册已注册的资源不会创建已注册资源的副本。  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 方法与用于访问嵌入在程序集中的资源的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 方法结合使用。 有关在应用程序中使用资源的详细信息，请参阅[ASP.NET 网页资源概述](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 方法。 在此示例中，*类型*参数设置为包含资源的程序集中的类的类型。 `resourceName` 参数是通过包含默认命名空间的资源的完全限定路径指定的。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下面的代码示例演示如何以编程方式应用 <xref:System.Web.UI.WebResourceAttribute> 元数据特性来标记将提供的资源的程序集。 在将默认命名空间设置为 `Samples.AspNet.CS.Controls` 或 `Samples.AspNet.VB.Controls`的类库中，编译以下类，具体取决于所使用的语言。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 此示例需要一个名为 `Script_include.js`的 JavaScript 文件。 .Js 文件是包含 `ClientScriptResourceLabel` 对象的程序集中的嵌入资源。 如果使用的是 Visual Studio，请在类库项目的属性窗口中，将 "**生成操作**" 设置为 "在选择脚本文件时**嵌入的资源**"。 如果要在命令行中编译库，请使用[/resource](/dotnet/csharp/language-reference/compiler-options/resource-compiler-option)开关来嵌入资源。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Web 资源类型为 <see langword="null" />。

- 或 -

Web 资源名称为 <see langword="null" />。  
  
- 或 - 
Web 资源名称长度为零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET 网页资源概述</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/resource （将资源文件嵌入到输出）（ C# 编译器选项）</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的客户端脚本块的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
        <returns>如果注册了客户端脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法之前调用此方法，以避免注册重复脚本。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 客户端脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。  
  
 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 方法的此重载调用重载，该重载采用类型设置为 <xref:System.Web.UI.Page> 对象的 `key` 和 `type` 参数  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的客户端脚本块的类型。</param>
        <param name="key">要搜索的客户端脚本块的键。</param>
        <summary>使用键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本块。</summary>
        <returns>如果注册了客户端脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法之前调用此方法，以避免注册重复脚本。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 客户端脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 基于将访问资源的对象指定类型。 例如，使用 `Page` 实例访问资源时，需要指定 `Page` 类型。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 方法。 请注意，如果已删除用于检查现有客户端脚本块的逻辑，则呈现的页面的 HTML 源代码中将不会有两个重复的客户端脚本，因为 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法会检查是否存在重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的客户端脚本包含的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
        <returns>如果注册了客户端脚本包含，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法之前调用此方法，以避免注册重复脚本。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 客户端脚本包含由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。  
  
 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 方法的此重载调用重载，该重载采用类型设置为 <xref:System.Web.UI.Page> 对象的 `key` 和 `type` 参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的客户端脚本包含的类型。</param>
        <param name="key">要搜索的客户端脚本包含的键。</param>
        <summary>使用键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了客户端脚本包含。</summary>
        <returns>如果注册了客户端脚本包含，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法之前调用此方法，以避免注册重复的客户端脚本包含。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 客户端脚本包含由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 基于将访问资源的对象指定类型。 例如，使用页面实例访问资源时，可以指定 `Page` 类型。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> 方法。 请注意，如果删除了要检查是否存在现有客户端脚本包含的逻辑，则在呈现的页面的 HTML 源代码中将不会有两个重复的客户端脚本，因为 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法会检查是否存在重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 此示例需要一个名为 `Script_include.js`的 JavaScript 文件，其中包含以下内容：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本包含类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了 OnSubmit 语句。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的 OnSubmit 语句的键。</param>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否使用指定键注册了 OnSubmit 语句。</summary>
        <returns>如果已注册 OnSubmit 语句，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 方法之前调用此方法，以避免注册重复的 OnSubmit 语句。 如果语句需要大量的服务器资源来创建，这一点特别重要。  
  
 语句由其键和类型唯一标识。 具有相同键和类型的语句被认为是重复的。  
  
 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 方法的此重载调用重载，该重载采用类型设置为 <xref:System.Web.UI.Page> 对象的 `key` 和 `type` 参数  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的 OnSubmit 语句的类型。</param>
        <param name="key">要搜索的 OnSubmit 语句的键。</param>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否使用指定的键和类型注册了 OnSubmit 语句。</summary>
        <returns>如果已注册 OnSubmit 语句，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 方法之前调用此方法，以避免注册重复的语句。 如果语句需要大量的服务器资源来创建，这一点特别重要。  
  
 语句由其键和类型唯一标识。 具有相同键和类型的语句被认为是重复的。 基于将访问资源的对象指定类型。 例如，使用 `Page` 实例访问资源时，需要指定 `Page` 类型。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 方法。 名为 `OnSubmitScript` 的脚本将注册到 <xref:System.Web.UI.Page>，以便在提交该页的窗体时调用该脚本。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit 语句的类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜索的启动脚本的键。</param>
        <summary>使用指定键确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
        <returns>如果注册了启动脚本，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法之前调用此方法，以避免注册重复脚本。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 启动脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。  
  
 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 方法的此重载调用重载，该重载同时采用字符串 `key` 和类型设置为 <xref:System.Web.UI.Page> 对象的 `type` 参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜索的启动脚本的类型。</param>
        <param name="key">要搜索的启动脚本的键。</param>
        <summary>使用指定键和类型确定 <see cref="T:System.Web.UI.Page" /> 对象是否注册了启动脚本。</summary>
        <returns>如果注册了启动脚本，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法之前调用此方法，以避免注册重复脚本。 如果脚本需要创建大量的服务器资源，则这一点特别重要。  
  
 客户端启动脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 方法。 请注意，如果已删除用于检查现有启动脚本块的逻辑，则呈现的页面的 HTML 源代码中将不会有两个重复的启动脚本，因为 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法会检查是否存在重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该启动脚本类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">要注册的数组名。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>使用数组名称和数组值向 <see cref="T:System.Web.UI.Page" /> 对象注册 JavaScript 数组声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 将检查是否存在与 `arrayName` 参数中指定的名称相同的已注册数组，如果是，则添加在 `arrayValue` 参数中指定的值。 由于基础存储机制基于 <xref:System.Collections.ArrayList>，因此允许重复项。 如果已注册的数组与 `arrayName` 参数的名称不存在，则将创建该数组，并将 `arrayValue` 参数中的值添加到该数组。  
  
 如果需要生成的 JavaScript 数组中的字符串文本，请在 `arrayValue` 参数中包含单引号（'）或转义双引号（\\"）。 `arrayValue` 参数的值应为单个元素。 如果需要将多个值添加到数组，请使用 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 方法进行多次调用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 和 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 方法。 该示例将注册一个数组和一个隐藏值，并定义 `<input>` 按钮的 `OnClick` 事件，以便计算数组的两个值和隐藏值的总和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptBlock (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本的类型。</param>
        <param name="key">要注册的客户端脚本的键。</param>
        <param name="script">要注册的客户端脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 只能向页面注册一个具有给定类型和密钥对的脚本。 尝试注册已经注册的脚本不会创建脚本的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 方法，以确定具有给定键和类型对的客户端脚本是否已注册，并避免不必要地尝试添加脚本。  
  
 在 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法的此重载中，必须确保 `script` 参数中提供的脚本在 `<script>` 元素块中包装。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法将脚本块添加到呈现的页面的顶部。 不保证脚本块按其注册顺序输出。 如果脚本块的顺序很重要，请使用 <xref:System.Text.StringBuilder> 对象将脚本一起收集在单个字符串中，然后将它们全部注册到单个客户端脚本块中。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptBlock (type As Type, key As String, script As String, addScriptTags As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本的类型。</param>
        <param name="key">要注册的客户端脚本的键。</param>
        <param name="script">要注册的客户端脚本文本。</param>
        <param name="addScriptTags">指示是否添加脚本标记的布尔值。</param>
        <summary>使用类型、键、脚本文本和指示是否添加脚本标记的布尔值向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 只能向页面注册一个具有给定类型和密钥对的脚本。 尝试注册已经注册的脚本不会创建脚本的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 方法，以确定是否已注册了具有给定键和类型对的客户端脚本。 这样可以避免不必要地尝试添加脚本。  
  
 在 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法的此重载中，你可以使用 `addScriptTags` 参数指示 `script` 参数中提供的脚本是否使用 `<script>` 元素块进行包装。 将 `addScriptTags` 设置为 `true` 指示将自动添加脚本标记。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法将脚本块添加到呈现的页面的顶部。 不保证脚本块按其注册顺序输出。 如果脚本块的顺序很重要，请使用 <xref:System.Text.StringBuilder> 对象将脚本一起收集在单个字符串中，然后将它们全部注册到单个客户端脚本块中。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 请注意，`addScriptTags` 参数设置为 `true` 因此 `script` 参数不包含开始和结束脚本标记。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本块类型为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本包含。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要注册的客户端脚本包含的键。</param>
        <param name="url">要注册的客户端脚本包含的 URL。</param>
        <summary>使用让客户端能够调用脚本的键和 URL 向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本包含由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 只能向页面注册一个具有给定类型和密钥对的脚本。 尝试注册已经注册的脚本不会创建脚本的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> 方法，以确定是否已注册了具有给定键和类型对的客户端脚本，并避免不必要地尝试添加脚本。  
  
> [!NOTE]
>  若要解析客户端 URL，请使用 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 方法。 此方法使用调用它的 URL 的上下文来解析路径。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法的此重载调用采用 `key`、`URL`和 `type` 参数的重载。  
  
 方法在呈现的页的顶部添加一个脚本块。  
  
   
  
## Examples  
 有关相关信息（包括语法、用法和示例），请参阅 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (type As Type, key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本包含的类型。</param>
        <param name="key">要注册的客户端脚本包含的键。</param>
        <param name="url">要注册的客户端脚本包含的 URL。</param>
        <summary>使用类型、键和 URL 向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本包含。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法的此重载采用*键*和*url*参数来标识脚本，并使用 `type` 参数来指定客户端脚本的标识。 基于将访问资源的对象指定类型。 例如，使用 `Page` 实例访问资源时，需要指定 `Page` 类型。  
  
> [!NOTE]
>  若要解析客户端 URL，请使用 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 方法。 此方法使用调用它的 URL 的上下文来解析路径。  
  
 此方法在呈现的页的顶部添加一个脚本块。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法。 请注意，如果删除了要检查是否存在现有客户端脚本包含的逻辑，则在呈现的页面中仍然不会有重复的客户端脚本，因为 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 方法会检查是否存在重复项。 检查的好处是减少不必要的计算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 此示例需要一个名为 Script_include 的 JavaScript 文件，其中包含以下内容：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端脚本包含类型为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该 URL 为 <see langword="null" />。  
  
- 或 - 
URL 为空。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptResource (type As Type, resourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的客户端脚本资源的类型。</param>
        <param name="resourceName">要注册的客户端脚本资源的名称。</param>
        <summary>使用类型和资源名向 <see cref="T:System.Web.UI.Page" /> 对象注册客户端脚本资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当通过 WebResource HTTP 处理程序从程序集访问已编译的资源时，将使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 方法。 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 方法将脚本注册到 <xref:System.Web.UI.Page> 对象，并阻止重复的脚本。 此方法使用 `<script>` 元素块包装资源 URL 的内容。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下面的代码示例演示如何以编程方式应用 <xref:System.Web.UI.WebResourceAttribute> 元数据特性来标记将提供的资源的程序集。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 此示例需要一个名为 `Script_include.js`的 JavaScript 文件，其中包含以下内容：  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 将 `Script_include.js` 文件编译为包含 `ClientScriptResourceLabel` 类的 `Samples.AspNet.CS.Controls` 程序集中的资源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">客户端资源类型为 <see langword="null" />。

- 或 -

客户端资源名称为 <see langword="null" />。  
  
- 或 - 
客户端资源名称长度为零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">页中包含自定义特性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <summary>将名称/值对注册为给定了控件 ID、特性名和特性值的指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 方法将名称/值对注册为指定 <xref:System.Web.UI.Control>上的自定义（expando）特性。 Expando 特性是从 JavaScript 动态设置的，以保留呈现控件标记的 XHTML 兼容性。 自定义（expando）特性的值中的引号和反斜杠将被转义。 如果你不希望转义引号和反斜杠，请调用 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 重载方法，并将 `encode` 参数设置为 `false`。  
  
 如果找不到 expando 特性或未找到将 expando 特性添加到的控件，则仍将发出客户端脚本，但它不会影响控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">页中包含自定义特性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <param name="encode">指示是否对要注册的自定义特性进行编码布尔值。</param>
        <summary>在给定了控件 ID、特性名称、特性值以及指示是否对特性值进行编码的布尔值的情况下，将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 方法将名称/值对注册为指定 <xref:System.Web.UI.Control>上的自定义（expando）特性。 Expando 特性是从 JavaScript 动态设置的，以保留呈现控件标记的 XHTML 兼容性。 如果需要转义 expando 特性值中的引号和反斜杠，请将 `encode` 参数设置为 `true`。  
  
 如果找不到 expando 特性或未找到将 expando 特性添加到的控件，则仍将发出客户端脚本，但它不会影响控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 方法。 呈现的页中的客户端脚本设置 `<span>` 元素的 `title` 特性。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为验证注册事件引用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <summary>使用唯一控件 ID（表示生成事件的客户端控件）注册事件引用以进行验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息和示例，请参阅 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法和 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 方法来注册用于验证的回调，以及如何验证回调是否源自该页。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" /> 对象指定生成客户端 JavaScript 以启动回发事件的方式。</param>
        <summary>通过 <see cref="T:System.Web.UI.PostBackOptions" /> 为验证注册事件引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息和示例，请参阅 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <param name="argument">随客户端事件传递的事件参数。</param>
        <summary>使用唯一控件 ID 和事件参数（表示生成事件的客户端控件）注册事件引用以进行验证。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法和 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 方法来注册验证回调，并验证回调是否源自该页。 若要改善示例中所示的验证，可以修改验证 `argument` 参数以包含特定于用户的信息，例如标识或角色  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法为验证注册回调。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> 方法之前调用此方法。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">具有验证实现示例的客户端回调</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">要注册的字段的初始值。</param>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册一个隐藏值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 方法在呈现的 HTML 页上创建隐藏的 `<input>` 元素。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 和 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 方法。 该示例将注册一个数组和一个隐藏值，并定义 `<input>` 按钮的 `OnClick` 事件，以便计算数组的两个值和隐藏值的总和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的 OnSubmit 语句的类型。</param>
        <param name="key">要注册的 OnSubmit 语句的键。</param>
        <param name="script">要注册的 OnSubmit 语句的脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册 OnSubmit 语句。 该语句在提交 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 时执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OnSubmit 语句由其键和类型唯一标识。 具有相同键和类型的语句被认为是重复的。 只能向页面注册一个具有给定类型和密钥对的语句。 尝试注册已注册的语句不会创建语句的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 方法，以确定是否已使用给定的键和类型对注册了 OnSubmit 语句，并避免了不必要地尝试添加脚本。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 方法的 `script` 参数可包含多个脚本命令，只要它们正确用分号（;) 分隔。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 添加在提交页面之前执行的脚本，并提供取消提交的机会。  
  
 有关 HTML 窗体和 `OnSubmit` 特性的详细信息，请参阅[万维网联合会（W3C）](https://go.microsoft.com/fwlink/?linkid=37125)网站。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterStartupScript (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要注册的启动脚本的类型。</param>
        <param name="key">要注册的启动脚本的键。</param>
        <param name="script">要注册的启动脚本文本。</param>
        <summary>使用类型、键和脚本文本向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 只能向页面注册一个具有给定类型和密钥对的脚本。 尝试注册已经注册的脚本不会创建脚本的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 方法，以确定具有给定键和类型对的启动脚本是否已注册，并避免不必要地尝试添加脚本。  
  
 在 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法的此重载中，必须确保 `script` 参数中提供的脚本使用 `<script>` 元素块进行包装。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法添加的脚本块在页面完成加载后，在引发页面 <xref:System.Web.UI.Control.OnLoad%2A> 事件之前执行。 不保证脚本块按其注册顺序输出。 如果脚本块的顺序很重要，请使用 <xref:System.Text.StringBuilder> 对象将脚本一起收集在单个字符串中，然后将它们全部注册到单个客户端脚本块中。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法。 请注意，在 `script` 参数中包含开始和结束脚本标记。 若要根据其他参数设置添加脚本标记，请参阅 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterStartupScript (type As Type, key As String, script As String, addScriptTags As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要注册的启动脚本的类型。</param>
        <param name="key">要注册的启动脚本的键。</param>
        <param name="script">要注册的启动脚本文本。</param>
        <param name="addScriptTags">指示是否添加脚本标记的布尔值。</param>
        <summary>使用类型、键、脚本文本和指示是否添加脚本标记的布尔值向 <see cref="T:System.Web.UI.Page" /> 对象注册启动脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启动脚本由其键和类型唯一标识。 具有相同键和类型的脚本被视为重复的。 只能向页面注册一个具有给定类型和密钥对的脚本。 尝试注册已经注册的脚本不会创建脚本的副本。  
  
 调用 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 方法，以确定具有给定键和类型对的启动脚本是否已注册，并避免不必要地尝试添加脚本。  
  
 在 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法的此重载中，你可以使用 `addScriptTags` 参数指示 `script` 参数中提供的脚本是否使用 `<script>` 元素块进行包装。 将 `addScriptTags` 设置为 `true` 指示将自动添加脚本标记。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法添加的脚本块在页面完成加载后，在引发页面 <xref:System.Web.UI.Control.OnLoad%2A> 事件之前执行。 不保证脚本块按其注册顺序输出。 如果脚本块的顺序很重要，请使用 <xref:System.Text.StringBuilder> 对象将脚本一起收集在单个字符串中，然后将它们全部注册到单个客户端脚本块中。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法。 请注意，`addScriptTags` 参数设置为 `false` 以便在 `script` 参数中包含开始和结束脚本标记。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>验证客户端事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <summary>验证使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> 方法为事件验证注册的客户端事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">表示生成事件的客户端控件的唯一 ID。</param>
        <param name="argument">随客户端事件传递的事件参数。</param>
        <summary>验证使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> 方法为事件验证注册的客户端事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 方法和 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 方法来注册验证回调，并验证回调是否源自该页。 若要改善此处显示的验证，可以修改验证 `argument` 参数以包含特定于用户的信息，例如标识或角色  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" /> 为 <see langword="null" /> 或空字符串 ("")。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
