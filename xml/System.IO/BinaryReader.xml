<Type Name="BinaryReader" FullName="System.IO.BinaryReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4e50dd63b1557773db24e64c18617531520de065" /><Meta Name="ms.sourcegitcommit" Value="a8ca33e500a87229bed50d12e09b1347df519648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/09/2020" /><Meta Name="ms.locfileid" Value="91912663" /></Metadata><TypeSignature Language="C#" Value="public class BinaryReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BinaryReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.BinaryReader" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryReader : IDisposable" />
  <TypeSignature Language="F#" Value="type BinaryReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.IO" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.0.0" To="System.Runtime.Extensions" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.1.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.2.0" To="System.Runtime.Extensions" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用特定的编码将基元数据类型读作二进制值。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader>类提供简化从流中读取基元数据类型的方法。 例如，可以使用 <xref:System.IO.BinaryReader.ReadBoolean%2A> 方法将下一个字节作为布尔值读取，并将流中的当前位置提升一个字节。 类包含支持不同数据类型的 read 方法。  
  
 在创建类的新实例时 <xref:System.IO.BinaryReader> ，提供从中读取的流，还可以选择指定编码的类型以及是否在释放对象后保持流处于打开状态 <xref:System.IO.BinaryReader> 。 如果未指定编码类型，将使用 UTF-8。  
  
> [!IMPORTANT]
>  此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/standard/io/how-to-read-and-write-to-a-newly-created-data-file">如何：对新建的数据文件进行读取和写入</related>
    <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
    <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
    <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.BinaryReader" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.IO.BinaryReader : System.IO.Stream -&gt; System.IO.BinaryReader" Usage="new System.IO.BinaryReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">输入流。</param>
        <summary>基于所指定的流和特定的 UTF-8 编码，初始化 <see cref="T:System.IO.BinaryReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该流不支持读取，为<see langword="null" /> 或已关闭。</exception>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.BinaryReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.BinaryReader" Usage="new System.IO.BinaryReader (input, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="input">输入流。</param>
        <param name="encoding">要使用的字符编码。</param>
        <summary>基于所指定的流和特定的字符编码，初始化 <see cref="T:System.IO.BinaryReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该流不支持读取，为<see langword="null" /> 或已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="encoding" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Text.Encoding encoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, encoding As Encoding, leaveOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input, System::Text::Encoding ^ encoding, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.BinaryReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.BinaryReader" Usage="new System.IO.BinaryReader (input, encoding, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">输入流。</param>
        <param name="encoding">要使用的字符编码。</param>
        <param name="leaveOpen">如果在释放 <see cref="T:System.IO.BinaryReader" /> 对象后保持流处于打开状态，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>基于所提供的流和特定的字符编码，初始化 <see cref="T:System.IO.BinaryReader" /> 类的新实例，有选择性的打开流。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">该流不支持读取，为<see langword="null" /> 或已关闭。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="encoding" /> 或 <paramref name="input" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BinaryReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.BinaryReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>公开对 <see cref="T:System.IO.BinaryReader" /> 的基础流的访问。</summary>
        <value>与 <see langword="BinaryReader" /> 关联的基础流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  在读取或使用时使用基础流 `BinaryReader` 可能会导致数据丢失和损坏。 例如，可能会多次读取相同的字节，可能会跳过字节或字符读取。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用类的和类，在内存中读取和写入 `Double` 数据 `BinaryReader` <xref:System.IO.BinaryWriter> <xref:System.IO.MemoryStream> 。 `MemoryStream` 仅读取和写入 `Byte` 数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CPP/rwdouble.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CS/rwdouble.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/VB/rwdouble.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="binaryReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭当前阅读器及基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的这一实现 `Close` 调用 <xref:System.IO.BinaryReader.Dispose%2A> 传递值的方法 `true` 。  
  
 除非显式调用或，否则刷新流将不会刷新其基础编码器 <xref:System.IO.Stream.Flush%2A> `Close` 。 如果设置为，则 <xref:System.IO.StreamWriter.AutoFlush%2A> `true` 表示将数据从缓冲区刷新到流，但不会刷新编码器状态。 这样，编码器就可以将其状态保留 (部分字符) 以便它能够正确地编码下一个字符块。 此方案影响 UTF8 和 UTF7，其中某些字符只能在编码器接收到相邻字符后编码。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放 <see cref="T:System.IO.BinaryReader" /> 类使用的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="binaryReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.IO.BinaryReader" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:System.IO.BinaryReader>。 `Dispose` 方法使 <xref:System.IO.BinaryReader> 处于不可用状态。 调用后 `Dispose` ，必须释放对的所有引用， <xref:System.IO.BinaryReader> 以便垃圾回收器能够回收占用的内存 <xref:System.IO.BinaryReader> 。  
  
 有关详细信息，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged) 和 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.IO.BinaryReader>。 否则，在垃圾回收器调用 <xref:System.IO.BinaryReader> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="binaryReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放 <see cref="T:System.IO.BinaryReader" /> 类使用的非托管资源，并可以选择释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由和调用 `Dispose` <xref:System.Object.Finalize%2A> 。 默认情况下，此方法将 `disposing` 参数指定为 `true` 。 <xref:System.Object.Finalize%2A> 指定 `disposing` 参数为 `false` 。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.BinaryReader> 引用的、由任何托管对象持有的全部资源。 此方法将调用每个被引用对象的 `Dispose` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.BinaryReader.Dispose(System.Boolean)" /> 可以由其他对象多次调用。 重写此方法时，请注意不要引用先前在调用时已释放的对象 <see langword="Dispose" /> 。 有关如何实现此方法的详细信息，请参阅 [实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
有关和的详细 <see cref="M:System.IDisposable.Dispose" /> 信息 <see cref="M:System.Object.Finalize" /> ，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</para></block>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="FillBuffer">
      <MemberSignature Language="C#" Value="protected virtual void FillBuffer (int numBytes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FillBuffer(int32 numBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.FillBuffer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub FillBuffer (numBytes As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void FillBuffer(int numBytes);" />
      <MemberSignature Language="F#" Value="abstract member FillBuffer : int -&gt; unit&#xA;override this.FillBuffer : int -&gt; unit" Usage="binaryReader.FillBuffer numBytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numBytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numBytes">要读取的字节数。</param>
        <summary>用从流中读取的指定字节数填充内部缓冲区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内部缓冲区大小是16与为指定编码返回的值之间较大的值 <xref:System.Text.Encoding.GetMaxByteCount%2A> 。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">在可以读取 <paramref name="numBytes" /> 之前到达了流的末尾。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">请求的 <paramref name="numBytes" /> 大于内部缓冲区大小。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="PeekChar">
      <MemberSignature Language="C#" Value="public virtual int PeekChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 PeekChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.PeekChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PeekChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int PeekChar();" />
      <MemberSignature Language="F#" Value="abstract member PeekChar : unit -&gt; int&#xA;override this.PeekChar : unit -&gt; int" Usage="binaryReader.PeekChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回下一个可用的字符，并且不提升字节或字符的位置。</summary>
        <returns>下一个可用的字符，或者，如果没有可用字符或者流不支持查找时为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果流中应有代理项字符 <xref:System.IO.BinaryReader.ReadChars%2A> ，请使用方法，然后将流设置回原始位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ArgumentException">当前字符无法通过使用为该流选择的 <see cref="T:System.Text.Encoding" /> 解码到内部字符缓冲区中。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从基础流中读取字节，并将流的当前位置前移。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; int&#xA;override this.Read : unit -&gt; int" Usage="binaryReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从基础流中读取字符，并根据所使用的 <see langword="Encoding" /> 和从流中读取的特定字符，提升流的当前位置。</summary>
        <returns>输入流中的下一个字符，如果当前无可用字符则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的示例演示如何使用内存作为后备存储来读取和写入数据。 此示例显示控制台的无效文件路径字符列表。 尽管代码尝试显示所有无效文件路径字符的列表，但并不是所有字符都在可显示的字符集中。 因为无效字符的列表可能因系统而异，所以此代码的输出也可能有所不同。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/CPP/rwreadchar.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/CS/rwreadchar.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/VB/rwreadchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="binaryReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">内存的区域。 当此方法返回时，此区域的内容将替换为从当前源读取的字节。</param>
        <summary>从当前流读取字节序列，并将流中的位置向前移动读取的字节数。</summary>
        <returns>读入缓冲区中的总字节数。 如果很多字节当前不可用，则这可小于在缓冲区中分配的字节数；如果已到达流结尾，则为零 (0)。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;char&gt; -&gt; int&#xA;override this.Read : Span&lt;char&gt; -&gt; int" Usage="binaryReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">字符范围。 当此方法返回时，此区域的内容将替换为从当前源读取的字符。</param>
        <summary>从当前流中读取与提供的缓冲区长度相同的字符数，将其写入提供的缓冲区，然后根据所使用的 <see langword="Encoding" /> 和从流中读取的特定字符，将当前位置前移。</summary>
        <returns>读入缓冲区的总字符数。 如果当前可用的字节没有请求的那么多，此数可能小于所请求的字符数；如果到达了流的末尾，此数可能为零。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int&#xA;override this.Read : byte[] * int * int -&gt; int" Usage="binaryReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">将数据读入的缓冲区。</param>
        <param name="index">缓冲区中的起始点，在该处开始读入缓冲区。</param>
        <param name="count">要读取的字节数。</param>
        <summary>从字节数组中的指定点开始，从流中读取指定的字节数。</summary>
        <returns>读入 <paramref name="buffer" /> 的字节数。 如果可用的字节没有请求的那么多，此数可能小于所请求的字节数；如果到达了流的末尾，此数可能为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读操作失败后不会还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的示例演示如何使用内存作为后备存储来编写二进制数据。 它向控制台显示一条消息，指示是否已正确写入数据。  
  
 [!code-csharp[System.IO.BinaryReaderWriter.RWBytes2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes2/CS/rwreadbytes.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWBytes2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes2/VB/rwreadbytes.vb#1)]  
  
 此示例读取文件的内容，并以16列格式显示每个字节的数字值。 当方法返回零字节时，将检测正在读取的文件的结尾 <xref:System.IO.BinaryReader.Read%2A> 。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source5.cs#6)]
 [!code-vb[System.IO.BinaryReaderWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source5.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。  
  
- 或 - 
要读取的解码字符数大于 <paramref name="count" />。 如果 Unicode 解码器返回回退字符或代理项对，则可能发生此情况。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : char[] * int * int -&gt; int&#xA;override this.Read : char[] * int * int -&gt; int" Usage="binaryReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">将数据读入的缓冲区。</param>
        <param name="index">缓冲区中的起始点，在该处开始读入缓冲区。</param>
        <param name="count">要读取的字符数。</param>
        <summary>从字符数组中的指定点开始，从流中读取指定的字符数。</summary>
        <returns>读入缓冲区的总字符数。 如果当前可用的字节没有请求的那么多，此数可能小于所请求的字符数；如果到达了流的末尾，此数可能为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读操作失败后不会还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的示例演示如何使用内存作为后备存储来读取和写入数据。 此示例显示控制台的无效文件路径字符列表。 尽管代码尝试显示所有无效文件路径字符的列表，但并不是所有字符都在可显示的字符集中。 因为无效字符的列表可能因系统而异，所以此代码的输出也可能有所不同。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/CPP/rwreadchars.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/CS/rwreadchars.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/VB/rwreadchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。  
  
- 或 - 
要读取的解码字符数大于 <paramref name="count" />。 如果 Unicode 解码器返回回退字符或代理项对，则可能发生此情况。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Read7BitEncodedInt">
      <MemberSignature Language="C#" Value="protected internal int Read7BitEncodedInt ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance int32 Read7BitEncodedInt() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read7BitEncodedInt" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function Read7BitEncodedInt () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; int Read7BitEncodedInt();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Read7BitEncodedInt : unit -&gt; int" Usage="binaryReader.Read7BitEncodedInt " />
      <MemberSignature Language="C#" Value="public int Read7BitEncodedInt ();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read7BitEncodedInt() cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Read7BitEncodedInt () As Integer" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read7BitEncodedInt();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C#" Value="protected int Read7BitEncodedInt ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int32 Read7BitEncodedInt() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Function Read7BitEncodedInt () As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; int Read7BitEncodedInt();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以压缩格式读入 32 位整数。</summary>
        <returns>压缩格式的 32 位整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 如果整数适合7位，则此整数仅使用一个字节的空间。 应通过写入整数 <xref:System.IO.BinaryWriter.Write7BitEncodedInt%2A?displayProperty=nameWithType> 。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.FormatException">流已损坏。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Read7BitEncodedInt64">
      <MemberSignature Language="C#" Value="public long Read7BitEncodedInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Read7BitEncodedInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read7BitEncodedInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function Read7BitEncodedInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Read7BitEncodedInt64();" />
      <MemberSignature Language="F#" Value="member this.Read7BitEncodedInt64 : unit -&gt; int64" Usage="binaryReader.Read7BitEncodedInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一次读取一个 7 位数字。</summary>
        <returns>从此二进制读取器实例中读取的数字。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadBoolean : unit -&gt; bool&#xA;override this.ReadBoolean : unit -&gt; bool" Usage="binaryReader.ReadBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 <see langword="Boolean" /> 值，并使该流的当前位置提升 1 个字节。</summary>
        <returns>如果字节为非零则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual byte ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Byte ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; byte&#xA;override this.ReadByte : unit -&gt; byte" Usage="binaryReader.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
        <returns>从当前流中读取的下一个字节。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 由于存在数据格式冲突，因此不建议将此方法用于以下编码：  
  
-   UTF-7  
  
-   ISO-2022-日本  
  
-   ISCII  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用内存作为后备存储来编写二进制数据，然后验证是否已正确写入数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/CPP/rwbyte.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/CS/rwbyte.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/VB/rwbyte.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] ReadBytes (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ReadBytes(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBytes (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ReadBytes(int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadBytes : int -&gt; byte[]&#xA;override this.ReadBytes : int -&gt; byte[]" Usage="binaryReader.ReadBytes count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">要读取的字节数。 此值必须为 0 或非负数字，否则将出现异常。</param>
        <summary>从当前流中读取指定的字节数以写入字节数组中，并将当前位置前移相应的字节数。</summary>
        <returns>包含从基础流中读取的数据的字节数组。 如果到达了流的末尾，则该字节数组可能小于所请求的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读操作失败后不会还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用内存作为后备存储来编写二进制数据，然后验证是否已正确写入数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/CPP/rwbytes.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/CS/rwbytes.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/VB/rwbytes.vb#1)]  
  
 此示例读取文件的内容，并将其作为转储文本显示到控制台。 当 <xref:System.Byte> 从返回的数组的长度为零时，将检测到读取的文件的结尾 <xref:System.IO.BinaryReader.ReadBytes%2A> 。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source5.cs#6)]
 [!code-vb[System.IO.BinaryReaderWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source5.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">要读取的解码字符数大于 <paramref name="count" />。 如果 Unicode 解码器返回回退字符或代理项对，则可能发生此情况。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public virtual char ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadChar () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual char ReadChar();" />
      <MemberSignature Language="F#" Value="abstract member ReadChar : unit -&gt; char&#xA;override this.ReadChar : unit -&gt; char" Usage="binaryReader.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取下一个字符，并根据所使用的 <see langword="Encoding" /> 和从流中读取的特定字符，提升流的当前位置。</summary>
        <returns>从当前流中读取的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该 <xref:System.IO.BinaryReader.ReadChar%2A> 方法尝试读取流中的代理项字符，则会引发异常，并将提升流中的位置。 如果流可查找，则在调用之前将位置还原到原始位置 <xref:System.IO.BinaryReader.ReadChar%2A> ; 但是，如果流为 unseekable，则不会更正位置。 如果流中应有代理项字符，请改用 <xref:System.IO.BinaryReader.ReadChars%2A> 方法。  
  
 由于存在数据格式冲突，因此不建议将此方法用于以下编码：  
  
-   UTF-7  
  
-   ISO-2022-日本  
  
-   ISCII  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用内存作为后备存储来读取和写入数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/CPP/rwchar.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/CS/rwchar.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/VB/rwchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ArgumentException">读取了一个代理项字符。</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public virtual char[] ReadChars (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] ReadChars(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadChars (count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ ReadChars(int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadChars : int -&gt; char[]&#xA;override this.ReadChars : int -&gt; char[]" Usage="binaryReader.ReadChars count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">要读取的字符数。</param>
        <summary>从当前流中读取指定的字符数，并以字符数组的形式返回数据，然后根据所使用的 <see langword="Encoding" /> 和从流中读取的特定字符，将当前位置前移。</summary>
        <returns>包含从基础流中读取的数据的字节数组。 如果到达了流的末尾，则该字符数组可能小于所请求的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读操作失败后不会还原文件位置。  
  
 从网络流中读取时， <xref:System.IO.BinaryReader.ReadChars%2A> 如果 <xref:System.IO.BinaryReader> 使用 Unicode 编码构造，则该方法可能会从流中读取额外的字符。 如果出现这种情况，可以使用 <xref:System.IO.BinaryReader.ReadBytes%2A> 方法读取固定长度的字节数组，然后将该数组传递给 <xref:System.IO.BinaryReader.ReadChars%2A> 方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用内存作为后备存储来读取和写入数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/CPP/rwchars.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/CS/rwchars.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/VB/rwchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">要读取的解码字符数大于 <paramref name="count" />。 如果 Unicode 解码器返回回退字符或代理项对，则可能发生此情况。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 为负数。</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadDecimal : unit -&gt; decimal&#xA;override this.ReadDecimal : unit -&gt; decimal" Usage="binaryReader.ReadDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
        <returns>从当前流中读取的十进制数值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadDouble : unit -&gt; double&#xA;override this.ReadDouble : unit -&gt; double" Usage="binaryReader.ReadDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
        <returns>从当前流中读取的 8 字节浮点值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用类的和类，在内存中读取和写入 `Double` 数据 `BinaryReader` <xref:System.IO.BinaryWriter> <xref:System.IO.MemoryStream> 。 `MemoryStream` 仅读取和写入 `Byte` 数据。  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CPP/rwdouble.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CS/rwdouble.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/VB/rwdouble.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public virtual short ReadInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int16 ReadInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt16" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual short ReadInt16();" />
      <MemberSignature Language="F#" Value="abstract member ReadInt16 : unit -&gt; int16&#xA;override this.ReadInt16 : unit -&gt; int16" Usage="binaryReader.ReadInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
        <returns>从当前流中读取的 2 字节有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public virtual int ReadInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt32" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadInt32();" />
      <MemberSignature Language="F#" Value="abstract member ReadInt32 : unit -&gt; int&#xA;override this.ReadInt32 : unit -&gt; int" Usage="binaryReader.ReadInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
        <returns>从当前流中读取的 2 字节有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 <xref:System.IO.BinaryReader> 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public virtual long ReadInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt64" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadInt64();" />
      <MemberSignature Language="F#" Value="abstract member ReadInt64 : unit -&gt; int64&#xA;override this.ReadInt64 : unit -&gt; int64" Usage="binaryReader.ReadInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置提升 8 个字节。</summary>
        <returns>从当前流中读取的 8 字节有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadSByte">
      <MemberSignature Language="C#" Value="public virtual sbyte ReadSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int8 ReadSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadSByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::SByte ReadSByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadSByte : unit -&gt; sbyte&#xA;override this.ReadSByte : unit -&gt; sbyte" Usage="binaryReader.ReadSByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从此流中读取 1 个有符号字节，并使流的当前位置提升 1 个字节。</summary>
        <returns>从当前流中读取的一个有符号字节。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadSingle">
      <MemberSignature Language="C#" Value="public virtual float ReadSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadSingle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadSingle();" />
      <MemberSignature Language="F#" Value="abstract member ReadSingle : unit -&gt; single&#xA;override this.ReadSingle : unit -&gt; single" Usage="binaryReader.ReadSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
        <returns>从当前流中读取的 4 字节浮点值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="binaryReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取一个字符串。 字符串有长度前缀，一次 7 位地被编码为整数。</summary>
        <returns>正被读取的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
   
  
## Examples  
 下面的代码示例演示如何在文件中存储和检索应用程序设置。  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16">
      <MemberSignature Language="C#" Value="public virtual ushort ReadUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int16 ReadUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt16 ReadUInt16();" />
      <MemberSignature Language="F#" Value="abstract member ReadUInt16 : unit -&gt; uint16&#xA;override this.ReadUInt16 : unit -&gt; uint16" Usage="binaryReader.ReadUInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
        <returns>从该流中读取的 2 字节无符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32">
      <MemberSignature Language="C#" Value="public virtual uint ReadUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int32 ReadUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt32 ReadUInt32();" />
      <MemberSignature Language="F#" Value="abstract member ReadUInt32 : unit -&gt; uint32&#xA;override this.ReadUInt32 : unit -&gt; uint32" Usage="binaryReader.ReadUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
        <returns>从该流中读取的 4 字节无符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64">
      <MemberSignature Language="C#" Value="public virtual ulong ReadUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int64 ReadUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt64 ReadUInt64();" />
      <MemberSignature Language="F#" Value="abstract member ReadUInt64 : unit -&gt; uint64&#xA;override this.ReadUInt64 : unit -&gt; uint64" Usage="binaryReader.ReadUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
        <returns>从该流中读取的 8 字节无符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> 读取失败后不还原文件位置。  
  
 `BinaryReader` 以小字节序格式读取此数据类型。  
  
 有关常见 i/o 任务的列表，请参阅 [常见 I/o 任务](/dotnet/standard/io/common-i-o-tasks)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到达流的末尾。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="binaryReader.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.IO.BinaryReader" /> 使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
调用 <xref:System.IO.BinaryReader.Dispose%2A> 会允许出于其他目的重新分配所使用的资源 <xref:System.IO.BinaryReader> 。 有关的详细信息 <xref:System.IO.BinaryReader.Dispose%2A> ，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。

]]></format>
        </remarks>
        <forInternalUseOnly />
        <related type="Article" href="/dotnet/standard/io/">文件和流 I/O</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">如何：从文件中读取文本</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">如何：将文本写入文件</related>
      </Docs>
    </Member>
  </Members>
</Type>
