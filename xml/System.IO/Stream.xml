<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e7a89b5a6d27ec01dd706d33b9b22672a91eee6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83959059" /></Metadata><TypeSignature Language="C#" Value="public abstract class Stream : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Stream extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Implements IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    interface IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IAsyncDisposable, IDisposable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Stream extends System.MarshalByRefObject implements class System.IAsyncDisposable, class System.IDisposable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IAsyncDisposable, IDisposable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IAsyncDisposable, IDisposable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IAsyncDisposable&#xA;    interface IDisposable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netstandard-2.0" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.IO" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="38849-101">提供字节序列的一般视图。</span><span class="sxs-lookup"><span data-stu-id="38849-101">Provides a generic view of a sequence of bytes.</span></span> <span data-ttu-id="38849-102">这是一个抽象类。</span><span class="sxs-lookup"><span data-stu-id="38849-102">This is an abstract class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-103"><xref:System.IO.Stream> 是所有流的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="38849-103"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span> <span data-ttu-id="38849-104">流是字节序列的抽象，例如文件、输入/输出设备、进程中通信管道或 TCP/IP 套接字。</span><span class="sxs-lookup"><span data-stu-id="38849-104">A stream is an abstraction of a sequence of bytes, such as a file, an input/output device, an inter-process communication pipe, or a TCP/IP socket.</span></span> <span data-ttu-id="38849-105"><xref:System.IO.Stream> 类及其派生类提供这些不同类型的输入和输出的一般视图，并将程序员与操作系统和基础设备的具体详细信息隔离开来。</span><span class="sxs-lookup"><span data-stu-id="38849-105">The <xref:System.IO.Stream> class and its derived classes provide a generic view of these different types of input and output, and isolate the programmer from the specific details of the operating system and the underlying devices.</span></span>  
  
 <span data-ttu-id="38849-106">流涉及三个基本操作：</span><span class="sxs-lookup"><span data-stu-id="38849-106">Streams involve three fundamental operations:</span></span>  
  
-   <span data-ttu-id="38849-107">可以从流中读取。</span><span class="sxs-lookup"><span data-stu-id="38849-107">You can read from streams.</span></span> <span data-ttu-id="38849-108">读取是将数据从流传输到数据结构（如字节数组）中。</span><span class="sxs-lookup"><span data-stu-id="38849-108">Reading is the transfer of data from a stream into a data structure, such as an array of bytes.</span></span>  
  
-   <span data-ttu-id="38849-109">可以写入流。</span><span class="sxs-lookup"><span data-stu-id="38849-109">You can write to streams.</span></span> <span data-ttu-id="38849-110">写入是指将数据从数据结构传输到流中。</span><span class="sxs-lookup"><span data-stu-id="38849-110">Writing is the transfer of data from a data structure into a stream.</span></span>  
  
-   <span data-ttu-id="38849-111">流可以支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-111">Streams can support seeking.</span></span> <span data-ttu-id="38849-112">查找是指查询和修改流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="38849-112">Seeking refers to querying and modifying the current position within a stream.</span></span> <span data-ttu-id="38849-113">查找功能取决于流具有的后备存储的类型。</span><span class="sxs-lookup"><span data-stu-id="38849-113">Seek capability depends on the kind of backing store a stream has.</span></span> <span data-ttu-id="38849-114">例如，网络流没有当前位置的统一概念，因此通常不支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-114">For example, network streams have no unified concept of a current position, and therefore typically do not support seeking.</span></span>  
  
 <span data-ttu-id="38849-115">继承自 <xref:System.IO.Stream> 的一些更常用的流 <xref:System.IO.FileStream>和 <xref:System.IO.MemoryStream>。</span><span class="sxs-lookup"><span data-stu-id="38849-115">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 <span data-ttu-id="38849-116">根据基础数据源或存储库，流可能只支持其中一些功能。</span><span class="sxs-lookup"><span data-stu-id="38849-116">Depending on the underlying data source or repository, streams might support only some of these capabilities.</span></span> <span data-ttu-id="38849-117">您可以使用 <xref:System.IO.Stream> 类的 <xref:System.IO.Stream.CanRead%2A>、<xref:System.IO.Stream.CanWrite%2A>和 <xref:System.IO.Stream.CanSeek%2A> 属性，查询流的功能。</span><span class="sxs-lookup"><span data-stu-id="38849-117">You can query a stream for its capabilities by using the <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, and <xref:System.IO.Stream.CanSeek%2A> properties of the <xref:System.IO.Stream> class.</span></span>  
  
 <span data-ttu-id="38849-118"><xref:System.IO.Stream.Read%2A> 和 <xref:System.IO.Stream.Write%2A> 方法使用各种格式读取和写入数据。</span><span class="sxs-lookup"><span data-stu-id="38849-118">The <xref:System.IO.Stream.Read%2A> and <xref:System.IO.Stream.Write%2A> methods read and write data in a variety of formats.</span></span> <span data-ttu-id="38849-119">对于支持查找的流，请使用 <xref:System.IO.Stream.Seek%2A> 和 <xref:System.IO.Stream.SetLength%2A> 方法以及 <xref:System.IO.Stream.Position%2A> 和 <xref:System.IO.Stream.Length%2A> 属性来查询和修改流的当前位置和长度。</span><span class="sxs-lookup"><span data-stu-id="38849-119">For streams that support seeking, use the <xref:System.IO.Stream.Seek%2A> and <xref:System.IO.Stream.SetLength%2A> methods and the <xref:System.IO.Stream.Position%2A> and <xref:System.IO.Stream.Length%2A> properties to query and modify the current position and length of a stream.</span></span>  
  
 <span data-ttu-id="38849-120">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="38849-120">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="38849-121">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="38849-121">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="38849-122">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-122">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="38849-123">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="38849-123">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="38849-124">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="38849-124">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="38849-125">释放 <xref:System.IO.Stream> 对象将刷新所有缓冲数据，并在本质上为您调用 <xref:System.IO.Stream.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-125">Disposing a <xref:System.IO.Stream> object flushes any buffered data, and essentially calls the <xref:System.IO.Stream.Flush%2A> method for you.</span></span> <span data-ttu-id="38849-126"><xref:System.IO.Stream.Dispose%2A> 还会释放操作系统资源（如文件句柄、网络连接或用于任何内部缓冲的内存）。</span><span class="sxs-lookup"><span data-stu-id="38849-126"><xref:System.IO.Stream.Dispose%2A> also releases operating system resources such as file handles, network connections, or memory used for any internal buffering.</span></span> <span data-ttu-id="38849-127"><xref:System.IO.BufferedStream> 类提供了围绕另一个流包装缓冲流以提高读写性能的功能。</span><span class="sxs-lookup"><span data-stu-id="38849-127">The <xref:System.IO.BufferedStream> class provides the capability of wrapping a buffered stream around another stream in order to improve read and write performance.</span></span>  
  
 <span data-ttu-id="38849-128">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，<xref:System.IO.Stream> 类包括异步方法来简化异步操作。</span><span class="sxs-lookup"><span data-stu-id="38849-128">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.IO.Stream> class includes async methods to simplify asynchronous operations.</span></span> <span data-ttu-id="38849-129">异步方法在其名称中包含 `Async`，如 <xref:System.IO.Stream.ReadAsync%2A>、<xref:System.IO.Stream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.Stream.FlushAsync%2A>。</span><span class="sxs-lookup"><span data-stu-id="38849-129">An async method contains `Async` in its name, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>.</span></span> <span data-ttu-id="38849-130">利用这些方法，您可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-130">These methods enable you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-131">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-131">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-132">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-132">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-133">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用程序中使用时，<xref:System.IO.Stream> 包含两个扩展方法： <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> 和 <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>。</span><span class="sxs-lookup"><span data-stu-id="38849-133">When used in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> includes two extension methods: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span></span> <span data-ttu-id="38849-134">这些方法将 <xref:System.IO.Stream> 对象转换为 [!INCLUDE[wrt](~/includes/wrt-md.md)]中的流。</span><span class="sxs-lookup"><span data-stu-id="38849-134">These methods convert a <xref:System.IO.Stream> object to a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)].</span></span> <span data-ttu-id="38849-135">还可以通过使用 <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> 和 <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> 方法，将 [!INCLUDE[wrt](~/includes/wrt-md.md)] 中的流转换为 <xref:System.IO.Stream> 的对象。</span><span class="sxs-lookup"><span data-stu-id="38849-135">You can also convert a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)] to a <xref:System.IO.Stream> object by using the <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> methods.</span></span> <span data-ttu-id="38849-136">有关详细信息，请参阅[如何：在 .NET Framework 流和 Windows 运行时流之间转换](/dotnet/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams)</span><span class="sxs-lookup"><span data-stu-id="38849-136">For more information, see [How to: Convert Between .NET Framework Streams and Windows Runtime Streams](/dotnet/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams)</span></span>  
  
 <span data-ttu-id="38849-137">某些流实现执行基础数据的本地缓冲以提高性能。</span><span class="sxs-lookup"><span data-stu-id="38849-137">Some stream implementations perform local buffering of the underlying data to improve performance.</span></span> <span data-ttu-id="38849-138">对于此类流，可以使用 <xref:System.IO.Stream.Flush%2A> 或 <xref:System.IO.Stream.FlushAsync%2A> 方法清除任何内部缓冲区，并确保所有数据都已写入基础数据源或存储库。</span><span class="sxs-lookup"><span data-stu-id="38849-138">For such streams, you can use the <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.FlushAsync%2A> method to clear any internal buffers and ensure that all data has been written to the underlying data source or repository.</span></span>  
  
 <span data-ttu-id="38849-139">如果需要一个没有后备存储的流（也称为 "位桶"），请使用 "<xref:System.IO.Stream.Null>" 字段检索为此目的而设计的流的实例。</span><span class="sxs-lookup"><span data-stu-id="38849-139">If you need a stream with no backing store (also known as a bit bucket), use the <xref:System.IO.Stream.Null> field to retrieve an instance of a stream that is designed for this purpose.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-140">下面的示例演示如何使用两个 <xref:System.IO.FileStream> 对象将文件从一个目录异步复制到另一个目录。</span><span class="sxs-lookup"><span data-stu-id="38849-140">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another directory.</span></span> <span data-ttu-id="38849-141"><xref:System.IO.FileStream> 类是从 <xref:System.IO.Stream> 类派生的。</span><span class="sxs-lookup"><span data-stu-id="38849-141">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span> <span data-ttu-id="38849-142">需要注意 <xref:System.Web.UI.WebControls.Button.Click> 控件的 <xref:System.Windows.Controls.Button> 事件处理程序具有 `async` 修饰符标记，因为它调用异步方法。</span><span class="sxs-lookup"><span data-stu-id="38849-142">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="38849-143">在实现 <see cref="T:System.IO.Stream" />的派生类时，必须提供 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> 和 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> 方法的实现。</span><span class="sxs-lookup"><span data-stu-id="38849-143">When you implement a derived class of <see cref="T:System.IO.Stream" />, you must provide implementations for the <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> methods.</span></span> <span data-ttu-id="38849-144"><see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />、<see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />和 <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> 的异步方法在其实现中使用同步方法 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> 和 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="38849-144">The asynchronous methods <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, and <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> use the synchronous methods <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> in their implementations.</span></span> <span data-ttu-id="38849-145">因此，<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> 和 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> 的实现将与异步方法一起正常工作。</span><span class="sxs-lookup"><span data-stu-id="38849-145">Therefore, your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> will work correctly with the asynchronous methods.</span></span> <span data-ttu-id="38849-146"><see cref="M:System.IO.Stream.ReadByte" /> 和 <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> 的默认实现创建新的单元素字节数组，然后调用 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> 和 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />的实现。</span><span class="sxs-lookup"><span data-stu-id="38849-146">The default implementations of <see cref="M:System.IO.Stream.ReadByte" /> and <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> create a new single-element byte array, and then call your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="38849-147">当从 <see cref="T:System.IO.Stream" />派生时，建议你重写这些方法，以便访问内部缓冲区（如果有），以显著提高性能。</span><span class="sxs-lookup"><span data-stu-id="38849-147">When you derive from <see cref="T:System.IO.Stream" />, we recommend that you override these methods to access your internal buffer, if you have one, for substantially better performance.</span></span> <span data-ttu-id="38849-148">还必须提供 <see cref="P:System.IO.Stream.CanRead" />、<see cref="P:System.IO.Stream.CanSeek" />、<see cref="P:System.IO.Stream.CanWrite" />、<see cref="M:System.IO.Stream.Flush" />、<see cref="P:System.IO.Stream.Length" />、<see cref="P:System.IO.Stream.Position" />、<see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />和 <see cref="M:System.IO.Stream.SetLength(System.Int64)" />的实现。</span><span class="sxs-lookup"><span data-stu-id="38849-148">You must also provide implementations of <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, and <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.</span></span>  
  
<span data-ttu-id="38849-149">请不要重写 <see cref="M:System.IO.Stream.Close" /> 方法，而是将所有 <see cref="T:System.IO.Stream" /> 清理逻辑放在 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> 方法中。</span><span class="sxs-lookup"><span data-stu-id="38849-149">Do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all the <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="38849-150">有关详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="38849-150">For more information, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span></para></block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
    <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-151">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-151">File and Stream I/O</span></span></related>
    <related type="Article" href="/dotnet/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams"><span data-ttu-id="38849-152">如何：在 .NET Framework 流与 Windows 运行时流之间转换</span><span class="sxs-lookup"><span data-stu-id="38849-152">How to: Convert Between .NET Framework Streams and Windows Runtime Streams</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-153">初始化 <see cref="T:System.IO.Stream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="38849-153">Initializes a new instance of the <see cref="T:System.IO.Stream" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-154"><xref:System.IO.Stream> 是所有流的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="38849-154"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span>  
  
 <span data-ttu-id="38849-155">继承自 <xref:System.IO.Stream> 的一些更常用的流 <xref:System.IO.FileStream>和 <xref:System.IO.MemoryStream>。</span><span class="sxs-lookup"><span data-stu-id="38849-155">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-156">要将数据读入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-156">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-157"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="38849-157">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-158">要读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-158">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="38849-159">可选的异步回调，将在读取完成时调用。</span><span class="sxs-lookup"><span data-stu-id="38849-159">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="38849-160">用户提供的对象，用于将此特定异步读取请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="38849-160">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="38849-161">开始执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="38849-161">Begins an asynchronous read operation.</span></span> <span data-ttu-id="38849-162">（请考虑改用 <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />。）</span><span class="sxs-lookup"><span data-stu-id="38849-162">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="38849-163">表示异步读取的 <see cref="T:System.IAsyncResult" />（可能仍处于挂起状态）。</span><span class="sxs-lookup"><span data-stu-id="38849-163">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-164">在 .NET Framework 4 和更早的版本中，您必须使用 <xref:System.IO.Stream.BeginRead%2A> 和 <xref:System.IO.Stream.EndRead%2A> 之类的方法来实现异步 I/O 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-164">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="38849-165">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.Stream.ReadAsync%2A>、<xref:System.IO.Stream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.Stream.FlushAsync%2A>）可帮助你更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-165">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="38849-166">流上 `BeginRead` 的默认实现同步调用 <xref:System.IO.Stream.Read%2A> 方法，这意味着 `Read` 可能会在某些流上阻塞。</span><span class="sxs-lookup"><span data-stu-id="38849-166">The default implementation of `BeginRead` on a stream calls the <xref:System.IO.Stream.Read%2A> method synchronously, which means that `Read` might block on some streams.</span></span> <span data-ttu-id="38849-167">但是，如果实例已异步打开，则类的实例（如 `FileStream` 和 `NetworkStream` 完全支持异步操作。</span><span class="sxs-lookup"><span data-stu-id="38849-167">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="38849-168">因此，对 `BeginRead` 的调用不会在这些流上阻塞。</span><span class="sxs-lookup"><span data-stu-id="38849-168">Therefore, calls to `BeginRead` will not block on those streams.</span></span> <span data-ttu-id="38849-169">例如，可以重写 `BeginRead` （例如，使用 async 委托）来提供异步行为。</span><span class="sxs-lookup"><span data-stu-id="38849-169">You can override `BeginRead` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="38849-170">将 `IAsyncResult` 返回值传递到流的 <xref:System.IO.Stream.EndRead%2A> 方法，以确定读取的字节数，以及释放用于读取的操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="38849-170">Pass the `IAsyncResult` return value to the <xref:System.IO.Stream.EndRead%2A> method of the stream to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="38849-171">对于每次调用 <xref:System.IO.Stream.BeginRead%2A>，都必须调用 <xref:System.IO.Stream.EndRead%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="38849-171"><xref:System.IO.Stream.EndRead%2A> must be called once for every call to <xref:System.IO.Stream.BeginRead%2A>.</span></span> <span data-ttu-id="38849-172">为此，可以使用 `BeginRead` 调用的相同代码，也可以在传递给 `BeginRead`的回调中执行此操作。</span><span class="sxs-lookup"><span data-stu-id="38849-172">You can do this either by using the same code that called `BeginRead` or in a callback passed to `BeginRead`.</span></span>  
  
 <span data-ttu-id="38849-173">发出异步读取或写入操作时，将更新流中的当前位置，而不是在 i/o 操作完成时进行更新。</span><span class="sxs-lookup"><span data-stu-id="38849-173">The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</span></span>  
  
 <span data-ttu-id="38849-174">多个同时进行的异步请求会导致不确定请求完成顺序。</span><span class="sxs-lookup"><span data-stu-id="38849-174">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="38849-175">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-175">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="38849-176">如果流已关闭或传递的参数无效，则会立即从 `BeginRead`引发异常。</span><span class="sxs-lookup"><span data-stu-id="38849-176">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginRead`.</span></span> <span data-ttu-id="38849-177">在异步读取请求期间发生的错误（例如，i/o 请求过程中的磁盘故障）会在线程池线程上发生，并在调用 `EndRead`时引发异常。</span><span class="sxs-lookup"><span data-stu-id="38849-177">Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndRead`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-178">尝试的异步读取超过了流的结尾，或者发生了磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="38849-178">Attempted an asynchronous read past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-179">一个或多个自变量无效。</span><span class="sxs-lookup"><span data-stu-id="38849-179">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-180">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-180">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-181">当前 <see langword="Stream" /> 实现不支持读取操作。</span><span class="sxs-lookup"><span data-stu-id="38849-181">The current <see langword="Stream" /> implementation does not support the read operation.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-182">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-182">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-183">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-183">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-184">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-184">How to: Write Text to a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o"><span data-ttu-id="38849-185">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-185">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-186">要从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-186">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-187"><paramref name="buffer" /> 中的字节偏移量，从此处开始写入。</span><span class="sxs-lookup"><span data-stu-id="38849-187">The byte offset in <paramref name="buffer" /> from which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="38849-188">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-188">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="38849-189">可选的异步回调，将在写入完成时调用。</span><span class="sxs-lookup"><span data-stu-id="38849-189">An optional asynchronous callback, to be called when the write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="38849-190">用户提供的对象，用于将此特定异步写入请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="38849-190">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="38849-191">开始执行异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="38849-191">Begins an asynchronous write operation.</span></span> <span data-ttu-id="38849-192">（请考虑改用 <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />。）</span><span class="sxs-lookup"><span data-stu-id="38849-192">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="38849-193">表示异步写入的 <see langword="IAsyncResult" />（可能仍处于挂起状态）。</span><span class="sxs-lookup"><span data-stu-id="38849-193">An <see langword="IAsyncResult" /> that represents the asynchronous write, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-194">在 .NET Framework 4 和更早的版本中，您必须使用 <xref:System.IO.Stream.BeginWrite%2A> 和 <xref:System.IO.Stream.EndWrite%2A> 之类的方法来实现异步 I/O 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-194">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="38849-195">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.Stream.ReadAsync%2A>、<xref:System.IO.Stream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.Stream.FlushAsync%2A>）可帮助你更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-195">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="38849-196">流上 `BeginWrite` 的默认实现同步调用 <xref:System.IO.Stream.Write%2A> 方法，这意味着 `Write` 可能会在某些流上阻塞。</span><span class="sxs-lookup"><span data-stu-id="38849-196">The default implementation of `BeginWrite` on a stream calls the <xref:System.IO.Stream.Write%2A> method synchronously, which means that `Write` might block on some streams.</span></span> <span data-ttu-id="38849-197">但是，如果实例已异步打开，则类的实例（如 `FileStream` 和 `NetworkStream` 完全支持异步操作。</span><span class="sxs-lookup"><span data-stu-id="38849-197">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="38849-198">因此，对 `BeginWrite` 的调用不会在这些流上阻塞。</span><span class="sxs-lookup"><span data-stu-id="38849-198">Therefore, calls to `BeginWrite` will not block on those streams.</span></span> <span data-ttu-id="38849-199">例如，可以重写 `BeginWrite` （例如，使用 async 委托）来提供异步行为。</span><span class="sxs-lookup"><span data-stu-id="38849-199">You can override `BeginWrite` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="38849-200">将当前方法返回的 `IAsyncResult` 传递到 <xref:System.IO.Stream.EndWrite%2A>，以确保写入完成，并适当地释放资源。</span><span class="sxs-lookup"><span data-stu-id="38849-200">Pass the `IAsyncResult` returned by the current method to <xref:System.IO.Stream.EndWrite%2A> to ensure that the write completes and frees resources appropriately.</span></span> <span data-ttu-id="38849-201">对于每次调用 <xref:System.IO.Stream.BeginWrite%2A>，都必须调用 <xref:System.IO.Stream.EndWrite%2A> 一次。</span><span class="sxs-lookup"><span data-stu-id="38849-201"><xref:System.IO.Stream.EndWrite%2A> must be called once for every call to <xref:System.IO.Stream.BeginWrite%2A>.</span></span> <span data-ttu-id="38849-202">为此，可以使用 `BeginWrite` 调用的相同代码，也可以在传递给 `BeginWrite`的回调中执行此操作。</span><span class="sxs-lookup"><span data-stu-id="38849-202">You can do this either by using the same code that called `BeginWrite` or in a callback passed to `BeginWrite`.</span></span> <span data-ttu-id="38849-203">如果在异步写入过程中发生错误，则在使用此方法返回的 `IAsyncResult` 调用 `EndWrite` 之前，将不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="38849-203">If an error occurs during an asynchronous write, an exception will not be thrown until `EndWrite` is called with the `IAsyncResult` returned by this method.</span></span>  
  
 <span data-ttu-id="38849-204">如果流可写，则在流的末尾写入会扩展流。</span><span class="sxs-lookup"><span data-stu-id="38849-204">If a stream is writable, writing at the end of the stream expands the stream.</span></span>  
  
 <span data-ttu-id="38849-205">发出异步读取或写入操作时，将更新流中的当前位置，而不是在 i/o 操作完成时进行更新。</span><span class="sxs-lookup"><span data-stu-id="38849-205">The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.</span></span> <span data-ttu-id="38849-206">多个同时进行的异步请求会导致不确定请求完成顺序。</span><span class="sxs-lookup"><span data-stu-id="38849-206">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="38849-207">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-207">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="38849-208">如果流已关闭或传递的参数无效，则会立即从 `BeginWrite`引发异常。</span><span class="sxs-lookup"><span data-stu-id="38849-208">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginWrite`.</span></span> <span data-ttu-id="38849-209">在异步写入请求期间发生的错误（例如，i/o 请求过程中的磁盘故障）会在线程池线程上发生，并在调用 `EndWrite`时引发异常。</span><span class="sxs-lookup"><span data-stu-id="38849-209">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-210">尝试进行的异步写入超过了流的结尾，或者发生了磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="38849-210">Attempted an asynchronous write past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-211">一个或多个自变量无效。</span><span class="sxs-lookup"><span data-stu-id="38849-211">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-212">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-212">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-213">当前 <see langword="Stream" /> 实现不支持写入操作。</span><span class="sxs-lookup"><span data-stu-id="38849-213">The current <see langword="Stream" /> implementation does not support the write operation.</span></span></exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-214">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-214">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-215">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-215">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-216">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-216">How to: Write Text to a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o"><span data-ttu-id="38849-217">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-217">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-218">当在派生类中重写时，获取指示当前流是否支持读取的值。</span><span class="sxs-lookup"><span data-stu-id="38849-218">When overridden in a derived class, gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="38849-219">如果流支持读取，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38849-219"><see langword="true" /> if the stream supports reading; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-220">如果从 <xref:System.IO.Stream> 派生的类不支持读取，则对 <xref:System.IO.Stream.Read%2A>、<xref:System.IO.Stream.ReadByte%2A>和 <xref:System.IO.Stream.BeginRead%2A> 方法的调用将引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="38849-220">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, and <xref:System.IO.Stream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="38849-221">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="38849-221">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-222">下面是使用 `CanRead` 属性的示例。</span><span class="sxs-lookup"><span data-stu-id="38849-222">The following is an example of using the `CanRead` property.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-223">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-223">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-224">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-224">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-225">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-225">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-226">当在派生类中重写时，获取指示当前流是否支持查找功能的值。</span><span class="sxs-lookup"><span data-stu-id="38849-226">When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="38849-227">如果流支持查找，为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38849-227"><see langword="true" /> if the stream supports seeking; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-228">如果从 <xref:System.IO.Stream> 派生的类不支持查找，则调用 <xref:System.IO.Stream.Length%2A>、<xref:System.IO.Stream.SetLength%2A>、<xref:System.IO.Stream.Position%2A>和 <xref:System.IO.Stream.Seek%2A> 引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="38849-228">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, and <xref:System.IO.Stream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="38849-229">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="38849-229">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-230">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-230">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-231">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-231">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-232">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-232">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-233">获取一个值，该值确定当前流是否可以超时。</span><span class="sxs-lookup"><span data-stu-id="38849-233">Gets a value that determines whether the current stream can time out.</span></span></summary>
        <value><span data-ttu-id="38849-234">一个确定当前流是否可以超时的值。</span><span class="sxs-lookup"><span data-stu-id="38849-234">A value that determines whether the current stream can time out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-235">
          <xref:System.IO.Stream.CanTimeout%2A> 属性始终返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="38849-235">The <xref:System.IO.Stream.CanTimeout%2A> property always returns `false`.</span></span> <span data-ttu-id="38849-236">某些流实现需要不同的行为，如 <xref:System.Net.Sockets.NetworkStream>，如果网络连接中断或丢失，会超时。</span><span class="sxs-lookup"><span data-stu-id="38849-236">Some stream implementations require different behavior, such as <xref:System.Net.Sockets.NetworkStream>, which times out if network connectivity is interrupted or lost.</span></span> <span data-ttu-id="38849-237">如果要实现的流必须能够超时，则应重写此属性以返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="38849-237">If you are implementing a stream that must be able to time out, this property should be overridden to return `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-238">当在派生类中重写时，获取指示当前流是否支持写入功能的值。</span><span class="sxs-lookup"><span data-stu-id="38849-238">When overridden in a derived class, gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="38849-239">如果流支持写入，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38849-239"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-240">如果从 <xref:System.IO.Stream> 派生的类不支持写入，则对 <xref:System.IO.Stream.Write%2A>、<xref:System.IO.Stream.BeginWrite%2A>或 <xref:System.IO.Stream.WriteByte%2A> 的调用将引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="38849-240">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="38849-241">在这种情况下，<xref:System.IO.Stream.Flush%2A> 通常实现为空方法以确保与其他 <xref:System.IO.Stream> 类型完全兼容，因为它可以刷新只读流。</span><span class="sxs-lookup"><span data-stu-id="38849-241">In such cases, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>
  
 <span data-ttu-id="38849-242">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="38849-242">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-243">下面是使用 `CanWrite` 属性的示例。</span><span class="sxs-lookup"><span data-stu-id="38849-243">The following is an example of using the `CanWrite` property.</span></span>  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-244">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-244">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-245">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-246">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-247">关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）。</span><span class="sxs-lookup"><span data-stu-id="38849-247">Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</span></span> <span data-ttu-id="38849-248">不直接调用此方法，而应确保流得以正确释放。</span><span class="sxs-lookup"><span data-stu-id="38849-248">Instead of calling this method, ensure that the stream is properly disposed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-249">此方法调用 <xref:System.IO.Stream.Dispose%2A>，指定 `true` 以释放所有资源。</span><span class="sxs-lookup"><span data-stu-id="38849-249">This method calls <xref:System.IO.Stream.Dispose%2A>, specifying `true` to release all resources.</span></span> <span data-ttu-id="38849-250">不需要专门调用 <xref:System.IO.Stream.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-250">You do not have to specifically call the <xref:System.IO.Stream.Close%2A> method.</span></span> <span data-ttu-id="38849-251">请确保每个 <xref:System.IO.Stream> 对象均已正确释放。</span><span class="sxs-lookup"><span data-stu-id="38849-251">Instead, ensure that every <xref:System.IO.Stream> object is properly disposed.</span></span> <span data-ttu-id="38849-252">可以在 `using` 块中（或在 Visual Basic 中 `Using` 块中）声明 <xref:System.IO.Stream> 对象，以确保释放流及其所有资源，或者可以显式调用 <xref:System.IO.Stream.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-252">You can declare <xref:System.IO.Stream> objects within a `using` block (or `Using` block in Visual Basic) to ensure that the stream and all of its resources are disposed, or you can explicitly call the <xref:System.IO.Stream.Dispose%2A> method.</span></span>  
  
 <span data-ttu-id="38849-253">除非显式调用 <xref:System.IO.Stream.Flush%2A> 或 `Close`的实现，否则刷新流将不会刷新其基础编码器。</span><span class="sxs-lookup"><span data-stu-id="38849-253">Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of <xref:System.IO.Stream.Flush%2A> or `Close`.</span></span> <span data-ttu-id="38849-254">将 <xref:System.IO.StreamWriter.AutoFlush%2A> 设置为 `true` 表示将数据从缓冲区刷新到流，但编码器状态不会被刷新。</span><span class="sxs-lookup"><span data-stu-id="38849-254">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="38849-255">这允许编码器保留其状态（部分字符），以使其能够正确编码下一个字符块。</span><span class="sxs-lookup"><span data-stu-id="38849-255">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="38849-256">此方案影响 UTF8 和 UTF7，其中某些字符只能在编码器接收到相邻字符后进行编码。</span><span class="sxs-lookup"><span data-stu-id="38849-256">This scenario affects UTF8 and UTF7 where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="38849-257">在流关闭之后尝试操作流可能会引发 <xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="38849-257">Attempts to manipulate the stream after the stream has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-258">在派生类中，不要重写 <see cref="M:System.IO.Stream.Close" /> 方法，而是在 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> 方法中放置所有 <see langword="Stream" /> 的清理逻辑。</span><span class="sxs-lookup"><span data-stu-id="38849-258">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the <see langword="Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="38849-259">有关详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="38849-259">For more information, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span></para></block>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-260">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-260">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-261">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-261">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-262">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-262">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-263">从当前流中读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="38849-263">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-264">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-264">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="38849-265">从当前流中读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="38849-265">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-266">从当前流中的当前位置开始复制，在复制操作完成后，不会重置目标流的位置。</span><span class="sxs-lookup"><span data-stu-id="38849-266">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-267">下面的示例将 <xref:System.IO.FileStream> 的内容复制到 <xref:System.IO.MemoryStream>。</span><span class="sxs-lookup"><span data-stu-id="38849-267">The following example copies the contents of a <xref:System.IO.FileStream> to a <xref:System.IO.MemoryStream>.</span></span>  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-268"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-268"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-269">当前流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-269">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="38849-270">- 或 -</span><span class="sxs-lookup"><span data-stu-id="38849-270">-or-</span></span> 
 <span data-ttu-id="38849-271"><paramref name="destination" /> 不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-271"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-272">在调用 <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> 方法前当前流或 <paramref name="destination" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="38849-272">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-273">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-273">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.IO.Stream * int -&gt; unit&#xA;override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-274">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-274">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="38849-275">缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="38849-275">The size of the buffer.</span></span> <span data-ttu-id="38849-276">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="38849-276">This value must be greater than zero.</span></span> <span data-ttu-id="38849-277">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="38849-277">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="38849-278">使用指定的缓冲区大小，从当前流中读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="38849-278">Reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-279">从当前流中的当前位置开始复制，在复制操作完成后，不会重置目标流的位置。</span><span class="sxs-lookup"><span data-stu-id="38849-279">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-280"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-280"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-281"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="38849-281"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-282">当前流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-282">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="38849-283">- 或 -</span><span class="sxs-lookup"><span data-stu-id="38849-283">-or-</span></span> 
 <span data-ttu-id="38849-284"><paramref name="destination" /> 不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-284"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-285">在调用 <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> 方法前当前流或 <paramref name="destination" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="38849-285">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-286">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-286">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (System.Buffers.ReadOnlySpanAction&lt;byte,object&gt; callback, object state, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Buffers.ReadOnlySpanAction`2&lt;unsigned int8, object&gt; callback, object state, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.Buffers.ReadOnlySpanAction{System.Byte,System.Object},System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (callback As ReadOnlySpanAction(Of Byte, Object), state As Object, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(System::Buffers::ReadOnlySpanAction&lt;System::Byte, System::Object ^&gt; ^ callback, System::Object ^ state, int bufferSize);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Buffers.ReadOnlySpanAction&lt;byte, obj&gt; * obj * int -&gt; unit&#xA;override this.CopyTo : System.Buffers.ReadOnlySpanAction&lt;byte, obj&gt; * obj * int -&gt; unit" Usage="stream.CopyTo (callback, state, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Buffers.ReadOnlySpanAction&lt;System.Byte,System.Object&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-287">从当前流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="38849-287">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-288">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-288">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="38849-289">从当前流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="38849-289">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <returns><span data-ttu-id="38849-290">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-290">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-291">利用 <xref:System.IO.Stream.CopyToAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-291">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-292">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-292">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-293">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-293">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-294">从当前流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="38849-294">Copying begins at the current position in the current stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-295">下面的示例演示如何使用两个 <xref:System.IO.FileStream> 对象将文件从一个目录异步复制到另一个目录。</span><span class="sxs-lookup"><span data-stu-id="38849-295">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another.</span></span> <span data-ttu-id="38849-296"><xref:System.IO.FileStream> 类是从 <xref:System.IO.Stream> 类派生的。</span><span class="sxs-lookup"><span data-stu-id="38849-296">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span>  <span data-ttu-id="38849-297">请注意，<xref:System.Windows.Controls.Button> 控件的 <xref:System.Web.UI.WebControls.Button.Click> 事件处理程序使用 `async` 修饰符标记，因为它调用异步方法</span><span class="sxs-lookup"><span data-stu-id="38849-297">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-298"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-298"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-299">当前流或目标流已释放。</span><span class="sxs-lookup"><span data-stu-id="38849-299">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-300">当前流不支持阅读，或目标流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-300">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-301">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-301">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="38849-302">缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="38849-302">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="38849-303">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="38849-303">This value must be greater than zero.</span></span> <span data-ttu-id="38849-304">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="38849-304">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="38849-305">使用指定的缓冲区大小，从当前流中异步读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="38849-305">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <returns><span data-ttu-id="38849-306">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-306">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-307">利用 <xref:System.IO.Stream.CopyToAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-307">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-308">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-308">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-309">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-309">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-310">从当前流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="38849-310">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="38849-311">有关在两个流之间进行复制的示例，请参阅 <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-311">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-312"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-312"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-313"><paramref name="buffersize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="38849-313"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-314">当前流或目标流已释放。</span><span class="sxs-lookup"><span data-stu-id="38849-314">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-315">当前流不支持阅读，或目标流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-315">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-316">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-316">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-317">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-317">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-318">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-318">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-319">通过指定的取消令牌，从当前流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="38849-319">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="38849-320">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-320">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-321">利用 <xref:System.IO.Stream.CopyToAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-321">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-322">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-322">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-323">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-323">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-324">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-324">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-325">从当前流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="38849-325">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="38849-326">有关在两个流之间进行复制的示例，请参阅 <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-326">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CopyToAsync (destination As Stream, bufferSize As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="38849-327">当前流的内容将复制到的流。</span><span class="sxs-lookup"><span data-stu-id="38849-327">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="38849-328">缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="38849-328">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="38849-329">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="38849-329">This value must be greater than zero.</span></span> <span data-ttu-id="38849-330">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="38849-330">The default size is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-331">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-331">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-332">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-332">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-333">使用指定的缓冲区大小和取消令牌，从当前流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="38849-333">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="38849-334">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-334">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-335">利用 <xref:System.IO.Stream.CopyToAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-335">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-336">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-336">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-337">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-337">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-338">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-338">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-339">从当前流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="38849-339">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="38849-340">有关在两个流之间进行复制的示例，请参阅 <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-340">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-341"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-341"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-342"><paramref name="buffersize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="38849-342"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-343">当前流或目标流已释放。</span><span class="sxs-lookup"><span data-stu-id="38849-343">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-344">当前流不支持阅读，或目标流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-344">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (Func&lt;ReadOnlyMemory&lt;byte&gt;,object,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&gt; callback, object state, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.Func`4&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;, object, valuetype System.Threading.CancellationToken, valuetype System.Threading.Tasks.ValueTask&gt; callback, object state, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.Func{System.ReadOnlyMemory{System.Byte},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Object,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CopyToAsync (callback As Func(Of ReadOnlyMemory(Of Byte), Object, CancellationToken, ValueTask), state As Object, bufferSize As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(Func&lt;ReadOnlyMemory&lt;System::Byte&gt;, System::Object ^, System::Threading::CancellationToken, System::Threading::Tasks::ValueTask&gt; ^ callback, System::Object ^ state, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : Func&lt;ReadOnlyMemory&lt;byte&gt;, obj, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask&gt; * obj * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : Func&lt;ReadOnlyMemory&lt;byte&gt;, obj, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask&gt; * obj * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (callback, state, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;System.ReadOnlyMemory&lt;System.Byte&gt;,System.Object,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-345">分配 <see cref="T:System.Threading.WaitHandle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="38849-345">Allocates a <see cref="T:System.Threading.WaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="38849-346">对已分配的 <see langword="WaitHandle" /> 的引用。</span><span class="sxs-lookup"><span data-stu-id="38849-346">A reference to the allocated <see langword="WaitHandle" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-347">当首次调用时，当前方法会创建一个 `WaitHandle` 对象并将其返回。</span><span class="sxs-lookup"><span data-stu-id="38849-347">When called for the first time, the current method creates a `WaitHandle` object and returns it.</span></span> <span data-ttu-id="38849-348">在后续调用中，`CreateWaitHandle` 返回对新的等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="38849-348">On subsequent calls, `CreateWaitHandle` returns a reference to a new wait handle.</span></span>  
  
 <span data-ttu-id="38849-349">如果实现异步方法，并要求在异步操作完成之前 <xref:System.IO.Stream.EndRead%2A> 或 <xref:System.IO.Stream.EndWrite%2A> 中阻止，请使用此方法。</span><span class="sxs-lookup"><span data-stu-id="38849-349">Use this method if you implement the asynchronous methods and require a way of blocking in <xref:System.IO.Stream.EndRead%2A> or <xref:System.IO.Stream.EndWrite%2A> until the asynchronous operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-350">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-350">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-351">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-351">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-352">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-352">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-353">释放 <see cref="T:System.IO.Stream" /> 对象使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="38849-353">Releases all resources used by the <see cref="T:System.IO.Stream" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-354">释放 <see cref="T:System.IO.Stream" /> 使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="38849-354">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-355">此方法通过将任何更改写入后备存储并关闭流以释放资源来释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-355">This method disposes the stream, by writing any changes to the backing store and closing the stream to release resources.</span></span>  
  
 <span data-ttu-id="38849-356">调用 `Dispose` 允许出于其他目的重新分配 <xref:System.IO.Stream> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="38849-356">Calling `Dispose` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="38849-357">有关 `Dispose`的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="38849-357">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-358">将 stream 对象的所有清理逻辑置于 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />中。</span><span class="sxs-lookup"><span data-stu-id="38849-358">Place all cleanup logic for your stream object in <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span> <span data-ttu-id="38849-359">不要覆盖 <see cref="M:System.IO.Stream.Close" />。</span><span class="sxs-lookup"><span data-stu-id="38849-359">Do not override <see cref="M:System.IO.Stream.Close" />.</span></span>  
  
<span data-ttu-id="38849-360">请注意，由于向后兼容性要求，此方法的实现与处理模式的建议指南不同。</span><span class="sxs-lookup"><span data-stu-id="38849-360">Note that because of backward compatibility requirements, this method's implementation differs from the recommended guidance for the Dispose pattern.</span></span>  <span data-ttu-id="38849-361">此方法调用 <see cref="M:System.IO.Stream.Close" />，后者随后调用 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="38849-361">This method calls <see cref="M:System.IO.Stream.Close" />, which then calls <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="38849-362">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="38849-362"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="38849-363">释放 <see cref="T:System.IO.Stream" /> 使用的非托管资源，并选择性地释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="38849-363">Releases the unmanaged resources used by the <see cref="T:System.IO.Stream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-364">你应通过为 `disposing`指定 `true` 来释放所有资源。</span><span class="sxs-lookup"><span data-stu-id="38849-364">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="38849-365">`true``disposing` 时，流还可以确保将数据刷新到基础缓冲区，并访问其他可终止对象。</span><span class="sxs-lookup"><span data-stu-id="38849-365">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span>  <span data-ttu-id="38849-366">由于在终结器之间缺少排序而从终结器调用时可能无法进行此调用。</span><span class="sxs-lookup"><span data-stu-id="38849-366">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>  
  
 <span data-ttu-id="38849-367">如果流使用操作系统句柄与其源进行通信，请考虑使用 <xref:System.Runtime.InteropServices.SafeHandle> 的子类来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="38849-367">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>  
  
 <span data-ttu-id="38849-368">此方法由 public <xref:System.ComponentModel.Component.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="38849-368">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="38849-369"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护的 <xref:System.IO.Stream.Dispose%2A> 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="38849-369"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Stream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="38849-370"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 <xref:System.IO.Stream.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="38849-370"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Stream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-371">在派生类中，不要重写 <see cref="M:System.IO.Stream.Close" /> 方法，而是将所有流清理逻辑放在 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> 方法中。</span><span class="sxs-lookup"><span data-stu-id="38849-371">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the Stream cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="38849-372"><see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="38849-372"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="38849-373">重写 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see cref="M:System.ComponentModel.Component.Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="38849-373">When overriding <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="38849-374">有关如何实现 <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。</span><span class="sxs-lookup"><span data-stu-id="38849-374">For more information about how to implement <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="38849-375">有关 <see cref="M:System.ComponentModel.Component.Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="38849-375">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="stream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-376">异步释放 <see cref="T:System.IO.Stream" /> 使用的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="38849-376">Asynchronously releases the unmanaged resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <returns><span data-ttu-id="38849-377">一个表示异步释放操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-377">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-378">使用 <xref:System.IO.Stream.DisposeAsync%2A> 方法，您可以在不阻塞主线程的情况下执行占用大量资源的释放操作。</span><span class="sxs-lookup"><span data-stu-id="38849-378">The <xref:System.IO.Stream.DisposeAsync%2A> method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="38849-379">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-379">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-380">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-380">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span> 
 
 <span data-ttu-id="38849-381">此方法通过将任何更改写入后备存储并关闭流以释放资源来释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-381">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>   
  
 <span data-ttu-id="38849-382">调用 `DisposeAsync` 允许出于其他目的重新分配 <xref:System.IO.Stream> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="38849-382">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="38849-383">有关详细信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="38849-383">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="38849-384">对要完成的挂起异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="38849-384">The reference to the pending asynchronous request to finish.</span></span></param>
        <summary><span data-ttu-id="38849-385">等待挂起的异步读取操作完成。</span><span class="sxs-lookup"><span data-stu-id="38849-385">Waits for the pending asynchronous read to complete.</span></span> <span data-ttu-id="38849-386">（请考虑改用 <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />。）</span><span class="sxs-lookup"><span data-stu-id="38849-386">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="38849-387">从流中读取的字节数，介于零 (0) 和所请求的字节数之间。</span><span class="sxs-lookup"><span data-stu-id="38849-387">The number of bytes read from the stream, between zero (0) and the number of bytes you requested.</span></span> <span data-ttu-id="38849-388">流仅在流的末尾才返回 (0)；否则，在至少一个字节可用之前流将阻塞。</span><span class="sxs-lookup"><span data-stu-id="38849-388">Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-389">在 .NET Framework 4 和更早的版本中，您必须使用 <xref:System.IO.Stream.BeginRead%2A> 和 <xref:System.IO.Stream.EndRead%2A> 之类的方法来实现异步 I/O 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-389">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="38849-390">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.Stream.ReadAsync%2A>、<xref:System.IO.Stream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.Stream.FlushAsync%2A>）可帮助你更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-390">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="38849-391">调用 `EndRead` 确定从流中读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-391">Call `EndRead` to determine how many bytes were read from the stream.</span></span>  
  
 <span data-ttu-id="38849-392">可以从 <xref:System.IO.Stream.BeginRead%2A>对每个 <xref:System.IAsyncResult> 调用一次 `EndRead`。</span><span class="sxs-lookup"><span data-stu-id="38849-392">`EndRead` can be called once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="38849-393">此方法将一直阻塞，直到 I/O 操作已完成。</span><span class="sxs-lookup"><span data-stu-id="38849-393">This method blocks until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-394"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-394"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-395">处于挂起状态的读取操作的句柄不可用。</span><span class="sxs-lookup"><span data-stu-id="38849-395">A handle to the pending read operation is not available.</span></span>  
  
 <span data-ttu-id="38849-396">- 或 -</span><span class="sxs-lookup"><span data-stu-id="38849-396">-or-</span></span>  
  
 <span data-ttu-id="38849-397">挂起操作不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-397">The pending operation does not support reading.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-398"><paramref name="asyncResult" /> 不源于当前流的 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-398"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-399">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="38849-399">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-400">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-400">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-401">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-401">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-402">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-402">How to: Write Text to a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o"><span data-ttu-id="38849-403">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-403">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="38849-404">对未完成的异步 I/O 请求的引用。</span><span class="sxs-lookup"><span data-stu-id="38849-404">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="38849-405">结束执行异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="38849-405">Ends an asynchronous write operation.</span></span> <span data-ttu-id="38849-406">（请考虑改用 <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />。）</span><span class="sxs-lookup"><span data-stu-id="38849-406">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-407">在 .NET Framework 4 和更早的版本中，您必须使用 <xref:System.IO.Stream.BeginWrite%2A> 和 <xref:System.IO.Stream.EndWrite%2A> 之类的方法来实现异步 I/O 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-407">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="38849-408">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.Stream.ReadAsync%2A>、<xref:System.IO.Stream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.Stream.FlushAsync%2A>）可帮助你更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-408">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="38849-409">必须对 <xref:System.IO.Stream.BeginWrite%2A>每个 <xref:System.IAsyncResult> 只调用一次 `EndWrite`。</span><span class="sxs-lookup"><span data-stu-id="38849-409">`EndWrite` must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="38849-410">此方法将一直阻塞，直到 I/O 操作已完成。</span><span class="sxs-lookup"><span data-stu-id="38849-410">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="38849-411">在异步写入请求期间发生的错误（例如，i/o 请求过程中的磁盘故障）将在线程池线程上发生，并在调用 `EndWrite`时变为可见。</span><span class="sxs-lookup"><span data-stu-id="38849-411">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and become visible upon a call to `EndWrite`.</span></span> <span data-ttu-id="38849-412">调用 `EndWrite`时，线程池线程引发的异常将不可见。</span><span class="sxs-lookup"><span data-stu-id="38849-412">Exceptions thrown by the thread pool thread will not be visible when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-413"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-413"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-414">处于挂起状态的写入操作的句柄不可用。</span><span class="sxs-lookup"><span data-stu-id="38849-414">A handle to the pending write operation is not available.</span></span>  
  
 <span data-ttu-id="38849-415">- 或 -</span><span class="sxs-lookup"><span data-stu-id="38849-415">-or-</span></span>  
  
 <span data-ttu-id="38849-416">挂起操作不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-416">The pending operation does not support writing.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-417"><paramref name="asyncResult" /> 不源于当前流的 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="38849-417"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-418">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="38849-418">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-419">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-419">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-420">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-420">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-421">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-421">How to: Write Text to a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o"><span data-ttu-id="38849-422">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-422">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-423">当在派生类中重写时，将清除该流的所有缓冲区，并使得所有缓冲数据被写入到基础设备。</span><span class="sxs-lookup"><span data-stu-id="38849-423">When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-424">重写实现缓冲区的流上的 `Flush`。</span><span class="sxs-lookup"><span data-stu-id="38849-424">Override `Flush` on streams that implement a buffer.</span></span> <span data-ttu-id="38849-425">使用此方法可将任何信息从基础缓冲区移到其目标，清除缓冲区，或同时移动两者。</span><span class="sxs-lookup"><span data-stu-id="38849-425">Use this method to move any information from an underlying buffer to its destination, clear the buffer, or both.</span></span> <span data-ttu-id="38849-426">根据对象的状态，可能需要修改流中的当前位置（例如，如果基础流支持查找）。</span><span class="sxs-lookup"><span data-stu-id="38849-426">Depending upon the state of the object, you might have to modify the current position within the stream (for example, if the underlying stream supports seeking).</span></span> <span data-ttu-id="38849-427">有关其他信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="38849-427">For additional information see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  

 <span data-ttu-id="38849-428">在从不支持写入的 <xref:System.IO.Stream> 派生的类中，<xref:System.IO.Stream.Flush%2A> 通常实现为空方法以确保与其他 <xref:System.IO.Stream> 类型完全兼容，因为它可以刷新只读流。</span><span class="sxs-lookup"><span data-stu-id="38849-428">In a class derived from <xref:System.IO.Stream> that doesn't support writing, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>

 <span data-ttu-id="38849-429">使用 <xref:System.IO.StreamWriter> 或 <xref:System.IO.BinaryWriter> 类时，请不要刷新基本 <xref:System.IO.Stream> 对象。</span><span class="sxs-lookup"><span data-stu-id="38849-429">When using the <xref:System.IO.StreamWriter> or <xref:System.IO.BinaryWriter> class, do not flush the base <xref:System.IO.Stream> object.</span></span> <span data-ttu-id="38849-430">请改用类的 <xref:System.IO.Stream.Flush%2A> 或 <xref:System.IO.Stream.Close%2A> 方法，这可确保先将数据刷新到基础流，然后再将数据写入文件。</span><span class="sxs-lookup"><span data-stu-id="38849-430">Instead, use the class's <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.Close%2A> method, which makes sure that the data is flushed to the underlying stream first and then written to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-431">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-431">An I/O error occurs.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-432">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-432">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-433">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-433">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-434">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-434">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-435">异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中。</span><span class="sxs-lookup"><span data-stu-id="38849-435">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-436">异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中。</span><span class="sxs-lookup"><span data-stu-id="38849-436">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <returns><span data-ttu-id="38849-437">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-437">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-438">如果派生类（如 <xref:System.IO.Compression.DeflateStream> 或 <xref:System.IO.Compression.GZipStream>）未在其 <xref:System.IO.Stream.Flush%2A> 方法的实现中刷新缓冲区，则 <xref:System.IO.Stream.FlushAsync%2A> 方法将不刷新缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-438">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-439">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-439">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FlushAsync (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="38849-440">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-440">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-441">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-441">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-442">异步清理这个流的所有缓冲区，并使所有缓冲数据写入基础设备，并且监控取消请求。</span><span class="sxs-lookup"><span data-stu-id="38849-442">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="38849-443">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-443">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-444">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-444">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-445">如果派生类（如 <xref:System.IO.Compression.DeflateStream> 或 <xref:System.IO.Compression.GZipStream>）未在其 <xref:System.IO.Stream.Flush%2A> 方法的实现中刷新缓冲区，则 <xref:System.IO.Stream.FlushAsync%2A> 方法将不刷新缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-445">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-446">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-446">The stream has been disposed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads"><span data-ttu-id="38849-447">取消</span><span class="sxs-lookup"><span data-stu-id="38849-447">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-448">当在派生类中重写时，获取流长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="38849-448">When overridden in a derived class, gets the length in bytes of the stream.</span></span></summary>
        <value><span data-ttu-id="38849-449">表示流长度（以字节为单位）的长值。</span><span class="sxs-lookup"><span data-stu-id="38849-449">A long value representing the length of the stream in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-450">从 <see langword="Stream" /> 派生的类不支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-450">A class derived from <see langword="Stream" /> does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-451">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-451">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-452">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-452">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-453">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-453">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-454">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-454">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-455">无后备存储区的 <see langword="Stream" />。</span><span class="sxs-lookup"><span data-stu-id="38849-455">A <see langword="Stream" /> with no backing store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-456">使用 `Null` 将输出重定向到不会使用任何操作系统资源的流。</span><span class="sxs-lookup"><span data-stu-id="38849-456">Use `Null` to redirect output to a stream that will not consume any operating system resources.</span></span> <span data-ttu-id="38849-457">当在 `Null`上调用提供写入的 `Stream` 方法时，调用只会返回，并且不写入任何数据。</span><span class="sxs-lookup"><span data-stu-id="38849-457">When the methods of `Stream` that provide writing are invoked on `Null`, the call simply returns, and no data is written.</span></span> <span data-ttu-id="38849-458">`Null` 还实现了返回零的 `Read` 方法，但不读取数据。</span><span class="sxs-lookup"><span data-stu-id="38849-458">`Null` also implements a `Read` method that returns zero without reading data.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-459">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-459">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-460">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-460">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-461">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-461">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-462">提供对 <see cref="T:System.Diagnostics.Contracts.Contract" /> 的支持。</span><span class="sxs-lookup"><span data-stu-id="38849-462">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-463">当在派生类中重写时，获取或设置当前流中的位置。</span><span class="sxs-lookup"><span data-stu-id="38849-463">When overridden in a derived class, gets or sets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="38849-464">流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="38849-464">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-465">流必须支持查找以获取或设置位置。</span><span class="sxs-lookup"><span data-stu-id="38849-465">The stream must support seeking to get or set the position.</span></span> <span data-ttu-id="38849-466">使用 <xref:System.IO.Stream.CanSeek%2A> 属性来确定流是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-466">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the stream supports seeking.</span></span>  
  
 <span data-ttu-id="38849-467">支持查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="38849-467">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="38849-468">"`Position`" 属性不会跟踪已消耗、跳过的流中的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-468">The `Position` property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-469">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-469">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-470">流不支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-470">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-471">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-471">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-472">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-472">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-473">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-473">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-474">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-474">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-475">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="38849-475">A region of memory.</span></span> <span data-ttu-id="38849-476">当此方法返回时，此区域的内容将替换为从当前源读取的字节。</span><span class="sxs-lookup"><span data-stu-id="38849-476">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="38849-477">当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-477">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="38849-478">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-478">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="38849-479">如果很多字节当前不可用，则这可小于在缓冲区中分配的字节数；如果已到达流结尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="38849-479">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-480">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-480">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="38849-481">使用 <xref:System.IO.Stream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="38849-481">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="38849-482">此方法的实现从当前流中读取最多 `buffer.Length` 个字节，并将它们存储在 `buffer`中。</span><span class="sxs-lookup"><span data-stu-id="38849-482">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="38849-483">流中的当前位置按读取的字节数提前;但是，如果发生异常，则流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="38849-483">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="38849-484">实现返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-484">Implementations return the number of bytes read.</span></span> <span data-ttu-id="38849-485">如果没有数据可用，则实现将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="38849-485">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="38849-486">仅当流中没有更多的数据，并且不需要更多的数据时（例如闭合套接字或文件尾），<xref:System.IO.Stream.Read%2A> 才返回0。</span><span class="sxs-lookup"><span data-stu-id="38849-486"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="38849-487">即使尚未到达流的末尾，实现也可以自由返回比请求更少的字节。</span><span class="sxs-lookup"><span data-stu-id="38849-487">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="38849-488">使用 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="38849-488">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>    
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-489">字节数组。</span><span class="sxs-lookup"><span data-stu-id="38849-489">An array of bytes.</span></span> <span data-ttu-id="38849-490">当此方法返回时，此缓冲区包含指定的字符数组，此数组中 <paramref name="offset" /> 和 (<paramref name="offset" /> + <paramref name="count" /> - 1) 之间的值被从当前源中读取的字节所替换。</span><span class="sxs-lookup"><span data-stu-id="38849-490">When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-491"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始存储从当前流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="38849-491">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-492">要从当前流中读取的最多字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-492">The maximum number of bytes to be read from the current stream.</span></span></param>
        <summary><span data-ttu-id="38849-493">当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-493">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="38849-494">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-494">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="38849-495">如果许多字节当前不可用，则该数字可能小于要求的字节数；如果尚未到达流的末尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="38849-495">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-496">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-496">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="38849-497">使用 <xref:System.IO.Stream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="38849-497">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="38849-498">此方法的实现从当前流中读取最多 `count` 个字节，并将它们存储在从 `offset`开始 `buffer`。</span><span class="sxs-lookup"><span data-stu-id="38849-498">Implementations of this method read a maximum of `count` bytes from the current stream and store them in `buffer` beginning at `offset`.</span></span> <span data-ttu-id="38849-499">流中的当前位置按读取的字节数提前;但是，如果发生异常，则流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="38849-499">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="38849-500">实现返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-500">Implementations return the number of bytes read.</span></span> <span data-ttu-id="38849-501">如果没有数据可用，则实现将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="38849-501">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="38849-502">仅当流中没有更多的数据，并且不需要更多的数据时（例如闭合套接字或文件尾），<xref:System.IO.Stream.Read%2A> 才返回0。</span><span class="sxs-lookup"><span data-stu-id="38849-502"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="38849-503">即使尚未到达流的末尾，实现也可以自由返回比请求更少的字节。</span><span class="sxs-lookup"><span data-stu-id="38849-503">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="38849-504">使用 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="38849-504">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-505">下面的示例演示如何使用 <xref:System.IO.Stream.Read%2A> 读取数据块。</span><span class="sxs-lookup"><span data-stu-id="38849-505">The following example shows how to use <xref:System.IO.Stream.Read%2A> to read a block of data.</span></span>  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-506"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-506">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-507"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-507"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-508"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-508"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-509">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-509">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-510">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-510">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-511">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-511">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-512">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-512">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-513">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-514">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-515">从当前流异步读取字节序列，并将流中的位置提升读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-515">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync (buffer As Memory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-516">要将数据写入的内存区域。</span><span class="sxs-lookup"><span data-stu-id="38849-516">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-517">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-517">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-518">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-518">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-519">从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="38849-519">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="38849-520">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-520">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="38849-521">其 <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> 属性的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-521">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="38849-522">如果很多字节当前不可用，则结果值可小于在缓冲区中分配的字节数；如果已到达流结尾，则结果值可以为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="38849-522">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-523">利用 <xref:System.IO.Stream.ReadAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-523">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-524">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-524">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-525">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-525">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-526">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-526">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="38849-527">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-527">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  
  
 <span data-ttu-id="38849-528">有关示例，请参阅 <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-528">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-529">数据写入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-529">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-530"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="38849-530">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-531">要读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-531">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="38849-532">从当前流异步读取字节序列，并将流中的位置提升读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-532">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="38849-533">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-533">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="38849-534"><paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-534">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="38849-535">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="38849-535">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-536">利用 <xref:System.IO.Stream.ReadAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-536">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-537">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-537">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-538">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-538">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-539">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-539">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-540">下面的示例演示如何以异步方式从文件读取。</span><span class="sxs-lookup"><span data-stu-id="38849-540">The following example shows how to read from a file asynchronously.</span></span> <span data-ttu-id="38849-541">该示例使用派生自 <xref:System.IO.Stream> 类的 <xref:System.IO.FileStream> 类。</span><span class="sxs-lookup"><span data-stu-id="38849-541">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-542"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-542"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-543"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-543"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-544"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-544">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-545">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-545">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-546">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-546">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-547">之前的读取操作当前正在使用流。</span><span class="sxs-lookup"><span data-stu-id="38849-547">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-548">数据写入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-548">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-549"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="38849-549">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-550">要读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-550">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-551">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-551">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-552">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-552">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-553">从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="38849-553">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="38849-554">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-554">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="38849-555"><paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-555">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="38849-556">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="38849-556">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-557">利用 <xref:System.IO.Stream.ReadAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-557">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-558">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-558">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-559">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-559">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-560">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-560">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="38849-561">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-561">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-562">有关示例，请参阅 <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-562">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-563"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-563"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-564"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-564"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-565"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-565">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-566">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-566">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-567">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-567">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-568">之前的读取操作当前正在使用流。</span><span class="sxs-lookup"><span data-stu-id="38849-568">The stream is currently in use by a previous read operation.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads"><span data-ttu-id="38849-569">取消</span><span class="sxs-lookup"><span data-stu-id="38849-569">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-570">从流中读取一个字节，并将流内的位置向前提升一个字节，或者如果已到达流结尾，则返回 -1。</span><span class="sxs-lookup"><span data-stu-id="38849-570">Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="38849-571">强制转换为 <see cref="T:System.Int32" /> 的无符号字节，如果到达流的末尾，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="38849-571">The unsigned byte cast to an <see cref="T:System.Int32" />, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-572">使用 <xref:System.IO.Stream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-572">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="38849-573">在流关闭之后尝试操作流可能会引发 <xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="38849-573">Attempts to manipulate the stream after the stream has been closed could throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-574">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="38849-574">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-575">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-575">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-576"><see langword="Stream" /> 上的默认实现创建新的单字节数组，然后调用 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="38849-576">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="38849-577">尽管这是正确的，但效率低下。</span><span class="sxs-lookup"><span data-stu-id="38849-577">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="38849-578">具有内部缓冲区的任何流都应该重写此方法，并提供一个更高效的版本来直接读取缓冲区，避免在每次调用时进行额外的数组分配。</span><span class="sxs-lookup"><span data-stu-id="38849-578">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-579">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-579">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-580">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-580">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-581">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-581">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-582">获取或设置一个值（以毫秒为单位），该值确定流在超时前将尝试读取的时间。</span><span class="sxs-lookup"><span data-stu-id="38849-582">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></summary>
        <value><span data-ttu-id="38849-583">一个值（以毫秒为单位），该值确定流在超时前将尝试读取的时间。</span><span class="sxs-lookup"><span data-stu-id="38849-583">A value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-584"><see cref="P:System.IO.Stream.ReadTimeout" /> 方法总是引发 <see cref="T:System.InvalidOperationException" />。</span><span class="sxs-lookup"><span data-stu-id="38849-584">The <see cref="P:System.IO.Stream.ReadTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-585">应重写 <see cref="P:System.IO.Stream.ReadTimeout" /> 属性，以便为流提供适当的行为。</span><span class="sxs-lookup"><span data-stu-id="38849-585">The <see cref="P:System.IO.Stream.ReadTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="38849-586">如果流不支持超时，则此属性应引发 <see cref="T:System.InvalidOperationException" />。</span><span class="sxs-lookup"><span data-stu-id="38849-586">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="38849-587">相对于 <paramref name="origin" /> 参数的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="38849-587">A byte offset relative to the <paramref name="origin" /> parameter.</span></span></param>
        <param name="origin"><span data-ttu-id="38849-588"><see cref="T:System.IO.SeekOrigin" /> 类型的值，指示用于获取新位置的参考点。</span><span class="sxs-lookup"><span data-stu-id="38849-588">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="38849-589">当在派生类中重写时，设置当前流中的位置。</span><span class="sxs-lookup"><span data-stu-id="38849-589">When overridden in a derived class, sets the position within the current stream.</span></span></summary>
        <returns><span data-ttu-id="38849-590">当前流中的新位置。</span><span class="sxs-lookup"><span data-stu-id="38849-590">The new position within the current stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-591">使用 <xref:System.IO.Stream.CanSeek%2A> 属性可确定当前实例是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-591">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the current instance supports seeking.</span></span>  
  
 <span data-ttu-id="38849-592">如果 `offset` 为负数，则需要将新位置置于 `origin` 指定的位置之前，`offset`指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-592">If `offset` is negative, the new position is required to precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="38849-593">如果 `offset` 为零（0），则需要将新位置作为 `origin`指定的位置。</span><span class="sxs-lookup"><span data-stu-id="38849-593">If `offset` is zero (0), the new position is required to be the position specified by `origin`.</span></span> <span data-ttu-id="38849-594">如果 `offset` 为正，则需要在由 `offset`指定的字节数 `origin` 指定的位置之后，新位置。</span><span class="sxs-lookup"><span data-stu-id="38849-594">If `offset` is positive, the new position is required to follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="38849-595">从支持查找的 `Stream` 派生的类必须重写此方法以提供上述功能。</span><span class="sxs-lookup"><span data-stu-id="38849-595">Classes derived from `Stream` that support seeking must override this method to provide the functionality described above.</span></span>  
  
 <span data-ttu-id="38849-596">支持查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="38849-596">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-597">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-597">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-598">流不支持查找，例如在流通过管道或控制台输出构造的情况下即为如此。</span><span class="sxs-lookup"><span data-stu-id="38849-598">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-599">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-599">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-600">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-600">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-601">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-601">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-602">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-602">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="38849-603">当前流的所需长度，以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="38849-603">The desired length of the current stream in bytes.</span></span></param>
        <summary><span data-ttu-id="38849-604">当在派生类中重写时，设置当前流的长度。</span><span class="sxs-lookup"><span data-stu-id="38849-604">When overridden in a derived class, sets the length of the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-605">如果指定的值小于流的当前长度，则流将被截断。</span><span class="sxs-lookup"><span data-stu-id="38849-605">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="38849-606">如果指定的值大于流的当前长度，则会扩展流。</span><span class="sxs-lookup"><span data-stu-id="38849-606">If the specified value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="38849-607">如果流已展开，则不会定义新旧长度之间的流内容。</span><span class="sxs-lookup"><span data-stu-id="38849-607">If the stream is expanded, the contents of the stream between the old and the new length are not defined.</span></span>  
  
 <span data-ttu-id="38849-608">流必须支持写入和查找 `SetLength` 才能工作。</span><span class="sxs-lookup"><span data-stu-id="38849-608">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 <span data-ttu-id="38849-609">使用 <xref:System.IO.Stream.CanWrite%2A> 属性来确定当前实例是否支持写入，并使用 <xref:System.IO.Stream.CanSeek%2A> 属性来确定是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="38849-609">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.Stream.CanSeek%2A> property to determine whether seeking is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-610">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-610">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-611">流不支持写入和查找，例如在流通过管道或控制台输出构造的情况下即为如此。</span><span class="sxs-lookup"><span data-stu-id="38849-611">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-612">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-612">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-613">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-613">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-614">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-614">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-615">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-615">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (stream As Stream) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="38849-616">要同步的 <see cref="T:System.IO.Stream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="38849-616">The <see cref="T:System.IO.Stream" /> object to synchronize.</span></span></param>
        <summary><span data-ttu-id="38849-617">在指定的 <see cref="T:System.IO.Stream" /> 对象周围创建线程安全（同步）包装。</span><span class="sxs-lookup"><span data-stu-id="38849-617">Creates a thread-safe (synchronized) wrapper around the specified <see cref="T:System.IO.Stream" /> object.</span></span></summary>
        <returns><span data-ttu-id="38849-618">一个线程安全的 <see cref="T:System.IO.Stream" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="38849-618">A thread-safe <see cref="T:System.IO.Stream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-619">此方法返回一个类，该类包装指定的 <xref:System.IO.Stream> 对象并限制从多个线程访问该对象。</span><span class="sxs-lookup"><span data-stu-id="38849-619">This method returns a class that wraps the specified <xref:System.IO.Stream> object and restricts access to it from multiple threads.</span></span> <span data-ttu-id="38849-620">对 <xref:System.IO.Stream> 对象的所有访问都是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="38849-620">All access to the <xref:System.IO.Stream> object will be thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-621"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-621"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="stream.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38849-622">释放 <see cref="T:System.IO.Stream" /> 使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="38849-622">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="38849-623">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="38849-623">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="38849-624">它只能在 <xref:System.IO.Stream> 实例被强制转换为 <xref:System.IDisposable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="38849-624">It can be used only when the <xref:System.IO.Stream> instance is cast to an <xref:System.IDisposable> interface.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-625">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="38849-625">A region of memory.</span></span> <span data-ttu-id="38849-626">此方法将此区域的内容复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="38849-626">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="38849-627">当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-627">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-628">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-628">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="38849-629">使用 <xref:System.IO.Stream.WriteAsync%2A> 方法异步写入当前流。</span><span class="sxs-lookup"><span data-stu-id="38849-629">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="38849-630">如果写入操作成功，则流中的位置将按写入的字节数向前推进。</span><span class="sxs-lookup"><span data-stu-id="38849-630">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="38849-631">如果发生异常，则流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="38849-631">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-632">字节数组。</span><span class="sxs-lookup"><span data-stu-id="38849-632">An array of bytes.</span></span> <span data-ttu-id="38849-633">此方法将 <paramref name="count" /> 个字节从 <paramref name="buffer" /> 复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="38849-633">This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-634"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="38849-634">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-635">要写入当前流的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-635">The number of bytes to be written to the current stream.</span></span></param>
        <summary><span data-ttu-id="38849-636">当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-636">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-637">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-637">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="38849-638">使用 <xref:System.IO.Stream.WriteAsync%2A> 方法异步写入当前流。</span><span class="sxs-lookup"><span data-stu-id="38849-638">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="38849-639">如果写入操作成功，则流中的位置将按写入的字节数向前推进。</span><span class="sxs-lookup"><span data-stu-id="38849-639">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="38849-640">如果发生异常，则流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="38849-640">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-641"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-641">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-642"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-642"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-643"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-643"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-644">发生 I/O 错误，例如找不到指定文件。</span><span class="sxs-lookup"><span data-stu-id="38849-644">An I/O error occurred, such as the specified file cannot be found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-645">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-645">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-646">在流关闭后调用 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="38849-646"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> was called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-647">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-647">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-648">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-648">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-649">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-649">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38849-650">将字节序列异步写入当前流，并将流的当前位置提升写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-650">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteAsync (buffer As ReadOnlyMemory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-651">从中写入数据的内存区域。</span><span class="sxs-lookup"><span data-stu-id="38849-651">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-652">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-652">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-653">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-653">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-654">将字节的序列异步写入当前流，将该流中的当前位置向前移动写入的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="38849-654">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="38849-655">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-655">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-656">利用 <xref:System.IO.Stream.WriteAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-656">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-657">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-657">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-658">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-658">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-659">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-659">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="38849-660">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-660">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-661">有关示例，请参阅 <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-661">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-662">要从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-662">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-663"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="38849-663">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-664">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-664">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="38849-665">将字节序列异步写入当前流，并将流的当前位置提升写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-665">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <returns><span data-ttu-id="38849-666">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-666">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-667">利用 <xref:System.IO.Stream.WriteAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-667">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-668">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-668">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-669">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-669">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-670">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-670">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38849-671">下面的示例演示如何以异步方式写入文件。</span><span class="sxs-lookup"><span data-stu-id="38849-671">The following example shows how to write asynchronously to a file.</span></span> <span data-ttu-id="38849-672">该示例使用派生自 <xref:System.IO.Stream> 类的 <xref:System.IO.FileStream> 类。</span><span class="sxs-lookup"><span data-stu-id="38849-672">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-673"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-673"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-674"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-674"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-675"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-675">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-676">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-676">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-677">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-677">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-678">流正在由前一次写操作使用。</span><span class="sxs-lookup"><span data-stu-id="38849-678">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="38849-679">要从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="38849-679">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="38849-680"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="38849-680">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="38849-681">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="38849-681">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="38849-682">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="38849-682">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="38849-683">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="38849-683">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="38849-684">将字节的序列异步写入当前流，将该流中的当前位置向前移动写入的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="38849-684">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="38849-685">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="38849-685">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-686">利用 <xref:System.IO.Stream.WriteAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="38849-686">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="38849-687">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="38849-687">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="38849-688">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="38849-688">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="38849-689">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-689">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="38849-690">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="38849-690">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="38849-691">有关示例，请参阅 <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="38849-691">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="38849-692"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="38849-692"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="38849-693"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="38849-693"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="38849-694"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="38849-694">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-695">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-695">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-696">已释放流。</span><span class="sxs-lookup"><span data-stu-id="38849-696">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-697">流正在由前一次写操作使用。</span><span class="sxs-lookup"><span data-stu-id="38849-697">The stream is currently in use by a previous write operation.</span></span></exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads"><span data-ttu-id="38849-698">取消</span><span class="sxs-lookup"><span data-stu-id="38849-698">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="38849-699">要写入流中的字节。</span><span class="sxs-lookup"><span data-stu-id="38849-699">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="38849-700">将一个字节写入流内的当前位置，并将流内的位置向前提升一个字节。</span><span class="sxs-lookup"><span data-stu-id="38849-700">Writes a byte to the current position in the stream and advances the position within the stream by one byte.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38849-701">使用 <xref:System.IO.Stream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="38849-701">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="38849-702">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="38849-702">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="38849-703">该流不支持写入，或者该流已关闭。</span><span class="sxs-lookup"><span data-stu-id="38849-703">The stream does not support writing, or the stream is already closed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="38849-704">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="38849-704">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-705"><see langword="Stream" /> 上的默认实现创建新的单字节数组，然后调用 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="38849-705">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="38849-706">尽管这是正确的，但效率低下。</span><span class="sxs-lookup"><span data-stu-id="38849-706">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="38849-707">具有内部缓冲区的任何流都应该重写此方法，并提供一个更高效的版本来直接写入缓冲区，避免每次调用时进行额外的数组分配。</span><span class="sxs-lookup"><span data-stu-id="38849-707">Any stream with an internal buffer should override this method and provide a much more efficient version that writes to the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="38849-708">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="38849-708">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="38849-709">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="38849-709">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="38849-710">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="38849-710">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38849-711">获取或设置一个值（以毫秒为单位），该值确定流在超时前将尝试写入多长时间。</span><span class="sxs-lookup"><span data-stu-id="38849-711">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></summary>
        <value><span data-ttu-id="38849-712">一个确定流在超时前将尝试写入多长时间的值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="38849-712">A value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="38849-713"><see cref="P:System.IO.Stream.WriteTimeout" /> 方法总是引发 <see cref="T:System.InvalidOperationException" />。</span><span class="sxs-lookup"><span data-stu-id="38849-713">The <see cref="P:System.IO.Stream.WriteTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="38849-714">应重写 <see cref="P:System.IO.Stream.WriteTimeout" /> 属性，以便为流提供适当的行为。</span><span class="sxs-lookup"><span data-stu-id="38849-714">The <see cref="P:System.IO.Stream.WriteTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="38849-715">如果流不支持超时，则此属性应引发 <see cref="T:System.InvalidOperationException" />。</span><span class="sxs-lookup"><span data-stu-id="38849-715">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>
