<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdb3c26372c7989215e98bc4de61133dc03a410c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86670356" /></Metadata><TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.0.0" To="System.Runtime.Extensions" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.1.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.IO" FromVersion="4.2.2.0" To="System.Runtime.Extensions" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a42f4-101">将缓冲层添加到另一个流上的读取和写入操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-101">Adds a buffering layer to read and write operations on another stream.</span></span> <span data-ttu-id="a42f4-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="a42f4-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-103">缓冲区是内存中用于缓存数据的字节块，从而减少了对操作系统的调用次数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="a42f4-104">缓冲区提高读写性能。</span><span class="sxs-lookup"><span data-stu-id="a42f4-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="a42f4-105">缓冲区可用于读取或写入，但不能同时使用这两种方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="a42f4-106"><xref:System.IO.BufferedStream.Read%2A> <xref:System.IO.BufferedStream.Write%2A> `BufferedStream` 自动维护缓冲区的和方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a42f4-107">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="a42f4-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a42f4-108">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="a42f4-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a42f4-109">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a42f4-110">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="a42f4-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a42f4-111">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a42f4-112">`BufferedStream` 可以围绕特定类型的流进行撰写。</span><span class="sxs-lookup"><span data-stu-id="a42f4-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="a42f4-113">它提供对基础数据源或存储库的字节的读写实现。</span><span class="sxs-lookup"><span data-stu-id="a42f4-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="a42f4-114">使用 <xref:System.IO.BinaryReader> 和 <xref:System.IO.BinaryWriter> 来读取和写入其他数据类型。</span><span class="sxs-lookup"><span data-stu-id="a42f4-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="a42f4-115">`BufferedStream` 用于防止缓冲区在不需要缓冲区时减慢输入和输出。</span><span class="sxs-lookup"><span data-stu-id="a42f4-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="a42f4-116">如果始终对大于内部缓冲区大小的大小进行读取和写入，则 `BufferedStream` 甚至可能不会分配内部缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="a42f4-117">`BufferedStream` 还缓冲共享缓冲区中的读取和写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="a42f4-118">假设您几乎总是要执行一系列的读或写操作，但这两个读取或写入操作很少发生更改。</span><span class="sxs-lookup"><span data-stu-id="a42f4-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-119">下面的代码示例演示如何对类使用 `BufferedStream` 类 `NetworkStream` 以提高某些 i/o 操作的性能。</span><span class="sxs-lookup"><span data-stu-id="a42f4-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="a42f4-120">启动客户端之前，在远程计算机上启动服务器。</span><span class="sxs-lookup"><span data-stu-id="a42f4-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="a42f4-121">启动客户端时，请将远程计算机名称指定为命令行参数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="a42f4-122">改变 `dataArraySize` 和 `streamBufferSize` 常量以查看其对性能的影响。</span><span class="sxs-lookup"><span data-stu-id="a42f4-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="a42f4-123">第一个示例显示了在客户端上运行的代码，第二个示例显示了在服务器上运行的代码。</span><span class="sxs-lookup"><span data-stu-id="a42f4-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="a42f4-124">**示例1：在客户端上运行的代码**</span><span class="sxs-lookup"><span data-stu-id="a42f4-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="a42f4-125">**示例2：在服务器上运行的代码**</span><span class="sxs-lookup"><span data-stu-id="a42f4-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-126">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-126">File and Stream I/O</span></span></related>
    <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-127">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-127">How to: Read Text from a File</span></span></related>
    <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-128">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-128">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a42f4-129">初始化 <see cref="T:System.IO.BufferedStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a42f4-129">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="a42f4-130">当前流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-130">The current stream.</span></span></param>
        <summary><span data-ttu-id="a42f4-131">使用默认的缓冲区大小 4096 字节初始化 <see cref="T:System.IO.BufferedStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a42f4-131">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-132">第一次 `BufferedStream` 使用此构造函数初始化对象时，将分配共享的读/写缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-132">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="a42f4-133">如果所有读取和写入都大于或等于，则不使用共享缓冲区 `bufferSize` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-133">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-134"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-134"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-135">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-135">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-136">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-136">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-137">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-137">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="a42f4-138">当前流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-138">The current stream.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a42f4-139">缓冲区大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-139">The buffer size in bytes.</span></span></param>
        <summary><span data-ttu-id="a42f4-140">使用指定的缓冲区大小初始化 <see cref="T:System.IO.BufferedStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a42f4-140">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-141">第一次 `BufferedStream` 使用此构造函数初始化对象时，将分配共享的读/写缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-141">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="a42f4-142">如果所有读取和写入都大于或等于，则不使用共享缓冲区 `bufferSize` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-142">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-143">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-143">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-144"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-144"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-145"><paramref name="bufferSize" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-145"><paramref name="bufferSize" /> is negative.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-146">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-146">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-147">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-147">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-148">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-148">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object? state);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-149">数据读入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-149">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-150"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="a42f4-150">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-151">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-151">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="a42f4-152">可选的异步回调，在完成读取时调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-152">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="a42f4-153">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a42f4-153">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="a42f4-154">开始异步读操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-154">Begins an asynchronous read operation.</span></span> <span data-ttu-id="a42f4-155">（请考虑改用 <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a42f4-155">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="a42f4-156">表示异步读取（可能仍处于挂起状态）的对象。</span><span class="sxs-lookup"><span data-stu-id="a42f4-156">An object that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-157">在 .NET Framework 4 及更早版本中，必须使用方法（如 <xref:System.IO.Stream.BeginRead%2A> 和） <xref:System.IO.Stream.EndRead%2A> 来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-157">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a42f4-158">这些方法在中仍可用 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以支持旧版代码; 但是，新的异步方法（如 <xref:System.IO.BufferedStream.ReadAsync%2A> 、 <xref:System.IO.BufferedStream.WriteAsync%2A> 和 <xref:System.IO.BufferedStream.FlushAsync%2A> ）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-158">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a42f4-159"><xref:System.IO.BufferedStream.EndWrite%2A> 对于每个调用，必须只调用一次 <xref:System.IO.BufferedStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-159"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="a42f4-160">在开始另一次读取之前未能结束读取进程可能会导致意外行为，如死锁。</span><span class="sxs-lookup"><span data-stu-id="a42f4-160">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a42f4-161">使用 <xref:System.IO.BufferedStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-161">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="a42f4-162"><xref:System.IO.BufferedStream.EndRead%2A> 若要确定读取的字节数，必须用此方法调用 <xref:System.IAsyncResult> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-162"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-163"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-164"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-164"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-165">试图在流的末尾之外进行异步读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-165">Attempted an asynchronous read past the end of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-166">缓冲区长度减去 <paramref name="offset" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-166">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-167">当前流不支持读取操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-167">The current stream does not support the read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object? state);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-168">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-168">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-169"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-169">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-170">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-170">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="a42f4-171">异步写操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-171">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="a42f4-172">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a42f4-172">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="a42f4-173">开始异步写操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-173">Begins an asynchronous write operation.</span></span> <span data-ttu-id="a42f4-174">（请考虑改用 <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a42f4-174">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="a42f4-175">一个表示异步写入（可能仍处于挂起状态）的对象。</span><span class="sxs-lookup"><span data-stu-id="a42f4-175">An object that references the asynchronous write which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-176">在 .NET Framework 4 及更早版本中，必须使用方法（如 <xref:System.IO.Stream.BeginWrite%2A> 和） <xref:System.IO.Stream.EndWrite%2A> 来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-176">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a42f4-177">这些方法在中仍可用 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以支持旧版代码; 但是，新的异步方法（如 <xref:System.IO.BufferedStream.ReadAsync%2A> 、 <xref:System.IO.BufferedStream.WriteAsync%2A> 和 <xref:System.IO.BufferedStream.FlushAsync%2A> ）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-177">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a42f4-178"><xref:System.IO.BufferedStream.EndWrite%2A> 必须对每个从只调用一次 <xref:System.IAsyncResult> <xref:System.IO.BufferedStream.BeginWrite%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-178"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="a42f4-179"><xref:System.IO.BufferedStream.EndWrite%2A> 在 i/o 操作完成之前，将一直阻止。</span><span class="sxs-lookup"><span data-stu-id="a42f4-179"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-180"><paramref name="buffer" /> 长度减去 <paramref name="offset" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-180"><paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-181"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-181"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-182"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-182"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-183">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-183">The stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-184">获取此缓冲流的缓冲区大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-184">Gets the buffer size in bytes for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="a42f4-185">表示缓冲区大小（以字节为单位）的整数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-185">An integer representing the buffer size in bytes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-186">获取一个值，该值指示当前流是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-186">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="a42f4-187">如果流支持读取，则为 <see langword="true" />；如果流已关闭或是通过只写访问方式打开的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-187"><see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-188">如果从派生的类不 <xref:System.IO.Stream> 支持读取，则调用、、、和的方法， <xref:System.IO.BufferedStream.Read%2A> <xref:System.IO.BufferedStream.ReadByte%2A> <xref:System.IO.Stream.BeginRead%2A> <xref:System.IO.Stream.EndRead%2A> `Peek` <xref:System.IO.StreamReader> <xref:System.IO.StringReader> 并 <xref:System.IO.TextReader> 引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-188">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a42f4-189">如果流已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-189">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-190">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-190">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-191">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-191">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-192">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-192">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-193">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-193">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-194">获取一个值，该值指示当前流是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="a42f4-194">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="a42f4-195">如果流支持查找，则为 <see langword="true" />；如果流已关闭或者如果流是由操作系统句柄（如管道或到控制台的输出）构造的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-195"><see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-196">如果从派生的类 <xref:System.IO.Stream> 不支持查找，则调用 <xref:System.IO.BufferedStream.Length%2A> 、、 <xref:System.IO.BufferedStream.SetLength%2A> 和将 <xref:System.IO.BufferedStream.Position%2A> <xref:System.IO.BufferedStream.Seek%2A> 引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-196">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a42f4-197">如果流已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-197">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-198">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-198">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-199">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-199">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-200">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-200">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-201">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-201">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-202">获取一个值，该值指示当前流是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-202">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="a42f4-203">如果流支持写入，则为 <see langword="true" />；如果流已关闭或是通过只读访问方式打开的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-203"><see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-204">如果从派生的类不 <xref:System.IO.Stream> 支持写入，则对、或的调用将 <xref:System.IO.BufferedStream.SetLength%2A> <xref:System.IO.BufferedStream.Write%2A> <xref:System.IO.BufferedStream.WriteByte%2A> 引发 <xref:System.NotSupportedException> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-204">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a42f4-205">如果流已关闭，则此属性返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-205">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-206">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-206">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-207">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-207">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-208">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-208">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-209">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-209">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a42f4-210">关闭流并释放与当前缓冲流关联的所有资源（尤其是系统资源，如套接字和文件句柄）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-210">Closes the stream and releases any resources (especially system resources such as sockets and file handles) associated with the current buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="a42f4-211">缓冲流关闭之前，以前写入缓冲区的任何数据都将复制到基础数据源或存储库。</span><span class="sxs-lookup"><span data-stu-id="a42f4-211">Any data previously written to the buffer is copied to the underlying data source or repository before the buffered stream is closed.</span></span> <span data-ttu-id="a42f4-212">因此，在 <xref:System.IO.BufferedStream.Flush> 调用 Close 之前无需调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-212">Therefore, it is not necessary to call <xref:System.IO.BufferedStream.Flush> before invoking Close.</span></span> <span data-ttu-id="a42f4-213">调用 Close 后，缓冲流上的任何操作都可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="a42f4-213">Following a call to Close, any operations on the buffered stream might raise exceptions.</span></span>

<span data-ttu-id="a42f4-214">除非显式调用或关闭，否则刷新流将不会刷新其基础编码器 <xref:System.IO.BufferedStream.Flush> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-214">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.BufferedStream.Flush> or Close.</span></span> <span data-ttu-id="a42f4-215"><xref:System.IO.StreamWriter.AutoFlush>如果设置为 true，则表示将数据从缓冲区刷新到流，但不会刷新编码器状态。</span><span class="sxs-lookup"><span data-stu-id="a42f4-215">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="a42f4-216">这样，编码器就可以将其状态保留 (部分字符) 以便它能够正确地编码下一个字符块。</span><span class="sxs-lookup"><span data-stu-id="a42f4-216">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="a42f4-217">此方案影响 UTF8 和 UTF7，其中某些字符只能在编码器接收到相邻字符后编码。</span><span class="sxs-lookup"><span data-stu-id="a42f4-217">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="a42f4-218">尝试在流关闭后对其进行操作可能会引发 <xref:System.ObjectDisposedException> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-218">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="a42f4-219">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-219">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>

```vb
' When bufStream is closed, netStream is in turn 
' closed, which in turn shuts down the connection 
' and closes clientSocket.
Console.WriteLine(vbCrLf & "Shutting down the connection.")
bufStream.Close()
```

```csharp
// When bufStream is closed, netStream is in turn
// closed, which in turn shuts down the connection
// and closes clientSocket.
Console.WriteLine("\nShutting down the connection.");
bufStream.Close();
```

```cpp
// When bufStream is closed, netStream is in turn closed,
// which in turn shuts down the connection and closes
// clientSocket.
Console::WriteLine( "\nShutting down connection." );
bufStream->Close();

```

]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-220">尝试关闭流时出错。</span><span class="sxs-lookup"><span data-stu-id="a42f4-220">An error occurred while trying to close the stream.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Flush" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-221">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-221">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-222">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-222">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-223">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-223">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="bufferedStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a42f4-224">将复制当前缓冲流的内容的流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-224">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a42f4-225">缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="a42f4-225">The size of the buffer.</span></span> <span data-ttu-id="a42f4-226">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="a42f4-226">This value must be greater than zero.</span></span> <span data-ttu-id="a42f4-227">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="a42f4-227">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="a42f4-228">从当前缓冲流中读取字节并将其写入到其他流中。</span><span class="sxs-lookup"><span data-stu-id="a42f4-228">Reads the bytes from the current buffered stream and writes them to another stream.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-229"><paramref name="destination" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-229"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-230"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a42f4-230"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-231">当前流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-231">The current stream does not support reading.</span></span>

<span data-ttu-id="a42f4-232">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a42f4-232">-or-</span></span>

<span data-ttu-id="a42f4-233"><paramref name="destination" /> 不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-233"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-234">在调用 <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> 方法前，当前流或 <paramref name="destination" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="a42f4-234">Either the current stream or <paramref name="destination" /> was closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-235">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a42f4-235">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CopyToAsync (destination As Stream, bufferSize As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a42f4-236">将复制当前缓冲流的内容的流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-236">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a42f4-237">缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-237">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="a42f4-238">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="a42f4-238">This value must be greater than zero.</span></span> <span data-ttu-id="a42f4-239">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="a42f4-239">The default sizer is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a42f4-240">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-240">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a42f4-241">默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-241">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a42f4-242">使用指定的缓冲区大小和取消令牌，从当前缓冲流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="a42f4-242">Asynchronously reads the bytes from the current buffered stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="a42f4-243">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-243">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a42f4-244">`CopyToAsync`方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-244">The `CopyToAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="a42f4-245">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a42f4-245">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a42f4-246">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-246">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="a42f4-247">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled> 属性的值 <xref:System.Threading.Tasks.Task.Status%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-247">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  

<span data-ttu-id="a42f4-248">从当前流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="a42f4-248">Copying begins at the current position in the current stream.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="a42f4-249">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-249"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="a42f4-250">释放缓冲流使用的非管理资源，并可选择释放受管理资源。</span><span class="sxs-lookup"><span data-stu-id="a42f4-250">Releases the unmanaged resources used by the buffered stream and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a42f4-251">你应通过将指定给来释放所有资源 `true` `disposing` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-251">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="a42f4-252">当 `disposing` 为时 `true` ，流还可以确保将数据刷新到基础缓冲区，并访问其他可终结对象。</span><span class="sxs-lookup"><span data-stu-id="a42f4-252">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span> <span data-ttu-id="a42f4-253">由于在终结器之间缺少排序而从终结器调用时可能无法进行此调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-253">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>

<span data-ttu-id="a42f4-254">如果流使用操作系统句柄与其源进行通信，请考虑使用的子类 <xref:System.Runtime.InteropServices.SafeHandle> 来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="a42f4-254">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>

<span data-ttu-id="a42f4-255">此方法由公共 <xref:System.ComponentModel.Component.Dispose> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-255">This method is called by the public <xref:System.ComponentModel.Component.Dispose> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="a42f4-256"><xref:System.ComponentModel.Component.Dispose> 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-256"><xref:System.ComponentModel.Component.Dispose> invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="a42f4-257"><xref:System.Object.Finalize%2A>`Dispose(Boolean)`在设置为的情况调用 `disposing` `false` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-257"><xref:System.Object.Finalize%2A> invokes `Dispose(Boolean)` with `disposing` set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a42f4-258">异步释放缓冲流使用的非管理资源。</span><span class="sxs-lookup"><span data-stu-id="a42f4-258">Asynchronously releases the unmanaged resources used by the buffered stream.</span></span></summary>
        <returns><span data-ttu-id="a42f4-259">一个表示异步释放操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-259">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a42f4-260">使用 `DisposeAsync` 方法，可以在不阻塞主线程的情况下执行占用大量资源的释放操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-260">The `DisposeAsync` method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="a42f4-261">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a42f4-261">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a42f4-262">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-262">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a42f4-263">此方法通过将任何更改写入后备存储并关闭流以释放资源来释放流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-263">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="a42f4-264">调用 `DisposeAsync` 会允许出于其他目的重新分配所使用的资源 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-264">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.BufferedStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="a42f4-265">有关详细信息，请参阅 [清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)。</span><span class="sxs-lookup"><span data-stu-id="a42f4-265">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="a42f4-266">对所等待的挂起异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-266">The reference to the pending asynchronous request to wait for.</span></span></param>
        <summary><span data-ttu-id="a42f4-267">等待挂起的异步读操作完成。</span><span class="sxs-lookup"><span data-stu-id="a42f4-267">Waits for the pending asynchronous read operation to complete.</span></span> <span data-ttu-id="a42f4-268">（请考虑改用 <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a42f4-268">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="a42f4-269">从流中读取的字节数，介于 0（零）和你请求的字节数之间。</span><span class="sxs-lookup"><span data-stu-id="a42f4-269">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span></span> <span data-ttu-id="a42f4-270">流仅在流的末尾返回 0；否则应一直阻塞到至少有 1 个字节可用为止。</span><span class="sxs-lookup"><span data-stu-id="a42f4-270">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-271">在 .NET Framework 4 及更早版本中，必须使用方法（如 <xref:System.IO.Stream.BeginRead%2A> 和） <xref:System.IO.Stream.EndRead%2A> 来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-271">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a42f4-272">这些方法在中仍可用 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以支持旧版代码; 但是，新的异步方法（如 <xref:System.IO.BufferedStream.ReadAsync%2A> 、 <xref:System.IO.BufferedStream.WriteAsync%2A> 和 <xref:System.IO.BufferedStream.FlushAsync%2A> ）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-272">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a42f4-273"><xref:System.IO.BufferedStream.EndRead%2A> 若要确定读取的字节数，必须用此方法调用 <xref:System.IAsyncResult> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-273"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-274"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-274"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-275">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</span><span class="sxs-lookup"><span data-stu-id="a42f4-275">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="a42f4-276">挂起的异步请求。</span><span class="sxs-lookup"><span data-stu-id="a42f4-276">The pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="a42f4-277">结束异步写入操作，在 I/O 操作完成之前一直阻止。</span><span class="sxs-lookup"><span data-stu-id="a42f4-277">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span></span> <span data-ttu-id="a42f4-278">（请考虑改用 <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a42f4-278">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-279">在 .NET Framework 4 及更早版本中，必须使用方法（如 <xref:System.IO.Stream.BeginWrite%2A> 和） <xref:System.IO.Stream.EndWrite%2A> 来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-279">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a42f4-280">这些方法在中仍可用 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以支持旧版代码; 但是，新的异步方法（如 <xref:System.IO.BufferedStream.ReadAsync%2A> 、 <xref:System.IO.BufferedStream.WriteAsync%2A> 和 <xref:System.IO.BufferedStream.FlushAsync%2A> ）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-280">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a42f4-281"><xref:System.IO.BufferedStream.EndWrite%2A> 对于每个调用，必须只调用一次 <xref:System.IO.BufferedStream.BeginRead%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-281"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="a42f4-282">在开始另一个读取操作之前未能结束读取进程可能会导致死锁或其他不需要的行为。</span><span class="sxs-lookup"><span data-stu-id="a42f4-282">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-283"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-283"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-284">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</span><span class="sxs-lookup"><span data-stu-id="a42f4-284">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a42f4-285">清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中。</span><span class="sxs-lookup"><span data-stu-id="a42f4-285">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-286">除非显式调用或，否则刷新流将不会刷新其基础编码器 `Flush` <xref:System.IO.Stream.Close%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-286">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="a42f4-287">如果使用 <xref:System.IO.BufferedStream.%23ctor%2A> 构造函数，从而在创建对象时指定缓冲区大小，则会在 `BufferedStream` 内容达到缓冲区大小时刷新内容。</span><span class="sxs-lookup"><span data-stu-id="a42f4-287">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="a42f4-288">例如， `BufferedStream bs = new BufferedStream(bs, 5)` 当缓冲区大小达到5个字节时，等代码将刷新内容。</span><span class="sxs-lookup"><span data-stu-id="a42f4-288">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="a42f4-289">所有读取和写入方法 `BufferedStream` 自动维护缓冲区，因此， `Flush` 在读取和写入之间来回切换时无需调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-289">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-290">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-290">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-291">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-291">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-292">数据源或储存库未打开。</span><span class="sxs-lookup"><span data-stu-id="a42f4-292">The data source or repository is not open.</span></span></exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-293">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-293">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-294">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-294">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-295">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-295">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="a42f4-296">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-296">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a42f4-297">异步清理此流的所有缓冲区，导致所有缓冲数据都写入基础设备，并且监控取消请求。</span><span class="sxs-lookup"><span data-stu-id="a42f4-297">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a42f4-298">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-298">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-299">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-299">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-300">获取流长度，长度以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="a42f4-300">Gets the stream length in bytes.</span></span></summary>
        <value><span data-ttu-id="a42f4-301">流长度，以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="a42f4-301">The stream length in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-302">基础流为 <see langword="null" /> 或已关闭。</span><span class="sxs-lookup"><span data-stu-id="a42f4-302">The underlying stream is <see langword="null" /> or closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-303">流不支持查找。</span><span class="sxs-lookup"><span data-stu-id="a42f4-303">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-304">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-304">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-305">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-305">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-306">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-306">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-307">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-307">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-308">获取当前流内的位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-308">Gets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="a42f4-309">当前流内的位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-309">The position within the current stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-310">`get`访问器调用 <xref:System.IO.BufferedStream.Seek%2A> 以获取基础流中的当前位置，然后根据缓冲区中的当前位置调整此值。</span><span class="sxs-lookup"><span data-stu-id="a42f4-310">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="a42f4-311">`set`访问器将先前写入缓冲区的所有数据复制到基础流，然后调用 <xref:System.IO.BufferedStream.Seek%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-311">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="a42f4-312">支持查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-312">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-313">传递给 <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> 的值为负。</span><span class="sxs-lookup"><span data-stu-id="a42f4-313">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-314">发生 I/O 错误，如流被关闭。</span><span class="sxs-lookup"><span data-stu-id="a42f4-314">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-315">流不支持查找。</span><span class="sxs-lookup"><span data-stu-id="a42f4-315">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-316">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-316">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-317">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-317">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-318">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-318">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-319">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-319">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="bufferedStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a42f4-320">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="a42f4-320">A region of memory.</span></span> <span data-ttu-id="a42f4-321">当此方法返回时，此区域的内容将替换为从当前源读取的字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-321">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="a42f4-322">将当前缓冲流中的字节复制到字节跨度，并按读取的字节数向前移动缓冲流中的位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-322">Copies bytes from the current buffered stream to a byte span and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="a42f4-323">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-323">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="a42f4-324">如果很多字节当前不可用，则这可小于在缓冲区中分配的字节数；如果已到达流结尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="a42f4-324">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="a42f4-325">使用 <xref:System.IO.BufferedStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-325">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="a42f4-326">使用 <xref:System.IO.BufferedStream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-326">Use the <xref:System.IO.BufferedStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="a42f4-327">此方法的实现从当前流中读取最多 `buffer.Length` 字节，并将它们存储在中 `buffer` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-327">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="a42f4-328">流中的当前位置按读取的字节数提前;但是，如果发生异常，则流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="a42f4-328">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="a42f4-329">实现返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-329">Implementations return the number of bytes read.</span></span> <span data-ttu-id="a42f4-330">如果没有数据可用，则实现将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-330">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="a42f4-331">`Read` 仅当流中没有更多的数据，但不需要更多的数据时，才会返回0， (例如关闭的套接字或文件末尾) 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-331">`Read` returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="a42f4-332">即使尚未到达流的末尾，实现也可以自由返回比请求更少的字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-332">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="a42f4-333">用于 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="a42f4-333">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a42f4-334">将字节复制到的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-334">The buffer to which bytes are to be copied.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-335">缓冲区中的字节偏移量，从此处开始读取字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-335">The byte offset in the buffer at which to begin reading bytes.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-336">要读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-336">The number of bytes to be read.</span></span></param>
        <summary><span data-ttu-id="a42f4-337">将字节从当前缓冲流复制到数组。</span><span class="sxs-lookup"><span data-stu-id="a42f4-337">Copies bytes from the current buffered stream to an array.</span></span></summary>
        <returns><span data-ttu-id="a42f4-338">读入 <paramref name="array" /> 中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-338">The total number of bytes read into <paramref name="array" />.</span></span> <span data-ttu-id="a42f4-339">如果可用的字节没有所请求的那么多，总字节数可能小于请求的字节数；或者如果在可读取任何数据前就已到达流的末尾，则为零。</span><span class="sxs-lookup"><span data-stu-id="a42f4-339">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-340">`Read`仅当到达流的末尾时，方法才会返回0。</span><span class="sxs-lookup"><span data-stu-id="a42f4-340">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="a42f4-341">在所有其他情况下，在 `Read` 返回前始终从流中读取至少一个字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-341">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="a42f4-342">按照定义，如果调用后流中没有可用数据 `Read` ，则该 `Read` 方法将返回 0 (自动到达流的末尾) 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-342">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="a42f4-343">即使尚未到达流的末尾，实现也可以自由返回比请求更少的字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-343">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="a42f4-344">用于 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="a42f4-344">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a42f4-345">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-345">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-346"><paramref name="array" /> 的长度减去 <paramref name="offset" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-346">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-347"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-347"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-348"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-348"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-349">流未打开或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-349">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-350">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-350">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-351">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-351">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-352">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-352">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-353">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-353">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-354">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-354">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Memory(Of Byte), Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-355">要将数据写入的内存区域。</span><span class="sxs-lookup"><span data-stu-id="a42f4-355">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a42f4-356">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-356">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a42f4-357">默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-357">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a42f4-358">从当前缓冲流异步读取字节序列，并按读取的字节数向前移动缓冲流中的位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-358">Asynchronously reads a sequence of bytes from the current buffered stream and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="a42f4-359">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-359">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="a42f4-360">其 <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> 属性的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-360">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="a42f4-361">如果很多字节当前不可用，则结果值可小于在缓冲区中分配的字节数；如果已到达流结尾，则结果值可以为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-361">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a42f4-362">`ReadAsync`方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-362">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="a42f4-363">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a42f4-363">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a42f4-364">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-364">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a42f4-365">使用 <xref:System.IO.BufferedStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-365">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="a42f4-366">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 属性的值 <xref:System.Threading.Tasks.Task.Status> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-366">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-367">要写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-367">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-368"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="a42f4-368">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-369">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-369">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a42f4-370">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-370">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a42f4-371">从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a42f4-371">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a42f4-372">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-372">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="a42f4-373"><paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-373">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="a42f4-374">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-374">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-375">可以通过创建类的实例 <xref:System.Threading.CancellationTokenSource> 并将 <xref:System.Threading.CancellationTokenSource.Token%2A> 属性作为参数传递来创建取消标记 `cancellationToken` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-375">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-376"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-377"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-377"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-378"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="a42f4-378">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-379">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-379">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-380">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-380">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a42f4-381">之前的读取操作当前正在使用流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-381">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a42f4-382">从基础流中读取一个字节，并返回转换为 <see langword="int" /> 的该字节；或者如果从流的末尾读取则返回 -1。</span><span class="sxs-lookup"><span data-stu-id="a42f4-382">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="a42f4-383">转换为 <see langword="int" /> 的字节，或者如果从流的末尾读取则为 -1。</span><span class="sxs-lookup"><span data-stu-id="a42f4-383">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-384">发生 I/O 错误，如流被关闭。</span><span class="sxs-lookup"><span data-stu-id="a42f4-384">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-385">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a42f4-385">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-386">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-386">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="a42f4-387">上的默认实现 <see langword="Stream" /> 创建新的单字节数组，然后调用 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-387">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="a42f4-388">尽管这是正确的，但效率低下。</span><span class="sxs-lookup"><span data-stu-id="a42f4-388">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="a42f4-389">具有内部缓冲区的任何流都应该重写此方法，并提供一个更高效的版本来直接读取缓冲区，避免在每次调用时进行额外的数组分配。</span><span class="sxs-lookup"><span data-stu-id="a42f4-389">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-390">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-390">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-391">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-391">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-392">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-392">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="a42f4-393">相对于 <paramref name="origin" /> 的字节偏移量。</span><span class="sxs-lookup"><span data-stu-id="a42f4-393">A byte offset relative to <paramref name="origin" />.</span></span></param>
        <param name="origin"><span data-ttu-id="a42f4-394"><see cref="T:System.IO.SeekOrigin" /> 类型的值，指示用于获得新位置的参考点。</span><span class="sxs-lookup"><span data-stu-id="a42f4-394">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="a42f4-395">设置当前缓冲流中的位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-395">Sets the position within the current buffered stream.</span></span></summary>
        <returns><span data-ttu-id="a42f4-396">当前缓冲流中的新位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-396">The new position within the current buffered stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-397">如果 `offset` 为负，则新位置位于 `origin` 指定的位置之前 `offset` 指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-397">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="a42f4-398">如果 `offset` 为0，则新位置将是指定的位置 `origin` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-398">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="a42f4-399">如果 `offset` 为正，则新位置位于 `origin` 指定的位置之后 `offset` 指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-399">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="a42f4-400">当 <xref:System.IO.BufferedStream> 对象是对象的基本流时 <xref:System.IO.StreamReader> ，调用 <xref:System.IO.BufferedStream.Seek%2A> 方法会导致流的位置不再与读取器中内部缓冲区的位置匹配。</span><span class="sxs-lookup"><span data-stu-id="a42f4-400">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="a42f4-401">若要重置内部缓冲区，请调用 <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> 方法; 但是，此方法会降低性能，只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-401">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="a42f4-402">支持查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-402">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-403">流未打开或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-403">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-404">流不支持查找。</span><span class="sxs-lookup"><span data-stu-id="a42f4-404">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-405">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-405">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-406">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-406">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-407">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-408">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a42f4-409">一个整数，指示当前缓冲流的所需长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a42f4-409">An integer indicating the desired length of the current buffered stream in bytes.</span></span></param>
        <summary><span data-ttu-id="a42f4-410">设置缓冲流的长度。</span><span class="sxs-lookup"><span data-stu-id="a42f4-410">Sets the length of the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-411">在设置基础数据源或存储库的长度之前，将刷新缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-411">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="a42f4-412">如果指定的值小于缓冲流的当前长度，则将截断缓冲流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-412">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="a42f4-413">如果指定的值大于缓冲流的当前长度，则将展开缓冲流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-413">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="a42f4-414">如果缓冲流已展开，则不会定义旧长度与新长度之间缓冲流的内容。</span><span class="sxs-lookup"><span data-stu-id="a42f4-414">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="a42f4-415">`SetLength` 如果需要，刷新任何缓冲的写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-415">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="a42f4-416">流必须支持写入和查找， `SetLength` 才能正常工作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-416">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-417"><paramref name="value" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-417"><paramref name="value" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-418">流未打开或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-418">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-419">该流不支持写入和查找。</span><span class="sxs-lookup"><span data-stu-id="a42f4-419">The stream does not support both writing and seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-420">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-420">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-421">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-421">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-422">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-422">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-423">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-423">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a42f4-424">获取此缓冲流的基础 <see cref="T:System.IO.Stream" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="a42f4-424">Gets the underlying <see cref="T:System.IO.Stream" /> instance for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="a42f4-425">基础流实例。</span><span class="sxs-lookup"><span data-stu-id="a42f4-425">The underlying stream instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="bufferedStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-426">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="a42f4-426">A region of memory.</span></span> <span data-ttu-id="a42f4-427">此方法将此区域的内容复制到当前缓冲流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-427">This method copies the contents of this region to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="a42f4-428">将字节序列写入当前缓冲流，并按写入的字节数向前移动此缓冲流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-428">Writes a sequence of bytes to the current buffered stream and advances the current position within this buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a42f4-429">使用 <xref:System.IO.BufferedStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-429">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="a42f4-430">使用 <xref:System.IO.BufferedStream.WriteAsync%2A> 方法异步写入当前缓冲流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-430">Use the <xref:System.IO.BufferedStream.WriteAsync%2A> method to write asynchronously to the current buffered stream.</span></span>

<span data-ttu-id="a42f4-431">如果写入操作成功，则缓冲流中的位置将按写入的字节数向前移动。</span><span class="sxs-lookup"><span data-stu-id="a42f4-431">If the write operation is successful, the position within the buffered stream advances by the number of bytes written.</span></span> <span data-ttu-id="a42f4-432">如果发生异常，则缓冲流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="a42f4-432">If an exception occurs, the position within the buffered stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a42f4-433">字节数组，从该字节数组将 <paramref name="count" /> 个字节复制到当前缓冲流中。</span><span class="sxs-lookup"><span data-stu-id="a42f4-433">The byte array from which to copy <paramref name="count" /> bytes to the current buffered stream.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-434">缓冲区中的偏移量，从此处开始将字节复制到当前缓冲流中。</span><span class="sxs-lookup"><span data-stu-id="a42f4-434">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-435">要写入当前缓冲流中的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-435">The number of bytes to be written to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="a42f4-436">将字节复制到缓冲流，并将缓冲流内的当前位置前进写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-436">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a42f4-437">此代码示例是为类提供的更大示例的一部分 <xref:System.IO.BufferedStream> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-437">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-438"><paramref name="array" /> 的长度减去 <paramref name="offset" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-438">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-439"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-439"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-440"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-440"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a42f4-441">流关闭或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-441">The stream is closed or <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-442">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-442">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-443">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-443">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-444">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-444">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-445">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-445">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-446">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-446">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As ReadOnlyMemory(Of Byte), Optional cancellationToken As CancellationToken = Nothing) As ValueTask" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-447">从中写入数据的内存区域。</span><span class="sxs-lookup"><span data-stu-id="a42f4-447">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a42f4-448">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-448">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a42f4-449">默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-449">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a42f4-450">将字节的序列异步写入当前缓冲流，按写入的字节数向前移动该缓冲流中的当前位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a42f4-450">Asynchronously writes a sequence of bytes to the current buffered stream, advances the current position within this buffered stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a42f4-451">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-451">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a42f4-452">`WriteAsync`方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="a42f4-452">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="a42f4-453">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a42f4-453">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a42f4-454">异步方法与 `async` `await` Visual Basic 和 c # 中的和关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-454">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a42f4-455">使用 <xref:System.IO.BufferedStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-455">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="a42f4-456">如果在操作完成前取消该操作，则返回的任务包含 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 属性的值 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-456">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a42f4-457">从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a42f4-457">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="a42f4-458"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-458">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a42f4-459">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-459">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a42f4-460">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a42f4-460">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a42f4-461">将字节的序列异步写入当前流，将该流中的当前位置向前移动写入的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a42f4-461">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a42f4-462">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a42f4-462">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a42f4-463">可以通过创建类的实例 <xref:System.Threading.CancellationTokenSource> 并将 <xref:System.Threading.CancellationTokenSource.Token%2A> 属性作为参数传递来创建取消标记 `cancellationToken` 。</span><span class="sxs-lookup"><span data-stu-id="a42f4-463">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-464"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-464"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a42f4-465"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a42f4-465"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a42f4-466"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="a42f4-466">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-467">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-467">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-468">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a42f4-468">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a42f4-469">流正在由前一次写操作使用。</span><span class="sxs-lookup"><span data-stu-id="a42f4-469">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a42f4-470">要写入流的字节。</span><span class="sxs-lookup"><span data-stu-id="a42f4-470">A byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="a42f4-471">将一个字节写入缓冲流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a42f4-471">Writes a byte to the current position in the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a42f4-472">使用 <xref:System.IO.BufferedStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-472">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a42f4-473">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a42f4-473">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a42f4-474"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a42f4-474"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a42f4-475">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a42f4-475">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="/dotnet/standard/io/"><span data-ttu-id="a42f4-476">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a42f4-476">File and Stream I/O</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file"><span data-ttu-id="a42f4-477">如何：从文件中读取文本</span><span class="sxs-lookup"><span data-stu-id="a42f4-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file"><span data-ttu-id="a42f4-478">如何：将文本写入文件</span><span class="sxs-lookup"><span data-stu-id="a42f4-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
