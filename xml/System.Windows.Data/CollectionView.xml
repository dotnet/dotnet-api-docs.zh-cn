<Type Name="CollectionView" FullName="System.Windows.Data.CollectionView">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b96ac09311851043a485e04479a1a6f326c6d248" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102064521" /></Metadata><TypeSignature Language="C#" Value="public class CollectionView : System.Windows.Threading.DispatcherObject, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.ICollectionView, System.ComponentModel.INotifyPropertyChanged" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CollectionView extends System.Windows.Threading.DispatcherObject implements class System.Collections.IEnumerable, class System.Collections.Specialized.INotifyCollectionChanged, class System.ComponentModel.ICollectionView, class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.CollectionView" />
  <TypeSignature Language="VB.NET" Value="Public Class CollectionView&#xA;Inherits DispatcherObject&#xA;Implements ICollectionView, IEnumerable, INotifyCollectionChanged, INotifyPropertyChanged" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionView : System::Windows::Threading::DispatcherObject, System::Collections::IEnumerable, System::Collections::Specialized::INotifyCollectionChanged, System::ComponentModel::ICollectionView, System::ComponentModel::INotifyPropertyChanged" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type CollectionView = class&#xA;    inherit DispatcherObject&#xA;    interface IEnumerable&#xA;    interface INotifyCollectionChanged&#xA;    interface ICollectionView&#xA;    interface INotifyPropertyChanged" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class CollectionView : System.Windows.Threading.DispatcherObject, System.Collections.IEnumerable, System.ComponentModel.ICollectionView, System.ComponentModel.INotifyPropertyChanged" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class CollectionView&#xA;Inherits DispatcherObject&#xA;Implements ICollectionView, IEnumerable, INotifyPropertyChanged" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionView : System::Windows::Threading::DispatcherObject, System::Collections::IEnumerable, System::ComponentModel::ICollectionView, System::ComponentModel::INotifyPropertyChanged" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type CollectionView = class&#xA;    inherit DispatcherObject&#xA;    interface ICollectionView&#xA;    interface IEnumerable&#xA;    interface INotifyCollectionChanged&#xA;    interface INotifyPropertyChanged" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Specialized.INotifyCollectionChanged</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICollectionView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示用于对数据集合进行分组、排序、筛选和导航的视图。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不应在代码中创建此类的对象。 若要创建仅实现的集合的集合视图 <xref:System.Collections.IEnumerable> ，请创建一个 <xref:System.Windows.Data.CollectionViewSource> 对象，将集合添加到 <xref:System.Windows.Data.CollectionViewSource.Source%2A> 属性中，并从属性获取集合视图 <xref:System.Windows.Data.CollectionViewSource.View%2A> 。  
  
 您可以将集合视图看作绑定源集合的一个层，它允许您根据排序、筛选和组查询来导航并显示集合，所有这些操作都无需处理基础源集合本身。 如果源集合实现了 <xref:System.Collections.Specialized.INotifyCollectionChanged> 接口，则引发事件的更改将 <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> 传播到视图。  
  
 由于视图不会更改基础源集合，因此，源集合可以有多个关联的视图。 通过使用视图，可以通过不同方式显示相同的数据。 例如，您可以对对象集合使用两个视图， `Task` 以显示按优先级排序的任务（在页面的某个部分上按优先级排序），并在页面的另一部分上按区域分组。  
  
 在 WPF 应用程序中，所有集合都具有关联的默认集合视图。 绑定引擎始终通过关联视图访问集合，而不是直接使用集合。 若要获取默认视图，请使用 <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A?displayProperty=nameWithType> 方法。 基于的内部类 <xref:System.Windows.Data.CollectionView> 是仅实现的集合的默认视图 <xref:System.Collections.IEnumerable> 。 <xref:System.Windows.Data.ListCollectionView> 是实现的集合的默认视图 <xref:System.Collections.IList> 。 <xref:System.Windows.Data.BindingListCollectionView> 是实现或的集合的默认视图 <xref:System.ComponentModel.IBindingListView> <xref:System.ComponentModel.IBindingList> 。  
  
 或者，你可以通过使用类 Extensible Application Markup Language (XAML) 创建集合的视图 <xref:System.Windows.Data.CollectionViewSource> ，然后将控件绑定到该视图。 <xref:System.Windows.Data.CollectionViewSource>类是类的 XAML 表示形式 <xref:System.Windows.Data.CollectionView> 。 有关示例，请参阅 [如何：在 XAML 中使用视图对数据进行排序和分组](/dotnet/framework/wpf/data/how-to-sort-and-group-data-using-a-view-in-xaml)。  
  
 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 若要在 XAML 中设置视图，请使用 <xref:System.Windows.Data.CollectionViewSource> 类。 <xref:System.Windows.Data.CollectionViewSource> 是类的 XAML 表示形式 <xref:System.Windows.Data.CollectionView> ，它公开了类中最常使用的成员 <xref:System.Windows.Data.CollectionView> 。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CollectionView (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.#ctor(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CollectionView(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Windows.Data.CollectionView : System.Collections.IEnumerable -&gt; System.Windows.Data.CollectionView" Usage="new System.Windows.Data.CollectionView collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">基础集合。</param>
        <summary>初始化表示指定集合视图的 <see cref="T:System.Windows.Data.CollectionView" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的实例 <xref:System.Windows.Data.CollectionView> 绑定到此构造函数的调用方 (UI) 线程调度程序的用户界面。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsCrossThreadChanges">
      <MemberSignature Language="C#" Value="protected bool AllowsCrossThreadChanges { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsCrossThreadChanges" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AllowsCrossThreadChanges As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AllowsCrossThreadChanges { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowsCrossThreadChanges : bool" Usage="System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示创建的 <see cref="T:System.Windows.Data.CollectionView" /> 线程能更改 <see cref="P:System.Windows.Data.CollectionView.SourceCollection" /> 的值。</summary>
        <value>如果除创建 <see cref="T:System.Windows.Data.CollectionView" /> 外的线程可更改 <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFilter">
      <MemberSignature Language="C#" Value="public virtual bool CanFilter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanFilter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanFilter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFilter : bool" Usage="System.Windows.Data.CollectionView.CanFilter" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.CanFilter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图是否支持筛选。</summary>
        <value>如果视图支持筛选，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性返回 `false` ，则设置 <xref:System.Windows.Data.CollectionView.Filter%2A> 属性将引发异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGroup">
      <MemberSignature Language="C#" Value="public virtual bool CanGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanGroup" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanGroup As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanGroup { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGroup : bool" Usage="System.Windows.Data.CollectionView.CanGroup" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.CanGroup</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图是否支持分组。</summary>
        <value>在所有情况下均为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在添加之前，使用此属性来测试视图是否支持排序 <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A> 。 派生类重写此属性，以指示它们是否支持分组。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSort">
      <MemberSignature Language="C#" Value="public virtual bool CanSort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSort : bool" Usage="System.Windows.Data.CollectionView.CanSort" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.CanSort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图是否支持排序。</summary>
        <value>在所有情况下均为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在添加之前，使用此属性来测试视图是否支持排序 <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> 。 派生类重写此属性，以指示它们是否支持排序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChangeLog">
      <MemberSignature Language="C#" Value="protected void ClearChangeLog ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChangeLog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearChangeLog" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChangeLog ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChangeLog();" />
      <MemberSignature Language="F#" Value="member this.ClearChangeLog : unit -&gt; unit" Usage="collectionView.ClearChangeLog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("Replaced by ClearPendingChanges")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Replaced by ClearPendingChanges")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从更改日志中清除所有挂起的更改。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ClearPendingChanges">
      <MemberSignature Language="C#" Value="protected void ClearPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearPendingChanges();" />
      <MemberSignature Language="F#" Value="member this.ClearPendingChanges : unit -&gt; unit" Usage="collectionView.ClearPendingChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除未处理更改为集合。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Custom Event CollectionChanged As NotifyCollectionChangedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::Collections::Specialized::NotifyCollectionChangedEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " Usage="member this.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event CollectionChanged As NotifyCollectionChangedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-4.0">E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改树时发生。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IComparer Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IComparer ^ Comparer { System::Collections::IComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.IComparer" Usage="System.Windows.Data.CollectionView.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回可用于比较视图中的项的对象。</summary>
        <value>可用于比较视图中的项的 <see cref="T:System.Collections.IComparer" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="collectionView.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要检查的对象。</param>
        <summary>返回一个值，该值指示指定项是否属于视图。</summary>
        <returns>如果项属于视图，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会对项是否属于基础集合作出任何假设。 如果调用方知道项属于基础集合，则调用方法会更有效 <xref:System.Windows.Data.CollectionView.PassesFilter%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Data.CollectionView.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取视图中的记录数。</summary>
        <value>视图中的记录数，或者，如果记录数未知，则为-1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果设置了筛选器，则此属性值仅包括通过筛选器的项。 如果基础集合的类型为 <xref:System.Collections.IEnumerable> ，则这是一个 O (N) 操作。 此值将被缓存，直到集合更改。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从派生时 <see cref="T:System.Windows.Data.CollectionView" /> ，重写此属性以提供更有效的实现。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.CollectionView.Culture" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.Culture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置排序期间使用的区域性信息。</summary>
        <value>排序期间使用的区域性信息。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public virtual event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event CurrentChanged As EventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CurrentChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanged : EventHandler " Usage="member this.CurrentChanged : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanged As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ICollectionView.CurrentChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 更改后发生。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>在更改后引发此事件 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 。</para></block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanging">
      <MemberSignature Language="C#" Value="public virtual event System.ComponentModel.CurrentChangingEventHandler CurrentChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CurrentChangingEventHandler CurrentChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event CurrentChanging As CurrentChangingEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::CurrentChangingEventHandler ^ CurrentChanging;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanging : System.ComponentModel.CurrentChangingEventHandler " Usage="member this.CurrentChanging : System.ComponentModel.CurrentChangingEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanging As CurrentChangingEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ICollectionView.CurrentChanging</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CurrentChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 正在更改时发生。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>在更改之前引发此事件 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 。</para></block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanging" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItem">
      <MemberSignature Language="C#" Value="public virtual object CurrentItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ CurrentItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentItem : obj" Usage="System.Windows.Data.CollectionView.CurrentItem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.CurrentItem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取视图中的当前项。</summary>
        <value>视图中的当前项。 默认情况下，该集合的第一项作为当前项启动。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。  
  
 请注意，移动当前记录指针与应用于集合的任何排序或筛选操作都有一定的交互。 排序将在所选的最后一条记录上保留当前记录指针，但集合视图将围绕它进行重构。  (可能是所选记录之前位于列表的开头，但现在所选记录可能位于中间的某个位置。如果筛选后，) 筛选将保留选定记录。 否则，当前记录指针将设置为筛选的集合视图的第一条记录。  
  
 如果绑定的目标为单独值，则将自动绑定到集合的当前项。 如果目标为 <xref:System.Windows.Controls.ItemsControl> ，则当前项与选定项同步。 例如，如果列表框绑定到集合，则 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> 将与当前选定项同步。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>只有传递对其他内部对象的货币处理调用的类 <see cref="T:System.Windows.Data.CollectionView" /> 应重写此属性; 所有其他派生类应使用 <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> 方法更新存储在基类中的当前值。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CurrentPosition">
      <MemberSignature Language="C#" Value="public virtual int CurrentPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CurrentPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPosition : int" Usage="System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.CurrentPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 在（可能经过排序和筛选）视图中的序号位置。</summary>
        <value><see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 在（可能经过排序和筛选）视图中的序号位置。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>只有传递对其他内部对象的货币处理调用的类 <see cref="T:System.Windows.Data.CollectionView" /> 应重写此属性; 所有其他派生类应使用 <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> 方法更新存储在基类中的当前值。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DeferRefresh">
      <MemberSignature Language="C#" Value="public virtual IDisposable DeferRefresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable DeferRefresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DeferRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeferRefresh () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ DeferRefresh();" />
      <MemberSignature Language="F#" Value="abstract member DeferRefresh : unit -&gt; IDisposable&#xA;override this.DeferRefresh : unit -&gt; IDisposable" Usage="collectionView.DeferRefresh " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.DeferRefresh</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>进入延迟循环，该循环可用于将更改合并到视图并延迟自动刷新。</summary>
        <returns>一个可用于释放调用对象的 <see cref="T:System.IDisposable" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的用法是 `using` 使用此方法创建一个范围，然后在该范围内放置多个视图更改调用。 这会延迟自动刷新，直到延迟周期退出。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachFromSourceCollection">
      <MemberSignature Language="C#" Value="public virtual void DetachFromSourceCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetachFromSourceCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DetachFromSourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetachFromSourceCollection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DetachFromSourceCollection();" />
      <MemberSignature Language="F#" Value="abstract member DetachFromSourceCollection : unit -&gt; unit&#xA;override this.DetachFromSourceCollection : unit -&gt; unit" Usage="collectionView.DetachFromSourceCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Windows.Data.CollectionView" /> 中移除对基础集合的引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可取消订阅基础集合上的事件，并允许 <xref:System.Windows.Data.CollectionView> 垃圾回收。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual Predicate&lt;object&gt; Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Predicate`1&lt;object&gt; Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As Predicate(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Predicate&lt;System::Object ^&gt; ^ Filter { Predicate&lt;System::Object ^&gt; ^ get(); void set(Predicate&lt;System::Object ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : Predicate&lt;obj&gt; with get, set" Usage="System.Windows.Data.CollectionView.Filter" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.Filter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Predicate&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于确定某个项是否适合包含在视图中的方法。</summary>
        <value>一个委托，表示用于确定某个项是否适合包含在视图中的方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更简单的实现不支持筛选和引发 <xref:System.NotSupportedException> 。 在使用 <xref:System.Windows.Data.CollectionView.CanFilter%2A> 非 null 值分配此属性之前，请使用属性来测试是否支持筛选。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当前实现不支持筛选。</exception>
        <altmember cref="E:System.Windows.Data.CollectionViewSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collectionView.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回可用于枚举视图中的项的对象。</summary>
        <returns>一个可用于枚举视图中的项的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemAt">
      <MemberSignature Language="C#" Value="public virtual object GetItemAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetItemAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetItemAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemAt (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetItemAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetItemAt : int -&gt; obj&#xA;override this.GetItemAt : int -&gt; obj" Usage="collectionView.GetItemAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要检索的项的从零开始的索引。</param>
        <summary>检索视图中位于从零开始的指定索引处的项。</summary>
        <returns>视图中位于从零开始的指定索引处的项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用 <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> <xref:System.Windows.Data.CollectionView.Filter%2A> 在视图上设置的任何或属性值来计算索引。  
  
 如果基础集合的类型为 <xref:System.Collections.IEnumerable> ，则这是一个 O (N) 操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 0。</exception>
        <block subset="none" type="overrides"><para>从派生时 <see cref="T:System.Windows.Data.CollectionView" /> ，重写此方法以提供更有效的实现。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GroupDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt; GroupDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.ComponentModel.GroupDescription&gt; GroupDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GroupDescriptions As ObservableCollection(Of GroupDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ GroupDescriptions { System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupDescriptions : System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;" Usage="System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.GroupDescriptions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.ComponentModel.GroupDescription" /> 对象的集合，该集合描述集合中的项在视图中的分组方式。</summary>
        <value>在所有情况下均为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值始终为， `null` 因为 <xref:System.Windows.Data.CollectionView> 类不支持对其基础集合进行分组。 派生类 <xref:System.Windows.Data.ListCollectionView> 和 <xref:System.Windows.Data.BindingListCollectionView> do 支持分组。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.ListCollectionView.GroupDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;object&gt; Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyObservableCollection`1&lt;object&gt; Groups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As ReadOnlyObservableCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ Groups { System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;obj&gt;" Usage="System.Windows.Data.CollectionView.Groups" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.Groups</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取顶级组的集合，该集合根据 <see cref="P:System.Windows.Data.CollectionView.GroupDescriptions" /> 属性构造而成。</summary>
        <value>在所有情况下均为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值始终为， `null` 因为 <xref:System.Windows.Data.CollectionView> 类不支持对其基础集合进行分组。 派生类 <xref:System.Windows.Data.ListCollectionView> 和 <xref:System.Windows.Data.BindingListCollectionView> do 支持分组。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (item As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="collectionView.IndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要定位的项。</param>
        <summary>返回指定项所在的索引位置。</summary>
        <returns>指定项所在的索引位置，如果该项未知则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回-1 以外的索引，则必须始终为 true，查看 [index-1] < 项 <= 视图 [index]，其中使用 <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> 视图的方法（如果存在）进行比较。  
  
 某些事件处理程序使用方法的这一特定行为 <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> 来加快对插入和删除的反应。 如果派生类不重写此方法，则侦听器使用方法执行二进制搜索 <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentAfterLast">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentAfterLast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentAfterLast" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentAfterLast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentAfterLast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentAfterLast : bool" Usage="System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.IsCurrentAfterLast</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 是否超出集合的末尾。</summary>
        <value>如果视图的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 超出集合的末尾，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentBeforeFirst">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentBeforeFirst { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentBeforeFirst" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentBeforeFirst As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentBeforeFirst { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentBeforeFirst : bool" Usage="System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.IsCurrentBeforeFirst</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 是否在集合开头之前。</summary>
        <value>如果视图的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 在集合开头之前，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentInSync">
      <MemberSignature Language="C#" Value="protected bool IsCurrentInSync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentInSync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsCurrentInSync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsCurrentInSync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentInSync : bool" Usage="System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 是否位于 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />。</summary>
        <value>如果 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 位于视图中且位于 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> 处，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="protected bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Windows.Data.CollectionView.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示基础集合是否提供更改通知。</summary>
        <value>如果基础集合提供更改通知，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public virtual bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Data.CollectionView.IsEmpty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示最终的（已筛选）视图是否为空。</summary>
        <value>如果获得的视图为空，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInUse">
      <MemberSignature Language="C#" Value="public virtual bool IsInUse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInUse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsInUse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInUse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInUse : bool" Usage="System.Windows.Data.CollectionView.IsInUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示所有对象是否支持此 <see cref="T:System.Windows.Data.CollectionView" /> 事件的值。</summary>
        <value>如果任何对象订阅此 <see cref="T:System.Windows.Data.CollectionView" /> 的事件，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRefreshDeferred">
      <MemberSignature Language="C#" Value="protected bool IsRefreshDeferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRefreshDeferred" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsRefreshDeferred As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsRefreshDeferred { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRefreshDeferred : bool" Usage="System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否有某个未完成的 <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> 正在运行。</summary>
        <value>如果有某个未完成的 <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> 正在运行，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>派生类应避免 <see cref="M:System.Windows.Data.CollectionView.Refresh" /> 在返回时调用 <see cref="P:System.Windows.Data.CollectionView.IsRefreshDeferred" /> <see langword="true" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentTo">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentTo (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentTo(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentTo (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentTo(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentTo : obj -&gt; bool&#xA;override this.MoveCurrentTo : obj -&gt; bool" Usage="collectionView.MoveCurrentTo item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 的项。</param>
        <summary>将指定项设置为视图中的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果最终的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 位于视图中，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果找不到指定的项，则方法将返回， `false` 并且 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> 定位在视图中集合的开头之前。  
  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 有关视图的当前项的详细信息，请参阅 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> 。  
  
   
  
## Examples  
 下面的示例演示如何使用此方法。  
  
 [!code-csharp[Colors#NewColor](~/samples/snippets/csharp/VS_Snippets_Wpf/Colors/CSharp/Colors.xaml.cs#newcolor)]
 [!code-vb[Colors#NewColor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Colors/visualbasic/colors.xaml.vb#newcolor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToFirst">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToFirst () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToFirst();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToFirst : unit -&gt; bool&#xA;override this.MoveCurrentToFirst : unit -&gt; bool" Usage="collectionView.MoveCurrentToFirst " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentToFirst</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将视图中的第一项设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果所生成的<see langword="true" /> 是视图中的项，则为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToLast">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToLast () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToLast();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToLast : unit -&gt; bool&#xA;override this.MoveCurrentToLast : unit -&gt; bool" Usage="collectionView.MoveCurrentToLast " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentToLast</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将视图中的最后一项设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果所生成的<see langword="true" /> 是视图中的项，则为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToNext">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToNext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToNext : unit -&gt; bool&#xA;override this.MoveCurrentToNext : unit -&gt; bool" Usage="collectionView.MoveCurrentToNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentToNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将视图中位于 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 之后的项设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果所生成的<see langword="true" /> 是视图中的项，则为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPosition">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPosition(int position);" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToPosition : int -&gt; bool&#xA;override this.MoveCurrentToPosition : int -&gt; bool" Usage="collectionView.MoveCurrentToPosition position" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentToPosition(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">一个索引位置，位于该位置的项将设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</param>
        <summary>将位于指定索引位置的项设置为视图中的 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果所生成的<see langword="true" /> 是视图中的项，则为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPrevious">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPrevious();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToPrevious : unit -&gt; bool&#xA;override this.MoveCurrentToPrevious : unit -&gt; bool" Usage="collectionView.MoveCurrentToPrevious " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.MoveCurrentToPrevious</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将视图中位于 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 之前的项设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />。</summary>
        <returns>如果所生成的<see langword="true" /> 是视图中的项，则为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合视图支持当前记录指针的概念。 当您在 "集合" 视图中导航对象时，您将移动一个记录指针，该指针允许您检索存在于集合中该特定位置的对象。 有关详细信息，请参阅 [数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)中的 "绑定到集合"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="NeedsRefresh">
      <MemberSignature Language="C#" Value="public virtual bool NeedsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NeedsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NeedsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool NeedsRefresh { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NeedsRefresh : bool" Usage="System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示视图是否需要刷新。</summary>
        <value>如果视图需要刷新，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示视图的内部状态是否已更改并需要 <xref:System.Windows.Data.CollectionView.Refresh%2A> 方法调用。 典型的情况是，当 <xref:System.ComponentModel.SortDescription> 视图处于延迟刷新周期时，如果已将或类似添加到视图中 (请参阅 <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>) 。 在这种情况下，不需要对进行显式调用 <xref:System.Windows.Data.CollectionView.Refresh%2A> ; 在延迟刷新周期结束后，视图将自动调用刷新。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.Refresh" />
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
      </Docs>
    </Member>
    <Member MemberName="NewItemPlaceholder">
      <MemberSignature Language="C#" Value="public static object NewItemPlaceholder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object NewItemPlaceholder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewItemPlaceholder As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ NewItemPlaceholder { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewItemPlaceholder : obj" Usage="System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取集合中表示新项的对象。</summary>
        <value>集合中表示新项的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Windows.Data.CollectionView> 实现的 <xref:System.ComponentModel.IEditableCollectionView> 已 <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> 设置为 <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> 或，则会将 <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd> <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> 添加到集合中。  <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>始终出现在集合中; 它不参与分组、排序或筛选。  
  
 <xref:System.Windows.Data.CollectionView.CurrentItem%2A>不能为 <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> 。 执行相对导航的方法（如）将 <xref:System.Windows.Data.CollectionView.MoveCurrentToNext%2A> 跳过 <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> 。  <xref:System.Windows.Data.CollectionView.MoveCurrentToFirst%2A><xref:System.Windows.Data.CollectionView.MoveCurrentToLast%2A> <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> 如果 <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> 设置为 <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> 或，则跳过 <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd> 。 如果是，则执行绝对导航（如）的方法 <xref:System.Windows.Data.CollectionView.MoveCurrentToPosition%2A> 不执行任何操作 <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> <xref:System.Windows.Data.CollectionView.CurrentItem%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OKToChangeCurrent">
      <MemberSignature Language="C#" Value="protected bool OKToChangeCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool OKToChangeCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OKToChangeCurrent" />
      <MemberSignature Language="VB.NET" Value="Protected Function OKToChangeCurrent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool OKToChangeCurrent();" />
      <MemberSignature Language="F#" Value="member this.OKToChangeCurrent : unit -&gt; bool" Usage="collectionView.OKToChangeCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示视图是否可以更改作为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 的项。</summary>
        <returns>如果侦听器取消了更改，则为 <see langword="false" />；否则为 <see langword="true" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAllowsCrossThreadChangesChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAllowsCrossThreadChangesChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAllowsCrossThreadChangesChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnAllowsCrossThreadChangesChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAllowsCrossThreadChangesChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAllowsCrossThreadChangesChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnAllowsCrossThreadChangesChanged : unit -&gt; unit&#xA;override this.OnAllowsCrossThreadChangesChanged : unit -&gt; unit" Usage="collectionView.OnAllowsCrossThreadChangesChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当 <see cref="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginChangeLogging">
      <MemberSignature Language="C#" Value="protected virtual void OnBeginChangeLogging (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeginChangeLogging(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeginChangeLogging (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeginChangeLogging(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginChangeLogging : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnBeginChangeLogging : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnBeginChangeLogging args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("Replaced by OnAllowsCrossThreadChangesChanged")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Replaced by OnAllowsCrossThreadChangesChanged")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">添加到更改日志的 <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> 对象。</param>
        <summary>由基类调用，以通知派生类 <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" /> 事件已发送到消息队列。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCollectionChanged">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>引发 <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> 事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnCollectionChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">要传递给事件处理程序的 <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用此方法以引发事件之前，请考虑对条件进行任何排序、筛选或分组 <xref:System.Windows.Data.CollectionView.CollectionChanged> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected void OnCollectionChanged (object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCollectionChanged(object sender, class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCollectionChanged (sender As Object, args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCollectionChanged(System::Object ^ sender, System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionChanged : obj * System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnCollectionChanged (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的发送方。</param>
        <param name="args">要传递给事件处理程序的 <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法 <xref:System.Windows.Data.CollectionView.ProcessCollectionChanged%2A> 在正确的 UI 线程调度程序上并且从未从其他线程进行更新，则调用此方法，或将更改发布到调度程序，以便在正确的线程上处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanged : unit -&gt; unit&#xA;override this.OnCurrentChanged : unit -&gt; unit" Usage="collectionView.OnCurrentChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see cref="E:System.Windows.Data.CollectionView.CurrentChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCurrentChanging">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>引发 <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> 事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected void OnCurrentChanging ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCurrentChanging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCurrentChanging ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCurrentChanging();" />
      <MemberSignature Language="F#" Value="member this.OnCurrentChanging : unit -&gt; unit" Usage="collectionView.OnCurrentChanging " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发一个不可取消的 <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将设置 <xref:System.Windows.Data.CollectionView.CurrentPosition%2A> 为-1。 此方法由影响的集合更改调用 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanging (System.ComponentModel.CurrentChangingEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanging(class System.ComponentModel.CurrentChangingEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging(System.ComponentModel.CurrentChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanging (args As CurrentChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanging(System::ComponentModel::CurrentChangingEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanging : System.ComponentModel.CurrentChangingEventArgs -&gt; unit&#xA;override this.OnCurrentChanging : System.ComponentModel.CurrentChangingEventArgs -&gt; unit" Usage="collectionView.OnCurrentChanging args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.ComponentModel.CurrentChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">有关事件的信息。</param>
        <summary>用指定的参数引发 <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="collectionView.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要引发事件的自变量。</param>
        <summary>用指定的参数引发 <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PassesFilter">
      <MemberSignature Language="C#" Value="public virtual bool PassesFilter (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PassesFilter(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.PassesFilter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PassesFilter (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PassesFilter(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PassesFilter : obj -&gt; bool&#xA;override this.PassesFilter : obj -&gt; bool" Usage="collectionView.PassesFilter item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要检查的项。</param>
        <summary>返回一个值，该值指示基础集合中的指定项是否属于视图。</summary>
        <returns>如果指定项属于视图或未对集合视图设置筛选器，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Windows.Data.CollectionView.Contains%2A> 方法不同，此方法假定指定项属于基础集合。 此方法使用筛选器。 通常，在集合更改通知期间使用此方法来确定已添加或已删除的项是否需要处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void ProcessCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ProcessCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ProcessCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ProcessCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.ProcessCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.ProcessCollectionChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">要处理的 <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> 对象。</param>
        <summary>当在派生类中重写时，处理 UI 线程上的单个更改。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>必须在派生类中重写此方法，以处理 UI 线程上的单个更改。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessPendingChanges">
      <MemberSignature Language="C#" Value="protected void ProcessPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessPendingChanges();" />
      <MemberSignature Language="F#" Value="member this.ProcessPendingChanges : unit -&gt; unit" Usage="collectionView.ProcessPendingChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确保此集合的所有待定更改都已被提交。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Custom Event PropertyChanged As PropertyChangedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberSignature Language="F#" Value="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " Usage="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event PropertyChanged As PropertyChangedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-4.0">E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在属性值更改时发生。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="collectionView.Refresh " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICollectionView.Refresh</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新创建视图。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置 <xref:System.Windows.Data.CollectionView.Filter%2A> 、 <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> 或属性时， <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A> 会进行刷新。  <xref:System.Windows.Data.CollectionView.Refresh%2A>设置这些属性之一后，就不必立即调用方法。 有关如何延迟自动刷新的信息，请参阅 <xref:System.Windows.Data.CollectionView.DeferRefresh%2A> 。  
  
 派生类使用受保护的 <xref:System.Windows.Data.CollectionView.RefreshOverride%2A> 方法来重写此方法的行为。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
        <altmember cref="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      </Docs>
    </Member>
    <Member MemberName="RefreshOrDefer">
      <MemberSignature Language="C#" Value="protected void RefreshOrDefer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RefreshOrDefer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOrDefer" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RefreshOrDefer ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RefreshOrDefer();" />
      <MemberSignature Language="F#" Value="member this.RefreshOrDefer : unit -&gt; unit" Usage="collectionView.RefreshOrDefer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刷新视图或指定视图在延迟循环完成后需要刷新。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshOverride">
      <MemberSignature Language="C#" Value="protected virtual void RefreshOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RefreshOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RefreshOverride ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RefreshOverride();" />
      <MemberSignature Language="F#" Value="abstract member RefreshOverride : unit -&gt; unit&#xA;override this.RefreshOverride : unit -&gt; unit" Usage="collectionView.RefreshOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新创建视图。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>派生类应重写此方法以更改方法的行为 <see cref="M:System.Windows.Data.CollectionView.Refresh" /> 。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCurrent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置 <see cref="T:System.Windows.Data.CollectionView" /> 的当前项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition);" />
      <MemberSignature Language="F#" Value="member this.SetCurrent : obj * int -&gt; unit" Usage="collectionView.SetCurrent (newItem, newPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">要设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 的项。</param>
        <param name="newPosition">要设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> 属性值的值。</param>
        <summary>将指定项和索引设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 和 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> 属性的值。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition, int count);" />
      <MemberSignature Language="F#" Value="member this.SetCurrent : obj * int * int -&gt; unit" Usage="collectionView.SetCurrent (newItem, newPosition, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">要设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 的项。</param>
        <param name="newPosition">要设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> 属性值的值。</param>
        <param name="count"><see cref="T:System.Windows.Data.CollectionView" /> 中的项数。</param>
        <summary>将指定项和索引设置为 <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> 和 <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> 属性的值。 可以从派生类的构造函数中调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从派生类的构造函数调用此重载。  不要将 <xref:System.Windows.Data.CollectionView.Count%2A> 属性（它是虚拟属性）作为进行传递 `count` 。 相反，传递表示集合的内部的计数 <xref:System.Collections.IList> 。  
  
 <xref:System.Windows.Data.CollectionView.SetCurrent%2A> .NET Framework 版本3.5 中引入。  有关详细信息，请参见[版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.SortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.SortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As SortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::SortDescriptionCollection ^ SortDescriptions { System::ComponentModel::SortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.SortDescriptionCollection" Usage="System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.SortDescriptions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.SortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.ComponentModel.SortDescription" /> 结构的集合，该集合描述集合中的项在视图中的排序方式。</summary>
        <value>在所有情况下均为空 <see cref="T:System.ComponentModel.SortDescriptionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能向 <xref:System.ComponentModel.SortDescription> 返回 (空) 集合中添加，因为基类不 <xref:System.Windows.Data.CollectionView> 支持排序。 相反，请使用派生类，这样就 <xref:System.Windows.Data.ListCollectionView> <xref:System.Windows.Data.BindingListCollectionView> 支持排序。 另外， <xref:System.Windows.Data.CollectionView.CanSort%2A> 在添加或删除对象之前，请检查属性 <xref:System.ComponentModel.SortDescription> 以避免异常。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionViewSource.SortDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="SourceCollection">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerable SourceCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable SourceCollection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SourceCollection As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IEnumerable ^ SourceCollection { System::Collections::IEnumerable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceCollection : System.Collections.IEnumerable" Usage="System.Windows.Data.CollectionView.SourceCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionView.SourceCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回未筛选的基础集合。</summary>
        <value>属于基础集合的 <see cref="T:System.Collections.IEnumerable" /> 对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collectionView.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回可用于枚举视图中的项的 <see cref="T:System.Collections.IEnumerator" /> 对象。</summary>
        <returns>一个可用于枚举视图中的项的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged">
      <MemberSignature Language="C#" Value="event System.Collections.Specialized.NotifyCollectionChangedEventHandler System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.System#Collections#Specialized#INotifyCollectionChanged#CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Custom Event CollectionChanged As NotifyCollectionChangedEventHandler Implements System.Collections.Specialized.INotifyCollectionChanged" />
      <MemberSignature Language="F#" Value="member this.System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " Usage="member this.System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改树时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.INotifyPropertyChanged.PropertyChanged">
      <MemberSignature Language="C#" Value="event System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.System#ComponentModel#INotifyPropertyChanged#PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Custom Event PropertyChanged As PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged" />
      <MemberSignature Language="F#" Value="member this.System.ComponentModel.INotifyPropertyChanged.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " Usage="member this.System.ComponentModel.INotifyPropertyChanged.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在属性值更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedOutsideDispatcher">
      <MemberSignature Language="C#" Value="protected bool UpdatedOutsideDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UpdatedOutsideDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property UpdatedOutsideDispatcher As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UpdatedOutsideDispatcher { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdatedOutsideDispatcher : bool" Usage="System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否有必要更新更改日志，因为在 <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> 没有首先进入用户界面 (UI) 线程调度程序的情况下，已在其他线程上收到通知。</summary>
        <value><see langword="true" /> 如果有必要更新更改日志，因为在 <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> 未首先输入用户界面 (UI) 线程调度程序的情况下，在其他线程上收到通知，则为; 否则为 <see langword="false" /> 。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>
