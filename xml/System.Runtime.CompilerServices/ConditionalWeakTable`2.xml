<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3661f27a93d1a21ead2b13cee75c7e760e6fc3d9" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77240113" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="f04e5-101">字段所附加到的引用类型。</span><span class="sxs-lookup"><span data-stu-id="f04e5-101">The reference type to which the field is attached.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="f04e5-102">字段的类型。</span><span class="sxs-lookup"><span data-stu-id="f04e5-102">The field's type.</span></span> <span data-ttu-id="f04e5-103">此类型必须是引用类型。</span><span class="sxs-lookup"><span data-stu-id="f04e5-103">This must be a reference type.</span></span></typeparam>
    <summary><span data-ttu-id="f04e5-104">使编译器可以将对象字段动态附加到托管对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-104">Enables compilers to dynamically attach object fields to managed objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-105"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类使语言编译器可以在运行时将任意属性附加到托管对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="f04e5-106"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 对象是一个字典，该字典将由键表示的托管对象绑定到其附加属性，该对象由值表示。</span><span class="sxs-lookup"><span data-stu-id="f04e5-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="f04e5-107">对象的键是属性附加到的 `TKey` 类的单个实例，其值是分配给相应对象的属性值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="f04e5-108">密钥必须唯一;换句话说，<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类支持每个托管对象一个附加值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="f04e5-109">如果将两个键传递到 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法返回 `true`，则这两个键相等。</span><span class="sxs-lookup"><span data-stu-id="f04e5-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f04e5-110">不能通过重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 来控制相等比较，以显式设置键的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="f04e5-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="f04e5-111"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类不使用 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 方法来计算哈希代码，因此不会调用 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 重写。</span><span class="sxs-lookup"><span data-stu-id="f04e5-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="f04e5-112">尽管 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类包含键/值对的集合，但最好将其视为表而不是字典对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="f04e5-113"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类在以下几个方面不同于字典：</span><span class="sxs-lookup"><span data-stu-id="f04e5-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="f04e5-114">它不会保留密钥。</span><span class="sxs-lookup"><span data-stu-id="f04e5-114">It does not persist keys.</span></span> <span data-ttu-id="f04e5-115">也就是说，键不会保持活动状态，因为它是集合的成员。</span><span class="sxs-lookup"><span data-stu-id="f04e5-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="f04e5-116">它不包含字典通常具有的所有方法（如 `GetEnumerator` 或 `Contains`）。</span><span class="sxs-lookup"><span data-stu-id="f04e5-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="f04e5-117">它不实现 <xref:System.Collections.Generic.IDictionary%602> 接口。</span><span class="sxs-lookup"><span data-stu-id="f04e5-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="f04e5-118"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类不同于其管理存储在集合中的键的对象生存期的其他集合对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="f04e5-119">通常情况下，当对象存储在集合中时，它的生存期将一直持续到删除（不存在对对象的其他引用）或直到集合对象本身被销毁。</span><span class="sxs-lookup"><span data-stu-id="f04e5-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="f04e5-120">但是，在 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 类中，将键/值对添加到表并不能确保该密钥将保持不变，即使该密钥可以直接从表中存储的值进行访问（例如，如果表包含一个键，A，值为 V1，第二个键 B 的值 P2 包含对的引用）。</span><span class="sxs-lookup"><span data-stu-id="f04e5-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="f04e5-121">相反，<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 会立即自动删除键/值项，因为表之外不存在对键的其他引用。</span><span class="sxs-lookup"><span data-stu-id="f04e5-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="f04e5-122">说明如示例所示。</span><span class="sxs-lookup"><span data-stu-id="f04e5-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f04e5-123">下面的示例演示了在销毁表外部的引用后，存储在 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表中的键不会保留。</span><span class="sxs-lookup"><span data-stu-id="f04e5-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="f04e5-124">该示例定义两个类： `ManagedClass`，表示表中的键，`ClassData`，表示键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="f04e5-125">该示例实例化每个类型的三个对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="f04e5-126">它还将实例化表示第二个 `ManagedClass`的 <xref:System.WeakReference> 对象，然后销毁第二个 `ManagedClass` 实例。</span><span class="sxs-lookup"><span data-stu-id="f04e5-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="f04e5-127">尝试从 <xref:System.WeakReference.Target%2A> 属性检索第二个 `ManagedClass` 对象时，表示不保留对该对象的引用。</span><span class="sxs-lookup"><span data-stu-id="f04e5-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f04e5-128"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 类的实例是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span></span> <span data-ttu-id="f04e5-129">它们不需要调用方执行任何其他锁定。</span><span class="sxs-lookup"><span data-stu-id="f04e5-129">They do not require callers to do any additional locking.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f04e5-130">初始化 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f04e5-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-131"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> 构造函数实例化一个空的 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表;也就是说，表中不包含键/值对。</span><span class="sxs-lookup"><span data-stu-id="f04e5-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="f04e5-132">可以通过调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>或 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 方法来添加键/值对。</span><span class="sxs-lookup"><span data-stu-id="f04e5-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="f04e5-133"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 对象中的每个键都必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="f04e5-134">如果键引用相同的对象（即，如果将它们作为参数传递给 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法返回 `true`），则它们不是唯一的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-135">要添加的键。</span><span class="sxs-lookup"><span data-stu-id="f04e5-135">The key to add.</span></span> <span data-ttu-id="f04e5-136"><paramref name="key" /> 表示该属性附加到的对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-136"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="value"><span data-ttu-id="f04e5-137">该键的属性值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-137">The key's property value.</span></span></param>
        <summary><span data-ttu-id="f04e5-138">将键添加到表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-138">Adds a key to the table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-139"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 对象中的每个键都必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="f04e5-140">如果键引用相同的对象（即，如果将它们作为参数传递给 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 方法返回 `true`），则它们不是唯一的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="f04e5-141">如果在加法运算过程中对该密钥进行垃圾回收，则会删除现有的键/值对，并添加新的键/值对，而不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f04e5-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f04e5-142">下面的示例定义了一个 `MainClass` 类和一个 `MainInfo` 类，该类提供 `MainClass` 实例的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f04e5-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="f04e5-143">然后，该示例调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 方法，将 `MainClass` 对象及其附加 `MainInfo` 对象添加到 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="f04e5-144">该示例还说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 和 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法的调用，以便向表中添加键/值对，并说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法的调用以检索现有键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-145"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-145"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f04e5-146"><paramref name="key" /> 已存在。</span><span class="sxs-lookup"><span data-stu-id="f04e5-146"><paramref name="key" /> already exists.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-147">要添加或更新的键。</span><span class="sxs-lookup"><span data-stu-id="f04e5-147">The key to add or update.</span></span> <span data-ttu-id="f04e5-148">可能不为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-148">May not be <see langword="null" />.</span></span></param>
        <param name="value"><span data-ttu-id="f04e5-149">要与 <paramref name="key" /> 关联的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-149">The value to associate with <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="f04e5-150">如果键不存在，则添加键和值，或如果其不存在，则更新现有键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-150">Adds the key and value if the key doesn't exist, or updates the existing key's value if it does exist.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-151"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-151"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f04e5-152">清除所有键/值对。</span><span class="sxs-lookup"><span data-stu-id="f04e5-152">Clears all the key/value pairs.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f04e5-153">确保垃圾回收器回收 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 对象时释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="f04e5-153">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-154">当当前对象准备好完成时，垃圾回收器将调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="f04e5-154">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-155">要搜索的键。</span><span class="sxs-lookup"><span data-stu-id="f04e5-155">The key to search for.</span></span> <span data-ttu-id="f04e5-156"><paramref name="key" /> 表示该属性附加到的对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-156"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <summary><span data-ttu-id="f04e5-157">以原子方式在表中搜索指定键，并返回对应的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-157">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="f04e5-158">如果表中不存在该键，此方法将调用表示表值的类的无参数构造函数，以创建绑定到指定键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-158">If the key does not exist in the table, the method invokes the parameterless constructor of the class that represents the table's value to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="f04e5-159">如果表中已存在 <paramref name="key" />，则为对应于 <paramref name="key" /> 的值；否则为 <paramref name="TValue" /> 范型类型参数定义的类的无参数构造函数创建的新值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-159">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the parameterless constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-160">如果表中不存在 `key`，则方法将添加它，以及通过调用由 `TValue` 泛型类型参数定义的类的无参数构造函数来实例化的对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-160">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the parameterless constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="f04e5-161">如果 `TValue` 类没有无参数构造函数，则将引发 <xref:System.MissingMethodException>。</span><span class="sxs-lookup"><span data-stu-id="f04e5-161">If the `TValue` class has no parameterless constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="f04e5-162">如果表值的类定义无参数的构造函数，则建议使用此方法检索现有值或向 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表添加新值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-162">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a parameterless constructor.</span></span> <span data-ttu-id="f04e5-163">如果它未定义无参数构造函数，则可以改为调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法，该方法依赖于回调提供的方法来实例化表示表值的对象</span><span class="sxs-lookup"><span data-stu-id="f04e5-163">If it does not define a parameterless constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="f04e5-164">若要检索现有键的值而不添加键/值对（如果在表中找不到该键），请调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f04e5-164">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f04e5-165">下面的示例定义了一个 `MainClass` 类和一个 `MainInfo` 类，该类提供 `MainClass` 实例的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f04e5-165">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="f04e5-166">该示例调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 方法，将 `MainClass` 对象及其附加 `MainInfo` 对象添加到 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-166">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="f04e5-167">该示例还说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 和 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法的调用，以便向表中添加键/值对，并说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法的调用以检索现有键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-167">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-168"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-168"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f04e5-169">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.MissingMemberException" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-169">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f04e5-170">表示表中值的类未定义无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="f04e5-170">The class that represents the table's value does not define a parameterless constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-171">要搜索的键。</span><span class="sxs-lookup"><span data-stu-id="f04e5-171">The key to search for.</span></span> <span data-ttu-id="f04e5-172"><paramref name="key" /> 表示该属性附加到的对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-172"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="createValueCallback"><span data-ttu-id="f04e5-173">可以为给定 <paramref name="key" /> 创建值的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="f04e5-173">A delegate to a method that can create a value for the given <paramref name="key" />.</span></span> <span data-ttu-id="f04e5-174">它只有一个 <c>TKey</c> 类型的参数，并返回一个 <c>TValue</c> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-174">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span></span></param>
        <summary><span data-ttu-id="f04e5-175">以原子方式在表中搜索指定键，并返回对应的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-175">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="f04e5-176">如果表中不存在该键，此方法将调用一个回调方法来创建绑定到指定键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-176">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="f04e5-177">如果表中已存在 <paramref name="key" />，则为附加到 <paramref name="key" /> 的值；否则为 <paramref name="createValueCallback" /> 委托返回的新值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-177">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-178">如果表中不存在 `key`，<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 调用由 `createValueCallback` 参数定义的方法，并向其传递密钥。</span><span class="sxs-lookup"><span data-stu-id="f04e5-178">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="f04e5-179">新值绑定到表中的键，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="f04e5-179">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="f04e5-180">仅当表示表值的类未定义无参数的构造函数时，才使用此方法。</span><span class="sxs-lookup"><span data-stu-id="f04e5-180">Use this method only when the class that represents the table's value does not define a parameterless constructor.</span></span> <span data-ttu-id="f04e5-181">如果它定义了无参数的构造函数，请改用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f04e5-181">If it does define a parameterless constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="f04e5-182">若要检索现有键的值而不添加键/值对（如果在表中找不到该键），请调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f04e5-182">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="f04e5-183">如果多个线程尝试创建相同的键，则可以用相同的键多次调用 `createValueCallback`。</span><span class="sxs-lookup"><span data-stu-id="f04e5-183">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="f04e5-184">只有其中一个调用将成功，并且其返回值将添加到表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-184">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="f04e5-185">哪个线程成功创建值是不确定的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-185">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="f04e5-186">此规则允许表调用内部表锁之外的 `createValueCallback` 以防止死锁。</span><span class="sxs-lookup"><span data-stu-id="f04e5-186">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f04e5-187">下面的示例定义了一个 `MainClass` 类和一个 `MainInfo` 类，该类提供 `MainClass` 实例的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f04e5-187">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="f04e5-188">它还定义了一个静态（`Shared` Visual Basic） `CreateAttachedValue` 方法，该方法可分配给 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> 委托并传递给 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f04e5-188">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="f04e5-189">该示例调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法，将 `MainClass` 对象及其附加 `MainInfo` 对象添加到 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-189">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="f04e5-190">该示例还说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 和 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 方法的调用，以便向表中添加键/值对，并说明了对 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法的调用以检索现有键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-190">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-191"><paramref name="key" /> 或 <paramref name="createValueCallback" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-191"><paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-192">要删除的键。</span><span class="sxs-lookup"><span data-stu-id="f04e5-192">The key to remove.</span></span></param>
        <summary><span data-ttu-id="f04e5-193">从表中移除某个键及其值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-193">Removes a key and its value from the table.</span></span></summary>
        <returns><span data-ttu-id="f04e5-194">如果找到并移除该键，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-194"><see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-195">如果在此操作过程中对密钥进行垃圾回收，则该方法不会引发异常，并且返回值是不确定的。</span><span class="sxs-lookup"><span data-stu-id="f04e5-195">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-196"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-196"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f04e5-197">返回一个可用于循环访问 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 表的枚举器。</span><span class="sxs-lookup"><span data-stu-id="f04e5-197">Returns an enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></summary>
        <returns><span data-ttu-id="f04e5-198">一个可用于循环访问 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 表的枚举器。</span><span class="sxs-lookup"><span data-stu-id="f04e5-198">An enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f04e5-199">返回的枚举器不会扩展表中除当前表之外的任何对象对的生存期。</span><span class="sxs-lookup"><span data-stu-id="f04e5-199">The returned enumerator does not extend the lifetime of any object pairs in the table, other than the current one.</span></span> <span data-ttu-id="f04e5-200">它不返回已收集或在检索枚举器后添加的项。</span><span class="sxs-lookup"><span data-stu-id="f04e5-200">It does not return entries that have already been collected or that were added after the enumerator was retrieved.</span></span> <span data-ttu-id="f04e5-201">此外，它不会返回检索枚举器时存在的所有条目，例如，在检索枚举器之后但在枚举枚举器之前收集或删除的条目。</span><span class="sxs-lookup"><span data-stu-id="f04e5-201">Additionally, it may not return all entries that were present when the enumerator was retrieved, for example, entries that were collected or removed after the enumerator was retrieved but before they were enumerated.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f04e5-202">返回一个可用于循环访问 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 表的枚举器。</span><span class="sxs-lookup"><span data-stu-id="f04e5-202">Returns an enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></summary>
        <returns><span data-ttu-id="f04e5-203">一个可用于循环访问 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 表的枚举器。</span><span class="sxs-lookup"><span data-stu-id="f04e5-203">An enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f04e5-204">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="f04e5-204">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="f04e5-205">它只能在 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 实例被强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="f04e5-205">It can be used only when the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span>

<span data-ttu-id="f04e5-206">返回的枚举器不会扩展表中除当前表之外的任何对象对的生存期。</span><span class="sxs-lookup"><span data-stu-id="f04e5-206">The returned enumerator does not extend the lifetime of any object pairs in the table, other than the current one.</span></span> <span data-ttu-id="f04e5-207">它不返回已收集或在检索枚举器后添加的项。</span><span class="sxs-lookup"><span data-stu-id="f04e5-207">It does not return entries that have already been collected or that were added after the enumerator was retrieved.</span></span> <span data-ttu-id="f04e5-208">此外，它不会返回检索枚举器时存在的所有条目，例如，在检索枚举器之后但在枚举枚举器之前收集或删除的条目。</span><span class="sxs-lookup"><span data-stu-id="f04e5-208">Additionally, it may not return all entries that were present when the enumerator was retrieved, for example, entries that were collected or removed after the enumerator was retrieved but before they were enumerated.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key * 'Value -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="f04e5-209">一个键，表示具有所附加的属性的对象。</span><span class="sxs-lookup"><span data-stu-id="f04e5-209">The key that represents an object with an attached property.</span></span></param>
        <param name="value"><span data-ttu-id="f04e5-210">此方法返回时，将包含所附加的属性值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-210">When this method returns, contains the attached property value.</span></span> <span data-ttu-id="f04e5-211">如果找不到 <paramref name="key" />，则 <paramref name="value" /> 包含默认值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-211">If <paramref name="key" /> is not found, <paramref name="value" /> contains the default value.</span></span></param>
        <summary><span data-ttu-id="f04e5-212">获取指定键的值。</span><span class="sxs-lookup"><span data-stu-id="f04e5-212">Gets the value of the specified key.</span></span></summary>
        <returns><span data-ttu-id="f04e5-213">如果找到 <see langword="true" />，则为 <paramref name="key" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-213"><see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f04e5-214">如果在此操作过程中对该密钥进行垃圾回收，则该方法可能返回 `false` 并将 `value` 设置为默认值（如同该键不存在）。</span><span class="sxs-lookup"><span data-stu-id="f04e5-214">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f04e5-215">下面的示例定义了一个 `MainClass` 类和一个 `MainInfo` 类，该类提供 `MainClass` 实例的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f04e5-215">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="f04e5-216">该示例调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>和 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 方法，将键/值对添加到 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-216">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="f04e5-217">在每种情况下，该示例都调用 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 方法来确认已将键/值对添加到表中。</span><span class="sxs-lookup"><span data-stu-id="f04e5-217">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f04e5-218"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f04e5-218"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>
