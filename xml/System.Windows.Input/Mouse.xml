<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4c05d40382f55301246a30e2a91b27341eda68a0" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102093134" /></Metadata><TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="38917-101">将鼠标设备表示为特定线程。</span><span class="sxs-lookup"><span data-stu-id="38917-101">Represents the mouse device to a specific thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-102"><xref:System.Windows.Input.Mouse>类提供与鼠标相关的事件、方法和属性，这些属性提供有关鼠标状态的信息。</span><span class="sxs-lookup"><span data-stu-id="38917-102">The <xref:System.Windows.Input.Mouse> class provides mouse related events, methods and, properties which provide information regarding the state of the mouse.</span></span>  
  
 <span data-ttu-id="38917-103"><xref:System.Windows.Input.Mouse>定义为附加事件的每个事件也由基元素类 <xref:System.Windows.UIElement> 和 <xref:System.Windows.ContentElement> 新的路由事件重新公开。</span><span class="sxs-lookup"><span data-stu-id="38917-103">Each event that <xref:System.Windows.Input.Mouse> defines as an attached event is also re-exposed by the base element classes <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement> as a new routed event.</span></span> <span data-ttu-id="38917-104">通常，在和上处理应用程序的鼠标事件更方便 <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> ，而不是使用 <xref:System.Windows.Input.Mouse> 事件。</span><span class="sxs-lookup"><span data-stu-id="38917-104">Generally, it is more convenient to handle mouse events for an application on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement>, rather than using the <xref:System.Windows.Input.Mouse> events.</span></span> <span data-ttu-id="38917-105">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-105">For details, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
 <span data-ttu-id="38917-106">类的静态成员 <xref:System.Windows.Input.Mouse> 委托给 <xref:System.Windows.Input.MouseDevice> 调用线程的输入管理器的主成员。</span><span class="sxs-lookup"><span data-stu-id="38917-106">The static members of the <xref:System.Windows.Input.Mouse> class delegate to the primary <xref:System.Windows.Input.MouseDevice> of the calling thread's input manager.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-107">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-107">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-108">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-108">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-109">为 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-109">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-110">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-110">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-111">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-111">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-112">为 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-112">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-113">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-113">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-114">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-114">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-115">为 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-115">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-116">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-116">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-117">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-117">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-118">为 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-118">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-119">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-119">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-120">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-120">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-121">为 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-121">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-122">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-122">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-123">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-123">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-124">为 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-124">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-125">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-125">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-126">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-126">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-127">为 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-127">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseUp" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-128">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-128">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-129">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-129">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-130">为 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-130">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-131">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-131">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-132">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-132">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-133">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-133">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-134">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-134">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-135">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-135">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-136">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-136">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-137">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-137">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-138">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-138">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-139">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-139">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-140">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-140">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-141">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-141">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-142">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-142">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-143">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-143">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-144">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-144">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-145">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-145">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-146">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-146">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-147">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-147">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-148">为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-148">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-149">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-149">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-150">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-150">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-151">为 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-151">Adds a handler for the <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-152">将鼠标输入捕获到指定元素。</span><span class="sxs-lookup"><span data-stu-id="38917-152">Captures mouse input to the specified element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-153">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-153">When an element captures the mouse, it receives mouse input whether or not the cursor is within its borders.</span></span>  
  
 <span data-ttu-id="38917-154">如果 <xref:System.Windows.Input.CaptureMode> 未指定，则默认值 <xref:System.Windows.Input.CaptureMode> 为 <xref:System.Windows.Input.CaptureMode.Element> 。</span><span class="sxs-lookup"><span data-stu-id="38917-154">If a <xref:System.Windows.Input.CaptureMode> is not specified, the default <xref:System.Windows.Input.CaptureMode> is <xref:System.Windows.Input.CaptureMode.Element>.</span></span>  
  
 <span data-ttu-id="38917-155">若要释放鼠标捕获，请调用 <xref:System.Windows.Input.Mouse.Capture%2A> `null` 作为要捕获的元素传递。</span><span class="sxs-lookup"><span data-stu-id="38917-155">To release mouse capture, call <xref:System.Windows.Input.Mouse.Capture%2A> passing `null` as the element to capture.</span></span>  
  
 <span data-ttu-id="38917-156">如果在 <xref:System.Windows.Input.Mouse.MouseDown> 引发或事件时捕获鼠标 <xref:System.Windows.Input.Mouse.MouseUp> ，并且输入不会转到鼠标下的元素，则 <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> 首先引发。</span><span class="sxs-lookup"><span data-stu-id="38917-156">If the mouse is captured when a <xref:System.Windows.Input.Mouse.MouseDown> or <xref:System.Windows.Input.Mouse.MouseUp> event is raised and the input is not going to the element underneath the mouse, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> and <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> are raised first.</span></span>  <span data-ttu-id="38917-157">这使得捕获的元素有机会在 <xref:System.Windows.Input.Mouse.MouseDown> 路由和事件之前释放捕获 <xref:System.Windows.Input.Mouse.MouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-157">This enables the captured element a chance to release capture before the <xref:System.Windows.Input.Mouse.MouseDown> and <xref:System.Windows.Input.Mouse.MouseUp> events are routed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-158">要捕获鼠标的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-158">The element to capture the mouse.</span></span></param>
        <summary><span data-ttu-id="38917-159">将鼠标输入捕获到指定元素。</span><span class="sxs-lookup"><span data-stu-id="38917-159">Captures mouse input to the specified element.</span></span></summary>
        <returns><span data-ttu-id="38917-160">如果元素能够捕获鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38917-160"><see langword="true" /> if the element was able to capture the mouse; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-161">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-161">When an element captures the mouse, it receives mouse input whether or not the cursor is within its borders.</span></span>  
  
 <span data-ttu-id="38917-162">如果 <xref:System.Windows.Input.CaptureMode> 未指定，则默认值 <xref:System.Windows.Input.CaptureMode> 为 <xref:System.Windows.Input.CaptureMode.Element> 。</span><span class="sxs-lookup"><span data-stu-id="38917-162">If a <xref:System.Windows.Input.CaptureMode> is not specified, the default <xref:System.Windows.Input.CaptureMode> is <xref:System.Windows.Input.CaptureMode.Element>.</span></span>  
  
 <span data-ttu-id="38917-163">若要释放鼠标捕获，请调用 <xref:System.Windows.Input.Mouse.Capture%2A> `null` 作为要捕获的元素传递。</span><span class="sxs-lookup"><span data-stu-id="38917-163">To release mouse capture, call <xref:System.Windows.Input.Mouse.Capture%2A> passing `null` as the element to capture.</span></span>  
  
 <span data-ttu-id="38917-164">如果在 <xref:System.Windows.Input.Mouse.MouseDown> 引发或事件时捕获鼠标 <xref:System.Windows.Input.Mouse.MouseUp> ，并且输入不会转到鼠标下的元素，则 <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> 首先引发。</span><span class="sxs-lookup"><span data-stu-id="38917-164">If the mouse is captured when a <xref:System.Windows.Input.Mouse.MouseDown> or <xref:System.Windows.Input.Mouse.MouseUp> event is raised and the input is not going to the element underneath the mouse, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> and <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> are raised first.</span></span>  <span data-ttu-id="38917-165">这使得捕获的元素有机会在 <xref:System.Windows.Input.Mouse.MouseDown> 路由和事件之前释放捕获 <xref:System.Windows.Input.Mouse.MouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-165">This enables the captured element a chance to release capture before the <xref:System.Windows.Input.Mouse.MouseDown> and <xref:System.Windows.Input.Mouse.MouseUp> events are routed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38917-166">下面的示例演示如何使用方法将鼠标捕获到特定元素 <xref:System.Windows.Input.Mouse.Capture%2A> 。</span><span class="sxs-lookup"><span data-stu-id="38917-166">The following example shows how to capture the mouse to a specific element by using the <xref:System.Windows.Input.Mouse.Capture%2A> method.</span></span>  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement, captureMode As CaptureMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-167">要捕获鼠标的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-167">The element to capture the mouse.</span></span></param>
        <param name="captureMode"><span data-ttu-id="38917-168">要使用的捕获策略。</span><span class="sxs-lookup"><span data-stu-id="38917-168">The capture policy to use.</span></span></param>
        <summary><span data-ttu-id="38917-169">使用指定的 <see cref="T:System.Windows.Input.CaptureMode" /> 将鼠标输入捕获到指定元素。</span><span class="sxs-lookup"><span data-stu-id="38917-169">Captures mouse input to the specified element using the specified <see cref="T:System.Windows.Input.CaptureMode" />.</span></span></summary>
        <returns><span data-ttu-id="38917-170">如果元素能够捕获鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38917-170"><see langword="true" /> if the element was able to capture the mouse; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-171">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-171">When an element captures the mouse, it receives mouse input whether the cursor is within its borders.</span></span>  
  
 <span data-ttu-id="38917-172">若要释放鼠标捕获，请调用 <xref:System.Windows.Input.Mouse.Capture%2A> `null` 作为要捕获的元素传递。</span><span class="sxs-lookup"><span data-stu-id="38917-172">To release mouse capture, call <xref:System.Windows.Input.Mouse.Capture%2A> passing `null` as the element to capture.</span></span>  
  
 <span data-ttu-id="38917-173">如果在 <xref:System.Windows.Input.Mouse.MouseDown> 引发或事件时捕获鼠标 <xref:System.Windows.Input.Mouse.MouseUp> ，并且输入不会转到鼠标下的元素，则 <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> 首先引发。</span><span class="sxs-lookup"><span data-stu-id="38917-173">If the mouse is captured when a <xref:System.Windows.Input.Mouse.MouseDown> or <xref:System.Windows.Input.Mouse.MouseUp> event is raised and the input is not going to the element underneath the mouse, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> and <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> are raised first.</span></span>  <span data-ttu-id="38917-174">这使得捕获的元素有机会在 <xref:System.Windows.Input.Mouse.MouseDown> 路由和事件之前释放捕获 <xref:System.Windows.Input.Mouse.MouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-174">This enables the captured element a chance to release capture before the <xref:System.Windows.Input.Mouse.MouseDown> and <xref:System.Windows.Input.Mouse.MouseUp> events are routed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38917-175">下面的示例演示如何使用方法将鼠标捕获到特定元素 <xref:System.Windows.Input.Mouse.Capture%2A> 。</span><span class="sxs-lookup"><span data-stu-id="38917-175">The following example shows how to capture the mouse to a specific element by using the <xref:System.Windows.Input.Mouse.Capture%2A> method.</span></span>  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-176">获取捕获了鼠标的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-176">Gets the element that has captured the mouse.</span></span></summary>
        <value><span data-ttu-id="38917-177">由鼠标捕获的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-177">The element captured by the mouse.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-178">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-178">When an element captures the mouse, it receives mouse input whether or not the cursor is within its borders.</span></span> <span data-ttu-id="38917-179">通常，仅在拖放操作过程中以这种方式捕获鼠标，并保留捕获，直到拖放操作的删除操作发生。</span><span class="sxs-lookup"><span data-stu-id="38917-179">The mouse is typically captured in this manner only during drag-and-drop operations, and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38917-180">下面的示例演示如何获取具有鼠标捕获的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-180">The follow example shows how to obtain the element that has mouse capture.</span></span>  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-181">获取鼠标指针正好悬停于的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-181">Gets the element the mouse pointer is directly over.</span></span></summary>
        <value><span data-ttu-id="38917-182">鼠标指针悬停的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-182">The element the mouse pointer is over.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-183">控件可以包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="38917-183">Controls can be composed of multiple elements.</span></span> <span data-ttu-id="38917-184"><xref:System.Windows.Input.Mouse.DirectlyOver%2A> 报告复合控件中的鼠标指针位于的特定元素，而不是控件本身。</span><span class="sxs-lookup"><span data-stu-id="38917-184"><xref:System.Windows.Input.Mouse.DirectlyOver%2A> reports the specific element in the composite control the mouse pointer is over and not the control itself.</span></span> <span data-ttu-id="38917-185">例如，根据指针的哪一部分 <xref:System.Windows.Controls.Button> ， <xref:System.Windows.Input.Mouse.DirectlyOver%2A> 属性可能会报告 <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.ContentControl.Content%2A> 属性或的 <xref:Microsoft.Windows.Themes.ButtonChrome> 。</span><span class="sxs-lookup"><span data-stu-id="38917-185">For example, depending on which part of a <xref:System.Windows.Controls.Button> the pointer is over, the <xref:System.Windows.Input.Mouse.DirectlyOver%2A> property could report the <xref:System.Windows.Controls.TextBox> of the <xref:System.Windows.Controls.ContentControl.Content%2A> property or the <xref:Microsoft.Windows.Themes.ButtonChrome>.</span></span>  
  
 <span data-ttu-id="38917-186">使用 <xref:System.Windows.IInputElement.IsMouseOver%2A> 和上的 <xref:System.Windows.UIElement> 属性 <xref:System.Windows.ContentElement> 来确定鼠标是否位于元素上，该元素包括其可视子元素或控件复合元素。</span><span class="sxs-lookup"><span data-stu-id="38917-186">Use the <xref:System.Windows.IInputElement.IsMouseOver%2A> property on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement> to determine whether the mouse is over an element, which includes its visual child elements or control compositing elements.</span></span>  
  
 <span data-ttu-id="38917-187">如果某个元素具有鼠标捕获，则在该元素上直接考虑鼠标指针，而不考虑鼠标指针的位置。</span><span class="sxs-lookup"><span data-stu-id="38917-187">If an element has mouse capture, the mouse pointer is considered directly over the element regardless of the where the mouse pointer is.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="38917-188"><paramref name="points" /> 所关联的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-188">The elements <paramref name="points" /> are in relation to.</span></span></param>
        <param name="points"><span data-ttu-id="38917-189">一个 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="38917-189">An array of objects.</span></span></param>
        <summary><span data-ttu-id="38917-190">检索以前的自上一个鼠标移动事件以来的鼠标指针坐标（最多可检索 64 个）。</span><span class="sxs-lookup"><span data-stu-id="38917-190">Retrieves up to 64 previous coordinates of the mouse pointer since the last mouse move event.</span></span></summary>
        <returns><span data-ttu-id="38917-191">返回的点数。</span><span class="sxs-lookup"><span data-stu-id="38917-191">The number of points returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="38917-192">计算鼠标在其中的位置的坐标空间。</span><span class="sxs-lookup"><span data-stu-id="38917-192">The coordinate space in which to calculate the position of the mouse.</span></span></param>
        <summary><span data-ttu-id="38917-193">获取与指定元素相对的鼠标位置。</span><span class="sxs-lookup"><span data-stu-id="38917-193">Gets the position of the mouse relative to a specified element.</span></span></summary>
        <returns><span data-ttu-id="38917-194">与参数 <paramref name="relativeTo" /> 相对的鼠标位置。</span><span class="sxs-lookup"><span data-stu-id="38917-194">The position of the mouse relative to the parameter <paramref name="relativeTo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-195">相对于指定元素计算鼠标指针的位置时，该元素的左上角是原点，0，0。</span><span class="sxs-lookup"><span data-stu-id="38917-195">The position of the mouse pointer is calculated relative to the specified element with the upper-left corner of element being the point of origin, 0,0.</span></span>  
  
 <span data-ttu-id="38917-196">在拖放操作过程中，无法通过可靠地确定鼠标的位置 <xref:System.Windows.Input.Mouse.GetPosition%2A> 。</span><span class="sxs-lookup"><span data-stu-id="38917-196">During drag-and-drop operations, the position of the mouse cannot be reliably determined through <xref:System.Windows.Input.Mouse.GetPosition%2A>.</span></span> <span data-ttu-id="38917-197">这是因为鼠标控制 (可能包括捕获) 由拖动的原始元素占用，直到拖放完成，并具有由基础 Win32 调用控制的大部分行为。</span><span class="sxs-lookup"><span data-stu-id="38917-197">This is because control of the mouse (possibly including capture) is held by the originating element of the drag until the drop is completed, with much of the behavior controlled by underlying Win32 calls.</span></span> <span data-ttu-id="38917-198">请尝试改用以下方法：</span><span class="sxs-lookup"><span data-stu-id="38917-198">Try the following approaches instead:</span></span>  
  
-   <span data-ttu-id="38917-199">调用 <xref:System.Windows.DragEventArgs.GetPosition%2A> <xref:System.Windows.DragEventArgs> 传递到拖动事件 (、) 的的方法 <xref:System.Windows.ContentElement.DragEnter> <xref:System.Windows.ContentElement.DragOver> <xref:System.Windows.ContentElement.DragLeave> 。</span><span class="sxs-lookup"><span data-stu-id="38917-199">Call the <xref:System.Windows.DragEventArgs.GetPosition%2A> method of the <xref:System.Windows.DragEventArgs> that is passed to the drag events (<xref:System.Windows.ContentElement.DragEnter>, <xref:System.Windows.ContentElement.DragOver>, <xref:System.Windows.ContentElement.DragLeave>).</span></span>  
  
-   <span data-ttu-id="38917-200">使用 P/Invoke 调用 [GetCursorPos](/windows/win32/api/winuser/nf-winuser-getcursorpos)。</span><span class="sxs-lookup"><span data-stu-id="38917-200">Call [GetCursorPos](/windows/win32/api/winuser/nf-winuser-getcursorpos), using P/Invoke.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38917-201">下面的示例演示如何使用 <xref:System.Windows.Input.Mouse.GetPosition%2A> 确定鼠标指针的位置。</span><span class="sxs-lookup"><span data-stu-id="38917-201">The following example shows how to use <xref:System.Windows.Input.Mouse.GetPosition%2A> to determine the position of the mouse pointer.</span></span>  <span data-ttu-id="38917-202">鼠标指针的位置存储在 <xref:System.Windows.Point> 结构中。</span><span class="sxs-lookup"><span data-stu-id="38917-202">The position of the mouse pointer is stored in a <xref:System.Windows.Point> structure.</span></span>  <span data-ttu-id="38917-203"><xref:System.Windows.Point.X%2A>对象的和 <xref:System.Windows.Point.Y%2A> 值 <xref:System.Windows.Point> 显示在中 <xref:System.Windows.Controls.TextBox> 。</span><span class="sxs-lookup"><span data-stu-id="38917-203">The <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values of the <xref:System.Windows.Point> object are displayed in a <xref:System.Windows.Controls.TextBox>.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-204">在元素捕获到鼠标时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-204">Occurs when an element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-205">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-205">When an element captures the mouse, it receives mouse input whether or not the cursor is within its borders.</span></span>  
  
 <span data-ttu-id="38917-206">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-206">This is an attached event.</span></span> <span data-ttu-id="38917-207">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-207">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-208">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-208">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-209">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-209">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-210">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-210">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-211">由于冒泡路由，具有捕获的实际元素可以是子元素，而不一定是实际附加了事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-211">Because of the bubbling routing, the actual element that has capture might be a child element, not necessarily the element where the event handler is actually attached.</span></span> <span data-ttu-id="38917-212">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件参数中的，以确定具有鼠标捕获的实际元素。</span><span class="sxs-lookup"><span data-stu-id="38917-212">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event arguments to determine the actual element that has mouse capture.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-213">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-213">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-214">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-214">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|<span data-ttu-id="38917-215">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-215">Routing strategy</span></span>|<span data-ttu-id="38917-216">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-216">Bubbling</span></span>|  
|<span data-ttu-id="38917-217">委托</span><span class="sxs-lookup"><span data-stu-id="38917-217">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="38917-218">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="38917-218">There is no defined corresponding tunneling event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-219">标识 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-219">Identifies the <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-220">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-220">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-221">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-221">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-222">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-222">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-223">获取鼠标左键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-223">Gets the state of the left button of the mouse.</span></span></summary>
        <value><span data-ttu-id="38917-224">鼠标左键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-224">The state of the left mouse button.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38917-225">下面的示例演示如何通过检查的状态是否 <xref:System.Windows.Input.Mouse.LeftButton%2A> 等于枚举值来确定是否按下了鼠标左键 <xref:System.Windows.Input.MouseButtonState> <xref:System.Windows.Input.MouseButtonState.Pressed> 。</span><span class="sxs-lookup"><span data-stu-id="38917-225">The following example shows how to determine whether the left mouse button is pressed by checking if the state of the <xref:System.Windows.Input.Mouse.LeftButton%2A> is equal to the <xref:System.Windows.Input.MouseButtonState> enumeration value <xref:System.Windows.Input.MouseButtonState.Pressed>.</span></span>  <span data-ttu-id="38917-226">如果按下该按钮，将调用一个方法，该方法将更新示例中的显示元素。</span><span class="sxs-lookup"><span data-stu-id="38917-226">If the button is pressed, a method is called which updates display elements in the sample.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-227">在元素丢失鼠标捕获时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-227">Occurs when an element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-228">当某个元素捕获鼠标时，它将接收鼠标输入，无论光标是否在其边界内。</span><span class="sxs-lookup"><span data-stu-id="38917-228">When an element captures the mouse, it receives mouse input whether or not the cursor is within its borders.</span></span> <span data-ttu-id="38917-229">T</span><span class="sxs-lookup"><span data-stu-id="38917-229">T</span></span>  
  
 <span data-ttu-id="38917-230">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-230">This is an attached event.</span></span> <span data-ttu-id="38917-231">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-231">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-232">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-232">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-233">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-233">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-234">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-234">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-235">由于冒泡路由，丢失捕获的实际元素可以是子元素，而不一定是实际附加了事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="38917-235">Because of the bubbling routing, the actual element that lost capture might be a child element, not necessarily the element where the event handler is actually attached.</span></span> <span data-ttu-id="38917-236">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件参数中的，以确定丢失捕获的实际元素。</span><span class="sxs-lookup"><span data-stu-id="38917-236">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event arguments to determine the actual element that lost capture.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-237">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-237">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-238">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-238">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|<span data-ttu-id="38917-239">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-239">Routing strategy</span></span>|<span data-ttu-id="38917-240">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-240">Bubbling</span></span>|  
|<span data-ttu-id="38917-241">委托</span><span class="sxs-lookup"><span data-stu-id="38917-241">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="38917-242">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="38917-242">There is no defined corresponding tunneling event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-243">标识 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-243">Identifies the <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-244">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-244">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-245">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-245">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-246">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-246">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-247">获取鼠标中键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-247">Gets the state of the middle button of the mouse.</span></span></summary>
        <value><span data-ttu-id="38917-248">鼠标中键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-248">The state of the middle mouse button.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38917-249">下面的示例演示如何通过检查的状态是否 <xref:System.Windows.Input.Mouse.MiddleButton%2A> 等于枚举值来确定是否按下鼠标中键 <xref:System.Windows.Input.MouseButtonState> <xref:System.Windows.Input.MouseButtonState.Pressed> 。</span><span class="sxs-lookup"><span data-stu-id="38917-249">The following example shows how to determine whether the middle mouse button is pressed by checking if the state of the <xref:System.Windows.Input.Mouse.MiddleButton%2A> is equal to the <xref:System.Windows.Input.MouseButtonState> enumeration value <xref:System.Windows.Input.MouseButtonState.Pressed>.</span></span>  <span data-ttu-id="38917-250">如果按下该按钮，将调用一个方法，该方法将更新示例中的显示元素。</span><span class="sxs-lookup"><span data-stu-id="38917-250">If the button is pressed, a method is called which updates display elements in the sample.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-251">当按下任何鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-251">Occurs when any mouse button is depressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-252">若要确定鼠标按下了哪个按钮，请 <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A> 在 <xref:System.Windows.Input.MouseButtonEventArgs> 传递到处理程序的中检查属性。</span><span class="sxs-lookup"><span data-stu-id="38917-252">To determine which mouse button was depressed, check the <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A> property in the <xref:System.Windows.Input.MouseButtonEventArgs> passed to the handler.</span></span>  
  
 <span data-ttu-id="38917-253">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-253">This is an attached event.</span></span> <span data-ttu-id="38917-254">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-254">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-255">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-255">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-256">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-256">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-257">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-257">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-258">Windows Presentation Foundation (WPF) framework 通过将其作为两个不同的公共语言运行时（在和上 (CLR) 事件）来生成，从而生成此附加事件 <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="38917-258">The Windows Presentation Foundation (WPF) framework builds on this attached event by surfacing it as two different common language runtime (CLR) events on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement>: <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="38917-259">这些实现处理基础 <xref:System.Windows.Input.Mouse.MouseDown> 事件并读取事件的参数，以确定是否涉及鼠标左键或右键。</span><span class="sxs-lookup"><span data-stu-id="38917-259">These implementations handle the underlying <xref:System.Windows.Input.Mouse.MouseDown> event and read the arguments of the event to determine whether the left or right mouse button was involved.</span></span> <span data-ttu-id="38917-260">对于三按钮鼠标，中间按钮没有框架级别的事件支持。</span><span class="sxs-lookup"><span data-stu-id="38917-260">For a three-button mouse, there is no framework-level event support for the center button.</span></span> <span data-ttu-id="38917-261">应该使用 <xref:System.Windows.Input.Mouse.MouseDown> 事件并检查 <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> 事件参数中的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-261">You should use the <xref:System.Windows.Input.Mouse.MouseDown> event and check the <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> state in the event arguments.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="38917-262">有些 <xref:System.Windows.ContentElement> 具有类似于控件的行为的派生类（例如， <xref:System.Windows.Documents.Hyperlink> ）可能具有鼠标按钮事件的固有类处理。</span><span class="sxs-lookup"><span data-stu-id="38917-262">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="38917-263">鼠标左键按下事件是在控件中具有类处理的最可能的事件。</span><span class="sxs-lookup"><span data-stu-id="38917-263">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="38917-264">类处理通常将基础 <xref:System.Windows.Input.Mouse> 类事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="38917-264">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="38917-265">将该事件标记为已处理后，通常不会引发附加到该元素的其他实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-265">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="38917-266">通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-266">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="38917-267">您可以通过使用以下任一解决方案解决前面重要说明中列出的问题，并仍 <xref:System.Windows.UIElement.MouseDown> 在具有类处理的派生类上接收鼠标左键按下事件的事件：</span><span class="sxs-lookup"><span data-stu-id="38917-267">You can resolve the issue that is outlined in the preceding Important note and still receive <xref:System.Windows.UIElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="38917-268">为事件附加处理程序 <xref:System.Windows.UIElement.PreviewMouseDown> ，这些处理程序未标记为由控件处理。</span><span class="sxs-lookup"><span data-stu-id="38917-268">Attach handlers for the <xref:System.Windows.UIElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="38917-269">请注意，因为这是预览事件，所以路由从根节点开始，向下隧道到控件。</span><span class="sxs-lookup"><span data-stu-id="38917-269">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="38917-270">通过调用 <xref:System.Windows.UIElement.AddHandler%2A> 并选择允许处理程序侦听事件的签名选项（即使它们已在路由事件数据中标记为已处理），在控件过程上注册处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-270">Register a handler on the control procedurally by calling <xref:System.Windows.UIElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
 <span data-ttu-id="38917-271">对于与鼠标相关的路由事件，请注意如何或何时将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="38917-271">For routed events that relate to the mouse, be careful about how or when you mark them handled.</span></span> <span data-ttu-id="38917-272">对父元素是否还应告知父元素是否还应知道是否应该知道是否有任何给定鼠标操作的难点在于，WPF 框架为何选择了将基础鼠标路由事件显示为沿路由的 CLR 事件的模型。</span><span class="sxs-lookup"><span data-stu-id="38917-272">The difficulty in making the appropriate choices about whether parent elements should also be informed about any given mouse action is in fact why the WPF framework chose the model of having the underlying mouse routed event be surfaced as CLR events along the route.</span></span> <span data-ttu-id="38917-273">隧道鼠标事件存在类似问题。</span><span class="sxs-lookup"><span data-stu-id="38917-273">Similar issues exist with tunneling mouse events.</span></span>  <span data-ttu-id="38917-274">是否应处理事件，而不让其通过其他子级进行处理，以及如何影响组合项可能具有预期鼠标行为的控件？</span><span class="sxs-lookup"><span data-stu-id="38917-274">Should you handle the event and not have it be handled by further children toward the source, and how would that affect compositing a control where the compositing pieces might have expected mouse behaviors?</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-275">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-275">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-276">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-276">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|<span data-ttu-id="38917-277">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-277">Routing strategy</span></span>|<span data-ttu-id="38917-278">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-278">Bubbling</span></span>|  
|<span data-ttu-id="38917-279">委托</span><span class="sxs-lookup"><span data-stu-id="38917-279">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="38917-280">对应的隧道事件为 <xref:System.Windows.Input.Mouse.PreviewMouseDown> 。</span><span class="sxs-lookup"><span data-stu-id="38917-280">The corresponding tunneling event is <xref:System.Windows.Input.Mouse.PreviewMouseDown>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-281">标识 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-281">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-282">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-282">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-283">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-283">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-284">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-284">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-285">当鼠标指针进入元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-285">Occurs when the mouse pointer enters the boundaries of an element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-286">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-286">This is an attached event.</span></span> <span data-ttu-id="38917-287">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-287">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-288">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-288">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-289">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-289">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-290">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-290">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-291">此事件使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="38917-291">This event uses the direct event handling routing strategy.</span></span> <span data-ttu-id="38917-292">直接路由事件不沿路由引发 (它们仅在引发它们) 的同一元素中进行处理。</span><span class="sxs-lookup"><span data-stu-id="38917-292">Direct routed events are not raised along a route (they are only handled in the same element on which they are raised).</span></span>  <span data-ttu-id="38917-293">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="38917-293">They do, however, enable other aspects of routed event behaviors, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="38917-294">尽管此事件用于跟踪鼠标进入元素的时间，但它也报告 <xref:System.Windows.UIElement.IsMouseOver%2A> `false` 此元素上的属性已从更改为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="38917-294">Although this event is used to track when the mouse enters an element, it is also reporting the <xref:System.Windows.UIElement.IsMouseOver%2A> property has changed from `false` to `true` on this element.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-295">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-295">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-296">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-296">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|<span data-ttu-id="38917-297">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-297">Routing strategy</span></span>|<span data-ttu-id="38917-298">直接</span><span class="sxs-lookup"><span data-stu-id="38917-298">Direct</span></span>|  
|<span data-ttu-id="38917-299">委托</span><span class="sxs-lookup"><span data-stu-id="38917-299">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-300">标识 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-300">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-301">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-301">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-302">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-302">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-303">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-303">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-304">当鼠标指针离开元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-304">Occurs when the mouse pointer leaves the boundaries of an element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-305">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-305">This is an attached event.</span></span> <span data-ttu-id="38917-306">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-306">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-307">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-307">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-308">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-308">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-309">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-309">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-310">此事件使用直接事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="38917-310">This event uses the direct event handling routing strategy.</span></span> <span data-ttu-id="38917-311">直接路由事件不遵循路由 (它们只在引发它们的同一元素中进行处理) 。</span><span class="sxs-lookup"><span data-stu-id="38917-311">Direct routed events do not follow a route (they are only handled in the same element on which they are raised).</span></span>  <span data-ttu-id="38917-312">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="38917-312">They do, however, enable other aspects of routed event behaviors, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="38917-313">尽管此事件用于跟踪鼠标离开元素的时间，但它也报告 <xref:System.Windows.UIElement.IsMouseOver%2A> `true` 此元素上的属性值已从更改为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="38917-313">Although this event is used to track when the mouse leaves an element, it is also reporting that the <xref:System.Windows.UIElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
## <a name="routed-event-information"></a><span data-ttu-id="38917-314">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-314">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-315">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-315">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|<span data-ttu-id="38917-316">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-316">Routing strategy</span></span>|<span data-ttu-id="38917-317">直接</span><span class="sxs-lookup"><span data-stu-id="38917-317">Direct</span></span>|  
|<span data-ttu-id="38917-318">委托</span><span class="sxs-lookup"><span data-stu-id="38917-318">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-319">标识 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-319">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-320">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-320">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-321">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-321">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-322">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-322">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-323">在鼠标指针移动时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-323">Occurs when the mouse pointer moves.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-324">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-324">This is an attached event.</span></span> <span data-ttu-id="38917-325">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-325">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-326">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-326">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-327">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-327">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-328">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-328">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
## <a name="routed-event-information"></a><span data-ttu-id="38917-329">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-329">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-330">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-330">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|<span data-ttu-id="38917-331">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-331">Routing strategy</span></span>|<span data-ttu-id="38917-332">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-332">Bubbling</span></span>|  
|<span data-ttu-id="38917-333">委托</span><span class="sxs-lookup"><span data-stu-id="38917-333">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="38917-334">对应的隧道事件为 <xref:System.Windows.Input.Mouse.PreviewMouseMove> 。</span><span class="sxs-lookup"><span data-stu-id="38917-334">The corresponding tunneling event is <xref:System.Windows.Input.Mouse.PreviewMouseMove>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-335">标识 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-335">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-336">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-336">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-337">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-337">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-338">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-338">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-339">当释放任何鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-339">Occurs when any mouse button is released.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-340">已释放的鼠标按钮通过检查事件的参数来确定。</span><span class="sxs-lookup"><span data-stu-id="38917-340">Which mouse button was released is determined by checking the arguments of the event.</span></span>  
  
 <span data-ttu-id="38917-341">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-341">This is an attached event.</span></span> <span data-ttu-id="38917-342">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-342">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-343">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-343">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-344">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-344">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-345">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-345">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-346">Windows Presentation Foundation (WPF) 框架通过将其作为两个不同的公共语言运行时在上 (CLR) 事件，在此附加事件上生成 <xref:System.Windows.UIElement> ： <xref:System.Windows.UIElement.MouseLeftButtonUp> 和 <xref:System.Windows.UIElement.MouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-346">The Windows Presentation Foundation (WPF) framework builds on this attached event by surfacing it as two different common language runtime (CLR) events on <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.MouseLeftButtonUp> and <xref:System.Windows.UIElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="38917-347">这些实现处理基础 <xref:System.Windows.Input.Mouse.MouseUp> 事件并读取事件的参数，以确定是否涉及鼠标左键或右键。</span><span class="sxs-lookup"><span data-stu-id="38917-347">These implementations handle the underlying <xref:System.Windows.Input.Mouse.MouseUp> event and read the arguments of the event to determine whether the left or right mouse button was involved.</span></span> <span data-ttu-id="38917-348">对于三按钮，中间按钮没有框架级事件支持，您应该使用 <xref:System.Windows.Input.Mouse.MouseUp> 事件并检查事件参数中的中间按钮条件。</span><span class="sxs-lookup"><span data-stu-id="38917-348">For three-button, there is no framework-level event support for the center button, and you should use the <xref:System.Windows.Input.Mouse.MouseUp> event and check for the center button condition in the event arguments.</span></span>  
  
 <span data-ttu-id="38917-349">对于与鼠标相关的路由事件，请注意如何或何时将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="38917-349">For routed events that relate to the mouse, be careful about how or when you mark them handled.</span></span> <span data-ttu-id="38917-350">对父元素是否还应告知父元素是否还应知道是否应该知道是否有任何给定鼠标操作的难点在于，WPF 框架为何选择了将基础 <xref:System.Windows.Input.Mouse> 路由事件呈现为所有沿路由的 CLR 事件的模型。</span><span class="sxs-lookup"><span data-stu-id="38917-350">The difficulty in making the appropriate choices about whether parent elements should also be informed about any given mouse action is in fact why the WPF framework chose the model of having the underlying <xref:System.Windows.Input.Mouse> routed event be surfaced as CLR events all along the route.</span></span>  
  
 <span data-ttu-id="38917-351">隧道鼠标事件存在类似问题。</span><span class="sxs-lookup"><span data-stu-id="38917-351">Similar issues exist with tunneling mouse events.</span></span>  <span data-ttu-id="38917-352">是否应该处理事件，而不是由进一步流向源的子级处理，以及如何影响组合项可能具有预期的鼠标行为的控件中的组合？</span><span class="sxs-lookup"><span data-stu-id="38917-352">Should you handle the event and not have it be handled by children further towards the source, and how would that affect compositing in a control where the compositing pieces might have expected mouse behaviors?</span></span>  
  
## <a name="routed-event-information"></a><span data-ttu-id="38917-353">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-353">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-354">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-354">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|<span data-ttu-id="38917-355">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-355">Routing strategy</span></span>|<span data-ttu-id="38917-356">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-356">Bubbling</span></span>|  
|<span data-ttu-id="38917-357">委托</span><span class="sxs-lookup"><span data-stu-id="38917-357">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 <span data-ttu-id="38917-358">对应的隧道事件为 <xref:System.Windows.Input.Mouse.PreviewMouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-358">The corresponding tunneling event is <xref:System.Windows.Input.Mouse.PreviewMouseUp>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-359">标识 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-359">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseUp" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-360">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-360">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-361">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-361">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-362">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-362">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-363">在鼠标滚轮转动时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-363">Occurs when the mouse wheel is rotated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-364">焦点或鼠标捕获优先于鼠标指针所在的位置。</span><span class="sxs-lookup"><span data-stu-id="38917-364">Focus or mouse capture take precedence over where the mouse pointer is.</span></span>  <span data-ttu-id="38917-365">如果从焦点或捕获的元素接收此事件，则鼠标指针实际上可能位于另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="38917-365">If you receive this event from a focused or captured element, the mouse pointer might in fact be over another element at the time.</span></span>  
  
 <span data-ttu-id="38917-366">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-366">This is an attached event.</span></span> <span data-ttu-id="38917-367">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-367">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-368">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-368">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-369">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-369">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-370">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-370">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-371">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-371">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-372">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-372">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|<span data-ttu-id="38917-373">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-373">Routing strategy</span></span>|<span data-ttu-id="38917-374">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-374">Bubbling</span></span>|  
|<span data-ttu-id="38917-375">委托</span><span class="sxs-lookup"><span data-stu-id="38917-375">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="38917-376">对应的隧道事件为 <xref:System.Windows.Input.Mouse.PreviewMouseWheel> 。</span><span class="sxs-lookup"><span data-stu-id="38917-376">The corresponding tunneling event is <xref:System.Windows.Input.Mouse.PreviewMouseWheel>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary><span data-ttu-id="38917-377">代表鼠标滚轮要滚过一行而转动的单位数。</span><span class="sxs-lookup"><span data-stu-id="38917-377">Represents the number of units the mouse wheel is rotated to scroll one line.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-378">在当前 Windows Presentation Foundation (WPF) ，此字段的值为120。</span><span class="sxs-lookup"><span data-stu-id="38917-378">In the current Windows Presentation Foundation (WPF), the value of this field is 120.</span></span> <span data-ttu-id="38917-379">现场公开的目的是允许供应商在未来生成更精细的鼠标轮，这可能包括无凹槽的自由旋转滚轮。</span><span class="sxs-lookup"><span data-stu-id="38917-379">The intention of the field exposure is to allow for vendors to build finer-resolution mouse wheels in the future, that perhaps would include a freely rotating wheel without notches.</span></span> <span data-ttu-id="38917-380">预期是这样一种设备会为每个轮换发送更多的消息，但每条消息中的值越小。</span><span class="sxs-lookup"><span data-stu-id="38917-380">The expectation is that such a device would send more messages per rotation, but with a smaller value in each message.</span></span> <span data-ttu-id="38917-381">为了支持这种可能性，你应该添加传入增量值，直到 <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> 达到该量 (这样，为使增量旋转获得相同的响应) ，或滚动部分行来响应更频繁的消息。</span><span class="sxs-lookup"><span data-stu-id="38917-381">To support this possibility, you should either add the incoming delta values until the <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> amount is reached (so for a delta-rotation you get the same response), or scroll partial lines in response to the more frequent messages.</span></span> <span data-ttu-id="38917-382">你还可以选择自己的滚动粒度并累积你自己选择的增量，直到达到该增量，或者可能引用用户控制的系统参数以实现鼠标敏感度并将这些参数外推到鼠标滚轮增量阈值。</span><span class="sxs-lookup"><span data-stu-id="38917-382">You could also choose your own scroll granularity and accumulate deltas of your own choosing until that delta is reached, or perhaps reference user-controllable system parameters for mouse sensitivity and extrapolate these to mouse wheel delta thresholds.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-383">标识 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-383">Identifies the <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-384">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-384">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-385">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-385">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-386">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-386">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-387">获取或设置整个应用程序的光标。</span><span class="sxs-lookup"><span data-stu-id="38917-387">Gets or sets the cursor for the entire application.</span></span></summary>
        <value><span data-ttu-id="38917-388">重写的光标，如果没有设置 <see langword="null" />，则为 <see cref="P:System.Windows.Input.Mouse.OverrideCursor" />。</span><span class="sxs-lookup"><span data-stu-id="38917-388">The override cursor or <see langword="null" /> if the <see cref="P:System.Windows.Input.Mouse.OverrideCursor" /> is not set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-389"><xref:System.Windows.Input.Cursor> <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 设置为的将应用于整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="38917-389">The <xref:System.Windows.Input.Cursor> that <xref:System.Windows.Input.Mouse.OverrideCursor%2A> is set to will be applied to the whole application.</span></span>  
  
 <span data-ttu-id="38917-390">若要清除替代 <xref:System.Windows.Input.Cursor> ，请将设置 <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="38917-390">To clear the override <xref:System.Windows.Input.Cursor>, set <xref:System.Windows.Input.Mouse.OverrideCursor%2A> to `null`.</span></span>  
  
 <span data-ttu-id="38917-391">设置 <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 为 <xref:System.Windows.Input.Cursors.None%2A> 将强制鼠标光标不显示，但仍会处理鼠标事件。</span><span class="sxs-lookup"><span data-stu-id="38917-391">Setting <xref:System.Windows.Input.Mouse.OverrideCursor%2A> to <xref:System.Windows.Input.Cursors.None%2A> will force the mouse cursor not to be displayed, but mouse events are still processed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38917-392">下面的示例演示了 <xref:System.Windows.Controls.RadioButton> 用于在单个元素和整个应用程序之间切换游标更改范围的的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-392">The following example shows an event handler for a <xref:System.Windows.Controls.RadioButton> that is used to toggle the scope of a cursor change between a single element and the entire application.</span></span>  <span data-ttu-id="38917-393">如果引发事件的控件为 `rbScopeElement` <xref:System.Windows.Controls.RadioButton> ，则将设置一个标志，该标志指示游标更改的作用域，并将 <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 设置为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="38917-393">If the control that raised the event is the `rbScopeElement`<xref:System.Windows.Controls.RadioButton>, a flag that denotes the scope of the cursor change is set and <xref:System.Windows.Input.Mouse.OverrideCursor%2A> is set to `null`.</span></span>  <span data-ttu-id="38917-394">如果引发事件的控件为 `rbScopeApplication` <xref:System.Windows.Controls.RadioButton> ，则将设置一个标志，用于指示游标更改的作用域，并将其 <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 设置为 <xref:System.Windows.FrameworkElement.Cursor%2A> 名为的控件的属性 <xref:System.Windows.Controls.Border> `DisplayArea` 。</span><span class="sxs-lookup"><span data-stu-id="38917-394">If the control that raised the event is the `rbScopeApplication`<xref:System.Windows.Controls.RadioButton>, a flag that denotes the scope of the cursor change is set and <xref:System.Windows.Input.Mouse.OverrideCursor%2A> is set to the <xref:System.Windows.FrameworkElement.Cursor%2A> property of the <xref:System.Windows.Controls.Border> control named `DisplayArea`.</span></span>  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-395">当按下任何鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-395">Occurs when any mouse button is depressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-396">通过检查事件的参数来确定按下的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="38917-396">Which mouse button was depressed is determined by checking the arguments of the event.</span></span> <span data-ttu-id="38917-397">这是一个附加事件 (使用隧道路由策略) ，该策略旨在通过现有用户界面 (UI) 接受输入的元素引用的附加事件语法来引用。</span><span class="sxs-lookup"><span data-stu-id="38917-397">This is an attached event (using tunneling routing strategy) that is intended through attached event syntax to be referenced by existing user interface (UI) elements that take input.</span></span>  
  
 <span data-ttu-id="38917-398">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-398">This is an attached event.</span></span> <span data-ttu-id="38917-399">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-399">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-400">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-400">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-401">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-401">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-402">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-402">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-403">Windows Presentation Foundation (WPF) 框架通过将其作为两个不同的公共语言运行时在上 (CLR) 事件，在此附加事件上生成 <xref:System.Windows.UIElement> ： <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="38917-403">The Windows Presentation Foundation (WPF) framework builds on this attached event by surfacing it as two different common language runtime (CLR) events on <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="38917-404">这些实现处理基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown> 事件并读取事件的参数，以确定是否涉及鼠标左键或右键。</span><span class="sxs-lookup"><span data-stu-id="38917-404">These implementations handle the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown> event and read the arguments of the event to determine whether the left or right mouse button was involved.</span></span> <span data-ttu-id="38917-405">对于三按钮，中间按钮没有框架级事件支持，您应该使用 <xref:System.Windows.Input.Mouse.PreviewMouseDown> 事件并检查事件参数中的中间按钮条件。</span><span class="sxs-lookup"><span data-stu-id="38917-405">For three-button, there is no framework-level event support for the center button, and you should use the <xref:System.Windows.Input.Mouse.PreviewMouseDown> event and check for the center button condition in the event arguments.</span></span>  
  
 <span data-ttu-id="38917-406">对于与鼠标相关的路由事件，请注意如何或何时将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="38917-406">For routed events that relate to the mouse, be careful about how or when you mark them handled.</span></span> <span data-ttu-id="38917-407">处理根附近的事件，并通过源进一步对源进行处理可能不适用于复合控件，其中的组合项可能具有预期的鼠标行为。</span><span class="sxs-lookup"><span data-stu-id="38917-407">Handling the event near the root and handling it by a child further toward the source may not be appropriate for composited controls, where the compositing pieces might have expected mouse behaviors.</span></span> <span data-ttu-id="38917-408">如果对其他元素是否还应知道有关任何给定鼠标操作的相关选择，这一困难非常困难，因为 WPF framework 选择的模型的基础 <xref:System.Windows.Input.Mouse> 路由事件会在路由时呈现为 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="38917-408">The difficulty in making the appropriate choices about whether other elements should also be informed about any given mouse action is in fact why the WPF framework chose the model of having the underlying <xref:System.Windows.Input.Mouse> routed event be surfaced as CLR events along the route.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-409">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-409">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-410">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-410">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|<span data-ttu-id="38917-411">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-411">Routing strategy</span></span>|<span data-ttu-id="38917-412">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-412">Tunneling</span></span>|  
|<span data-ttu-id="38917-413">委托</span><span class="sxs-lookup"><span data-stu-id="38917-413">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="38917-414">对应的冒泡事件为 <xref:System.Windows.Input.Mouse.MouseDown> 。</span><span class="sxs-lookup"><span data-stu-id="38917-414">The corresponding bubbling event is <xref:System.Windows.Input.Mouse.MouseDown>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-415">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-415">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-416">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-416">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-417">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-417">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-418">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-418">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-419">当在捕获鼠标事件的元素之外按下主鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-419">Occurs when the primary mouse button is pressed outside the element that is capturing mouse events.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-420">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-420">This is an attached event.</span></span> <span data-ttu-id="38917-421">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-421">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-422">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-422">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-423">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-423">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-424">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-424">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-425">此事件不 resurfaced 在基元素上。</span><span class="sxs-lookup"><span data-stu-id="38917-425">This event is not resurfaced on base elements.</span></span> <span data-ttu-id="38917-426">主要是为了控制在其控件组合中尝试协调鼠标捕获和鼠标输入的作者。</span><span class="sxs-lookup"><span data-stu-id="38917-426">It is mainly of concern to control authors that are attempting to reconcile mouse capture and mouse input within their control compositing.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-427">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-427">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-428">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-428">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|<span data-ttu-id="38917-429">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-429">Routing strategy</span></span>|<span data-ttu-id="38917-430">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-430">Tunneling</span></span>|  
|<span data-ttu-id="38917-431">委托</span><span class="sxs-lookup"><span data-stu-id="38917-431">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-432">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-432">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-433">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-433">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-434">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-434">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-435">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-435">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-436">在鼠标移过元素时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-436">Occurs when the mouse moves over an element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-437">当鼠标指针在元素边界内最近移动时，以及当鼠标指针移动到元素边界内并且仍在移动时，将发生此事件。</span><span class="sxs-lookup"><span data-stu-id="38917-437">This event occurs both when the mouse pointer is newly moved in the element bounds, and also when the mouse pointer moves while still remaining in the element bounds.</span></span>  
  
 <span data-ttu-id="38917-438">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-438">This is an attached event.</span></span> <span data-ttu-id="38917-439">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-439">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-440">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-440">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-441">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-441">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-442">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-442">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-443">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-443">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-444">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-444">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|<span data-ttu-id="38917-445">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-445">Routing strategy</span></span>|<span data-ttu-id="38917-446">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-446">Tunneling</span></span>|  
|<span data-ttu-id="38917-447">委托</span><span class="sxs-lookup"><span data-stu-id="38917-447">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="38917-448">对应的冒泡事件为 <xref:System.Windows.Input.Mouse.MouseMove> 。</span><span class="sxs-lookup"><span data-stu-id="38917-448">The corresponding bubbling event is <xref:System.Windows.Input.Mouse.MouseMove>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-449">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-449">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-450">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-450">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-451">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-451">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-452">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-452">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-453">当释放任何鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-453">Occurs when any mouse button is released.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-454">已释放的鼠标按钮通过检查事件的参数来确定。</span><span class="sxs-lookup"><span data-stu-id="38917-454">Which mouse button was released is determined by checking the arguments of the event.</span></span>  
  
 <span data-ttu-id="38917-455">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-455">This is an attached event.</span></span> <span data-ttu-id="38917-456">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-456">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-457">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-457">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-458">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-458">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-459">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-459">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-460">Windows Presentation Foundation (WPF) 框架通过将其作为两个不同的公共语言运行时在上 (CLR) 事件，在此附加事件上生成 <xref:System.Windows.UIElement> ： <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-460">The Windows Presentation Foundation (WPF) framework builds on this attached event by surfacing it as two different common language runtime (CLR) events on <xref:System.Windows.UIElement>: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="38917-461">这些实现处理基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp> 事件并读取事件的参数，以确定是否涉及鼠标左键或右键。</span><span class="sxs-lookup"><span data-stu-id="38917-461">These implementations handle the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp> event and read the arguments of the event to determine whether the left or right mouse button was involved.</span></span> <span data-ttu-id="38917-462">对于三按钮，中间按钮没有框架级事件支持，您应该使用 <xref:System.Windows.Input.Mouse.PreviewMouseUp> 事件并检查事件参数中的中间按钮条件。</span><span class="sxs-lookup"><span data-stu-id="38917-462">For three-button, there is no framework-level event support for the center button, and you should use the <xref:System.Windows.Input.Mouse.PreviewMouseUp> event and check for the center button condition in the event arguments.</span></span>  
  
 <span data-ttu-id="38917-463">对于与鼠标相关的路由事件，请注意如何或何时将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="38917-463">For routed events that relate to the mouse, be careful about how or when you mark them handled.</span></span> <span data-ttu-id="38917-464">处理根附近的事件，而不对源进行的处理可能不适用于组合控件，其中的合成部分可能具有预期的鼠标行为。</span><span class="sxs-lookup"><span data-stu-id="38917-464">Handling the event near the root and not handling by a child further toward the source may not be appropriate for composited controls, where the compositing pieces might have expected mouse behaviors.</span></span> <span data-ttu-id="38917-465">如果对其他元素是否还应知道有关任何给定鼠标操作的相关选择，这一困难非常困难，因为 WPF framework 选择的模型的基础 <xref:System.Windows.Input.Mouse> 路由事件会在路由时呈现为 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="38917-465">The difficulty in making the appropriate choices about whether other elements should also be informed about any given mouse action is in fact why the WPF framework chose the model of having the underlying <xref:System.Windows.Input.Mouse> routed event be surfaced as CLR events along the route.</span></span>  
  
## <a name="routed-event-information"></a><span data-ttu-id="38917-466">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-466">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-467">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-467">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|<span data-ttu-id="38917-468">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-468">Routing strategy</span></span>|<span data-ttu-id="38917-469">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-469">Tunneling</span></span>|  
|<span data-ttu-id="38917-470">委托</span><span class="sxs-lookup"><span data-stu-id="38917-470">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="38917-471">对应的冒泡事件为 <xref:System.Windows.Input.Mouse.MouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="38917-471">The corresponding bubbling event is <xref:System.Windows.Input.Mouse.MouseUp>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-472">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-472">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-473">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-473">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-474">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-474">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-475">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-475">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-476">当在捕获鼠标事件的元素之外释放主鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-476">Occurs when the primary mouse button is released outside the element that is capturing mouse events.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-477">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-477">This is an attached event.</span></span> <span data-ttu-id="38917-478">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-478">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-479">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-479">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-480">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-480">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-481">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-481">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
 <span data-ttu-id="38917-482">此事件不 resurfaced 在基元素上。</span><span class="sxs-lookup"><span data-stu-id="38917-482">This event is not resurfaced on base elements.</span></span> <span data-ttu-id="38917-483">主要是为了控制在其控件组合中尝试协调鼠标捕获和鼠标输入的作者。</span><span class="sxs-lookup"><span data-stu-id="38917-483">It is mainly of concern to control authors that are attempting to reconcile mouse capture and mouse input within their control compositing.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-484">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-484">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-485">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-485">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|<span data-ttu-id="38917-486">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-486">Routing strategy</span></span>|<span data-ttu-id="38917-487">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-487">Tunneling</span></span>|  
|<span data-ttu-id="38917-488">委托</span><span class="sxs-lookup"><span data-stu-id="38917-488">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="38917-489">没有相应的冒泡事件。</span><span class="sxs-lookup"><span data-stu-id="38917-489">There is no corresponding bubbling event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-490">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-490">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-491">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-491">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-492">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-492">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-493">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-493">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-494">在鼠标滚轮转动时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-494">Occurs when the mouse wheel rotates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-495">焦点或鼠标捕获优先于鼠标指针所在的位置;因此，如果从焦点或捕获的元素接收此事件，则鼠标指针实际上可能位于另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="38917-495">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might in fact be over another element at the time.</span></span>  
  
 <span data-ttu-id="38917-496">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-496">This is an attached event.</span></span> <span data-ttu-id="38917-497">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-497">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-498">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-498">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-499">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-499">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-500">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-500">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-501">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-501">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-502">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-502">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|<span data-ttu-id="38917-503">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-503">Routing strategy</span></span>|<span data-ttu-id="38917-504">隧道</span><span class="sxs-lookup"><span data-stu-id="38917-504">Tunneling</span></span>|  
|<span data-ttu-id="38917-505">委托</span><span class="sxs-lookup"><span data-stu-id="38917-505">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="38917-506">对应的冒泡事件为 <xref:System.Windows.Input.Mouse.MouseWheel> 。</span><span class="sxs-lookup"><span data-stu-id="38917-506">The corresponding bubbling event is <xref:System.Windows.Input.Mouse.MouseWheel>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-507">标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-507">Identifies the <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-508">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-508">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-509">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-509">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-510">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-510">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-511">获取主鼠标设备。</span><span class="sxs-lookup"><span data-stu-id="38917-511">Gets the primary mouse device.</span></span></summary>
        <value><span data-ttu-id="38917-512">设备。</span><span class="sxs-lookup"><span data-stu-id="38917-512">The device.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-513">此属性支持 Windows Presentation Foundation 基础结构，不应在代码中直接使用。</span><span class="sxs-lookup"><span data-stu-id="38917-513">This property supports the Windows Presentation Foundation infrastructure and is not intended to be used directly from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="38917-514">当元素查询当前鼠标光标时发生。</span><span class="sxs-lookup"><span data-stu-id="38917-514">Occurs when an element queries for the current mouse cursor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-515">这是一个附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-515">This is an attached event.</span></span> <span data-ttu-id="38917-516">WPF 将附加事件作为路由事件实现。</span><span class="sxs-lookup"><span data-stu-id="38917-516">WPF implements attached events as routed events.</span></span> <span data-ttu-id="38917-517">附加事件本质上是一个 XAML 语言概念，用于引用可以在未定义该事件的对象上处理的事件，WPF 通过同时启用该事件来遍历路由。</span><span class="sxs-lookup"><span data-stu-id="38917-517">Attached events are fundamentally a XAML language concept for referencing events that can be handled on objects that do not define that event, which WPF expands upon by also enabling the event to traverse a route.</span></span> <span data-ttu-id="38917-518">附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序，请使用指定的 Add \* 处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="38917-518">Attached events do not have a direct handling syntax in code; to attach handlers for a routed event in code, you use a designated Add\*Handler method.</span></span> <span data-ttu-id="38917-519">有关详细信息，请参阅 [附加事件概述](/dotnet/framework/wpf/advanced/attached-events-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-519">For details, see [Attached Events Overview](/dotnet/framework/wpf/advanced/attached-events-overview).</span></span>  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="38917-520">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="38917-520">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="38917-521">标识符字段</span><span class="sxs-lookup"><span data-stu-id="38917-521">Identifier field</span></span>|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|<span data-ttu-id="38917-522">路由策略</span><span class="sxs-lookup"><span data-stu-id="38917-522">Routing strategy</span></span>|<span data-ttu-id="38917-523">冒泡</span><span class="sxs-lookup"><span data-stu-id="38917-523">Bubbling</span></span>|  
|<span data-ttu-id="38917-524">委托</span><span class="sxs-lookup"><span data-stu-id="38917-524">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 <span data-ttu-id="38917-525">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="38917-525">There is no defined corresponding tunneling event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-526">标识 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件。</span><span class="sxs-lookup"><span data-stu-id="38917-526">Identifies the <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-527">在注册路由事件时创建路由事件标识符，并将结果存储为注册路由事件的类中的字段。</span><span class="sxs-lookup"><span data-stu-id="38917-527">Routed event identifiers are created when routed events are registered, and the result is stored as a field on the class that registers the routed event.</span></span> <span data-ttu-id="38917-528">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。</span><span class="sxs-lookup"><span data-stu-id="38917-528">These identifiers contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span> <span data-ttu-id="38917-529">通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="38917-529">You often use these identifiers as parameters to event system methods, to identify a particular routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-530">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-530">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-531">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-531">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-532">移除 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-532">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-533">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-533">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-534">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-534">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-535">移除 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-535">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-536">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-536">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-537">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-537">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-538">移除 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-538">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-539">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-539">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-540">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-540">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-541">移除 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-541">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-542">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-542">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-543">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-543">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-544">移除 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-544">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-545">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-545">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-546">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-546">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-547">移除 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-547">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-548">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-548">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-549">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-549">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-550">移除 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-550">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseUp" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-551">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-551">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-552">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-552">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-553">移除 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-553">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-554">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-554">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-555">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-555">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-556">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-556">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-557">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-557">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-558">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-558">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-559">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-559">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-560">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-560">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-561">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-561">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-562">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-562">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-563">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-563">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-564">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-564">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-565">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-565">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-566">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-566">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-567">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-567">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-568">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-568">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-569">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-569">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-570">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-570">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-571">移除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-571">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element"><span data-ttu-id="38917-572">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="38917-572">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to this event.</span></span></param>
        <param name="handler"><span data-ttu-id="38917-573">事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-573">The event handler.</span></span></param>
        <summary><span data-ttu-id="38917-574">移除 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="38917-574">Removes a handler for the <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-575">获取鼠标右键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-575">Gets the state of the right button.</span></span></summary>
        <value><span data-ttu-id="38917-576">鼠标右键的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-576">The state of the right mouse button.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38917-577">下面的示例演示如何通过检查的状态是否 <xref:System.Windows.Input.Mouse.RightButton%2A> 等于枚举值来确定是否按下了鼠标右键 <xref:System.Windows.Input.MouseButtonState> <xref:System.Windows.Input.MouseButtonState.Pressed> 。</span><span class="sxs-lookup"><span data-stu-id="38917-577">The following example shows how to determine whether the right mouse button is pressed by checking if the state of the <xref:System.Windows.Input.Mouse.RightButton%2A> is equal to the <xref:System.Windows.Input.MouseButtonState> enumeration value <xref:System.Windows.Input.MouseButtonState.Pressed>.</span></span>  <span data-ttu-id="38917-578">如果按下该按钮，将调用一个方法，该方法将更新示例中的显示元素。</span><span class="sxs-lookup"><span data-stu-id="38917-578">If the button is pressed, a method is called which updates display elements in the sample.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetCursor (cursor As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor"><span data-ttu-id="38917-579">要将鼠标指针设置为的光标。</span><span class="sxs-lookup"><span data-stu-id="38917-579">The cursor to set the mouse pointer to.</span></span></param>
        <summary><span data-ttu-id="38917-580">将鼠标指针设置到指定的 <see cref="T:System.Windows.Input.Cursor" />。</span><span class="sxs-lookup"><span data-stu-id="38917-580">Sets the mouse pointer to the specified <see cref="T:System.Windows.Input.Cursor" />.</span></span></summary>
        <returns><span data-ttu-id="38917-581">如果设置了光标，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="38917-581"><see langword="true" />, if the cursor was set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38917-582">正在设置的游标不适用于任何特定的元素，而是应用于整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="38917-582">The cursor being set does not apply to any particular element, but rather it applies to the whole application.</span></span>  <span data-ttu-id="38917-583">因此，如果在设置光标后将鼠标指针移动到设置光标的对象上，则将再次更改光标。</span><span class="sxs-lookup"><span data-stu-id="38917-583">So, if after setting the cursor the mouse pointer moves over an object which sets the cursor, the cursor will be changed again.</span></span>  
  
 <span data-ttu-id="38917-584">若要强制鼠标指针指向特定的 <xref:System.Windows.Input.Cursor> 并对所有元素强制执行此 <xref:System.Windows.Input.Cursor> 设置，请设置 <xref:System.Windows.Input.Mouse.OverrideCursor%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="38917-584">To force the mouse pointer to a specific <xref:System.Windows.Input.Cursor> and to force this <xref:System.Windows.Input.Cursor> on all elements, set the <xref:System.Windows.Input.Mouse.OverrideCursor%2A> property.</span></span>  
  
 <span data-ttu-id="38917-585">若要在特定元素上设置光标，请 <xref:System.Windows.FrameworkElement.Cursor%2A> 在或上使用 <xref:System.Windows.FrameworkElement> 属性 <xref:System.Windows.FrameworkContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="38917-585">To set the cursor on a specific element, use the <xref:System.Windows.FrameworkElement.Cursor%2A> property on either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span>  <span data-ttu-id="38917-586">有关基元素的详细信息，请参阅 [基元素概述](/dotnet/framework/wpf/advanced/base-elements-overview)。</span><span class="sxs-lookup"><span data-stu-id="38917-586">For more information on the base elements, see the [Base Elements Overview](/dotnet/framework/wpf/advanced/base-elements-overview).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38917-587">强制同步鼠标重新。</span><span class="sxs-lookup"><span data-stu-id="38917-587">Forces the mouse to resynchronize.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="38917-588">强制更新鼠标光标。</span><span class="sxs-lookup"><span data-stu-id="38917-588">Forces the mouse cursor to be updated.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-589">获取第一个扩展按钮的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-589">Gets the state of the first extended button.</span></span></summary>
        <value><span data-ttu-id="38917-590">第一个鼠标扩展按钮的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-590">The state of the first extended mouse button.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38917-591">下面的示例演示如何通过检查的状态是否 <xref:System.Windows.Input.Mouse.XButton1%2A> 等于枚举值来确定是否按下了第一个鼠标扩展按钮 <xref:System.Windows.Input.MouseButtonState> <xref:System.Windows.Input.MouseButtonState.Pressed> 。</span><span class="sxs-lookup"><span data-stu-id="38917-591">The following example shows how to determine whether the first extended mouse button is pressed by checking if the state of <xref:System.Windows.Input.Mouse.XButton1%2A> is equal to the <xref:System.Windows.Input.MouseButtonState> enumeration value <xref:System.Windows.Input.MouseButtonState.Pressed>.</span></span>  <span data-ttu-id="38917-592">如果按下该按钮，将调用一个方法，该方法将更新示例中的显示元素。</span><span class="sxs-lookup"><span data-stu-id="38917-592">If the button is pressed, a method is called which updates display elements in the sample.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="38917-593">获取第二个扩展按钮的当前状态。</span><span class="sxs-lookup"><span data-stu-id="38917-593">Gets the state of the second extended button.</span></span></summary>
        <value><span data-ttu-id="38917-594">第二个鼠标扩展按钮的状态。</span><span class="sxs-lookup"><span data-stu-id="38917-594">The state of the second extended mouse button.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38917-595">下面的示例演示如何通过检查的状态是否 <xref:System.Windows.Input.Mouse.XButton2%2A> 等于枚举值来确定是否按下了第二个鼠标扩展按钮 <xref:System.Windows.Input.MouseButtonState> <xref:System.Windows.Input.MouseButtonState.Pressed> 。</span><span class="sxs-lookup"><span data-stu-id="38917-595">The following example shows how to determine whether the second extended mouse button is pressed by checking if the state of <xref:System.Windows.Input.Mouse.XButton2%2A> is equal to the <xref:System.Windows.Input.MouseButtonState> enumeration value <xref:System.Windows.Input.MouseButtonState.Pressed>.</span></span>  <span data-ttu-id="38917-596">如果按下该按钮，将调用一个方法，该方法将更新示例中的显示元素。</span><span class="sxs-lookup"><span data-stu-id="38917-596">If the button is pressed, a method is called which updates display elements in the sample.</span></span>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>
