<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata><Meta Name="ms.openlocfilehash" Value="37bab51ac0dfe091a4e88510c2f55d99b576f6f4" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86692833" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示工作流实例。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowInstance> 类可以公开用于控制执行工作流实例的方法和属性，它实质上是工作流运行时引擎所使用的实际工作流的代理。 通过调用包含在 <xref:System.Workflow.Runtime.WorkflowInstance> 类中的适当方法，宿主或服务可以指示工作流运行时引擎在工作流实例上执行操作。  如果请求的操作无效，例如，如果宿主在一个已完成的工作流实例上调用 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A>，则工作流运行时引擎将引发相应的异常。  
  
> [!NOTE]
>  如果工作流实例由于宿主应用程序上的调用未返回而无法响应，则恢复此实例的唯一方法是重新启动运行时。 但是，如果实例被强行卸载、中止或挂起，则仍可以通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> 方法继续此实例。  
  
   
  
## Examples  
 下面的代码示例演示如何在工作流主机中创建和启动 <xref:System.Workflow.Runtime.WorkflowInstance>。 此代码先创建 <xref:System.Workflow.Runtime.WorkflowRuntime> 的实例，将服务添加至运行时，然后演示一个创建 <xref:System.Workflow.Runtime.WorkflowInstance> 对象的推荐方式。 该代码通过调用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法并向该方法传递事先创建的类型来初始化 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>。 使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法调用启动 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>。  
  
 此代码示例摘自 Program.cs 文件中的“取消工作流”SDK 示例。 有关详细信息，请参阅 [取消工作流](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">取消工作流</related>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中止工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流实例以同步方式中止，即方法在中止工作流实例之后返回。 工作流运行时引擎将使内存中的工作流实例无效，并清除 <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>。 如果工作流实例使用了持久性服务，则在最后一个持久点之后执行的所有工作都将被丢弃。 在中止工作流实例之后，工作流运行时引擎将引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> 事件。 您可以调用 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 以便重新加载工作流实例，并从其最后的持久点启动。  
  
 `Abort` 与 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 的不同之处在于，`Abort` 只是清除内存中的工作流实例，并可以从最后一个持久点重新启动；而 Terminate 则是清除内存中的工作流实例，并通知持久性服务此实例已从内存中清除。 对于 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>，这表示终止时该工作流实例的所有状态信息都已从数据库中删除。 您将无法从先前存储的持久点处重新加载工作流实例。  
  
   
  
## Examples  
 下面的示例演示如何在类型为 Workflow1 的工作流实例上调用“Abort”。  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyWorkflowChanges (workflowChanges As WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">一个 <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />，为工作流实例指定动态更新。</param>
        <summary>将更改应用到 <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> 对象所指定的工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作流实例尚未挂起，则工作流运行时引擎将在应用更改之前暂时挂起实例。  
  
   
  
## Examples  
 下面的代码示例演示如何对 <xref:System.Workflow.Runtime.WorkflowInstance> 对象调用 ApplyWorkflowChanges。  此代码示例摘自 Mainform.cs 文件中“自定义持久性服务”SDK 示例。  有关详细信息，请参阅 [订购状态机示例](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c)。  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName"><see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 的名称。</param>
        <param name="item">要排入队列的对象。</param>
        <param name="pendingWork">允许在传递 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 时通知发送方的 <paramref name="item" />。</param>
        <param name="workItem">要传递给 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 方法的对象。</param>
        <summary>将消息同步发送到指定工作流队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 `item` 发送到指定的 <xref:System.Workflow.Runtime.WorkflowQueue>。 若要在传递消息之后获得通知，您可以在您的服务中实现 <xref:System.Workflow.Runtime.IPendingWork>，并将一个 `workItem` 和一个 <xref:System.Workflow.Runtime.IPendingWork> 对象传送至 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 如果不想要此类通知，则可以为 `Nothing` 和 `pendingWork` 传送空引用（在 Visual Basic 中为 `workItem`）。  
  
 在将此方法和状态机工作流一起使用时，您可能会收到异常，并收到消息“未启用队列‘{0}’”。 当状态机的当前状态不知道如何处理特定事件时，则会发生此异常。 例如，当前状态以外的其他状态包含 <xref:System.Workflow.Activities.EventDrivenActivity>，而后者包含由队列“{0}”表示的 <xref:System.Workflow.Activities.HandleExternalEventActivity> 时。  
  
> [!NOTE]
>  不保证工作流实例按消息发送的顺序接收消息。 例如，如果在现有队列（队列 A）中接收消息会导致工作流创建另一个队列（队列 B），该队列随后会侦听在发送第一条消息之后发送的另一条消息，那么，有可能第二条消息会先到达，但由于尚未创建其队列而无法接收。 为了避免此问题，在发送第二条消息之前，必须先验证第二个队列是否存在（使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>）。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 当 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件发生时，调用本示例中定义的 `OnWorkflowIdled` 方法。 该方法使用 <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> 属性来确定哪个工作流处于空闲状态，然后通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法来获取该工作流实例的排队项的集合。 该代码会循环访问该集合以确定哪个活动正在等待使工作流处于空闲状态的事件。 然后，该代码将使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> 方法以及事件队列项的名称向工作流队列发出一个异常。  
  
 此代码示例摘自 Program.cs 文件中的“取消工作流”SDK 示例。 有关详细信息，请参阅 [取消工作流](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="queueName" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。  
  
- 或 - 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 不存在。  
  
- 或 - 
由 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 未启用。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">取消工作流</related>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName"><see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 的名称。</param>
        <param name="item">要排入队列的对象。</param>
        <param name="pendingWork">允许在传递 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 时通知发送方的 <paramref name="item" />。</param>
        <param name="workItem">要传递给 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 方法的对象。</param>
        <summary>当工作流处于空闲状态时，将消息发送到指定的工作流队列。 在确认工作流计划程序处于空闲状态（即没有执行任何有效操作）之后，<see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> 将一直等待，直至工作流达到空闲点并编排队列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等待工作流实例变为空闲状态，然后将 `item` 发送到指定的 <xref:System.Workflow.Runtime.WorkflowQueue>。 如果在工作流实例处于挂起状态时调用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A>，工作流运行时引擎将引发 <xref:System.InvalidOperationException>。 若要在传递消息之后获得通知，您可以在您的服务中实现 <xref:System.Workflow.Runtime.IPendingWork>，并将一个 `workItem` 和一个 <xref:System.Workflow.Runtime.IPendingWork> 对象传送至 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 如果不想要此类通知，则可以为 `Nothing` 和 `pendingWork` 传送空引用（在 Visual Basic 中为 `workItem`）。  
  
 在将此方法和状态机工作流一起使用时，您可能会收到异常，并收到消息“未启用队列‘{0}’”。 当状态机的当前状态不知道如何处理特定事件时，则会发生此异常。 例如，当前状态以外的其他状态包含 <xref:System.Workflow.Activities.EventDrivenActivity>，而后者包含由队列“{0}”表示的 <xref:System.Workflow.Activities.HandleExternalEventActivity> 时。  
  
   
  
## Examples  
 下面的示例演示如何使用 `EnqueueItemOnIdle` 方法将信息发送到工作流实例。 首先，创建并启动 WorkflowInstance 对象；接着，创建一个实现 <xref:System.Workflow.Runtime.IPendingWork> 接口的对象。 `EnqueueItemOnIdle` 然后，将调用，传入队列名称的字符串值、排队项以及要传递给 pendingWork 对象的方法的工作项。  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="queueName" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。  
  
- 或 - 
工作流实例处于挂起状态。  
  
- 或 - 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 不存在。  
  
- 或 - 
由 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 未启用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比较的对象。</param>
        <summary>返回一个值，该值指示指定对象是否等于 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</summary>
        <returns>如果指定对象等于此 <see langword="true" />，则为 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此对象必须是 <xref:System.Workflow.Runtime.WorkflowInstance> 类的一个实例，并具有与此 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 相同的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此工作流实例的哈希代码。</summary>
        <returns>此 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> 返回的哈希代码基于 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索此工作流实例的根活动。</summary>
        <returns>一个 <see cref="T:System.Workflow.ComponentModel.Activity" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用根活动来定位工作流的活动层次结构。  
  
 此方法不是线程安全的，因此宿主应将其调用与此方法同步。  
  
   
  
## Examples  
 下面的示例演示如何从工作流实例中检索工作流定义。  此代码示例摘自 Mainform.cs 文件中“自定义持久性服务”SDK 示例。  有关详细信息，请参阅 [订购状态机示例](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c)。  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回下一个时间点，已计划在此时间点向此 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 传递计时器消息。</summary>
        <returns>DateTime 值表示下一个 <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> 时间，将在此时间向此 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 传递计时器消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> 方法来确定是否将其他工作流计时器消息编入队列。 此示例摘自 Program.cs 文件中的 WorkflowThreading SDK 示例。 有关详细信息，请参阅 [工作流线程示例](https://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9)。  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> 对象的集合，该集合包含与此工作流实例关联的工作流队列的挂起项和订阅活动。</summary>
        <returns>一个由 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 对象构成的 <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 将返回 <xref:System.Workflow.Runtime.WorkflowQueueInfo> 对象的集合，每个集合都包含与此工作流实例关联的其中一个工作流队列状态的有关信息。 <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> 包含 <xref:System.Workflow.Runtime.WorkflowQueue> 的挂起项，<xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> 包含一个活动列表，需要订阅这些活动以便在 <xref:System.Workflow.Runtime.WorkflowQueue> 上发送项。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法获取有关与 <xref:System.Workflow.Runtime.WorkflowInstance> 对象关联的所有工作流队列状态的信息。 当 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件发生时，调用本示例中定义的 `OnWorkflowIdled` 方法。 该方法使用 <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> 属性来确定哪个工作流处于空闲状态，然后通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法来获取该工作流实例的排队项的集合。 该代码会循环访问该集合以确定哪个活动正在等待使工作流处于空闲状态的事件。 然后，该代码将使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> 方法以及事件队列项的名称向工作流队列发出一个异常。  
  
 此代码示例摘自 Program.cs 文件中的“取消工作流”SDK 示例。 有关详细信息，请参阅 [取消工作流](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">取消工作流</related>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取工作流实例的唯一标识符。</summary>
        <value>工作流实例的 <see cref="T:System.Guid" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 来引用工作流实例。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 属性获取有关 <xref:System.Workflow.Runtime.WorkflowInstance> 对象的信息。 第一个代码段创建名为 <xref:System.Workflow.Runtime.WorkflowInstance> 的 `instanceId` 变量。  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 当调用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 方法时，第二个代码段使用 `OrderEventArgs` 属性作为 `CallBackForApproval` 构造函数调用中的第一个对象。  
  
 此代码示例摘自 OrderServiceImple.cs 文件中“自定义持久性服务”SDK 示例。 有关详细信息，请参阅 [侦听示例](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90))。  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)">“侦听”示例</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加载先前卸载的工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 是同步的，如果工作流实例可以加载，则 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 将在工作流实例被加载到内存并由工作流运行时引擎计划后返回。 运行时将在持久性服务恢复内存中的工作流之后与工作流运行时引擎计划实例之前引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 事件。  
  
   
  
## Examples  
 下面的示例演示如何加载先前卸载的 <xref:System.Workflow.Runtime.WorkflowInstance> 对象。  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载此工作流实例的跟踪配置文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 运行时跟踪基础结构将为与其跟踪通道关联的工作流实例重新加载各个 <xref:System.Workflow.Runtime.Tracking.TrackingProfile>。 如果它还没有处于挂起状态，则运行时跟踪基础结构将暂时挂起工作流，同时重新加载跟踪配置文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>继续执行先前挂起的工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宿主可以调用 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> 以继续执行先前挂起的工作流实例。 如果工作流实例不处于挂起状态，则不执行任何操作。 运行时恰好在继续执行工作流实例之前引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。  
  
   
  
## Examples  
 下面的示例演示如何在先前挂起的工作流实例上调用“Resume”。  此示例摘自“挂起和终止”SDK 示例。  有关详细信息，请参阅 [挂起和终止示例](https://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517)。  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始执行工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 将对此工作流实例的根活动调用 <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A>。 如果 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 遇到异常，则它将通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A>，并使用异常的 <xref:System.Exception.Message%2A> 属性（作为终止原因传递）来终止此工作流实例。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 方法在工作流主机中启动 <xref:System.Workflow.Runtime.WorkflowInstance>。 此代码先创建 <xref:System.Workflow.Runtime.WorkflowRuntime> 的实例，将服务添加至运行时，然后演示一个创建 <xref:System.Workflow.Runtime.WorkflowInstance> 对象的推荐方式。 它将创建一个 <xref:System.Type> 对象，然后将其强制转换为一个与其宿主关联的工作流对象。 代码接着通过调用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法并传递给其先前创建的类型来初始化 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>。 使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法调用启动 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>。  
  
 此代码示例摘自 Program.cs 文件中的“取消工作流”SDK 示例。 有关详细信息，请参阅 [取消工作流](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。  
  
 - 或 -  
  
 工作流实例已经启动。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">取消工作流</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">挂起工作流实例原因的说明。</param>
        <summary>挂起工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此工作流实例是以同步方式挂起的。 如果工作流实例已经挂起，则不执行任何操作；否则，工作流运行时引擎将挂起工作流实例，引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 事件，并在 `reason` 中传递 <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>。  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> 不会卸载此工作流实例。  
  
   
  
## Examples  
 下面的代码示例演示如何在 <xref:System.Workflow.Runtime.WorkflowInstance> 对象上调用“Suspend”。  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">终止工作流实例原因的说明。</param>
        <summary>以同步方式终止工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此工作流实例是以同步方式终止的。 宿主调用 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 终止工作流实例。 工作流运行时引擎将清除内存中的工作流实例，并通知持久性服务实例已经从内存中清除。 对于 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>，这表示终止时该工作流实例的所有状态信息都已从数据库中删除。 您将无法从先前存储的持久点处重新加载工作流实例。  
  
 在清除内存中的工作流实例并通知持久性服务终止之后， 方法将引发  事件，并在 包含的 T:System.Workflow.ComponentModel.WorkflowTerminatedException 的  属性中传递 。  
  
 `Terminate` 与 <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> 的不同之处在于，Terminate 将清除内存中的工作流实例，并通知持久性服务已发生终止；而 `Abort` 只是清除内存中的工作流实例，然后您可以从最后一个持久点重新启动该实例。  
  
   
  
## Examples  
 下面的代码示例演示如何在 <xref:System.Workflow.Runtime.WorkflowInstance> 对象上调用“Terminate”。  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎未运行。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当实例处于挂起或空闲状态时，将工作流实例从内存卸载到持久性存储区。</summary>
        <returns>如果已卸载工作流实例，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作流实例处于“空闲”或“挂起”状态，则 <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 将使用持久性服务从内存中移除此工作流实例，并将其保留到数据存储区。 如果不存在使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 注册的持久性服务，则 <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 将引发 <xref:System.InvalidOperationException>。 如果工作流实例成功保留，则运行时将引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件，并返回 `true`。 如果工作流实例已卸载、已中止或已完成，则 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 将返回 `false`。  
  
 宿主可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 回收空闲工作流的系统资源。  
  
   
  
## Examples  
 下面的示例演示如何在 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件激发时使用 TryUnload 方法卸载工作流。 此示例摘自 Program.cs 文件中的“使用持久性服务”SDK 示例。 有关详细信息，请参阅 [使用持久性服务示例](https://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6)。  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">不存在已注册到工作流运行时引擎的持久性服务。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将工作流实例从内存卸载到持久性存储区。 此调用将进行阻止，直至当前计划的工作完成或事务范围结束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 是同步的，也就是说，它将在完成其执行的任何操作之后返回。 如果工作流实例不处于空闲状态，则运行时将一直等待，直至可以中断实例。 只有当前计划的工作项完成之后，才可以中断实例，这种情况通常发生在当前运行的活动从其 <xref:System.Workflow.ComponentModel.Activity.Execute%2A> 方法返回时。 但是，如果实例正在执行 <xref:System.Workflow.ComponentModel.TransactionScopeActivity>，则事务范围必须在可将实例中断之前完成执行。 然后，“Unload”将使用持久性服务从内存中移除工作流实例，并将其保留在数据存储区。 如果不存在使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 注册的持久性服务，则 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 将引发 <xref:System.InvalidOperationException>。 如果工作流实例成功保留，则运行时将引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件。  
  
 宿主可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 回收空闲工作流的系统资源。  
  
   
  
## Examples  
 下面的示例演示对 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 对象调用 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">不存在已注册到工作流运行时引擎的持久性服务。</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此工作流实例的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</summary>
        <value>一个 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />，表示此工作流实例在其中运行的执行环境。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何访问 <xref:System.Workflow.Runtime.WorkflowRuntime> 对象的正在执行的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
