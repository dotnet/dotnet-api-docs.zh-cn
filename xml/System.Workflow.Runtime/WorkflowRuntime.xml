<Type Name="WorkflowRuntime" FullName="System.Workflow.Runtime.WorkflowRuntime">
  <Metadata><Meta Name="ms.openlocfilehash" Value="461bd1059424a54570086ca19e287d52aa817cc1" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83947889" /></Metadata><TypeSignature Language="C#" Value="public class WorkflowRuntime : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi WorkflowRuntime extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowRuntime" />
  <TypeSignature Language="VB.NET" Value="Public Class WorkflowRuntime&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowRuntime : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type WorkflowRuntime = class&#xA;    interface IServiceProvider&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示工作流运行时引擎为工作流提供的可配置执行环境。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowRuntime> 公开主机应用程序和服务所需的功能来配置和控制工作流运行时引擎，并接收工作流运行时引擎及其任何工作流实例发生更改的通知。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 构造函数和 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A>、<xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 方法。 该代码还给出了建议采用的方法，即如何使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法在工作流主机中创建 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 对象。 它还演示如何为 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted>、<xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> 事件设置事件处理程序。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime> 是以默认属性值进行初始化的，包含默认的核心服务。 若要另外配置工作流运行时引擎，可以通过使用 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.RemoveService%2A> 来添加和移除服务，还可以设置 <xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A>。 配置 <xref:System.Workflow.Runtime.WorkflowRuntime> 后，调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 以启动工作流运行时引擎及其服务。  
  
 下表显示 <xref:System.Workflow.Runtime.WorkflowRuntime> 类的实例的初始属性值。  
  
|属性|初始值|  
|--------------|-------------------|  
|<xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A>|"WorkflowRuntime"|  
|<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>|`false`|  
  
 默认核心服务是 <xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService> 和 <xref:System.Workflow.Runtime.Hosting.DefaultWorkflowSchedulerService>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流主机中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 它提供了有关如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 构造函数来创建 <xref:System.Workflow.Runtime.WorkflowRuntime> 实例并访问其方法和事件的示例。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime (string configSectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configSectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configSectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime(System::String ^ configSectionName);" />
      <MemberSignature Language="F#" Value="new System.Workflow.Runtime.WorkflowRuntime : string -&gt; System.Workflow.Runtime.WorkflowRuntime" Usage="new System.Workflow.Runtime.WorkflowRuntime configSectionName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configSectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configSectionName">应用程序配置文件中有效的 <see langword="workflowSettings" /> 节的名称。</param>
        <summary>使用应用程序配置文件的指定节初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据应用程序配置文件中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 所指定节中的设置初始化的 `configSectionName`。 `configSectionName` 必须与配置文件的有效 `workflowSettings` 部分对应。  
  
 当通过使用应用程序配置文件来配置工作流运行时引擎时，它将加载并实例化配置文件的 `Services` 节中列出的类型的类。 工作流运行时引擎构造这些类时，将按以下顺序查找使用以下签名的类构造函数：  
  
1.  Service(WorkflowRuntime 运行时,NameValueCollection 参数)  
  
2.  Service(WorkflowRuntime 运行时)  
  
3.  Service(NameValueCollection 参数)  
  
4.  Service()  
  
 从配置文件加载的所有服务类至少必须实现这些构造函数签名之一。  
  
 有关详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="configSectionName" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ArgumentException">在应用程序配置文件中无法找到有效的 <see langword="workflowSettings" /> 节。</exception>
        <exception cref="T:System.InvalidOperationException">此应用程序域已存在 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime (System.Workflow.Runtime.Configuration.WorkflowRuntimeSection settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Workflow.Runtime.Configuration.WorkflowRuntimeSection settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor(System.Workflow.Runtime.Configuration.WorkflowRuntimeSection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As WorkflowRuntimeSection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime(System::Workflow::Runtime::Configuration::WorkflowRuntimeSection ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Workflow.Runtime.WorkflowRuntime : System.Workflow.Runtime.Configuration.WorkflowRuntimeSection -&gt; System.Workflow.Runtime.WorkflowRuntime" Usage="new System.Workflow.Runtime.WorkflowRuntime settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settings" Type="System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" />
      </Parameters>
      <Docs>
        <param name="settings">一个 <see cref="T:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" />。</param>
        <summary>使用指定的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 中的设置初始化 <see cref="T:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数提供了一个机制，可对不使用应用程序配置文件的宿主使用单一方法调用来配置工作流运行时引擎。 不使用应用程序配置文件的原因很多。 宿主可以在不允许使用配置文件的环境中运行，例如在受信任环境中由于安全原因不允许从应用程序配置文件读取数据。 此外，宿主可以使用专有的配置机制；例如，宿主可以将工作流运行时引擎的配置设置存储在 SQL 数据库中。  
  
 工作流运行时引擎将会加载 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.Services%2A?displayProperty=nameWithType> 中所含类型的类并将其实例化。 工作流运行时引擎构造这些类时，将按以下顺序查找使用以下签名的类构造函数：  
  
1.  Service(WorkflowRuntime 运行时,NameValueCollection 参数)  
  
2.  Service(WorkflowRuntime 运行时)  
  
3.  Service(NameValueCollection 参数)  
  
4.  Service()  
  
 `settings` 中指定的所有服务类至少必须实现这些构造函数签名之一。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="settings" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.InvalidOperationException">此应用程序域已存在 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddService">
      <MemberSignature Language="C#" Value="public void AddService (object service);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddService(object service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.AddService(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddService (service As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddService(System::Object ^ service);" />
      <MemberSignature Language="F#" Value="member this.AddService : obj -&gt; unit" Usage="workflowRuntime.AddService service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="service">一个对象，表示要添加服务。</param>
        <summary>将指定的服务添加到工作流运行时引擎中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过添加核心服务可以配置工作流运行时引擎。 核心服务是派生自以下任一服务基类的服务：<xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 类和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 类。  仅当工作流运行时引擎未运行时，才能添加核心服务;也就是说，当 `false`<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 时。 <xref:System.Workflow.Runtime.WorkflowRuntime> 也可以用作存储其他服务的容器，其他工作流或宿主上运行的应用程序可能会使用这些服务。 如果您在工作流运行时引擎启动后添加派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的非核心服务，则 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 将会调用该服务实现的 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A> 方法。  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 有一些限制，即不能将同一 <xref:System.Type> 的两个服务添加到 <xref:System.Workflow.Runtime.WorkflowRuntime>。 但是，您可以添加派生自相同基类的多个服务。  从 <xref:System.Workflow.Runtime.WorkflowRuntime> 中的以下每个服务基类只能派生一个服务：<xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 类和 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 类。  如果您添加了派生自其中一个类的多个服务（例如两个持久性服务），则 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 将引发 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 它提供了有关如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 方法向工作流运行时引擎添加 <xref:System.Workflow.Activities.ExternalDataExchangeService> 和 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 的示例。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkId=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="service" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="service" /> 已向工作流运行时引擎注册。  
  
- 或 - 
 <paramref name="service" /> 为核心服务，且工作流运行时引擎已运行（此时 <see cref="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" /> 为 <see langword="true" />）。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateWorkflow">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用指定参数创建工作流实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未启动工作流运行时引擎，<xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 方法将调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。 有关可能的异常的列表，请参见 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。 创建工作流实例后，请对 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A?displayProperty=nameWithType> 方法返回的 <xref:System.Workflow.Runtime.WorkflowInstance> 对象调用 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 以开始执行此实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow workflowType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="workflowType">待创建工作流的 <see cref="T:System.Type" />。</param>
        <summary>使用指定工作流 <see cref="T:System.Type" /> 创建新的工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法在工作流主机中创建 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 对象。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow workflowDefinitionReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">一个 <see cref="T:System.Xml.XmlReader" />，它包含工作流定义。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 创建工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该工作流实例是根据 <xref:System.Xml.XmlReader> 引用的 XAML 工作流定义文件创建的。  
  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
   
  
## Examples  
 下面的示例演示如何在给定基于 XAML 的工作流定义的情况下创建工作流。  
  
```  
static void Main(string[] args)  
{  
    using (WorkflowRuntime workflowRuntime = new WorkflowRuntime())  
    {  
        AutoResetEvent waitHandle = new AutoResetEvent(false);  
        workflowRuntime.WorkflowCompleted += delegate(object sender, WorkflowCompletedEventArgs e)  
        {  
            waitHandle.Set();  
        };  
        workflowRuntime.WorkflowTerminated += delegate(object sender, WorkflowTerminatedEventArgs e)  
        {  
            Console.WriteLine(e.Exception.Message);  
            waitHandle.Set();  
        };  
  
        TypeProvider typeProvider = new TypeProvider(null);  
        // Add referenced assemblies, if needed  
        // typeProvider.AddAssembly(...);  
        workflowRuntime.AddService(typeProvider);  
  
        using (XmlReader reader = XmlReader.Create("Workflow1.xoml"))  
        {  
            WorkflowInstance instance = workflowRuntime.CreateWorkflow(reader);  
            instance.Start();  
        }  
  
        waitHandle.WaitOne();  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowDefinitionReader" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type, namedArgumentValues As Dictionary(Of String, Object)) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type * System.Collections.Generic.Dictionary&lt;string, obj&gt; -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowType, namedArgumentValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowType">待创建工作流的 <see cref="T:System.Type" />。</param>
        <param name="namedArgumentValues">对象的一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，由表示工作流参数的字符串进行键控。</param>
        <summary>使用指定工作流 <see cref="T:System.Type" /> 和指定 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的工作流参数创建工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 有关将参数传递到 `CreateWorkflow`的示例，请参阅[带参数的工作流示例](https://go.microsoft.com/fwlink/?LinkId=157403)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues, valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type, namedArgumentValues As Dictionary(Of String, Object), instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type * System.Collections.Generic.Dictionary&lt;string, obj&gt; * Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowType, namedArgumentValues, instanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="workflowType">待创建工作流的 <see cref="T:System.Type" />。</param>
        <param name="namedArgumentValues">对象的一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，由表示工作流参数的字符串进行键控。</param>
        <param name="instanceId">待创建的特定 <see cref="T:System.Guid" /> 的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</param>
        <summary>使用指定参数创建工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 由 `instanceId` 加载的任何运行工作流的工作流 <xref:System.Workflow.Runtime.WorkflowRuntime> 必须具有唯一性。 如果您要传递一个 `instanceId` 来创建工作流，而某个运行中的工作流已在使用该 `instanceId`，将会引发 <xref:System.InvalidOperationException>。  
  
 有关将参数传递到 `CreateWorkflow`的示例，请参阅[带参数的工作流示例](https://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader, System.Xml.XmlReader rulesReader, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader, class System.Xml.XmlReader rulesReader, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader,System.Xml.XmlReader,System.Collections.Generic.Dictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader, rulesReader As XmlReader, namedArgumentValues As Dictionary(Of String, Object)) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader, System::Xml::XmlReader ^ rulesReader, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader * System.Xml.XmlReader * System.Collections.Generic.Dictionary&lt;string, obj&gt; -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowDefinitionReader, rulesReader, namedArgumentValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
        <Parameter Name="rulesReader" Type="System.Xml.XmlReader" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">一个 <see cref="T:System.Xml.XmlReader" />，它包含工作流定义。</param>
        <param name="rulesReader">一个 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="namedArgumentValues">对象的一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，由表示工作流参数的字符串进行键控。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 对象和指定的 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的自变量创建工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该工作流实例是根据 <xref:System.Xml.XmlReader> 引用的工作流定义和 `namedArgumentValues` 提供的自变量创建的。  
  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 有关将参数传递到 `CreateWorkflow`的示例，请参阅[带参数的工作流示例](https://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 有关使用 XML 中定义的规则的示例，请参阅[IfElse With Rules 示例](https://go.microsoft.com/fwlink/?LinkId=157404)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowDefinitionReader" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader, System.Xml.XmlReader rulesReader, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader, class System.Xml.XmlReader rulesReader, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues, valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader,System.Xml.XmlReader,System.Collections.Generic.Dictionary{System.String,System.Object},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader, rulesReader As XmlReader, namedArgumentValues As Dictionary(Of String, Object), instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader, System::Xml::XmlReader ^ rulesReader, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader * System.Xml.XmlReader * System.Collections.Generic.Dictionary&lt;string, obj&gt; * Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowDefinitionReader, rulesReader, namedArgumentValues, instanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
        <Parameter Name="rulesReader" Type="System.Xml.XmlReader" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">一个 <see cref="T:System.Xml.XmlReader" />，它包含工作流定义。</param>
        <param name="rulesReader">一个 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="namedArgumentValues">对象的一个 <see cref="T:System.Collections.Generic.Dictionary`2" />，由表示工作流参数的字符串进行键控。</param>
        <param name="instanceId">待创建的特定 <see cref="T:System.Guid" /> 的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</param>
        <summary>使用指定参数创建工作流实例。</summary>
        <returns>创建的工作流实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，会对其执行验证。 如果出现任何验证错误，则会引发 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 这对简单的方案很有用，但在服务器环境中，在每次激活时重新验证工作流可能会增加不必要的系统开销。  
  
 有关禁用验证的详细信息，请参阅 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 由 `instanceId` 加载的任何运行工作流的工作流 <xref:System.Workflow.Runtime.WorkflowRuntime> 必须具有唯一性。 如果您要传递一个 `instanceId` 来创建工作流，而某个运行中的工作流已在使用该 `instanceId`，将会引发 <xref:System.InvalidOperationException>。  
  
 有关将参数传递到 `CreateWorkflow`的示例，请参阅[带参数的工作流示例](https://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 有关使用 XML 中定义的规则的示例，请参阅[IfElse With Rules 示例](https://go.microsoft.com/fwlink/?LinkID=157404)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="workflowType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="workflowRuntime.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 使用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要正常关闭 <xref:System.Workflow.Runtime.WorkflowRuntime>，应仅在调用 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 之后才调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。 这是因为单独调用 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法会使 <xref:System.Workflow.Runtime.WorkflowRuntime> 处于不可用状态。 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 通过关闭文件句柄、数据库连接等来释放运行时占用的资源，但它不会卸载工作流实例、停止服务或执行 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 所执行的任何其他操作。  
  
 只有当宿主应用程序必须在垃圾收集器自动释放 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 使用的资源前释放这些资源时，才应调用 <xref:System.Workflow.Runtime.WorkflowRuntime>。 有关 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A>的常规信息，请参阅[清理非托管资源](/dotnet/standard/garbage-collection/unmanaged)和[实现 Dispose 方法](/dotnet/standard/garbage-collection/implementing-dispose)。  
  
   
  
## Examples  
 下面的示例演示如何对 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 对象调用 <xref:System.Workflow.Runtime.WorkflowRuntime>。 在此示例中，将会针对应用程序的主窗体从 FormClosing 事件处理程序中调用 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法；这可确保在应用程序关闭时正确清理运行时创建的对象。 此示例来自[语音应用程序示例](https://go.microsoft.com/fwlink/?LinkId=157405)。  
  
 [!code-csharp[WF_Samples#108](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#108)]
 [!code-vb[WF_Samples#108](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllServices">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;object&gt; GetAllServices (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;object&gt; GetAllServices(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetAllServices(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllServices (serviceType As Type) As ReadOnlyCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Object ^&gt; ^ GetAllServices(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="member this.GetAllServices : Type -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;obj&gt;" Usage="workflowRuntime.GetAllServices serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">要返回服务所必须实现的 <see cref="T:System.Type" />。</param>
        <summary>检索实现或派生自指定的 <see cref="T:System.Type" /> 且添加到工作流运行时引擎的所有服务。</summary>
        <returns>实现或派生自指定 <see cref="T:System.Type" /> 的服务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 空 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 表示没有向工作流运行时引擎添加实现或派生自指定的 <xref:System.Type> 的服务。  
  
   
  
## Examples  
 下面的示例演示如何从 <xref:System.Workflow.Runtime.WorkflowRuntime> 对象中检索给定类型的所有服务。  
  
 [!code-csharp[WF_Samples#19](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#19)]
 [!code-vb[WF_Samples#19](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllServices&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; GetAllServices&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; GetAllServices&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetAllServices``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllServices(Of T) () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ GetAllServices();" />
      <MemberSignature Language="F#" Value="member this.GetAllServices : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="workflowRuntime.GetAllServices " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">服务类型。</typeparam>
        <summary>检索实现或派生自指定的泛型类型且添加到工作流运行时引擎的所有服务。</summary>
        <returns>实现或派生自指定泛型类型的服务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 空 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 表示没有向工作流运行时引擎添加实现或派生自指定泛型类型的服务。  
  
   
  
## Examples  
 下面的示例演示如何从 <xref:System.Workflow.Runtime.WorkflowRuntime> 对象中检索给定类型的所有服务。  
  
 [!code-csharp[WF_Samples#6](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#6)]
 [!code-vb[WF_Samples#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedWorkflows">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt; GetLoadedWorkflows ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowInstance&gt; GetLoadedWorkflows() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetLoadedWorkflows" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedWorkflows () As ReadOnlyCollection(Of WorkflowInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowInstance ^&gt; ^ GetLoadedWorkflows();" />
      <MemberSignature Language="F#" Value="member this.GetLoadedWorkflows : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt;" Usage="workflowRuntime.GetLoadedWorkflows " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个集合，该集合包含当前加载到内存的所有工作流实例。</summary>
        <returns>内存中当前加载的每个工作流实例的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，与 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 不同，在运行时未启动的情况下，此方法不会引发 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下面的示例演示如何从 <xref:System.Workflow.Runtime.WorkflowRuntime> 对象中检索已加载工作流的集合。  
  
 [!code-csharp[WF_Samples#18](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#18)]
 [!code-vb[WF_Samples#18](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="workflowRuntime.GetService serviceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">要检索的服务的 <see cref="T:System.Type" />。</param>
        <summary>从工作流运行时引擎中检索指定的 <see cref="T:System.Type" /> 的服务。</summary>
        <returns>指定的 <see cref="T:System.Type" /> 的服务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果存在多个指定的 <xref:System.Workflow.Runtime.WorkflowRuntime.GetService%2A> 的服务，则 <xref:System.InvalidOperationException> 将引发 <xref:System.Type>。 因此，如果 <xref:System.Workflow.Runtime.WorkflowRuntime.GetAllServices%2A> 中出现多个指定类型的服务，您应使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 的重载方法之一。 例如，工作流运行时引擎可能有多个跟踪服务。 如果通过指定 <xref:System.Workflow.Runtime.Tracking.TrackingService> 基类来请求跟踪服务，则可能会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceType" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">已找到多个 <paramref name="serviceType" /> 类型的服务。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetService&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetService&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetService&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetService``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetService();" />
      <MemberSignature Language="F#" Value="member this.GetService : unit -&gt; 'T" Usage="workflowRuntime.GetService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">服务类型。</typeparam>
        <summary>从工作流运行时引擎中检索指定泛型类型的服务。</summary>
        <returns>指定泛型类型的单个服务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果存在多个指定泛型类型的服务，则 <xref:System.Workflow.Runtime.WorkflowRuntime.GetService%2A> 将引发 <xref:System.InvalidOperationException>。 因此，如果 <xref:System.Workflow.Runtime.WorkflowRuntime.GetAllServices%2A> 中出现多个该泛型类型的服务，您应使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 的重载方法之一。 例如，工作流运行时引擎可能有多个跟踪服务。 如果通过指定 <xref:System.Workflow.Runtime.Tracking.TrackingService> 基类来请求跟踪服务，则可能会引发异常。  
  
   
  
## Examples  
 下面的示例演示如何从 <xref:System.Workflow.Runtime.WorkflowRuntime> 对象中检索单个服务；在本例中是 <xref:System.Workflow.Runtime.Hosting.ManualWorkflowSchedulerService> 类型的服务。 此示例来自[工作流线程示例](https://go.microsoft.com/fwlink/?LinkId=157350)。  
  
 [!code-csharp[WF_Samples#28](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#28)]
 [!code-vb[WF_Samples#28](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
        <exception cref="T:System.InvalidOperationException">已找到多个该泛型类型的服务。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance GetWorkflow (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance GetWorkflow(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflow (instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ GetWorkflow(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.GetWorkflow : Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.GetWorkflow instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">工作流实例的 <see cref="T:System.Guid" />。</param>
        <summary>检索具有指定 <see cref="T:System.Guid" /> 的工作流实例。</summary>
        <returns>具有指定 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 的 <see cref="T:System.Guid" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `instanceId` 指定的工作流实例当前不在内存中，则会将该工作流实例加载到内存并计划执行。 例如，某个工作流实例被中止后，您可以调用 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 以将该工作流实例重新加载回内存。 在这种情况下，持久性服务会将工作流实例的上一个保留状态加载到内存。  
  
   
  
## Examples  
 下面的代码示例演示 `ReloadWorkflow`<xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A>方法如何调用 {3} 方法。 `ReloadWorkflow` 方法是一个更大类的一部分，该大类具有的 `Runtime` 属性可访问 <xref:System.Workflow.Runtime.WorkflowRuntime> 类的所有方法、属性和事件。  
  
 此代码示例是[自定义持久性服务示例](https://go.microsoft.com/fwlink/?LinkId=157351)示例的一部分。  
  
> [!NOTE]
>  在该示例中，调用 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 是多余的，因为 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 和 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 两种方法都使用相同的内部帮助器方法将工作流实例加载到内存中。  
  
 [!code-csharp[WF_Samples#265](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#265)]
 [!code-vb[WF_Samples#265](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#265)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流运行时未启动。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStarted">
      <MemberSignature Language="C#" Value="public bool IsStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStarted" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStarted : bool" Usage="System.Workflow.Runtime.WorkflowRuntime.IsStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已启动工作流运行时引擎。</summary>
        <value>如果该工作流运行时引擎已启动，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 指示工作流运行时引擎服务正在运行。 在主机调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>之前 `false` <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>。 在宿主调用 `true` 之前，它一直保留 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。  
  
> [!NOTE]
>  工作流运行时引擎运行时，您不能向其中添加核心服务。 核心服务是派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 类、<xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 类和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 类的服务。  
  
   
  
## Examples  
 下面的示例演示如何访问 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 对象的 <xref:System.Workflow.Runtime.WorkflowRuntime> 属性。 在此示例中，如果运行时已启动，则会向控制台输出消息。  
  
 [!code-csharp[WF_Samples#21](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#21)]
 [!code-vb[WF_Samples#21](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowRuntime.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Workflow.Runtime.WorkflowRuntime.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 关联的名称。</summary>
        <value>与此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 关联的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当工作流运行时引擎正在运行时，不能设置 <xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A> （<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> `true`）。  
  
   
  
## Examples  
 下面的示例演示如何访问 <xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A> 对象的 <xref:System.Workflow.Runtime.WorkflowRuntime> 属性。 在本示例中，运行时的名称设置为“Main Runtime”。  
  
 [!code-csharp[WF_Samples#20](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#20)]
 [!code-vb[WF_Samples#20](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">尝试对释放的 <see cref="P:System.Workflow.Runtime.WorkflowRuntime.Name" /> 设置 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">尝试在工作流运行时引擎运行时设置 <see cref="P:System.Workflow.Runtime.WorkflowRuntime.Name" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveService">
      <MemberSignature Language="C#" Value="public void RemoveService (object service);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveService(object service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.RemoveService(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveService (service As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveService(System::Object ^ service);" />
      <MemberSignature Language="F#" Value="member this.RemoveService : obj -&gt; unit" Usage="workflowRuntime.RemoveService service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="service">一个对象，表示要移除的服务。</param>
        <summary>从工作流运行时引擎中移除指定的服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当工作流运行时引擎正在运行时，不能删除核心服务（<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> `true`）。 核心服务是派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 类或 <xref:System.Workflow.Runtime.Tracking.TrackingService> 类的服务。  如果 `service` 派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类，则 <xref:System.Workflow.Runtime.WorkflowRuntime.RemoveService%2A> 将调用由 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Stop%2A> 实现的 `service` 方法。  
  
   
  
## Examples  
 在下面的示例中，将向 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 添加和移除一个 <xref:System.Workflow.Runtime.WorkflowRuntime>。  
  
 [!code-csharp[WF_Samples#16](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#16)]
 [!code-vb[WF_Samples#16](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="service" /> 为空引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">工作流运行时引擎已启动（<see cref="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" /> 为 <see langword="true" />），且 <paramref name="service" /> 为核心服务。  
  
- 或 - 
 <paramref name="service" /> 未向工作流运行时引擎注册。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServicesExceptionNotHandled">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; ServicesExceptionNotHandled;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; ServicesExceptionNotHandled" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ServicesExceptionNotHandled As EventHandler(Of ServicesExceptionNotHandledEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::ServicesExceptionNotHandledEventArgs ^&gt; ^ ServicesExceptionNotHandled;" />
      <MemberSignature Language="F#" Value="member this.ServicesExceptionNotHandled : EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; " Usage="member this.ServicesExceptionNotHandled : System.EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event ServicesExceptionNotHandled As EventHandler(Of ServicesExceptionNotHandledEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生自 <see cref="T:System.Workflow.Runtime.Hosting.WorkflowRuntimeService" /> 类的服务调用 <see cref="M:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent(System.Exception,System.Guid)" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的服务可调用 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent%2A> 方法，以通知 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 事件的订户在执行过程中出现无法处理的异常。 您可以订阅此事件以实现恢复机制。  
  
 在工作流运行时引擎尚未创建工作流实例前引发此事件，同时将出现一个异常。 在此方案中，通知主机应用程序发生异常的唯一方法是引发此事件。 但是，工作流运行时引擎不直接调用此方法。 工作流运行时引擎而是向工作流实例发送异常，或者在没有实例的情况下将异常引发回调用方（本例中调用方实际上是激发此事件的服务）。 如果要创建自己的持久性服务或计划程序，您必须自己使用 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent%2A> 基方法来实现此事件。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含使用服务的工作流实例的 <xref:System.Guid>，以及无法处理的 <xref:System.Exception>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 与一个事件处理程序（即一个名为 `OnExceptionNotHandled` 的方法）相关联。  
  
 此代码示例是[自定义持久性服务示例](https://go.microsoft.com/fwlink/?LinkID=157351)的一部分。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Started">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Started;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Started" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.Started" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Started As EventHandler(Of WorkflowRuntimeEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowRuntimeEventArgs ^&gt; ^ Started;" />
      <MemberSignature Language="F#" Value="member this.Started : EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " Usage="member this.Started : System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event Started As EventHandler(Of WorkflowRuntimeEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>启动工作流运行时引擎时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 方法在验证了工作流运行时引擎的核心服务配置后引发了 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 事件，已调用了从 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类派生的每个服务实现的 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A> 方法，并已将 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 设置为 `true`。 工作流运行时引擎并不按照固定顺序启动派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的服务，一部分工作流运行时引擎服务可能需要依赖另一部分服务所提供的功能来完成其启动任务。 引发 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.OnStarted%2A?displayProperty=nameWithType> 事件后，工作流运行时引擎服务可以重写 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 方法，以执行需要其他工作流运行时引擎服务支持的任何最终启动任务。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 在下面的示例中，将向 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 的 <xref:System.Workflow.Runtime.WorkflowRuntime> 事件添加一个事件处理程序。 在此示例中，处理程序是向控制台输出简单消息的匿名方法。  
  
 [!code-csharp[WF_Samples#15](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#15)]
 [!code-vb[WF_Samples#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartRuntime">
      <MemberSignature Language="C#" Value="public void StartRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.StartRuntime" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartRuntime ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartRuntime();" />
      <MemberSignature Language="F#" Value="member this.StartRuntime : unit -&gt; unit" Usage="workflowRuntime.StartRuntime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动工作流运行时引擎和工作流运行时引擎服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法验证是否存在有效的核心服务集，然后启动派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的任何服务。  以下核心服务中必须有且仅有一个：派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 基类的工作流 `CommitWorkBatch` 服务，以及派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 基类的计划程序服务。  如果缺少其中一个或两个核心服务，则工作流运行时引擎将为计划程序服务的工作流 `CommitWorkBatch` 服务和 <xref:System.Workflow.Runtime.Hosting.DefaultWorkflowSchedulerService> 提供相应的默认服务： <xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService>。 持久性服务为可选服务，但最多只能有一个持久性服务。 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 验证服务配置后，将对派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A> 类的所有服务调用 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService>。  最后，工作流运行时引擎将设置 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 并引发 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 事件。  
  
 在工作流运行时引擎启动后，您不能添加或移除核心服务。 核心服务是派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 类、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 类或 <xref:System.Workflow.Runtime.Tracking.TrackingService> 类的服务。  如果您在工作流运行时引擎运行过程中调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>，将不会执行任何操作。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 在 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 创建了 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 实例并在调用了 <xref:System.Workflow.Runtime.WorkflowRuntime> 来向运行时添加服务后，代码将调用 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A>。 在进行其他任何处理之前，它还会调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkId=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已释放。</exception>
        <exception cref="T:System.InvalidOperationException">工作流 <see langword="CommitWorkBatch" /> 服务向此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 注册了多个服务。  
  
- 或 - 
注册到此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 的计划程序服务有多个。  
  
- 或 - 
注册到此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 的持久性服务有多个。</exception>
      </Docs>
    </Member>
    <Member MemberName="Stopped">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Stopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Stopped" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.Stopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stopped As EventHandler(Of WorkflowRuntimeEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowRuntimeEventArgs ^&gt; ^ Stopped;" />
      <MemberSignature Language="F#" Value="member this.Stopped : EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " Usage="member this.Stopped : System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event Stopped As EventHandler(Of WorkflowRuntimeEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>工作流运行时引擎停止后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 方法在调用 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 方法后引发 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Stop%2A> 事件，所调用的方法由它派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的每个服务实现。  停止这些工作流运行时引擎服务的顺序并不固定，其中一些服务可能需要保留其他服务所依赖的一些功能，直到也停止这些服务。 引发 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.OnStopped%2A?displayProperty=nameWithType> 事件后，此类服务可重写 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 方法，以执行任何剩余的关闭逻辑。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 在下面的示例中，将向 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 的 <xref:System.Workflow.Runtime.WorkflowRuntime> 事件添加一个事件处理程序。 在此示例中，处理程序是向控制台输出简单消息的匿名方法。  
  
 [!code-csharp[WF_Samples#14](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#14)]
 [!code-vb[WF_Samples#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopRuntime">
      <MemberSignature Language="C#" Value="public void StopRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.StopRuntime" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopRuntime ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopRuntime();" />
      <MemberSignature Language="F#" Value="member this.StopRuntime : unit -&gt; unit" Usage="workflowRuntime.StopRuntime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止工作流运行时引擎和运行时服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法导致工作流运行时引擎卸载其每个工作流实例，停止所有派生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 类的服务，将 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 设置为 `false`，并引发 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 事件。  
  
 若要正常关闭 <xref:System.Workflow.Runtime.WorkflowRuntime>，请在调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 之前调用 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A>。  
  
 有关更多信息，请参见 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 在宿主完成其他所有与运行时关联的处理后，将调用 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkId=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#259](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#259)]
 [!code-vb[WF_Samples#259](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#259)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowAborted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowAborted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowAborted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowAborted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowAborted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowAborted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowAborted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowAborted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在中止工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在工作流实例的所有挂起工作被清除之后，但在内存中验证工作流实例之前，会发生 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted>。 通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A?displayProperty=nameWithType> 可以中止工作流实例。  
  
 在此事件中，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> 与一个事件处理程序即一个名为 `OnWorkflowAborted` 的方法相关联。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#141](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#141)]
 [!code-vb[WF_Samples#141](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#141)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; WorkflowCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; WorkflowCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowCompleted As EventHandler(Of WorkflowCompletedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowCompletedEventArgs ^&gt; ^ WorkflowCompleted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowCompleted : EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; " Usage="member this.WorkflowCompleted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowCompleted As EventHandler(Of WorkflowCompletedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在完成工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成工作流实例之后，在内存中的实例失效之前，会引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted>。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowCompletedEventArgs> 包含 <xref:System.Workflow.Runtime.WorkflowInstance> 及其输出参数。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> 与一个事件处理程序即一个名为 `OnWorkflowCompleted` 的方法相关联。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkId=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowCreated" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowCreated As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowCreated;" />
      <MemberSignature Language="F#" Value="member this.WorkflowCreated : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowCreated : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowCreated As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完全构造工作流实例之后但在处理活动之前，工作流运行时引擎会引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated> 事件。 在此事件中，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated> 与一个事件处理程序即一个名为 `OnWorkflowCreated` 的方法相关联。  
  
 此代码示例是[自定义持久性服务示例](https://go.microsoft.com/fwlink/?LinkID=15735)的一部分。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowIdled">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowIdled;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowIdled" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowIdled As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowIdled;" />
      <MemberSignature Language="F#" Value="member this.WorkflowIdled : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowIdled : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowIdled As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流实例进入空闲状态后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在工作流实例进入空闲状态后，工作流运行时引擎引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件；例如，工作流在等待 <xref:System.Workflow.Activities.DelayActivity> 活动完成时会引发该事件。  
  
 在此事件中，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 与一个事件处理程序即一个名为 `OnWorkflowIdled` 的方法相关联。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowLoaded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowLoaded As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowLoaded;" />
      <MemberSignature Language="F#" Value="member this.WorkflowLoaded : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowLoaded : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowLoaded As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将工作流实例加载到内存时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在持久性服务存储工作流实例后与工作流运行时引擎开始执行任何活动前，会发生 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded>。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 与一个事件处理程序即一个名为 `OnWorkflowLoad` 的方法相关联。  
  
 此代码示例是[自定义持久性服务](https://go.microsoft.com/fwlink/?LinkID=157351)示例的一部分。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowPersisted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowPersisted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowPersisted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowPersisted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowPersisted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowPersisted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowPersisted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowPersisted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在保留工作流的状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 保留工作流状态的原因可能很多。 例如，宿主可能对工作流实例调用 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType>，或工作流运行时引擎可能由于实例变为空闲状态或完成原子作用域而保留工作流实例。 如果 <xref:System.Workflow.Runtime.WorkflowRuntime> 中存在持久性服务，则在将工作流实例的状态保存到内存后，运行时会引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted>。 如果不存在持久性服务，将仍然会引发该事件，但不会保存实例状态。 如果 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件由于正在卸载工作流实例而发生，则 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件将紧随其后发生。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流主机中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 与一个事件处理程序即一个名为 `OnWorkflowPersisted` 的方法相关联。  
  
 此代码示例是[自定义持久性服务示例](https://go.microsoft.com/fwlink/?LinkID=15735)的一部分。  
  
 [!code-csharp[WF_Samples#279](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#279)]
 [!code-vb[WF_Samples#279](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#279)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowResumed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowResumed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowResumed" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowResumed As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowResumed;" />
      <MemberSignature Language="F#" Value="member this.WorkflowResumed : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowResumed : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowResumed As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在暂停后继续执行工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流运行时引擎恰好在计划工作流实例之前引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件通常是由于对 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> 的显式调用而引发的。 但是，工作流运行时引擎可能会暂时挂起实例以执行操作，例如，应用工作流更改。 在这种情况下，当运行时引擎在该操作后恢复执行工作流实例时将引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流主机中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 与一个事件处理程序即一个名为 `OnWorkflowResume` 的方法相关联。  
  
 此代码示例是[挂起和终止示例](https://go.microsoft.com/fwlink/?LinkId=157402)的一部分。  
  
 [!code-csharp[WF_Samples#171](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#171)]
 [!code-vb[WF_Samples#171](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#171)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowStarted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowStarted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowStarted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowStarted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowStarted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowStarted As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在启动工作流实例后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过计划要执行的根活动启动工作流实例后，工作流运行时引擎将引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted> 事件。 在此事件中，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted> 与一个事件处理程序即一个名为 `OnWorkflowStarted` 的方法相关联。  
  
 此代码示例是[主机通信示例](https://go.microsoft.com/fwlink/?LinkId=157406)的一部分。  
  
 [!code-csharp[WF_Samples#297](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets38.cs#297)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowSuspended">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; WorkflowSuspended;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; WorkflowSuspended" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowSuspended As EventHandler(Of WorkflowSuspendedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowSuspendedEventArgs ^&gt; ^ WorkflowSuspended;" />
      <MemberSignature Language="F#" Value="member this.WorkflowSuspended : EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; " Usage="member this.WorkflowSuspended : System.EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowSuspended As EventHandler(Of WorkflowSuspendedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在挂起工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流实例可由宿主通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> 方法挂起，也可由 <xref:System.Workflow.ComponentModel.SuspendActivity> 活动或工作流运行时引擎隐式挂起。 例如，工作流运行时引擎在将动态更改应用于实例时暂时挂起实例。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs> 包含 <xref:System.Workflow.Runtime.WorkflowInstance> 以及一个说明挂起实例原因的字符串。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 与一个事件处理程序即一个名为 `OnWorkflowSuspended` 的方法相关联。  
  
 此代码示例是[挂起和终止示例](https://go.microsoft.com/fwlink/?LinkID=157402)的一部分。  
  
 [!code-csharp[WF_Samples#170](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#170)]
 [!code-vb[WF_Samples#170](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#170)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowTerminated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; WorkflowTerminated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; WorkflowTerminated" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowTerminated As EventHandler(Of WorkflowTerminatedEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowTerminatedEventArgs ^&gt; ^ WorkflowTerminated;" />
      <MemberSignature Language="F#" Value="member this.WorkflowTerminated : EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; " Usage="member this.WorkflowTerminated : System.EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowTerminated As EventHandler(Of WorkflowTerminatedEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在终止工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流可由宿主通过调用 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 方法来终止，也可由 <xref:System.Workflow.ComponentModel.TerminateActivity> 活动终止，或者在发生未处理的异常时由工作流运行时引擎终止。 在工作流实例终止之后但在内存中失效之前，工作流运行时引擎会引发 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> 事件。  
  
 对于 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs> 包含 <xref:System.Workflow.Runtime.WorkflowInstance>，以及在 <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs.Exception%2A?displayProperty=nameWithType> 属性中终止实例的原因的相关信息。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> 与一个事件处理程序即一个名为 `OnWorkflowCompleted` 的方法相关联。  
  
 此代码示例是[取消工作流](https://go.microsoft.com/fwlink/?LinkID=157346)示例的一部分。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowUnloaded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowUnloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowUnloaded" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WorkflowUnloaded As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowUnloaded;" />
      <MemberSignature Language="F#" Value="member this.WorkflowUnloaded : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowUnloaded : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowUnloaded As EventHandler(Of WorkflowEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从内存卸载工作流实例时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

可以通过显式调用 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 从内存卸载工作流实例，也可以由工作流运行时引擎根据自身的语义来隐式卸载工作流实例。 例如，工作流运行时引擎将在实例进入空闲状态时卸载工作流实例，并为其 `true`<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle%2A> 添加了运行时 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService>。  
  
工作流运行时引擎在工作流实例的状态成功保存后，但在内存中的实例失效之前，将引发 `WorkflowUnloaded` 事件。 因此，<xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件将在 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件之前发生。  
  
对于 `WorkflowUnloaded` 事件，发送方包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 包含与事件关联的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
有关处理事件的详细信息，请参阅[处理和引发事件](/dotnet/standard/events/)。  
  
## Examples

下面的代码示例演示如何使用工作流宿主中的 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 该代码将 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 与一个事件处理程序即一个名为 `OnWorkflowUnload` 的方法相关联。  
  
 此代码示例是[自定义持久性服务示例](https://go.microsoft.com/fwlink/?LinkID=157351)的一部分。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
