<Type Name="GZipStream" FullName="System.IO.Compression.GZipStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9e24da3141b7b05bc7bf9997552daaa91f83eace" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83524465" /></Metadata><TypeSignature Language="C#" Value="public class GZipStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GZipStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Compression.GZipStream" />
  <TypeSignature Language="VB.NET" Value="Public Class GZipStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class GZipStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type GZipStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Compression</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.IO.Compression" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.IO.Compression" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO.Compression" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinmac-3.0" />
    <TypeForwarding From="System.IO.Compression" FromVersion="4.2.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.7.2;netframework-4.8" />
    <TypeForwarding From="System.IO.Compression" FromVersion="2.0.5.0" To="System" ToVersion="2.0.5.0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ac611-101">使用 GZip 数据格式规范提供用于压缩和解压缩流的方法和属性。</span><span class="sxs-lookup"><span data-stu-id="ac611-101">Provides methods and properties used to compress and decompress streams by using the GZip data format specification.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-102">此类表示 gzip 数据格式，该格式使用适用于无损文件压缩和解压缩的行业标准算法。</span><span class="sxs-lookup"><span data-stu-id="ac611-102">This class represents the gzip data format, which uses an industry-standard algorithm for lossless file compression and decompression.</span></span> <span data-ttu-id="ac611-103">该格式包含用于检测数据损坏的循环冗余检查值。</span><span class="sxs-lookup"><span data-stu-id="ac611-103">The format includes a cyclic redundancy check value for detecting data corruption.</span></span> <span data-ttu-id="ac611-104">Gzip 数据格式使用与 <xref:System.IO.Compression.DeflateStream> 类相同的算法，但可以对其进行扩展以使用其他压缩格式。</span><span class="sxs-lookup"><span data-stu-id="ac611-104">The gzip data format uses the same algorithm as the <xref:System.IO.Compression.DeflateStream> class, but can be extended to use other compression formats.</span></span> <span data-ttu-id="ac611-105">此格式可以通过专利未涵盖的方式随时实现。</span><span class="sxs-lookup"><span data-stu-id="ac611-105">The format can be readily implemented in a manner not covered by patents.</span></span>  
  
 <span data-ttu-id="ac611-106">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，<xref:System.IO.Compression.DeflateStream> 类使用 zlib 库进行压缩。</span><span class="sxs-lookup"><span data-stu-id="ac611-106">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.IO.Compression.DeflateStream> class uses the zlib library for compression.</span></span> <span data-ttu-id="ac611-107">因此，它提供了更好的压缩算法，在大多数情况下，它比在早期版本的 .NET Framework 中提供的压缩文件更小。</span><span class="sxs-lookup"><span data-stu-id="ac611-107">As a result, it provides a better compression algorithm and, in most cases, a smaller compressed file than it provides in earlier versions of the .NET Framework.</span></span>  
  
 <span data-ttu-id="ac611-108">写入扩展名为 gz 的文件的压缩 <xref:System.IO.Compression.GZipStream> 对象可以使用多种常用的压缩工具进行解压缩;但是，此类本质上不提供向 zip 存档添加文件或从中提取文件的功能。</span><span class="sxs-lookup"><span data-stu-id="ac611-108">Compressed <xref:System.IO.Compression.GZipStream> objects written to a file with an extension of .gz can be decompressed using many common compression tools; however, this class does not inherently provide functionality for adding files to or extracting files from zip archives.</span></span>  
  
 <span data-ttu-id="ac611-109"><xref:System.IO.Compression.DeflateStream> 和 <xref:System.IO.Compression.GZipStream> 中的压缩功能作为流公开。</span><span class="sxs-lookup"><span data-stu-id="ac611-109">The compression functionality in <xref:System.IO.Compression.DeflateStream> and <xref:System.IO.Compression.GZipStream> is exposed as a stream.</span></span> <span data-ttu-id="ac611-110">数据逐字节读取，因此不能执行多个传递来确定压缩整个文件或大型数据块的最佳方法。</span><span class="sxs-lookup"><span data-stu-id="ac611-110">Data is read on a byte-by-byte basis, so it is not possible to perform multiple passes to determine the best method for compressing entire files or large blocks of data.</span></span> <span data-ttu-id="ac611-111"><xref:System.IO.Compression.DeflateStream> 和 <xref:System.IO.Compression.GZipStream> 类最适用于未压缩的数据源。</span><span class="sxs-lookup"><span data-stu-id="ac611-111">The <xref:System.IO.Compression.DeflateStream> and <xref:System.IO.Compression.GZipStream> classes are best used on uncompressed sources of data.</span></span> <span data-ttu-id="ac611-112">如果源数据已压缩，使用这些类实际上可能会增加流的大小。</span><span class="sxs-lookup"><span data-stu-id="ac611-112">If the source data is already compressed, using these classes may actually increase the size of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-113">下面的示例演示如何使用 <xref:System.IO.Compression.GZipStream> 类压缩和解压缩文件的目录。</span><span class="sxs-lookup"><span data-stu-id="ac611-113">The following example shows how to use the <xref:System.IO.Compression.GZipStream> class to compress and decompress a directory of files.</span></span>  
  
 [!code-csharp[IO.Compression.GZip1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Compression.GZip1/CS/gziptest.cs#1)]
 [!code-vb[IO.Compression.GZip1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Compression.GZip1/VB/gziptest.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="ac611-114">从 <see cref="T:System.IO.Compression.GZipStream" />继承时，必须重写以下成员： <see cref="P:System.IO.Compression.GZipStream.CanSeek" />、<see cref="P:System.IO.Compression.GZipStream.CanWrite" />和 <see cref="P:System.IO.Compression.GZipStream.CanRead" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-114">When you inherit from <see cref="T:System.IO.Compression.GZipStream" />, you must override the following members: <see cref="P:System.IO.Compression.GZipStream.CanSeek" />, <see cref="P:System.IO.Compression.GZipStream.CanWrite" />, and <see cref="P:System.IO.Compression.GZipStream.CanRead" />.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ac611-115">初始化 <see cref="T:System.IO.Compression.GZipStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ac611-115">Initializes a new instance of the <see cref="T:System.IO.Compression.GZipStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GZipStream (System.IO.Stream stream, System.IO.Compression.CompressionLevel compressionLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.CompressionLevel compressionLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, compressionLevel As CompressionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GZipStream(System::IO::Stream ^ stream, System::IO::Compression::CompressionLevel compressionLevel);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.GZipStream : System.IO.Stream * System.IO.Compression.CompressionLevel -&gt; System.IO.Compression.GZipStream" Usage="new System.IO.Compression.GZipStream (stream, compressionLevel)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="ac611-116">要压缩的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-116">The stream to compress.</span></span></param>
        <param name="compressionLevel"><span data-ttu-id="ac611-117">压缩流时，指示是否要强调速度或压缩效率的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="ac611-117">One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.</span></span></param>
        <summary><span data-ttu-id="ac611-118">用指定的流和压缩级别初始化 <see cref="T:System.IO.Compression.GZipStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ac611-118">Initializes a new instance of the <see cref="T:System.IO.Compression.GZipStream" /> class by using the specified stream and compression level.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-119">当您想要指定压缩效率或速度对于 <xref:System.IO.Compression.GZipStream> 类的实例是否更重要时，可以使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="ac611-119">You use this constructor when you want to specify whether compression efficiency or speed is more important for an instance of the <xref:System.IO.Compression.GZipStream> class.</span></span>  
  
 <span data-ttu-id="ac611-120">此构造函数重载使用压缩模式 <xref:System.IO.Compression.CompressionMode.Compress>。</span><span class="sxs-lookup"><span data-stu-id="ac611-120">This constructor overload uses the compression mode <xref:System.IO.Compression.CompressionMode.Compress>.</span></span> <span data-ttu-id="ac611-121">若要将压缩模式设置为另一个值，请使用 <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%29> 或 <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%2CSystem.Boolean%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="ac611-121">To set the compression mode to another value, use the <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%29> or <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%2CSystem.Boolean%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-122">下面的示例演示如何在创建 <xref:System.IO.Compression.GZipStream> 对象时设置压缩级别。</span><span class="sxs-lookup"><span data-stu-id="ac611-122">The following example shows how to set the compression level when creating a <xref:System.IO.Compression.GZipStream> object.</span></span>  
  
 [!code-csharp[System.IO.Compression.GZipStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.gzipstream/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.GZipStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.gzipstream/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-123"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-123"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-124">流不支持写入操作，如压缩。</span><span class="sxs-lookup"><span data-stu-id="ac611-124">The stream does not support write operations such as compression.</span></span> <span data-ttu-id="ac611-125">（流对象上的 <see cref="P:System.IO.Stream.CanWrite" /> 属性是 <see langword="false" />。）</span><span class="sxs-lookup"><span data-stu-id="ac611-125">(The <see cref="P:System.IO.Stream.CanWrite" /> property on the stream object is <see langword="false" />.)</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GZipStream (System.IO.Stream stream, System.IO.Compression.CompressionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.CompressionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, mode As CompressionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GZipStream(System::IO::Stream ^ stream, System::IO::Compression::CompressionMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.GZipStream : System.IO.Stream * System.IO.Compression.CompressionMode -&gt; System.IO.Compression.GZipStream" Usage="new System.IO.Compression.GZipStream (stream, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.CompressionMode" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="ac611-126">压缩或解压缩后的数据被写入的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-126">The stream the compressed or decompressed data is written to.</span></span></param>
        <param name="mode"><span data-ttu-id="ac611-127">指示是要压缩还是解压缩流的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="ac611-127">One of the enumeration values that indicates whether to compress or decompress the stream.</span></span></param>
        <summary><span data-ttu-id="ac611-128">用指定的流和压缩模式初始化 <see cref="T:System.IO.Compression.GZipStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ac611-128">Initializes a new instance of the <see cref="T:System.IO.Compression.GZipStream" /> class by using the specified stream and compression mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-129">默认情况下，<xref:System.IO.Compression.GZipStream> 拥有基础流，因此关闭 `stream` 参数也会关闭基础流。</span><span class="sxs-lookup"><span data-stu-id="ac611-129">By default, <xref:System.IO.Compression.GZipStream> owns the underlying stream, so closing the `stream` parameter also closes the underlying stream.</span></span> <span data-ttu-id="ac611-130">请注意，基础流的状态可能会影响流的可用性。</span><span class="sxs-lookup"><span data-stu-id="ac611-130">Note that the state of the underlying stream can affect the usability of the stream.</span></span> <span data-ttu-id="ac611-131">此外，不执行显式检查，因此在创建新实例时不会引发其他异常。</span><span class="sxs-lookup"><span data-stu-id="ac611-131">Also, no explicit checks are performed, so no additional exceptions are thrown when the new instance is created.</span></span>  
  
 <span data-ttu-id="ac611-132">如果创建 <xref:System.IO.Compression.GZipStream> 类的实例时使用的 `mode` 参数等于 `Compress`，并且不执行其他操作，则流将显示为有效的空压缩文件。</span><span class="sxs-lookup"><span data-stu-id="ac611-132">If an instance of the <xref:System.IO.Compression.GZipStream> class is created with the `mode` parameter equal to `Compress` and no further action occurs, the stream will appear as a valid, empty compressed file.</span></span>  
  
 <span data-ttu-id="ac611-133">默认情况下，在 <xref:System.IO.Compression.CompressionMode.Compress>压缩模式时，压缩级别设置为 <xref:System.IO.Compression.CompressionLevel.Optimal>。</span><span class="sxs-lookup"><span data-stu-id="ac611-133">By default, the compression level is set to <xref:System.IO.Compression.CompressionLevel.Optimal> when the compression mode is <xref:System.IO.Compression.CompressionMode.Compress>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-134">下面的示例通过将 `mode` 设置为 <xref:System.IO.Compression.CompressionMode.Compress>，初始化 <xref:System.IO.Compression.GZipStream> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ac611-134">The following example initializes a new instance of the <xref:System.IO.Compression.GZipStream> class with `mode` set to <xref:System.IO.Compression.CompressionMode.Compress>.</span></span> <span data-ttu-id="ac611-135">此示例是为 <xref:System.IO.Compression.GZipStream> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="ac611-135">This example is part of a larger example provided for the <xref:System.IO.Compression.GZipStream> class.</span></span>  
  
 [!code-csharp[IO.Compression.GZip1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Compression.GZip1/CS/gziptest.cs#1)]
 [!code-vb[IO.Compression.GZip1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Compression.GZip1/VB/gziptest.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-136"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-136"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-137"><paramref name="mode" /> 不是有效的 <see cref="T:System.IO.Compression.CompressionMode" /> 枚举值。</span><span class="sxs-lookup"><span data-stu-id="ac611-137"><paramref name="mode" /> is not a valid <see cref="T:System.IO.Compression.CompressionMode" /> enumeration value.</span></span>  
  
<span data-ttu-id="ac611-138">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-138">-or-</span></span> 
 <span data-ttu-id="ac611-139"><see cref="T:System.IO.Compression.CompressionMode" /> 为 <see cref="F:System.IO.Compression.CompressionMode.Compress" />，而 <see cref="P:System.IO.Stream.CanWrite" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-139"><see cref="T:System.IO.Compression.CompressionMode" /> is <see cref="F:System.IO.Compression.CompressionMode.Compress" /> and <see cref="P:System.IO.Stream.CanWrite" /> is <see langword="false" />.</span></span>  
  
<span data-ttu-id="ac611-140">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-140">-or-</span></span> 
 <span data-ttu-id="ac611-141"><see cref="T:System.IO.Compression.CompressionMode" /> 为 <see cref="F:System.IO.Compression.CompressionMode.Decompress" />，而 <see cref="P:System.IO.Stream.CanRead" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-141"><see cref="T:System.IO.Compression.CompressionMode" /> is <see cref="F:System.IO.Compression.CompressionMode.Decompress" /> and <see cref="P:System.IO.Stream.CanRead" /> is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GZipStream (System.IO.Stream stream, System.IO.Compression.CompressionLevel compressionLevel, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.CompressionLevel compressionLevel, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, compressionLevel As CompressionLevel, leaveOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GZipStream(System::IO::Stream ^ stream, System::IO::Compression::CompressionLevel compressionLevel, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.GZipStream : System.IO.Stream * System.IO.Compression.CompressionLevel * bool -&gt; System.IO.Compression.GZipStream" Usage="new System.IO.Compression.GZipStream (stream, compressionLevel, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="ac611-142">要将压缩数据写入到其中的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-142">The stream to write the compressed data to.</span></span></param>
        <param name="compressionLevel"><span data-ttu-id="ac611-143">压缩流时，指示是否要强调速度或压缩效率的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="ac611-143">One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="ac611-144">如果在释放 <see cref="T:System.IO.Compression.GZipStream" /> 对象之后打开流对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-144"><see langword="true" /> to leave the stream object open after disposing the <see cref="T:System.IO.Compression.GZipStream" /> object; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ac611-145">使用指定的流和压缩级别，初始化 <see cref="T:System.IO.Compression.GZipStream" /> 类的新实例，有选择性的打开流。</span><span class="sxs-lookup"><span data-stu-id="ac611-145">Initializes a new instance of the <see cref="T:System.IO.Compression.GZipStream" /> class by using the specified stream and compression level, and optionally leaves the stream open.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-146">若要指定压缩效率或速度对于 <xref:System.IO.Compression.GZipStream> 类的实例是否更重要，以及在释放 <xref:System.IO.Compression.GZipStream> 对象后是否将流对象保持打开状态，请使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="ac611-146">You use this constructor when you want to specify whether compression efficiency or speed is more important for an instance of the <xref:System.IO.Compression.GZipStream> class, and whether to leave the stream object open after disposing the <xref:System.IO.Compression.GZipStream> object.</span></span>  
  
 <span data-ttu-id="ac611-147">此构造函数重载使用压缩模式 <xref:System.IO.Compression.CompressionMode.Compress>。</span><span class="sxs-lookup"><span data-stu-id="ac611-147">This constructor overload uses the compression mode <xref:System.IO.Compression.CompressionMode.Compress>.</span></span> <span data-ttu-id="ac611-148">若要将压缩模式设置为另一个值，请使用 <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%29> 或 <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%2CSystem.Boolean%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="ac611-148">To set the compression mode to another value, use the <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%29> or <xref:System.IO.Compression.GZipStream.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.CompressionMode%2CSystem.Boolean%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-149">下面的示例演示如何在创建 <xref:System.IO.Compression.GZipStream> 对象时设置压缩级别，以及如何使流保持打开状态。</span><span class="sxs-lookup"><span data-stu-id="ac611-149">The following example shows how to set the compression level when creating a <xref:System.IO.Compression.GZipStream> object and how to leave the stream open.</span></span>  
  
 [!code-csharp[System.IO.Compression.GZipStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.gzipstream/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.GZipStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.gzipstream/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-150"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-150"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-151">流不支持写入操作，如压缩。</span><span class="sxs-lookup"><span data-stu-id="ac611-151">The stream does not support write operations such as compression.</span></span> <span data-ttu-id="ac611-152">（流对象上的 <see cref="P:System.IO.Stream.CanWrite" /> 属性是 <see langword="false" />。）</span><span class="sxs-lookup"><span data-stu-id="ac611-152">(The <see cref="P:System.IO.Stream.CanWrite" /> property on the stream object is <see langword="false" />.)</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GZipStream (System.IO.Stream stream, System.IO.Compression.CompressionMode mode, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.CompressionMode mode, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (stream As Stream, mode As CompressionMode, leaveOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GZipStream(System::IO::Stream ^ stream, System::IO::Compression::CompressionMode mode, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.GZipStream : System.IO.Stream * System.IO.Compression.CompressionMode * bool -&gt; System.IO.Compression.GZipStream" Usage="new System.IO.Compression.GZipStream (stream, mode, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.CompressionMode" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="ac611-153">要压缩的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-153">The stream to compress.</span></span></param>
        <param name="mode"><span data-ttu-id="ac611-154">指示是要压缩还是解压缩流的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="ac611-154">One of the enumeration values that indicates whether to compress or decompress the stream.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="ac611-155">如果在释放 <see cref="T:System.IO.Compression.GZipStream" /> 对象之后打开流，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-155"><see langword="true" /> to leave the stream open after disposing the <see cref="T:System.IO.Compression.GZipStream" /> object; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ac611-156">使用指定的流和压缩模式，初始化 <see cref="T:System.IO.Compression.GZipStream" /> 类的新实例，有选择性的打开流。</span><span class="sxs-lookup"><span data-stu-id="ac611-156">Initializes a new instance of the <see cref="T:System.IO.Compression.GZipStream" /> class by using the specified stream and compression mode, and optionally leaves the stream open.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-157">默认情况下，<xref:System.IO.Compression.GZipStream> 拥有基础流，因此关闭 `stream` 参数也会关闭基础流。</span><span class="sxs-lookup"><span data-stu-id="ac611-157">By default, <xref:System.IO.Compression.GZipStream> owns the underlying stream, so closing the `stream` parameter also closes the underlying stream.</span></span> <span data-ttu-id="ac611-158">请注意，基础流的状态可能会影响流的可用性。</span><span class="sxs-lookup"><span data-stu-id="ac611-158">Note that the state of the underlying stream can affect the usability of the stream.</span></span> <span data-ttu-id="ac611-159">此外，不执行显式检查，因此在创建新实例时不会引发其他异常。</span><span class="sxs-lookup"><span data-stu-id="ac611-159">Also, no explicit checks are performed, so no additional exceptions are thrown when the new instance is created.</span></span>  
  
 <span data-ttu-id="ac611-160">如果创建 <xref:System.IO.Compression.GZipStream> 类的实例时使用的 `mode` 参数等于 `Compress`，并且不执行其他操作，则流将显示为有效的空压缩文件。</span><span class="sxs-lookup"><span data-stu-id="ac611-160">If an instance of the <xref:System.IO.Compression.GZipStream> class is created with the `mode` parameter equal to `Compress` and no further action occurs, the stream will appear as a valid, empty compressed file.</span></span>  
  
 <span data-ttu-id="ac611-161">默认情况下，在 <xref:System.IO.Compression.CompressionMode.Compress>压缩模式时，压缩级别设置为 <xref:System.IO.Compression.CompressionLevel.Optimal>。</span><span class="sxs-lookup"><span data-stu-id="ac611-161">By default, the compression level is set to <xref:System.IO.Compression.CompressionLevel.Optimal> when the compression mode is <xref:System.IO.Compression.CompressionMode.Compress>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-162"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-162"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-163"><paramref name="mode" /> 不是有效的 <see cref="T:System.IO.Compression.CompressionMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-163"><paramref name="mode" /> is not a valid <see cref="T:System.IO.Compression.CompressionMode" /> value.</span></span>  
  
<span data-ttu-id="ac611-164">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-164">-or-</span></span> 
 <span data-ttu-id="ac611-165"><see cref="T:System.IO.Compression.CompressionMode" /> 为 <see cref="F:System.IO.Compression.CompressionMode.Compress" />，而 <see cref="P:System.IO.Stream.CanWrite" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-165"><see cref="T:System.IO.Compression.CompressionMode" /> is <see cref="F:System.IO.Compression.CompressionMode.Compress" /> and <see cref="P:System.IO.Stream.CanWrite" /> is <see langword="false" />.</span></span>  
  
<span data-ttu-id="ac611-166">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-166">-or-</span></span> 
 <span data-ttu-id="ac611-167"><see cref="T:System.IO.Compression.CompressionMode" /> 为 <see cref="F:System.IO.Compression.CompressionMode.Decompress" />，而 <see cref="P:System.IO.Stream.CanRead" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-167"><see cref="T:System.IO.Compression.CompressionMode" /> is <see cref="F:System.IO.Compression.CompressionMode.Decompress" /> and <see cref="P:System.IO.Stream.CanRead" /> is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Compression.GZipStream.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-168">获取对基础流的引用。</span><span class="sxs-lookup"><span data-stu-id="ac611-168">Gets a reference to the underlying stream.</span></span></summary>
        <value><span data-ttu-id="ac611-169">表示基础流的流对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-169">A stream object that represents the underlying stream.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac611-170">基础流已关闭。</span><span class="sxs-lookup"><span data-stu-id="ac611-170">The underlying stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, count As Integer, asyncCallback As AsyncCallback, asyncState As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="gZipStream.BeginRead (array, offset, count, asyncCallback, asyncState)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback cback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback cback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, cback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ cback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="gZipStream.BeginRead (buffer, offset, count, cback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-171">将数据读入的字节数组。</span><span class="sxs-lookup"><span data-stu-id="ac611-171">The byte array to read the data into.</span></span></param>
        <param name="buffer"><span data-ttu-id="ac611-172">将数据读入的字节数组。</span><span class="sxs-lookup"><span data-stu-id="ac611-172">The byte array to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-173"><paramref name="array" /> 中的字节偏移量，从该偏移量开始读取流中的数据。</span><span class="sxs-lookup"><span data-stu-id="ac611-173">The byte offset in <paramref name="array" /> at which to begin reading data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-174">要读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-174">The maximum number of bytes to read.</span></span></param>
        <param name="asyncCallback"><span data-ttu-id="ac611-175">可选的异步回调，在完成读取操作时调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-175">An optional asynchronous callback, to be called when the read operation is complete.</span></span></param>
        <param name="cback"><span data-ttu-id="ac611-176">可选的异步回调，在完成读取操作时调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-176">An optional asynchronous callback, to be called when the read operation is complete.</span></span></param>
        <param name="asyncState"><span data-ttu-id="ac611-177">用户提供的对象，用于将此特定异步读取请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="ac611-177">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <param name="state"><span data-ttu-id="ac611-178">用户提供的对象，用于将此特定异步读取请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="ac611-178">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="ac611-179">开始执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-179">Begins an asynchronous read operation.</span></span> <span data-ttu-id="ac611-180">（请考虑改用 <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> 方法。）</span><span class="sxs-lookup"><span data-stu-id="ac611-180">(Consider using the <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> method instead.)</span></span></summary>
        <returns><span data-ttu-id="ac611-181">表示异步读取操作（可能仍处于挂起状态）的对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-181">An object that represents the asynchronous read operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-182">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，你可以通过使用 <xref:System.IO.Stream.ReadAsync%2A?displayProperty=nameWithType> 方法执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-182">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can perform asynchronous read operations by using the <xref:System.IO.Stream.ReadAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ac611-183"><xref:System.IO.Compression.GZipStream.BeginRead%2A> 方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中仍可用以支持旧版代码;不过，您可以使用新的异步方法更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-183">The <xref:System.IO.Compression.GZipStream.BeginRead%2A> method is still available in [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, you can implement asynchronous I/O operations more easily by using the new async methods.</span></span> <span data-ttu-id="ac611-184">有关详细信息，请参阅[异步文件 I/O](~/docs/standard/io/asynchronous-file-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-184">For more information, see [Asynchronous File I/O](~/docs/standard/io/asynchronous-file-i-o.md).</span></span>
  
 <span data-ttu-id="ac611-185">将 <xref:System.IAsyncResult> 返回值传递到流的 <xref:System.IO.Compression.GZipStream.EndRead%2A> 方法，以确定读取的字节数，以及释放用于读取的操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-185">Pass the <xref:System.IAsyncResult> return value to the <xref:System.IO.Compression.GZipStream.EndRead%2A> method of the stream to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="ac611-186">为此，可以使用 <xref:System.IO.Compression.GZipStream.BeginRead%2A> 调用的相同代码，也可以在传递给 <xref:System.IO.Compression.GZipStream.BeginRead%2A>的回调中执行此操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-186">You can do this either by using the same code that called <xref:System.IO.Compression.GZipStream.BeginRead%2A> or in a callback passed to <xref:System.IO.Compression.GZipStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="ac611-187">发出异步读取或写入操作时，将更新流中的当前位置，而不是在 i/o 操作完成时进行更新。</span><span class="sxs-lookup"><span data-stu-id="ac611-187">The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</span></span>  
  
 <span data-ttu-id="ac611-188">多个同时进行的异步请求会导致不确定请求完成顺序。</span><span class="sxs-lookup"><span data-stu-id="ac611-188">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="ac611-189">使用 <xref:System.IO.Compression.GZipStream.CanRead%2A> 属性来确定当前 <xref:System.IO.Compression.GZipStream> 对象是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-189">Use the <xref:System.IO.Compression.GZipStream.CanRead%2A> property to determine whether the current <xref:System.IO.Compression.GZipStream> object supports reading.</span></span>  
  
 <span data-ttu-id="ac611-190">如果流已关闭或传递的参数无效，则会立即从 <xref:System.IO.Compression.GZipStream.BeginRead%2A>引发异常。</span><span class="sxs-lookup"><span data-stu-id="ac611-190">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <xref:System.IO.Compression.GZipStream.BeginRead%2A>.</span></span> <span data-ttu-id="ac611-191">在异步读取请求期间发生的错误（例如，i/o 请求过程中的磁盘故障）会在线程池线程上发生，并在调用 <xref:System.IO.Compression.GZipStream.EndRead%2A>时引发异常。</span><span class="sxs-lookup"><span data-stu-id="ac611-191">Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling <xref:System.IO.Compression.GZipStream.EndRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-192">下面的代码示例演示如何使用 <xref:System.IO.Compression.GZipStream> 类压缩和解压缩文件。</span><span class="sxs-lookup"><span data-stu-id="ac611-192">The following code example shows how to use the <xref:System.IO.Compression.GZipStream> class to compress and decompress a file.</span></span>  
  
 [!code-csharp[IO.Compression.GZip1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Compression.GZip1/CS/gziptest.cs#1)]
 [!code-vb[IO.Compression.GZip1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Compression.GZip1/VB/gziptest.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac611-193">尝试异步读取超过了流的结尾，或者发生了磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="ac611-193">The method tried to  read asynchronously past the end of the stream, or a disk error occurred.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-194">一个或多个自变量无效。</span><span class="sxs-lookup"><span data-stu-id="ac611-194">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac611-195">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="ac611-195">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac611-196">当前 <see cref="T:System.IO.Compression.GZipStream" /> 实现不支持读取操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-196">The current <see cref="T:System.IO.Compression.GZipStream" /> implementation does not support the read operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ac611-197">由于流已关闭，因此无法执行读取操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-197">A read operation cannot be performed because the stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, count As Integer, asyncCallback As AsyncCallback, asyncState As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="gZipStream.BeginWrite (array, offset, count, asyncCallback, asyncState)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback cback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback cback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, cback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ cback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="gZipStream.BeginWrite (buffer, offset, count, cback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-198">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-198">The buffer containing data to write to the current stream.</span></span></param>
        <param name="buffer"><span data-ttu-id="ac611-199">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-199">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-200"><paramref name="array" /> 中的字节偏移量，从此处开始写入。</span><span class="sxs-lookup"><span data-stu-id="ac611-200">The byte offset in <paramref name="array" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-201">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-201">The maximum number of bytes to write.</span></span></param>
        <param name="asyncCallback"><span data-ttu-id="ac611-202">可选的异步回调，在完成写入操作时调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-202">An optional asynchronous callback to be called when the write operation is complete.</span></span></param>
        <param name="cback"><span data-ttu-id="ac611-203">可选的异步回调，在完成写入操作时调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-203">An optional asynchronous callback to be called when the write operation is complete.</span></span></param>
        <param name="asyncState"><span data-ttu-id="ac611-204">用户提供的对象，用于将此特定异步写入请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="ac611-204">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <param name="state"><span data-ttu-id="ac611-205">用户提供的对象，用于将此特定异步写入请求与其他请求区分开来。</span><span class="sxs-lookup"><span data-stu-id="ac611-205">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="ac611-206">开始执行异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-206">Begins an asynchronous write operation.</span></span> <span data-ttu-id="ac611-207">（请考虑改用 <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> 方法。）</span><span class="sxs-lookup"><span data-stu-id="ac611-207">(Consider using the <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> method instead.)</span></span></summary>
        <returns><span data-ttu-id="ac611-208">表示异步写入操作（可能仍处于挂起状态）的对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-208">An  object that represents the asynchronous write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-209">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，可以通过使用 <xref:System.IO.Stream.WriteAsync%2A?displayProperty=nameWithType> 方法执行异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-209">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can perform asynchronous write operations by using the <xref:System.IO.Stream.WriteAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ac611-210"><xref:System.IO.Compression.GZipStream.BeginWrite%2A> 方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中仍可用以支持旧版代码;不过，您可以使用新的异步方法更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-210">The <xref:System.IO.Compression.GZipStream.BeginWrite%2A> method is still available in [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, you can implement asynchronous I/O operations more easily by using the new async methods.</span></span> <span data-ttu-id="ac611-211">有关详细信息，请参阅[异步文件 I/O](~/docs/standard/io/asynchronous-file-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-211">For more information, see [Asynchronous File I/O](~/docs/standard/io/asynchronous-file-i-o.md).</span></span>
  
 <span data-ttu-id="ac611-212"><xref:System.IO.Compression.GZipStream.BeginWrite%2A> 方法对 <xref:System.IO.Compression.GZipStream> 流对象启动异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-212">The <xref:System.IO.Compression.GZipStream.BeginWrite%2A> method starts an asynchronous write operation to a <xref:System.IO.Compression.GZipStream> stream object.</span></span>  
  
 <span data-ttu-id="ac611-213">必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.IO.Compression.GZipStream.BeginWrite%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ac611-213">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.IO.Compression.GZipStream.BeginWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ac611-214">此基础流为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-214">The underlying stream is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ac611-215">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-215">-or-</span></span> 
<span data-ttu-id="ac611-216">基础流已关闭。</span><span class="sxs-lookup"><span data-stu-id="ac611-216">The underlying stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Compression.GZipStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-217">获取一个值，该值指示流是否支持在解压缩文件的过程中读取文件。</span><span class="sxs-lookup"><span data-stu-id="ac611-217">Gets a value indicating whether the stream supports reading while decompressing a file.</span></span></summary>
        <value><span data-ttu-id="ac611-218">如果 <see cref="T:System.IO.Compression.CompressionMode" /> 值为 <see langword="Decompress," /> 而且基础流未关闭并支持读取，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-218"><see langword="true" /> if the <see cref="T:System.IO.Compression.CompressionMode" /> value is <see langword="Decompress," /> and the underlying stream supports reading and is not closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ac611-219">从 <see cref="T:System.IO.Compression.GZipStream" />继承时，必须重写以下成员： <see cref="P:System.IO.Compression.GZipStream.CanSeek" />、<see cref="P:System.IO.Compression.GZipStream.CanWrite" />和 <see cref="P:System.IO.Compression.GZipStream.CanRead" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-219">When you inherit from <see cref="T:System.IO.Compression.GZipStream" />, you must override the following members: <see cref="P:System.IO.Compression.GZipStream.CanSeek" />, <see cref="P:System.IO.Compression.GZipStream.CanWrite" />, and <see cref="P:System.IO.Compression.GZipStream.CanRead" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Compression.GZipStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-220">获取一个值，该值指示流是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="ac611-220">Gets a value indicating whether the stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="ac611-221">所有情况下均为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-221"><see langword="false" /> in all cases.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ac611-222">从 <see cref="T:System.IO.Compression.GZipStream" />继承时，必须重写以下成员： <see cref="P:System.IO.Compression.GZipStream.CanSeek" />、<see cref="P:System.IO.Compression.GZipStream.CanWrite" />和 <see cref="P:System.IO.Compression.GZipStream.CanRead" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-222">When you inherit from <see cref="T:System.IO.Compression.GZipStream" />, you must override the following members: <see cref="P:System.IO.Compression.GZipStream.CanSeek" />, <see cref="P:System.IO.Compression.GZipStream.CanWrite" />, and <see cref="P:System.IO.Compression.GZipStream.CanRead" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Compression.GZipStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-223">获取一个值，该值指示流是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ac611-223">Gets a value indicating whether the stream supports writing.</span></span></summary>
        <value><span data-ttu-id="ac611-224">如果 <see cref="T:System.IO.Compression.CompressionMode" /> 值为 <see langword="Compress" /> 而且基础流未关闭并支持写入，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-224"><see langword="true" /> if the <see cref="T:System.IO.Compression.CompressionMode" /> value is <see langword="Compress" />, and the underlying stream supports writing and is not closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ac611-225">从 <see cref="T:System.IO.Compression.GZipStream" />继承时，必须重写以下成员： <see cref="P:System.IO.Compression.GZipStream.CanSeek" />、<see cref="P:System.IO.Compression.GZipStream.CanWrite" />和 <see cref="P:System.IO.Compression.GZipStream.CanRead" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-225">When you inherit from <see cref="T:System.IO.Compression.GZipStream" />, you must override the following members: <see cref="P:System.IO.Compression.GZipStream.CanSeek" />, <see cref="P:System.IO.Compression.GZipStream.CanWrite" />, and <see cref="P:System.IO.Compression.GZipStream.CanRead" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="gZipStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ac611-226">向其中复制当前 GZip 流的内容的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-226">The stream to which the contents of the current GZip stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="ac611-227">缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="ac611-227">The size of the buffer.</span></span> <span data-ttu-id="ac611-228">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="ac611-228">This value must be greater than zero.</span></span> <span data-ttu-id="ac611-229">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="ac611-229">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="ac611-230">使用指定的缓冲区大小，从当前 GZip 流中读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="ac611-230">Reads the bytes from the current GZip stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-231">从当前的 GZip 流中的当前位置开始复制，在复制操作完成后，不会重置目标流的位置。</span><span class="sxs-lookup"><span data-stu-id="ac611-231">Copying begins at the current position in the current GZip stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CopyToAsync (destination As Stream, bufferSize As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="gZipStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ac611-232">向其中复制当前 GZip 流的内容的流。</span><span class="sxs-lookup"><span data-stu-id="ac611-232">The stream to which the contents of the current GZip stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="ac611-233">缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ac611-233">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="ac611-234">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="ac611-234">This value must be greater than zero.</span></span> <span data-ttu-id="ac611-235">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="ac611-235">The default size is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ac611-236">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-236">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-237">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-237">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-238">使用指定的缓冲区大小，从当前 GZip 流中异步读取字节并将其写入到另一流中。</span><span class="sxs-lookup"><span data-stu-id="ac611-238">Asynchronously reads the bytes from the current GZip stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <returns><span data-ttu-id="ac611-239">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-239">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-240">利用 <xref:System.IO.Compression.GZipStream.CopyToAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-240">The <xref:System.IO.Compression.GZipStream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ac611-241">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-241">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-242">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-242">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-243">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-243">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="ac611-244">从当前的 GZip 流中的当前位置开始复制。</span><span class="sxs-lookup"><span data-stu-id="ac611-244">Copying begins at the current position in the current GZip stream.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="gZipStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="ac611-245">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-245"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="ac611-246">释放 <see cref="T:System.IO.Compression.GZipStream" /> 使用的非托管资源，并选择性地释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-246">Releases the unmanaged resources used by the <see cref="T:System.IO.Compression.GZipStream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-247">此方法由 public <xref:System.ComponentModel.Component.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-247">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="ac611-248"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护的 <xref:System.IO.Compression.GZipStream.Dispose%2A> 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ac611-248"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Compression.GZipStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="ac611-249"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 <xref:System.IO.Compression.GZipStream.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="ac611-249"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Compression.GZipStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="ac611-250">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.Compression.DeflateStream> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-250">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Compression.DeflateStream> references.</span></span> <span data-ttu-id="ac611-251">此方法将调用每个被引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ac611-251">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ac611-252">
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="ac611-252">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="ac611-253">重写 <see cref="M:System.IO.Compression.GZipStream.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see cref="M:System.ComponentModel.Component.Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-253">When overriding <see cref="M:System.IO.Compression.GZipStream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="ac611-254">有关如何实现 <see cref="M:System.IO.Compression.GZipStream.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-254">For more information about how to implement <see cref="M:System.IO.Compression.GZipStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="ac611-255">有关 <see cref="M:System.ComponentModel.Component.Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-255">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="gZipStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac611-256">异步释放 <see cref="T:System.IO.Compression.GZipStream" /> 使用的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-256">Asynchronously releases the unmanaged resources used by the <see cref="T:System.IO.Compression.GZipStream" />.</span></span></summary>
        <returns><span data-ttu-id="ac611-257">一个表示异步释放操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-257">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-258">使用 `DisposeAsync` 方法，您可以在不阻塞主线程的情况下执行占用大量资源的释放操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-258">The `DisposeAsync` method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="ac611-259">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-259">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-260">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-260">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-261">此方法通过将任何更改写入后备存储并关闭流以释放资源来释放 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-261">This method disposes the GZip stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="ac611-262">调用 `DisposeAsync` 允许出于其他目的重新分配 <xref:System.IO.Compression.GZipStream> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="ac611-262">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.Compression.GZipStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="ac611-263">有关详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-263">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="gZipStream.EndRead asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult async_result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult async_result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (async_result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ async_result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="gZipStream.EndRead async_result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="async_result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ac611-264">对要完成的挂起异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="ac611-264">The reference to the pending asynchronous request to finish.</span></span></param>
        <param name="async_result"><span data-ttu-id="ac611-265">对要完成的挂起异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="ac611-265">The reference to the pending asynchronous request to finish.</span></span></param>
        <summary><span data-ttu-id="ac611-266">等待挂起的异步读取操作完成。</span><span class="sxs-lookup"><span data-stu-id="ac611-266">Waits for the pending asynchronous read to complete.</span></span> <span data-ttu-id="ac611-267">（请考虑改用 <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> 方法。）</span><span class="sxs-lookup"><span data-stu-id="ac611-267">(Consider using the <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> method instead.)</span></span></summary>
        <returns><span data-ttu-id="ac611-268">从流中读取的字节数，介于 0（零）和你请求的字节数之间。</span><span class="sxs-lookup"><span data-stu-id="ac611-268">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span></span> <span data-ttu-id="ac611-269"><see cref="T:System.IO.Compression.GZipStream" /> 仅在流的末尾返回零 (0)；否则将一直阻塞，只到至少有一个字节可用。</span><span class="sxs-lookup"><span data-stu-id="ac611-269"><see cref="T:System.IO.Compression.GZipStream" /> returns 0 only at the end of the stream; otherwise, it blocks until at least one byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-270">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，你可以通过使用 <xref:System.IO.Stream.ReadAsync%2A?displayProperty=nameWithType> 方法执行异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-270">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can perform asynchronous read operations by using the <xref:System.IO.Stream.ReadAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ac611-271"><xref:System.IO.Compression.GZipStream.EndRead%2A> 方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中仍可用以支持旧版代码;不过，您可以使用新的异步方法更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-271">The <xref:System.IO.Compression.GZipStream.EndRead%2A> method is still available in [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, you can implement asynchronous I/O operations more easily by using the new async methods.</span></span> <span data-ttu-id="ac611-272">有关详细信息，请参阅[异步文件 I/O](~/docs/standard/io/asynchronous-file-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-272">For more information, see [Asynchronous File I/O](~/docs/standard/io/asynchronous-file-i-o.md).</span></span>
  
 <span data-ttu-id="ac611-273">调用此方法以确定从流中读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-273">Call this method to determine how many bytes were read from the stream.</span></span> <span data-ttu-id="ac611-274">可以调用此方法一次，以返回对 <xref:System.IO.Compression.GZipStream.BeginRead%2A> 和 <xref:System.IO.Compression.GZipStream.EndRead%2A>的调用之间的读取字节量。</span><span class="sxs-lookup"><span data-stu-id="ac611-274">This method can be called once to return the amount of bytes read between calls to <xref:System.IO.Compression.GZipStream.BeginRead%2A> and <xref:System.IO.Compression.GZipStream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="ac611-275">此方法将一直阻塞，直到 I/O 操作已完成。</span><span class="sxs-lookup"><span data-stu-id="ac611-275">This method blocks until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-276">下面的代码示例演示如何使用 <xref:System.IO.Compression.GZipStream> 类压缩和解压缩文件。</span><span class="sxs-lookup"><span data-stu-id="ac611-276">The following code example shows how to use the <xref:System.IO.Compression.GZipStream> class to compress and decompress a file.</span></span>  
  
 [!code-csharp[IO.Compression.GZip1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Compression.GZip1/CS/gziptest.cs#1)]
 [!code-vb[IO.Compression.GZip1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Compression.GZip1/VB/gziptest.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-277"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-277"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac611-278"><paramref name="asyncResult" /> 不源于当前流的 <see cref="M:System.IO.Compression.GZipStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ac611-278"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Compression.GZipStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ac611-279">由于流已关闭，因此无法执行结束操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-279">The end operation cannot be performed because the stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="gZipStream.EndWrite asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult async_result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult async_result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (async_result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ async_result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="gZipStream.EndWrite async_result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="async_result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ac611-280">表示异步调用的对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-280">The object that represents the asynchronous call.</span></span></param>
        <param name="async_result"><span data-ttu-id="ac611-281">表示异步调用的对象。</span><span class="sxs-lookup"><span data-stu-id="ac611-281">The object that represents the asynchronous call.</span></span></param>
        <summary><span data-ttu-id="ac611-282">处理异步写入操作的结束。</span><span class="sxs-lookup"><span data-stu-id="ac611-282">Handles the end of an asynchronous write operation.</span></span> <span data-ttu-id="ac611-283">（请考虑改用 <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> 方法。）</span><span class="sxs-lookup"><span data-stu-id="ac611-283">(Consider using the <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> method instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-284">从 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]开始，可以通过使用 <xref:System.IO.Stream.WriteAsync%2A?displayProperty=nameWithType> 方法执行异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-284">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can perform asynchronous write operations by using the <xref:System.IO.Stream.WriteAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ac611-285"><xref:System.IO.Compression.GZipStream.EndWrite%2A> 方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中仍可用以支持旧版代码;不过，您可以使用新的异步方法更轻松地实现异步 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-285">The <xref:System.IO.Compression.GZipStream.EndWrite%2A> method is still available in [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, you can implement asynchronous I/O operations more easily by using the new async methods.</span></span> <span data-ttu-id="ac611-286">有关详细信息，请参阅[异步文件 I/O](~/docs/standard/io/asynchronous-file-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="ac611-286">For more information, see [Asynchronous File I/O](~/docs/standard/io/asynchronous-file-i-o.md).</span></span>
  
 <span data-ttu-id="ac611-287"><xref:System.IO.Compression.GZipStream.EndWrite%2A> 方法完成 <xref:System.IO.Compression.GZipStream.BeginWrite%2A> 方法中启动的异步写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-287">The <xref:System.IO.Compression.GZipStream.EndWrite%2A> method completes the asynchronous write operation started in the <xref:System.IO.Compression.GZipStream.BeginWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ac611-288">此基础流为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-288">The underlying stream is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ac611-289">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-289">-or-</span></span> 
<span data-ttu-id="ac611-290">基础流已关闭。</span><span class="sxs-lookup"><span data-stu-id="ac611-290">The underlying stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="gZipStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac611-291">刷新内部缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-291">Flushes the internal buffers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-292">仅当当前压缩模式为 <xref:System.IO.Compression.CompressionMode.Compress> 并且基础流仍有一些要写入的输入时，此方法才会刷新。</span><span class="sxs-lookup"><span data-stu-id="ac611-292">This method flushes only if the current compression mode is <xref:System.IO.Compression.CompressionMode.Compress> and the underlying stream still has some input left to write.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac611-293">基础流已关闭。</span><span class="sxs-lookup"><span data-stu-id="ac611-293">The underlying stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="gZipStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="ac611-294">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-294">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-295">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-295">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-296">异步清理此 GZip 流的所有缓冲区，使所有缓冲数据写入基础设备，并监控取消请求。</span><span class="sxs-lookup"><span data-stu-id="ac611-296">Asynchronously clears all buffers for this GZip stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ac611-297">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-297">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-298">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-298">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Compression.GZipStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-299">此属性不受支持，并且总是引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-299">This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <value><span data-ttu-id="ac611-300">一个长值。</span><span class="sxs-lookup"><span data-stu-id="ac611-300">A long value.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac611-301">此流中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="ac611-301">This property is not supported on this stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.GZipStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Compression.GZipStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ac611-302">此属性不受支持，并且总是引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-302">This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <value><span data-ttu-id="ac611-303">一个长值。</span><span class="sxs-lookup"><span data-stu-id="ac611-303">A long value.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac611-304">此流中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="ac611-304">This property is not supported on this stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="gZipStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ac611-305">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="ac611-305">A region of memory.</span></span> <span data-ttu-id="ac611-306">当此方法返回时，此区域的内容将替换为从当前源读取的字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-306">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="ac611-307">将当前 GZip 流中的一个字节序列读取到某字节范围，并按读取的字节数向前移动 GZip 流中的位置。</span><span class="sxs-lookup"><span data-stu-id="ac611-307">Reads a sequence of bytes from the current GZip stream into a byte span and advances the position within the GZip stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="ac611-308">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-308">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="ac611-309">如果很多字节当前不可用，则这可小于在缓冲区中分配的字节数；如果已到达流结尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="ac611-309">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-310">使用 <xref:System.IO.Compression.GZipStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-310">Use the <xref:System.IO.Compression.GZipStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="ac611-311">使用 <xref:System.IO.Compression.GZipStream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-311">Use the <xref:System.IO.Compression.GZipStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="ac611-312">此方法从当前流中读取最多 `buffer.Length` 个字节，并将它们存储在 `buffer`中。</span><span class="sxs-lookup"><span data-stu-id="ac611-312">This method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="ac611-313">GZip 流中的当前位置由读取的字节数提前;但是，如果发生异常，则 GZip 流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="ac611-313">The current position within the GZip stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the GZip stream remains unchanged.</span></span> <span data-ttu-id="ac611-314">如果没有数据可用，则此方法将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-314">This method will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="ac611-315">仅当流中没有更多的数据，并且不需要更多的数据时（例如闭合套接字或文件尾），`Read` 才返回0。</span><span class="sxs-lookup"><span data-stu-id="ac611-315">`Read` returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="ac611-316">即使尚未到达流的末尾，方法也可以随意返回比所请求的字节更少的字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-316">The method is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

 <span data-ttu-id="ac611-317">使用 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="ac611-317">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="gZipStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-318">用于存储解压缩字节的数组。</span><span class="sxs-lookup"><span data-stu-id="ac611-318">The array used to store decompressed bytes.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-319"><paramref name="array" /> 中的字节偏移量，将在此处放置读取的字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-319">The byte offset in <paramref name="array" /> at which the read bytes will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-320">最多要读取的解压缩字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-320">The maximum number of decompressed bytes to read.</span></span></param>
        <summary><span data-ttu-id="ac611-321">将若干解压缩的字节读入指定的字节数组。</span><span class="sxs-lookup"><span data-stu-id="ac611-321">Reads a number of decompressed bytes into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="ac611-322">解压缩到字节数组中的字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-322">The number of bytes that were decompressed into the byte array.</span></span> <span data-ttu-id="ac611-323">如果已到达流的末尾，则返回 0 或已读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-323">If the end of the stream has been reached, zero or the number of bytes read is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-324">如果发现数据的格式无效，则会作为最后一个操作的一个 <xref:System.IO.InvalidDataException> 引发。</span><span class="sxs-lookup"><span data-stu-id="ac611-324">If data is found in an invalid format, an <xref:System.IO.InvalidDataException> is thrown as one of the last operations.</span></span> <span data-ttu-id="ac611-325">循环冗余检查（CRC）作为此方法的最后一次操作执行。</span><span class="sxs-lookup"><span data-stu-id="ac611-325">A cyclic redundancy check (CRC) is performed as one of the last operations of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-326">下面的示例演示如何使用 <xref:System.IO.Compression.GZipStream.Read%2A> 和 <xref:System.IO.Compression.GZipStream.Write%2A> 方法压缩和解压缩字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-326">The following example shows how to compress and decompress bytes by using the <xref:System.IO.Compression.GZipStream.Read%2A> and <xref:System.IO.Compression.GZipStream.Write%2A> methods.</span></span>  
  
 [!code-csharp[System.IO.Compression.GZipStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.gzipstream/cs/program3.cs#3)]
 [!code-vb[System.IO.Compression.GZipStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.gzipstream/vb/program3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac611-327"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-327"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ac611-328">创建对象时 <see cref="T:System.IO.Compression.CompressionMode" /> 值是 <see langword="Compress" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-328">The <see cref="T:System.IO.Compression.CompressionMode" /> value was <see langword="Compress" /> when the object was created.</span></span>  
  
<span data-ttu-id="ac611-329">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-329">-or-</span></span> 
<span data-ttu-id="ac611-330">基础流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-330">The underlying stream does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ac611-331"><paramref name="offset" /> 或 <paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="ac611-331"><paramref name="offset" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="ac611-332">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ac611-332">-or-</span></span> 
 <span data-ttu-id="ac611-333"><paramref name="array" /> 长度减去索引起始点小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-333"><paramref name="array" /> length minus the index starting point is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.IO.InvalidDataException"><span data-ttu-id="ac611-334">数据的格式无效。</span><span class="sxs-lookup"><span data-stu-id="ac611-334">The data is in an invalid format.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac611-335">流已关闭。</span><span class="sxs-lookup"><span data-stu-id="ac611-335">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Memory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="gZipStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ac611-336">要将数据写入的内存区域。</span><span class="sxs-lookup"><span data-stu-id="ac611-336">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ac611-337">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-337">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-338">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-338">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-339">从当前 GZip 流将字节的序列异步读取到一个字节内存区域中，按读取的字节数向前移动 GZip 流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ac611-339">Asynchronously reads a sequence of bytes from the current GZip stream into a byte memory region, advances the position within the GZip stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ac611-340">一个表示异步读取操作并将读取的总字节数包装到缓冲区中的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-340">A task that represents the asynchronous read operation, which wraps the total number of bytes read into the buffer.</span></span> <span data-ttu-id="ac611-341">如果很多字节当前不可用，则结果值可小于在缓冲区中分配的字节数；如果已到达 GZip 流结尾，则结果值可以为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="ac611-341">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the GZip stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-342">利用 `ReadAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-342">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ac611-343">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-343">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-344">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-344">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-345">使用 <xref:System.IO.Compression.GZipStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-345">Use the <xref:System.IO.Compression.GZipStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="ac611-346">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-346">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] array, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] array, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (array As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ array, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="gZipStream.ReadAsync (array, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-347">数据写入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-347">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-348"><paramref name="array" /> 中的字节偏移量，从该偏移量开始写入从 GZip 流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="ac611-348">The byte offset in <paramref name="array" /> at which to begin writing data from the GZip stream.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-349">要读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-349">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ac611-350">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-350">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-351">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-351">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-352">从当前 GZip 流将字节的序列异步读取到一个字节数组中，按读取的字节数向前移动 GZip 流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="ac611-352">Asynchronously reads a sequence of bytes from the current GZip stream into a byte array, advances the position within the GZip stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ac611-353">一个表示异步读取操作（将读取的总字节数包装到 <paramref name="array" /> 中）的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-353">A task that represents the asynchronous read operation, which wraps the total number of bytes read into the <paramref name="array" />.</span></span> <span data-ttu-id="ac611-354">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达 GZip 流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="ac611-354">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the GZip stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Remarks

<span data-ttu-id="ac611-355">利用 `ReadAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-355">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ac611-356">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-356">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-357">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-357">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-358">使用 <xref:System.IO.Compression.GZipStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-358">Use the <xref:System.IO.Compression.GZipStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="ac611-359">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-359">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="gZipStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac611-360">从 GZip 流中读取一个字节，并将流内的位置向前提升一个字节，或者如果已到达 GZip 流结尾，则返回 -1。</span><span class="sxs-lookup"><span data-stu-id="ac611-360">Reads a byte from the GZip stream and advances the position within the stream by one byte, or returns -1 if at the end of the GZip stream.</span></span></summary>
        <returns><span data-ttu-id="ac611-361">强制转换为 <see cref="T:System.Int32" /> 的无符号字节，如果到达流的末尾，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="ac611-361">The unsigned byte cast to an <see cref="T:System.Int32" />, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-362">使用 <xref:System.IO.Compression.GZipStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="ac611-362">Use the <xref:System.IO.Compression.GZipStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="gZipStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="ac611-363">流中的位置。</span><span class="sxs-lookup"><span data-stu-id="ac611-363">The location in the stream.</span></span></param>
        <param name="origin"><span data-ttu-id="ac611-364"><see cref="T:System.IO.SeekOrigin" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ac611-364">One of the <see cref="T:System.IO.SeekOrigin" /> values.</span></span></param>
        <summary><span data-ttu-id="ac611-365">此属性不受支持，并且总是引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-365">This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="ac611-366">一个长值。</span><span class="sxs-lookup"><span data-stu-id="ac611-366">A long value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac611-367">此流中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="ac611-367">This property is not supported on this stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="gZipStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ac611-368">流的长度。</span><span class="sxs-lookup"><span data-stu-id="ac611-368">The length of the stream.</span></span></param>
        <summary><span data-ttu-id="ac611-369">此属性不受支持，并且总是引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-369">This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac611-370">此流中不支持此属性。</span><span class="sxs-lookup"><span data-stu-id="ac611-370">This property is not supported on this stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="gZipStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ac611-371">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="ac611-371">A region of memory.</span></span> <span data-ttu-id="ac611-372">此方法将此区域的内容复制到当前 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-372">This method copies the contents of this region to the current GZip stream.</span></span></param>
        <summary><span data-ttu-id="ac611-373">从一个只读字节范围将字节的序列写入当前 GZip 流，并按写入的字节数向前移动此 GZip 流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="ac611-373">Writes a sequence of bytes to the current GZip stream from a read-only byte span and advances the current position within this GZip stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-374">使用 <xref:System.IO.Compression.GZipStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ac611-374">Use the <xref:System.IO.Compression.GZipStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="ac611-375">使用 <xref:System.IO.Compression.GZipStream.WriteAsync%2A> 方法异步写入当前流。</span><span class="sxs-lookup"><span data-stu-id="ac611-375">Use the <xref:System.IO.Compression.GZipStream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>

<span data-ttu-id="ac611-376">如果写入操作成功，则 GZip 流中的位置将按写入的字节数向前移动。</span><span class="sxs-lookup"><span data-stu-id="ac611-376">If the write operation is successful, the position within the GZip stream advances by the number of bytes written.</span></span> <span data-ttu-id="ac611-377">如果发生异常，则 GZip 流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="ac611-377">If an exception occurs, the position within the GZip stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="gZipStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-378">包含要压缩的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-378">The buffer that contains the data to compress.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-379"><paramref name="array" /> 中的字节偏移量，将在此处读取字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-379">The byte offset in <paramref name="array" /> from which the bytes will be read.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-380">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-380">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="ac611-381">从指定的字节数组中将压缩的字节写入基础 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-381">Writes compressed bytes to the underlying GZip stream from the specified byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac611-382">写操作可能不会立即发生，而是在达到缓冲区大小时或调用 <xref:System.IO.Compression.GZipStream.Flush%2A> 或 <xref:System.IO.Stream.Close%2A> 方法之前进行缓冲处理。</span><span class="sxs-lookup"><span data-stu-id="ac611-382">The write operation might not occur immediately but is buffered until the buffer size is reached or until the <xref:System.IO.Compression.GZipStream.Flush%2A> or <xref:System.IO.Stream.Close%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac611-383">下面的示例演示如何使用 <xref:System.IO.Compression.GZipStream.Read%2A> 和 <xref:System.IO.Compression.GZipStream.Write%2A> 方法压缩和解压缩字节。</span><span class="sxs-lookup"><span data-stu-id="ac611-383">The following example shows how to compress and decompress bytes by using the <xref:System.IO.Compression.GZipStream.Read%2A> and <xref:System.IO.Compression.GZipStream.Write%2A> methods.</span></span>  
  
 [!code-csharp[System.IO.Compression.GZipStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.gzipstream/cs/program3.cs#3)]
 [!code-vb[System.IO.Compression.GZipStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.gzipstream/vb/program3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac611-384">由于流已关闭，因此无法执行写入操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-384">The write operation cannot be performed because the stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As ReadOnlyMemory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="gZipStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ac611-385">从中写入数据的内存区域。</span><span class="sxs-lookup"><span data-stu-id="ac611-385">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ac611-386">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-386">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-387">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-387">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-388">从指定的只读字节内存区域中，将压缩的字节异步写入基础 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-388">Asynchronously writes compressed bytes to the underlying GZip stream from the specified read-only byte memory region.</span></span></summary>
        <returns><span data-ttu-id="ac611-389">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-389">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-390">利用 `WriteAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-390">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ac611-391">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-391">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-392">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-392">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-393">使用 <xref:System.IO.Compression.GZipStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ac611-393">Use the <xref:System.IO.Compression.GZipStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="ac611-394">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-394">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] array, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] array, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.GZipStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (array As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ array, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="gZipStream.WriteAsync (array, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="ac611-395">包含要压缩的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ac611-395">The buffer that contains the data to compress.</span></span></param>
        <param name="offset"><span data-ttu-id="ac611-396"><paramref name="array" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-396">The zero-based byte offset in <paramref name="array" /> from which to begin copying bytes to the GZip stream.</span></span></param>
        <param name="count"><span data-ttu-id="ac611-397">要写入的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="ac611-397">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ac611-398">要监视的取消请求标记。</span><span class="sxs-lookup"><span data-stu-id="ac611-398">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ac611-399">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="ac611-399">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ac611-400">从指定的字节数组中将压缩的字节异步写入基础 GZip 流。</span><span class="sxs-lookup"><span data-stu-id="ac611-400">Asynchronously writes compressed bytes to the underlying GZip stream from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="ac611-401">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="ac611-401">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ac611-402">利用 `WriteAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="ac611-402">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="ac611-403">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="ac611-403">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="ac611-404">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="ac611-404">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="ac611-405">使用 <xref:System.IO.Compression.GZipStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="ac611-405">Use the <xref:System.IO.Compression.GZipStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="ac611-406">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="ac611-406">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
