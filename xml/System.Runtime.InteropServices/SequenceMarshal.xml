<Type Name="SequenceMarshal" FullName="System.Runtime.InteropServices.SequenceMarshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="55b01c75b1c833f975a1c0c8b47c34ccc10e87d0" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100298292" /></Metadata><TypeSignature Language="C#" Value="public static class SequenceMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit SequenceMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SequenceMarshal" />
  <TypeSignature Language="VB.NET" Value="Public Class SequenceMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class SequenceMarshal abstract sealed" />
  <TypeSignature Language="F#" Value="type SequenceMarshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="956bc-101">提供与 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 进行互操作的方法集合。</span><span class="sxs-lookup"><span data-stu-id="956bc-101">Provides a collection of methods for interoperating with <see cref="T:System.Buffers.ReadOnlySequence`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="TryGetArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetArray&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ArraySegment`1&lt;!!T&gt;&amp; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetArray(Of T) (sequence As ReadOnlySequence(Of T), ByRef segment As ArraySegment(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetArray(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ArraySegment&lt;T&gt; % segment);" />
      <MemberSignature Language="F#" Value="static member TryGetArray : System.Buffers.ReadOnlySequence&lt;'T&gt; * ArraySegment -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetArray (sequence, segment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="956bc-102">只读序列的类型。</span><span class="sxs-lookup"><span data-stu-id="956bc-102">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="956bc-103">要从中检索数组段的只读序列。</span><span class="sxs-lookup"><span data-stu-id="956bc-103">The read-only sequence from which the array segment will be retrieved.</span></span></param>
        <param name="segment"><span data-ttu-id="956bc-104">返回的数组段。</span><span class="sxs-lookup"><span data-stu-id="956bc-104">The returned array segment.</span></span></param>
        <summary><span data-ttu-id="956bc-105">获取基础只读序列中的数组段。</span><span class="sxs-lookup"><span data-stu-id="956bc-105">Gets an array segment from the underlying read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="956bc-106">如果可以检索数组段，则为 <see langword="true" />；否则为 <see langword="false" /> 且返回默认数组段。</span><span class="sxs-lookup"><span data-stu-id="956bc-106"><see langword="true" /> if it's possible to retrieve the array segment; otherwise, <see langword="false" /> and a default array segment is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlyMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlyMemory&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlyMemory&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] valuetype System.ReadOnlyMemory`1&lt;!!T&gt;&amp; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlyMemory(Of T) (sequence As ReadOnlySequence(Of T), ByRef memory As ReadOnlyMemory(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlyMemory(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] ReadOnlyMemory&lt;T&gt; % memory);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlyMemory : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlyMemory -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory (sequence, memory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="956bc-107">只读序列的类型。</span><span class="sxs-lookup"><span data-stu-id="956bc-107">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="956bc-108">要从中检索内存的只读序列。</span><span class="sxs-lookup"><span data-stu-id="956bc-108">The read-only sequence from which the memory will be retrieved.</span></span></param>
        <param name="memory"><span data-ttu-id="956bc-109">返回的类型为 T 的只读内存。</span><span class="sxs-lookup"><span data-stu-id="956bc-109">The returned read-only memory of type T.</span></span></param>
        <summary><span data-ttu-id="956bc-110">尝试检索指定的只读序列中的只读内存。</span><span class="sxs-lookup"><span data-stu-id="956bc-110">Attempts to retrieve a read-only memory from the specified read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="956bc-111">如果可以检索只读内存，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="956bc-111"><see langword="true" /> if the read-only memory can be retrieved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReadOnlySequenceSegment&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlySequenceSegment&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt;? startSegment, out int? startIndex, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt;? endSegment, out int? endIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetReadOnlySequenceSegment&lt;T&gt;(valuetype System.Buffers.ReadOnlySequence`1&lt;!!T&gt; sequence, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; startSegment, [out] int32&amp; startIndex, [out] class System.Buffers.ReadOnlySequenceSegment`1&lt;!!T&gt;&amp; endSegment, [out] int32&amp; endIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetReadOnlySequenceSegment(Of T) (sequence As ReadOnlySequence(Of T), ByRef startSegment As ReadOnlySequenceSegment(Of T), ByRef startIndex As Integer, ByRef endSegment As ReadOnlySequenceSegment(Of T), ByRef endIndex As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetReadOnlySequenceSegment(System::Buffers::ReadOnlySequence&lt;T&gt; sequence, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % startSegment, [Runtime::InteropServices::Out] int % startIndex, [Runtime::InteropServices::Out] System::Buffers::ReadOnlySequenceSegment&lt;T&gt; ^ % endSegment, [Runtime::InteropServices::Out] int % endIndex);" />
      <MemberSignature Language="F#" Value="static member TryGetReadOnlySequenceSegment : System.Buffers.ReadOnlySequence&lt;'T&gt; * ReadOnlySequenceSegment * int * ReadOnlySequenceSegment * int -&gt; bool" Usage="System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment (sequence, startSegment, startIndex, endSegment, endIndex)" />
      <MemberSignature Language="C#" Value="public static bool TryGetReadOnlySequenceSegment&lt;T&gt; (System.Buffers.ReadOnlySequence&lt;T&gt; sequence, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; startSegment, out int startIndex, out System.Buffers.ReadOnlySequenceSegment&lt;T&gt; endSegment, out int endIndex);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Buffers.ReadOnlySequence&lt;T&gt;" />
        <Parameter Name="startSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startIndex" Type="System.Int32" RefType="out" />
        <Parameter Name="endSegment" Type="System.Buffers.ReadOnlySequenceSegment&lt;T&gt;" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="endIndex" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="956bc-112">只读序列的类型。</span><span class="sxs-lookup"><span data-stu-id="956bc-112">The type of the read-only sequence.</span></span></typeparam>
        <param name="sequence"><span data-ttu-id="956bc-113">从中检索只读序列段的只读序列。</span><span class="sxs-lookup"><span data-stu-id="956bc-113">The read-only sequence from which the read-only sequence segment will be retrieved.</span></span></param>
        <param name="startSegment"><span data-ttu-id="956bc-114">只读序列段的开头。</span><span class="sxs-lookup"><span data-stu-id="956bc-114">The beginning read-only sequence segment.</span></span></param>
        <param name="startIndex"><span data-ttu-id="956bc-115">初始位置。</span><span class="sxs-lookup"><span data-stu-id="956bc-115">The initial position.</span></span></param>
        <param name="endSegment"><span data-ttu-id="956bc-116">只读序列段的结尾。</span><span class="sxs-lookup"><span data-stu-id="956bc-116">The ending read-only sequence segment.</span></span></param>
        <param name="endIndex"><span data-ttu-id="956bc-117">最终位置。</span><span class="sxs-lookup"><span data-stu-id="956bc-117">The final position.</span></span></param>
        <summary><span data-ttu-id="956bc-118">尝试检索指定的只读序列中的只读序列段。</span><span class="sxs-lookup"><span data-stu-id="956bc-118">Attempts to retrieve a read-only sequence segment from the specified read-only sequence.</span></span></summary>
        <returns><span data-ttu-id="956bc-119">如果可以检索只读序列段，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="956bc-119"><see langword="true" /> if the read-only sequence segment can be retrieved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRead&lt;T&gt; (ref System.Buffers.SequenceReader&lt;byte&gt; reader, out T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRead&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Buffers.SequenceReader`1&lt;unsigned int8&gt;&amp; reader, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRead(Of T As Structure) (ByRef reader As SequenceReader(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryRead(System::Buffers::SequenceReader&lt;System::Byte&gt; % reader, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryRead : SequenceReader * 'T -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.SequenceMarshal.TryRead (reader, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Buffers.SequenceReader&lt;System.Byte&gt;" RefType="ref" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="value" Type="T" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="956bc-120">值的类型。</span><span class="sxs-lookup"><span data-stu-id="956bc-120">The type of the value.</span></span></typeparam>
        <param name="reader"><span data-ttu-id="956bc-121">对序列读取器的引用。</span><span class="sxs-lookup"><span data-stu-id="956bc-121">A reference to the sequence reader.</span></span></param>
        <param name="value"><span data-ttu-id="956bc-122">如果读取成功，则为返回值。</span><span class="sxs-lookup"><span data-stu-id="956bc-122">The returned value if the read was successful.</span></span> <span data-ttu-id="956bc-123">如果（由于空间不足）失败，<paramref name="value" /> 将为 <see langword="default" />。</span><span class="sxs-lookup"><span data-stu-id="956bc-123"><paramref name="value" /> will be <see langword="default" /> if failed (due to lack of space).</span></span></param>
        <summary><span data-ttu-id="956bc-124">尝试读取缓冲区外的指定类型。</span><span class="sxs-lookup"><span data-stu-id="956bc-124">Attempts to read the specified type out of the buffer.</span></span> <span data-ttu-id="956bc-125">将此方法与任意结构一起使用不太安全 - 请参阅注释以获取详细信息。</span><span class="sxs-lookup"><span data-stu-id="956bc-125">It's dangerous to use this method with arbitrary structs - see remarks for more information.</span></span></summary>
        <returns><span data-ttu-id="956bc-126">如果读取尝试成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="956bc-126"><see langword="true" /> if the read attempt was successful, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> <span data-ttu-id="956bc-127">Read 是位的直接副本。</span><span class="sxs-lookup"><span data-stu-id="956bc-127">The read is a straight copy of bits.</span></span> <span data-ttu-id="956bc-128">如果结构依赖于其成员的特定状态才能正常运行，这可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="956bc-128">If a struct depends on the specific state of its members to behave correctly, this can lead to exceptions.</span></span> <span data-ttu-id="956bc-129">如果要读取 endian 特定的整数，请使用显式重载，如 [TryReadLittleEndian (SequenceReader \<Byte> 、Int32) ](xref:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian%2A)。</span><span class="sxs-lookup"><span data-stu-id="956bc-129">If you're reading endian specific integers, use the explicit overloads such as [TryReadLittleEndian(SequenceReader\<Byte>, Int32)](xref:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian%2A).</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
