<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e94f5f7670645e368878c075920dd4cb42046187" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83508261" /></Metadata><TypeSignature Language="C#" Value="public static class Marshal" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Marshal = class" />
  <TypeSignature Language="C#" Value="public sealed class Marshal" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Marshal extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Marshal" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Marshal extends System.Object" FrameworkAlternate="netframework-4.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.InteropServices" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d3881-101">提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-101">Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-102">对 <xref:System.Runtime.InteropServices.Marshal> 类定义的 `static` 方法对于使用非托管代码很重要。</span><span class="sxs-lookup"><span data-stu-id="d3881-102">The `static` methods defined on the <xref:System.Runtime.InteropServices.Marshal> class are essential to working with unmanaged code.</span></span> <span data-ttu-id="d3881-103">此类中定义的大多数方法通常由想要在托管和非托管编程模型之间提供桥梁的开发人员使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-103">Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</span></span> <span data-ttu-id="d3881-104">例如，<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 方法将 ANSI 字符从指定的字符串（在托管堆中）复制到非托管堆中的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="d3881-104">For example, the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</span></span> <span data-ttu-id="d3881-105">它还分配适当大小的目标堆。</span><span class="sxs-lookup"><span data-stu-id="d3881-105">It also allocates the target heap of the right size.</span></span>  
  
 <span data-ttu-id="d3881-106">公共语言运行时提供特定封送处理功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-106">The common language runtime provides specific marshaling capabilities.</span></span> <span data-ttu-id="d3881-107">有关封送处理行为的详细信息，请参阅[互操作封送处理](~/docs/framework/interop/interop-marshaling.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-107">For details on marshaling behavior, see [Interop Marshaling](~/docs/framework/interop/interop-marshaling.md).</span></span>  
  
 <span data-ttu-id="d3881-108"><xref:System.Runtime.InteropServices.Marshal> 类中的 `Read` 和 `Write` 方法支持对齐和未对齐的访问。</span><span class="sxs-lookup"><span data-stu-id="d3881-108">The `Read` and `Write` methods in the <xref:System.Runtime.InteropServices.Marshal> class support both aligned and unaligned access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-109">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal> 类定义的各种方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-109">The following example shows how to use various methods defined by the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member AddRef : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.AddRef pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="d3881-110">要递增的接口引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-110">The interface reference count to increment.</span></span></param>
        <summary><span data-ttu-id="d3881-111">递增指定接口上的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-111">Increments the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="d3881-112"><paramref name="pUnk" /> 参数上的引用计数的新值。</span><span class="sxs-lookup"><span data-stu-id="d3881-112">The new value of the reference count on the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-113">公共语言运行时管理 COM 对象的引用计数，因此无需直接使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-113">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="d3881-114">在极少数情况下（例如测试自定义封送拆收器），您可能会发现需要手动操作对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="d3881-114">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="d3881-115">调用 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>之后，必须使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>等方法来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-115">After calling <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, you must decrement the reference count by using a method such as <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-116">不要依赖于 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>的返回值，因为它有时可能不稳定。</span><span class="sxs-lookup"><span data-stu-id="d3881-116">Do not rely on the return value of <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, as it can sometimes be unstable.</span></span>  
  
 <span data-ttu-id="d3881-117">可以调用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>或 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>，以获取表示[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口指针的 <xref:System.IntPtr> 值。</span><span class="sxs-lookup"><span data-stu-id="d3881-117">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents an [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface pointer.</span></span> <span data-ttu-id="d3881-118">你还可以在托管对象上使用这些方法和 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> 方法，以获取托管对象的 COM 可调用包装器所表示的 COM 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-118">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</span></span> <span data-ttu-id="d3881-119">如果你不熟悉此包装类型的详细信息，请参阅[COM 可调用包装](~/docs/framework/interop/com-callable-wrapper.md)器。</span><span class="sxs-lookup"><span data-stu-id="d3881-119">If you are not familiar with the details of this wrapper type, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=148625"><span data-ttu-id="d3881-120">IUnknown：： AddRef</span><span class="sxs-lookup"><span data-stu-id="d3881-120">IUnknown::AddRef</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberSignature Language="F#" Value="static member AllocCoTaskMem : int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocCoTaskMem cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="d3881-121">要分配的内存块的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-121">The size of the block of memory to be allocated.</span></span></param>
        <summary><span data-ttu-id="d3881-122">从 COM 任务内存分配器分配指定大小的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-122">Allocates a block of memory of specified size from the COM task memory allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-123">一个整数，表示分配的内存块的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-123">An integer representing the address of the block of memory allocated.</span></span> <span data-ttu-id="d3881-124">必须使用 <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> 释放该内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-124">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-125"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> 是 <xref:System.Runtime.InteropServices.Marshal> 类中两个内存分配 API 方法之一。</span><span class="sxs-lookup"><span data-stu-id="d3881-125"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> is one of two memory allocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="d3881-126">（<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> 是另一个。）返回的初始内存内容是未定义的，分配的内存可能大于请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-126">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</span></span> <span data-ttu-id="d3881-127">此方法公开 COM [CoTaskMemAlloc](https://go.microsoft.com/fwlink/?LinkId=148626)函数，该函数称为 com 任务内存分配器。</span><span class="sxs-lookup"><span data-stu-id="d3881-127">This method exposes the COM [CoTaskMemAlloc](https://go.microsoft.com/fwlink/?LinkId=148626) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-128">没有足够的内存来满足该请求。</span><span class="sxs-lookup"><span data-stu-id="d3881-128">There is insufficient memory to satisfy the request.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-129">从进程的非托管内存中分配内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-129">Allocates memory from the unmanaged memory of the process.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberSignature Language="F#" Value="static member AllocHGlobal : int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocHGlobal cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="d3881-130">内存中的所需字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-130">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="d3881-131">通过使用指定的字节数，从进程的非托管内存中分配内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-131">Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-132">指向新分配的内存的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-132">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="d3881-133">必须使用 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> 方法释放该内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-133">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-134"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 是 <xref:System.Runtime.InteropServices.Marshal> 类中两个内存分配方法之一。</span><span class="sxs-lookup"><span data-stu-id="d3881-134"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="d3881-135">（<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> 是另一个。）此方法从 Kernel32.dll 公开 Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkId=148628)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-135">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkId=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="d3881-136">当 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 调用 `LocalAlloc`时，它将传递一个 `LMEM_FIXED` 标志，这会导致已分配的内存就地锁定。</span><span class="sxs-lookup"><span data-stu-id="d3881-136">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="d3881-137">而且，分配的内存不会填充零。</span><span class="sxs-lookup"><span data-stu-id="d3881-137">Also, the allocated memory is not zero-filled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-138">下面的示例演示如何调用 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-138">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> method.</span></span> <span data-ttu-id="d3881-139">此代码示例是为 <xref:System.Runtime.InteropServices.Marshal> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3881-139">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-140">没有足够的内存来满足该请求。</span><span class="sxs-lookup"><span data-stu-id="d3881-140">There is insufficient memory to satisfy the request.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberSignature Language="F#" Value="static member AllocHGlobal : nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.AllocHGlobal cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="d3881-141">内存中的所需字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-141">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="d3881-142">通过使用指向指定字节数的指针，从进程的非托管内存中分配内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-142">Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-143">指向新分配的内存的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-143">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="d3881-144">必须使用 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> 方法释放该内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-144">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-145"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 是 <xref:System.Runtime.InteropServices.Marshal> 类中两个内存分配方法之一。</span><span class="sxs-lookup"><span data-stu-id="d3881-145"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="d3881-146">（<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> 是另一个。）此方法从 Kernel32.dll 公开 Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkID=148628)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-146">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](https://go.microsoft.com/fwlink/?LinkID=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="d3881-147">当 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 调用 `LocalAlloc`时，它将传递一个 `LMEM_FIXED` 标志，这会导致已分配的内存就地锁定。</span><span class="sxs-lookup"><span data-stu-id="d3881-147">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="d3881-148">而且，分配的内存不会填充零。</span><span class="sxs-lookup"><span data-stu-id="d3881-148">Also, the allocated memory is not zero-filled.</span></span>  
  
 <span data-ttu-id="d3881-149">有关代码示例，请参阅 <xref:System.Runtime.InteropServices.Marshal>和 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-149">For example code, see <xref:System.Runtime.InteropServices.Marshal> and <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-150">没有足够的内存来满足该请求。</span><span class="sxs-lookup"><span data-stu-id="d3881-150">There is insufficient memory to satisfy the request.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberSignature Language="F#" Value="static member AreComObjectsAvailableForCleanup : unit -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-151">指示是否可以清除任何上下文中的运行时可调用包装器 (RCW)。</span><span class="sxs-lookup"><span data-stu-id="d3881-151">Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</span></span></summary>
        <returns><span data-ttu-id="d3881-152">如果存在任何可清除的 RCW，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-152"><see langword="true" /> if there are any RCWs available for cleanup; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-153">如果托管代码和本机代码之间存在很多引用和深度依赖关系图，则清理所有对象可能需要较长时间。</span><span class="sxs-lookup"><span data-stu-id="d3881-153">If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</span></span> <span data-ttu-id="d3881-154">每次 GC 运行时，将释放一些 Rcw，这会依次释放基础 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-154">Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</span></span> <span data-ttu-id="d3881-155">然后，这些 COM 对象将释放其托管引用，并在下次运行 GC 时使更多对象可用于清理，这将重新启动该过程。</span><span class="sxs-lookup"><span data-stu-id="d3881-155">Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</span></span>  
  
 <span data-ttu-id="d3881-156"><xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> 方法为应用程序提供了一种方法来确定 GC 循环的次数。收集和 GC。需要进行 WaitForPendingFinalizers 清理。</span><span class="sxs-lookup"><span data-stu-id="d3881-156">The <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberSignature Language="F#" Value="static member BindToMoniker : string -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.BindToMoniker monikerName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="monikerName"><span data-ttu-id="d3881-157">与所需接口指针相对应的名字对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-157">The moniker corresponding to the desired interface pointer.</span></span></param>
        <summary><span data-ttu-id="d3881-158">获取由指定的名字对象标识的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-158">Gets an interface pointer identified by the specified moniker.</span></span></summary>
        <returns><span data-ttu-id="d3881-159">一个对象，它包含对由 <paramref name="monikerName" /> 参数标识的接口指针的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-159">An object containing a reference to the interface pointer identified by the <paramref name="monikerName" /> parameter.</span></span> <span data-ttu-id="d3881-160">名字对象是一个名称，在此情况下，名字对象由接口定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-160">A moniker is a name, and in this case, the moniker is defined by an interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-161"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> 公开 COM `BindToMoniker` 方法，该方法生成可强制转换为所需的任何 COM 接口的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-161"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> exposes the COM `BindToMoniker` method, which produces an object that you can cast to any COM interface you require.</span></span> <span data-ttu-id="d3881-162">此方法提供与 Visual Basic 6.0 和 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]中 `GetObject` 方法相同的功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-162">This method provides the same functionality as the `GetObject` method in Visual Basic 6.0 and [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="d3881-163">非托管的 <see langword="BindToMoniker" /> 方法返回无法识别的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-163">An unrecognized HRESULT was returned by the unmanaged <see langword="BindToMoniker" /> method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberSignature Language="F#" Value="static member BufferToBSTR : Array * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.BufferToBSTR (ptr, slen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="slen" Type="System.Int32" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberSignature Language="F#" Value="static member ChangeWrapperHandleStrength : obj * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength (otp, fIsWeak)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="fIsWeak" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="otp"><span data-ttu-id="d3881-164">一个对象，其 CCW 包含带有引用计数的句柄。</span><span class="sxs-lookup"><span data-stu-id="d3881-164">The object whose CCW holds a reference counted handle.</span></span> <span data-ttu-id="d3881-165">如果 CCW 上的引用计数大于零，则该句柄是强句柄；否则为弱句柄。</span><span class="sxs-lookup"><span data-stu-id="d3881-165">The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</span></span></param>
        <param name="fIsWeak"><span data-ttu-id="d3881-166">为 <see langword="true" /> 时，忽略 <paramref name="otp" /> 的引用计数，将其句柄强度改为弱；为 <see langword="false" /> 时，重置要进行引用计数的 <paramref name="otp" /> 上的句柄强度。</span><span class="sxs-lookup"><span data-stu-id="d3881-166"><see langword="true" /> to change the strength of the handle on the <paramref name="otp" /> parameter to weak, regardless of its reference count; <see langword="false" /> to reset the handle strength on <paramref name="otp" /> to be reference counted.</span></span></param>
        <summary><span data-ttu-id="d3881-167">更改对象的 <see href="~/docs/framework/interop/com-callable-wrapper.md">COM 可调用包装器 (CCW)</see> 句柄的强度。</span><span class="sxs-lookup"><span data-stu-id="d3881-167">Changes the strength of an object's <see href="~/docs/framework/interop/com-callable-wrapper.md">COM Callable Wrapper (CCW)</see> handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-168"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> 用于对象池功能，不应由用户代码直接调用。</span><span class="sxs-lookup"><span data-stu-id="d3881-168"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> is used for object pooling functionality and should never be called by user code directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberSignature Language="F#" Value="static member CleanupUnusedObjectsInCurrentContext : unit -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-169">通知运行时清理当前上下文中分配的所有<see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">运行时可调用包装器 (RCW)</see>。</span><span class="sxs-lookup"><span data-stu-id="d3881-169">Notifies the runtime to clean up all <see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">Runtime Callable Wrappers (RCWs)</see> allocated in the current context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-170">互操作系统会在尝试清理 Rcw 时抽取消息。</span><span class="sxs-lookup"><span data-stu-id="d3881-170">The interop system pumps messages while it attempts to clean up RCWs.</span></span> <span data-ttu-id="d3881-171">这可确保在所有应用程序中都发生了单线程单元（STA）的清理，包括不经常进行抽取的应用程序。</span><span class="sxs-lookup"><span data-stu-id="d3881-171">This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</span></span> <span data-ttu-id="d3881-172">但是，某些进行了泵处理的应用程序对于发生泵处理的情况非常敏感。</span><span class="sxs-lookup"><span data-stu-id="d3881-172">However, some applications that do pump appropriately are very sensitive to where pumping occurs.</span></span> <span data-ttu-id="d3881-173">当互操作系统在这些应用程序中抽取消息时，在意外的位置，应用程序可能会遇到难以诊断的重入问题。</span><span class="sxs-lookup"><span data-stu-id="d3881-173">When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</span></span> <span data-ttu-id="d3881-174">因此，应用程序需要能够控制自己的特定 STA 泵并控制 Rcw 的清理。</span><span class="sxs-lookup"><span data-stu-id="d3881-174">Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</span></span>  
  
 <span data-ttu-id="d3881-175">但是，开发人员通常只控制其应用程序中的一小部分线程，因此不能确保所有线程都在适当的情况下进行泵。</span><span class="sxs-lookup"><span data-stu-id="d3881-175">However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</span></span>  
  
 <span data-ttu-id="d3881-176">若要解决此问题：</span><span class="sxs-lookup"><span data-stu-id="d3881-176">To solve this problem:</span></span>  
  
1.  <span data-ttu-id="d3881-177">使用 <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> 方法可在每个线程的基础上关闭对 Rcw 的自动清理以及发生的消息泵。</span><span class="sxs-lookup"><span data-stu-id="d3881-177">Use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</span></span> <span data-ttu-id="d3881-178">这使开发人员可以选择退出自动清理，并选择相应的消息泵。</span><span class="sxs-lookup"><span data-stu-id="d3881-178">This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</span></span>  
  
2.  <span data-ttu-id="d3881-179">使用 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> 方法通知运行时清理当前上下文中分配的所有 Rcw。</span><span class="sxs-lookup"><span data-stu-id="d3881-179">Use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> method to notify the runtime to clean up all RCWs that are allocated in the current context.</span></span> <span data-ttu-id="d3881-180">此伴生方法使开发人员能够精确控制运行时在当前上下文中执行清理的时间。</span><span class="sxs-lookup"><span data-stu-id="d3881-180">This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-181">将数据从托管数组复制到非托管内存指针，或从非托管内存指针复制到托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-181">Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : byte[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-182">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-182">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-183">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-183">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-184">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-184">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-185">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-185">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-186">将数据从一维托管 8 位无符号整数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-186">Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-187">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-187">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-188">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> 重载将一个数组复制到非托管内存，然后使用 <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 重载将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-188">The following example copies an array to unmanaged memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> overload, and then copies the unmanaged array back to managed memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-189"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-189"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-190"><paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-190"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : char[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-191">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-191">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-192">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-192">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-193">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-193">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-194">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-194">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-195">将数据从一维托管字符数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-195">Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-196">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-196">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-197">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-197">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-198"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-198"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-199"><paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-199"><paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : double[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-200">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-200">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-201">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-201">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-202">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-202">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-203">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-203">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-204">将数据从一维托管双精度浮点数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-204">Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-205">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-205">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-206">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-206">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-207"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-207"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-208"><paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-208"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int16[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-209">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-209">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-210">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-210">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-211">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-211">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-212">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-212">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-213">将数据从一维托管 16 位带符号整数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-213">Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-214">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-214">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-215">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-215">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-216"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-216"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-217"><paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-217"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-218">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-218">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-219">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-219">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-220">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-220">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-221">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-221">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-222">将数据从一维托管 32 位带符号整数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-222">Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-223">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-223">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-224">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-224">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-225"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-225"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-226"><paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-226"><paramref name="startIndex" /> or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : int64[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-227">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-227">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-228">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-228">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-229">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-229">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-230">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-230">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-231">将数据从一维托管 64 位带符号整数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-231">Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-232">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-232">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-233">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-233">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-234"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-234"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-235"><paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-235"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * byte[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-236">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-236">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-237">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-237">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-238">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-238">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-239">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-239">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-240">将数据从非托管内存指针复制到托管 8 位无符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-240">Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-241">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-241">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-242">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-242">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-243">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-243">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-244">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-244">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-245"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-245"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * char[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-246">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-246">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-247">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-247">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-248">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-248">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-249">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-249">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-250">将数据从非托管内存指针复制到托管字符数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-250">Copies data from an unmanaged memory pointer to a managed character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-251">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-251">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-252">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-252">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-253">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-253">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-254">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-254">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-255"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-255"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * double[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-256">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-256">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-257">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-257">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-258">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-258">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-259">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-259">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-260">将数据从非托管内存指针复制到托管双精度浮点数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-260">Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-261">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-261">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-262">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-262">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-263">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-263">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-264">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-264">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-265"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-265"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int16[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-266">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-266">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-267">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-267">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-268">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-268">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-269">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-269">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-270">将数据从非托管内存指针复制到托管 16 位带符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-270">Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-271">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-271">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-272">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-272">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-273">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-273">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-274">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-274">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-275"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-275"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-276">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-276">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-277">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-277">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-278">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-278">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-279">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-279">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-280">将数据从非托管内存指针复制到托管 32 位带符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-280">Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-281">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-281">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-282">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-282">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-283">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-283">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-284">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-284">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-285"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-285"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * int64[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-286">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-286">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-287">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-287">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-288">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-288">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-289">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-289">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-290">将数据从非托管内存指针复制到托管 64 位带符号整数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-290">Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-291">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-291">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-292">因此，与`source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-292">Thus, the unmanaged data corresponding to the`source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-293">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-293">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-294">下面的示例将一个数组复制到非托管内存，然后将非托管数组复制回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-294">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-295"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-295"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * nativeint[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.IntPtr[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-296">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-296">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-297">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-297">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-298">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-298">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-299">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-299">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-300">将数据从非托管的内存指针复制到托管的 <see cref="T:System.IntPtr" /> 数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-300">Copies data from an unmanaged memory pointer to a managed <see cref="T:System.IntPtr" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-301">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-301">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-302">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-302">Therefore, the unmanaged data that corresponds to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-303">在调用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> 方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-303">You must initialize the managed array with the appropriate size before calling the <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-304"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-304"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint * single[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, destination, startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-305">从中进行复制的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-305">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-306">要复制到的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-306">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-307">目标数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-307">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-308">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-308">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-309">将数据从非托管内存指针复制到托管单精度浮点数数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-309">Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-310">非托管、C 样式的数组不包含界限信息，这会阻止验证 `startIndex` 和 `length` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-310">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="d3881-311">因此，与 `source` 参数对应的非托管数据将填充托管数组，而不考虑其有用性。</span><span class="sxs-lookup"><span data-stu-id="d3881-311">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="d3881-312">在调用此方法之前，必须先用适当的大小初始化托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-312">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-313"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-313"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : nativeint[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-314">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-314">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-315">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-315">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-316">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-316">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-317">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-317">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-318">将数据从一维托管的 <see cref="T:System.IntPtr" /> 数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-318">Copies data from a one-dimensional, managed <see cref="T:System.IntPtr" /> array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-319">可以使用此方法将一维托管 <xref:System.IntPtr> 数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-319">You can use this method to copy a subset of a one-dimensional managed <xref:System.IntPtr> array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-320"><paramref name="source" />、<paramref name="destination" />、<paramref name="startIndex" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-320"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : single[] * int * nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Copy (source, startIndex, destination, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d3881-321">从中进行复制的一维数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-321">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="d3881-322">源数组中从零开始的索引，在此处开始复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-322">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="d3881-323">要复制到的内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-323">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="d3881-324">要复制的数组元素的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-324">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-325">将数据从一维托管单精度浮点数数组复制到非托管内存指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-325">Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-326">可以使用此方法将一维托管数组的子集复制到非托管 C 样式数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-326">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-327"><paramref name="startIndex" /> 和 <paramref name="length" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-327"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-328"><paramref name="source" />、<paramref name="startIndex" />、<paramref name="destination" /> 或 <paramref name="length" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-328"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member CreateAggregatedObject : nativeint * obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.CreateAggregatedObject (pOuter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("CreateAggregatedObject(IntPtr, Object) may be unavailable in future releases. Instead, use CreateAggregatedObject&lt;T&gt;(IntPtr, T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296518")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pOuter"><span data-ttu-id="d3881-329">外部 <see langword="IUnknown" /> 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-329">The outer <see langword="IUnknown" /> pointer.</span></span></param>
        <param name="o"><span data-ttu-id="d3881-330">要聚合的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-330">An object to aggregate.</span></span></param>
        <summary><span data-ttu-id="d3881-331">聚合托管对象和指定的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-331">Aggregates a managed object with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-332">托管对象的内部 <see langword="IUnknown" /> 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-332">The inner <see langword="IUnknown" /> pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-333"><xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> 方法使用指定的外部指针聚合托管对象的内部托管指针，然后返回托管对象的内部[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-333">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-334"><paramref name="o" /> 是一个 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-334"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberSignature Language="F#" Value="static member CreateAggregatedObject : nativeint * 'T -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.CreateAggregatedObject (pOuter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-335">要聚合的托管对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-335">The type of the managed object to aggregate.</span></span></typeparam>
        <param name="pOuter"><span data-ttu-id="d3881-336">外部 [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-336">The outer [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) pointer.</span></span></param>
        <param name="o"><span data-ttu-id="d3881-337">要集合的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-337">The managed object to aggregate.</span></span></param>
        <summary><span data-ttu-id="d3881-338">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-338">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-339">聚合指定类型的托管对象和指定的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-339">Aggregates a managed object of the specified type with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-340">托管对象的内部 <see href="https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-340">The inner <see href="https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-341"><xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> 方法使用指定的外部指针聚合指定类型的托管对象的内部托管指针，并返回托管对象的内部[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-341">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-342"><paramref name="o" /> 是一个 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-342"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member CreateWrapperOfType : obj * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.CreateWrapperOfType (o, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("CreateWrapperOfType(Object, Type) may be unavailable in future releases. Instead, use CreateWrapperOfType&lt;T,T2&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296519")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-343">要包装的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-343">The object to be wrapped.</span></span></param>
        <param name="t"><span data-ttu-id="d3881-344">要创建的包装器的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-344">The type of wrapper to create.</span></span></param>
        <summary><span data-ttu-id="d3881-345">在指定类型的对象中包装指定的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-345">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-346">新包装的对象，该对象是所需类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-346">The newly wrapped object that is an instance of the desired type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-347"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> 将一个 COM 类类型（通常为基 `__ComObject` 类型）转换为另一个 COM 类类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-347"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> converts one COM class type, typically the base `__ComObject` type, to another COM class type.</span></span> <span data-ttu-id="d3881-348">由参数 `o`表示的输入 COM 对象是一个[运行时可调用包装器（RCW）](~/docs/framework/interop/runtime-callable-wrapper.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-348">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper (RCW)](~/docs/framework/interop/runtime-callable-wrapper.md).</span></span>  
  
 <span data-ttu-id="d3881-349">`t` 和 `o` 参数都必须是其签名与 <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>属性特性相同的类。</span><span class="sxs-lookup"><span data-stu-id="d3881-349">Both the `t` and `o` parameters must be classes whose signatures are attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-350">当导入类型库时， [tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具会为您应用此特性。</span><span class="sxs-lookup"><span data-stu-id="d3881-350">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="d3881-351">如果在源代码中手动创建 RCW，则应将此特性应用于表示原始 coclass 的托管签名，以表示其 COM 来源。</span><span class="sxs-lookup"><span data-stu-id="d3881-351">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="d3881-352">Tlbimp.exe 导入 COM[组件类](https://docs.microsoft.com/previous-versions/windows/desktop/automat/coclass)作为托管类和接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-352">Tlbimp.exe imports a COM [coclass](https://docs.microsoft.com/previous-versions/windows/desktop/automat/coclass) as a managed class and an interface.</span></span> <span data-ttu-id="d3881-353">Coclass 接口具有与原始 coclass 相同的名称，并且托管类的原始 coclass 名称后面追加了 "Class"。</span><span class="sxs-lookup"><span data-stu-id="d3881-353">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="d3881-354">例如，名为的 coclass `MyCoclass` 成为称为 `MyCoclass` 的组件类接口和名为 `MyCoclassClass`的托管类。</span><span class="sxs-lookup"><span data-stu-id="d3881-354">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="d3881-355">由于 `t` 必须是类，而不是接口，因此请确保指定托管类（`MyCoclassClass`）而不是 coclass 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-355">Since `t` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the coclass interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-356">您将丢失输入 COM 对象的标识，因为新的 RCW 实例包装了由原始 RCW 公开的[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-356">You lose the identity of the input COM object because a new RCW instance wraps the [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-357"><paramref name="t" /> 必须派生自 <see langword="__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-357"><paramref name="t" /> must derive from <see langword="__ComObject" />.</span></span>  
  
<span data-ttu-id="d3881-358">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-358">-or-</span></span> 
 <span data-ttu-id="d3881-359"><paramref name="t" /> 是 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-359"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-360">
          <paramref name="t" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-360">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-361"><paramref name="o" /> 不支持所有必需的接口，因此无法转换为目标类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-361"><paramref name="o" /> cannot be converted to the destination type because it does not support all required interfaces.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberSignature Language="F#" Value="static member CreateWrapperOfType : 'T -&gt; 'Wrapper" Usage="System.Runtime.InteropServices.Marshal.CreateWrapperOfType o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-362">要包装的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-362">The type of object to wrap.</span></span></typeparam>
        <typeparam name="TWrapper"><span data-ttu-id="d3881-363">要返回的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-363">The type of object to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="d3881-364">要包装的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-364">The object to be wrapped.</span></span></param>
        <summary><span data-ttu-id="d3881-365">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-365">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-366">在指定类型的对象中包装指定的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-366">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-367">新包装的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-367">The newly wrapped object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-368"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> 将 `T` 类型的 COM 对象转换为 `TWrapper` COM 类类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-368"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> converts a COM object of type `T` to the `TWrapper` COM class type.</span></span> <span data-ttu-id="d3881-369">由参数 `o`表示的输入 COM 对象是一个[运行时可调用包装器（RCW）](~/docs/framework/interop/runtime-callable-wrapper.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-369">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper (RCW)](~/docs/framework/interop/runtime-callable-wrapper.md).</span></span>  
  
 <span data-ttu-id="d3881-370">`T` 泛型类型参数和 `o` 参数都必须为其签名与 <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> 属性特性相同的类。</span><span class="sxs-lookup"><span data-stu-id="d3881-370">Both the `T` generic type parameter and the `o` parameter must be classes whose signatures are attributed with the <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="d3881-371">当导入类型库时， [tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具会为您应用此特性。</span><span class="sxs-lookup"><span data-stu-id="d3881-371">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="d3881-372">如果在源代码中手动创建 RCW，则应将此特性应用于表示原始 coclass 的托管签名，以表示其 COM 来源。</span><span class="sxs-lookup"><span data-stu-id="d3881-372">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="d3881-373">Tlbimp.exe 导入 COM[组件类](https://docs.microsoft.com/previous-versions/windows/desktop/automat/coclass)作为托管类和接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-373">Tlbimp.exe imports a COM [coclass](https://docs.microsoft.com/previous-versions/windows/desktop/automat/coclass) as a managed class and an interface.</span></span> <span data-ttu-id="d3881-374">Coclass 接口具有与原始 coclass 相同的名称，并且托管类的原始 coclass 名称后面追加了 "Class"。</span><span class="sxs-lookup"><span data-stu-id="d3881-374">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="d3881-375">例如，名为的 coclass `MyCoclass` 成为称为 `MyCoclass` 的组件类接口和名为 `MyCoclassClass`的托管类。</span><span class="sxs-lookup"><span data-stu-id="d3881-375">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="d3881-376">由于`T` 必须是类，而不是接口，因此请确保指定托管类（`MyCoclassClass`）而不是 `coclass` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-376">Because`T` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the `coclass` interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-377">你丢失了输入 COM 对象的标识，因为新的 RCW 实例包装了由原始 RCW 公开的[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-377">You lose the identity of the input COM object, because a new RCW instance wraps the [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-378"><typeparamref name="T" /> 必须派生自 <see langword="__ComObject" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-378"><typeparamref name="T" /> must derive from <see langword="__ComObject" />.</span></span>  
  
<span data-ttu-id="d3881-379">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-379">-or-</span></span> 
 <span data-ttu-id="d3881-380"><typeparamref name="T" /> 是 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-380"><typeparamref name="T" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-381"><paramref name="o" /> 无法转换为 <paramref name="TWrapper" />，因为它不支持所有需要的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-381"><paramref name="o" /> cannot be converted to the <paramref name="TWrapper" /> because it does not support all required interfaces.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberSignature Language="F#" Value="static member DestroyStructure : nativeint * Type -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.DestroyStructure (ptr, structuretype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("DestroyStructure(IntPtr, Type) may be unavailable in future releases. Instead, use DestroyStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296520")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-382">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-382">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structuretype"><span data-ttu-id="d3881-383">格式化类的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-383">Type of a formatted class.</span></span> <span data-ttu-id="d3881-384">该类型提供删除 <paramref name="ptr" /> 参数指向的缓冲区时必需的布局信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-384">This provides the layout information necessary to delete the buffer in the <paramref name="ptr" /> parameter.</span></span></param>
        <summary><span data-ttu-id="d3881-385">释放指定的非托管内存块所指向的所有子结构。</span><span class="sxs-lookup"><span data-stu-id="d3881-385">Frees all substructures that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-386">您可以使用此方法来释放非托管结构的引用类型字段，如字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-386">You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="d3881-387">与字段不同，结构可以是值类型或引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-387">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="d3881-388">值类型的结构，其中包含值类型字段（所有这些都是可直接复制的）都没有必须释放其内存的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-388">Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="d3881-389"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> 方法使用此方法来防止重用结构占用的内存时的内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="d3881-389">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="d3881-390"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 调用 COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkId=148633)函数，该函数反过来会释放已分配的字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-390"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 <span data-ttu-id="d3881-391">除了 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>之外，<xref:System.Runtime.InteropServices.Marshal> 类还提供两个其他的内存释放方法： <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> 和 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-391">In addition to <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-392"><paramref name="structureType" /> 具有自动布局。</span><span class="sxs-lookup"><span data-stu-id="d3881-392"><paramref name="structureType" /> has an automatic layout.</span></span> <span data-ttu-id="d3881-393">但请该用连续或显式布局。</span><span class="sxs-lookup"><span data-stu-id="d3881-393">Use sequential or explicit instead.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
        <related type="Article" href="~/docs/framework/interop/blittable-and-non-blittable-types.md"><span data-ttu-id="d3881-394">可直接复制和非直接复制到本机类型</span><span class="sxs-lookup"><span data-stu-id="d3881-394">Blittable and Non-Blittable types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member DestroyStructure : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.DestroyStructure ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-395">格式化结构的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-395">The type of the formatted structure.</span></span> <span data-ttu-id="d3881-396">该类型提供删除 <paramref name="ptr" /> 参数指向的缓冲区时必需的布局信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-396">This provides the layout information necessary to delete the buffer in the <paramref name="ptr" /> parameter.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="d3881-397">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-397">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="d3881-398">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-398">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-399">释放指定的非托管内存块所指向的所有指定类型的子结构。</span><span class="sxs-lookup"><span data-stu-id="d3881-399">Frees all substructures of a specified type that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-400">您可以使用此方法来释放非托管结构的引用类型字段（如字符串）。</span><span class="sxs-lookup"><span data-stu-id="d3881-400">You can use this method to free reference type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="d3881-401">与字段不同，结构可以是值类型或引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-401">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="d3881-402">包含值类型字段（所有通过直接复制）的值类型结构没有必须释放其内存的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-402">Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="d3881-403"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> 方法使用此方法来防止重用结构占用的内存时的内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="d3881-403">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="d3881-404"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 调用 COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkId=148633)函数，该函数反过来会释放已分配的字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-404"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-405"><typeparamref name="T" /> 具有自动布局。</span><span class="sxs-lookup"><span data-stu-id="d3881-405"><typeparamref name="T" /> has an automatic layout.</span></span> <span data-ttu-id="d3881-406">但请该用连续或显式布局。</span><span class="sxs-lookup"><span data-stu-id="d3881-406">Use sequential or explicit instead.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member FinalReleaseComObject : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.FinalReleaseComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-407">要释放的 RCW。</span><span class="sxs-lookup"><span data-stu-id="d3881-407">The RCW to be released.</span></span></param>
        <summary><span data-ttu-id="d3881-408">通过将<see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">运行时可调用包装器 (RCW)</see> 的引用计数设置为 0，释放对它的所有引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-408">Releases all references to a <see href="https://docs.microsoft.com/dotnet/framework/interop/runtime-callable-wrapper">Runtime Callable Wrapper (RCW)</see> by setting its reference count to 0.</span></span></summary>
        <returns><span data-ttu-id="d3881-409">与 <paramref name="o" /> 参数关联的 RCW 的新引用计数值，如果释放成功，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="d3881-409">The new value of the reference count of the RCW associated with the <paramref name="o" /> parameter, which is 0 (zero) if the release is successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-410"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 方法释放对 COM 对象的托管引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-410">The <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method releases the managed reference to a COM object.</span></span> <span data-ttu-id="d3881-411">调用此方法等效于在循环中调用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法，直到该方法返回0（零）。</span><span class="sxs-lookup"><span data-stu-id="d3881-411">Calling this method is equivalent to calling the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="d3881-412">当 COM 对象的引用计数变为0时，通常会释放 COM 对象，尽管这依赖于 COM 对象的实现，但超出了运行时的控制范围。</span><span class="sxs-lookup"><span data-stu-id="d3881-412">When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</span></span> <span data-ttu-id="d3881-413">但是，RCW 仍可存在，并等待垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="d3881-413">However, the RCW can still exist, waiting to be garbage-collected.</span></span>  
  
 <span data-ttu-id="d3881-414">在将 COM 对象与其基础 RCW 分离后，不能使用它。</span><span class="sxs-lookup"><span data-stu-id="d3881-414">The COM object cannot be used after it has been separated from its underlying RCW.</span></span> <span data-ttu-id="d3881-415">如果尝试在 RCW 的引用计数变为0后调用该方法，将会引发 <xref:System.Runtime.InteropServices.InvalidComObjectException>。</span><span class="sxs-lookup"><span data-stu-id="d3881-415">If you try to call a method on the RCW after its reference count becomes 0, a <xref:System.Runtime.InteropServices.InvalidComObjectException> will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-416"><paramref name="o" /> 不是有效的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-416"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-417"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-417"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member FreeBSTR : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeBSTR ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-418">要释放的 BSTR 的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-418">The address of the BSTR to be freed.</span></span></param>
        <summary><span data-ttu-id="d3881-419">使用 COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkID=148633) 函数释放 <see langword="BSTR" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-419">Frees a <see langword="BSTR" /> using the COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkID=148633) function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-420">与 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>一样，你可以使用此方法来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-420">Like <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, you can use this method to deallocate memory.</span></span> <span data-ttu-id="d3881-421"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> 调用 COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkID=148633)函数，该函数释放由以下任何非托管方法分配的内存： `SysAllocString`、`SysAllocStringByteLen`、`SysAllocStringLen`、`SysReAllocString`、`SysReAllocStringLen`。</span><span class="sxs-lookup"><span data-stu-id="d3881-421"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> calls the COM [SysFreeString](https://go.microsoft.com/fwlink/?LinkID=148633) function, which frees memory allocated by any of the following unmanaged methods: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span></span> <span data-ttu-id="d3881-422">您可以通过平台调用调用非托管方法，例如它们。</span><span class="sxs-lookup"><span data-stu-id="d3881-422">You can call unmanaged methods such as these with platform invoke.</span></span> <span data-ttu-id="d3881-423">有关详细信息，请参阅[使用非托管 DLL 函数](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-423">For details, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member FreeCoTaskMem : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeCoTaskMem ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-424">要释放的内存的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-424">The address of the memory to be freed.</span></span></param>
        <summary><span data-ttu-id="d3881-425">释放由非托管 COM 任务内存分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-425">Frees a block of memory allocated by the unmanaged COM task memory allocator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-426">您可以使用 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> 释放由 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>、<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>或任何等效的非托管方法分配的任何内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-426">You can use <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> to free any memory allocated by <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, or any equivalent unmanaged method.</span></span> <span data-ttu-id="d3881-427">如果 `ptr` 参数 `null`，则此方法不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="d3881-427">If the `ptr` parameter is `null`, the method does nothing.</span></span>  
  
 <span data-ttu-id="d3881-428"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> 公开 COM [CoTaskMemFree](https://go.microsoft.com/fwlink/?LinkId=148638)函数，该函数将释放所有字节，使你无法再使用 `ptr` 参数指向的内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-428"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> exposes the COM [CoTaskMemFree](https://go.microsoft.com/fwlink/?LinkId=148638) function, which frees all bytes so that you can no longer use the memory that the `ptr` parameter points to.</span></span>  
  
 <span data-ttu-id="d3881-429">除了 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>之外，<xref:System.Runtime.InteropServices.Marshal> 类还提供两个其他的内存释放方法： <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 和 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-429">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberSignature Language="F#" Value="static member FreeHGlobal : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.FreeHGlobal hglobal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal"><span data-ttu-id="d3881-430">由对 <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> 的原始匹配调用返回的句柄。</span><span class="sxs-lookup"><span data-stu-id="d3881-430">The handle returned by the original matching call to <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <summary><span data-ttu-id="d3881-431">释放以前从进程的非托管内存中分配的内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-431">Frees memory previously allocated from the unmanaged memory of the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-432">您可以使用 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 从 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>、<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>或任何等效的非托管 API 方法分配的全局堆中释放任何内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-432">You can use <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> to free any memory from the global heap allocated by <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, or any equivalent unmanaged API method.</span></span> <span data-ttu-id="d3881-433">如果 `hglobal` 参数 <xref:System.IntPtr.Zero?displayProperty=nameWithType> 则此方法不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="d3881-433">If the `hglobal` parameter is <xref:System.IntPtr.Zero?displayProperty=nameWithType> the method does nothing.</span></span>  
  
 <span data-ttu-id="d3881-434"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 公开 Kernel32.dll 中的[LocalFree](https://go.microsoft.com/fwlink/?LinkId=148640)函数，该函数可释放所有字节，因此你不能再使用 `hglobal`指向的内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-434"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> exposes the [LocalFree](https://go.microsoft.com/fwlink/?LinkId=148640) function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by `hglobal`.</span></span>  
  
 <span data-ttu-id="d3881-435">除了 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>之外，<xref:System.Runtime.InteropServices.Marshal> 类还提供两个其他的内存释放 API 方法： <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 和 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-435">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation API methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-436">下面的示例演示如何调用 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-436">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method.</span></span> <span data-ttu-id="d3881-437">此代码示例是为 <xref:System.Runtime.InteropServices.Marshal> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3881-437">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 <span data-ttu-id="d3881-438">下面的示例演示如何将托管 <xref:System.String> 类的内容转换为非托管内存，并在完成后释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-438">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateGuidForType (type As Type) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GenerateGuidForType : Type -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GenerateGuidForType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="d3881-439">要为其生成 GUID 的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-439">The type to generate a GUID for.</span></span></param>
        <summary><span data-ttu-id="d3881-440">返回指定类型的全局唯一标识符 (GUID)，或使用类型库导出程序 (Tlbexp.exe) 所用的算法生成 GUID。</span><span class="sxs-lookup"><span data-stu-id="d3881-440">Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</span></span></summary>
        <returns><span data-ttu-id="d3881-441">指定类型的标识符。</span><span class="sxs-lookup"><span data-stu-id="d3881-441">An identifier for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-442">如果该类型在元数据中具有 GUID，则返回该类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-442">If the type has a GUID in the metadata, it is returned.</span></span> <span data-ttu-id="d3881-443">否则，会自动生成 GUID。</span><span class="sxs-lookup"><span data-stu-id="d3881-443">Otherwise, a GUID is automatically generated.</span></span> <span data-ttu-id="d3881-444">您可以使用此方法以编程方式确定任何托管类型（包括 COM 不可见的类型）的 COM GUID。</span><span class="sxs-lookup"><span data-stu-id="d3881-444">You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</span></span> <span data-ttu-id="d3881-445">类接口是唯一的异常，因为它们与托管类型不对应。</span><span class="sxs-lookup"><span data-stu-id="d3881-445">Class interfaces are the only exception because they do not correspond to a managed type.</span></span> <span data-ttu-id="d3881-446"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> 提供与 <xref:System.Type.GUID%2A?displayProperty=nameWithType> 属性相同的功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-446"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> provides the same functionality as the <xref:System.Type.GUID%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateProgIdForType (type As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GenerateProgIdForType : Type -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GenerateProgIdForType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="d3881-447">要获取其 ProgID 的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-447">The type to get a ProgID for.</span></span></param>
        <summary><span data-ttu-id="d3881-448">返回指定类型的编程标识符 (ProgID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-448">Returns a programmatic identifier (ProgID) for the specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-449">指定类型的 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d3881-449">The ProgID of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-450">如果该类型在元数据中具有 ProgID，则返回该 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d3881-450">If the type has a ProgID in the metadata, that ProgID is returned.</span></span> <span data-ttu-id="d3881-451">否则，将基于该类型的完全限定名生成 ProgID。</span><span class="sxs-lookup"><span data-stu-id="d3881-451">Otherwise, a ProgID is generated based on the fully qualified name of the type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-452"><paramref name="type" /> 参数不是由 COM 创建的类。</span><span class="sxs-lookup"><span data-stu-id="d3881-452">The <paramref name="type" /> parameter is not a class that can be create by COM.</span></span> <span data-ttu-id="d3881-453">该类必须是公共的，必须具有公共的无参数构造函数，而且必须是 COM 可见的。</span><span class="sxs-lookup"><span data-stu-id="d3881-453">The class must be public, have a public parameterless constructor, and be COM visible.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-454">
          <paramref name="type" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-454">The <paramref name="type" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetActiveObject : string -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetActiveObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="d3881-455">所请求的对象的编程标识符 (ProgID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-455">The programmatic identifier (ProgID) of the object that was requested.</span></span></param>
        <summary><span data-ttu-id="d3881-456">从运行对象表 (ROT) 获取指定对象的运行实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-456">Obtains a running instance of the specified object from the running object table (ROT).</span></span></summary>
        <returns><span data-ttu-id="d3881-457">所请求的对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-457">The object that was requested; otherwise <see langword="null" />.</span></span> <span data-ttu-id="d3881-458">可将此对象转换为它支持的任何 COM 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-458">You can cast this object to any COM interface that it supports.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-459"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>公开 OLEAUT32.DLL 中的 COM [GetActiveObject](/windows/win32/api/oleauto/nf-oleauto-getactiveobject)函数。 .DLL但是, 后者需要类标识符 (CLSID), 而不是此方法所需`ProgID`的编程标识符 ()。</span><span class="sxs-lookup"><span data-stu-id="d3881-459"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> exposes the COM [GetActiveObject](/windows/win32/api/oleauto/nf-oleauto-getactiveobject) function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (`ProgID`) expected by this method.</span></span> <span data-ttu-id="d3881-460">若要获取未注册 `ProgID`的 COM 对象的运行实例，请使用平台调用来定义 COM [GetActiveObject](/windows/win32/api/oleauto/nf-oleauto-getactiveobject)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-460">To obtain a running instance of a COM object without a registered `ProgID`, use platform invoke to define the COM [GetActiveObject](/windows/win32/api/oleauto/nf-oleauto-getactiveobject) function.</span></span> <span data-ttu-id="d3881-461">有关平台调用的说明，请参阅[使用非托管 DLL 函数](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-461">For a description of platform invoke, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
## <a name="progid-and-clsid"></a><span data-ttu-id="d3881-462">ProgID 和 CLSID</span><span class="sxs-lookup"><span data-stu-id="d3881-462">ProgID and CLSID</span></span>  
 <span data-ttu-id="d3881-463">注册表的 HKEY_CLASSES_ROOT 子树中的键包含多种子项类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-463">Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</span></span> <span data-ttu-id="d3881-464">大多数子项均为 Progid，这会将用户友好的字符串映射到 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d3881-464">Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</span></span> <span data-ttu-id="d3881-465">应用程序通常使用这些可读取的字符串而不是数字 Clsid。</span><span class="sxs-lookup"><span data-stu-id="d3881-465">Applications often use these human-readable strings instead of the numeric CLSIDs.</span></span> <span data-ttu-id="d3881-466">通常，组件具有独立于版本的 ProgID，该 ProgID 映射到系统上安装的最新版本的组件。</span><span class="sxs-lookup"><span data-stu-id="d3881-466">Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</span></span>  
  
 <span data-ttu-id="d3881-467">应用程序和组件主要使用 Progid 检索其相应的 Clsid。</span><span class="sxs-lookup"><span data-stu-id="d3881-467">Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-468">以下示例在配置了运行 Microsoft Word 实例的计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="d3881-468">The following example was run on a computer that was configured with a running instance of Microsoft Word.</span></span> <span data-ttu-id="d3881-469">Microsoft Excel 没有运行的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-469">There were no instances of Microsoft Excel running.</span></span>  
  
 <span data-ttu-id="d3881-470">该示例调用两次 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-470">The example calls <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> twice.</span></span> <span data-ttu-id="d3881-471">第一次调用尝试检索对 Microsoft Word （`Word.Application` 对象的实例）的实例的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-471">The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the `Word.Application` object).</span></span> <span data-ttu-id="d3881-472">第二次调用尝试检索对 Microsoft Excel （`Excel.Application` 对象的实例）的实例的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-472">The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an `Excel.Application` object).</span></span>  
  
 <span data-ttu-id="d3881-473">此代码成功检索对 Microsoft Word 实例的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-473">The code retrieves a reference to an instance of Microsoft Word successfully.</span></span> <span data-ttu-id="d3881-474">但是，由于 Microsoft Excel 未运行，尝试检索第二个对象会引发 <xref:System.Runtime.InteropServices.COMException>。</span><span class="sxs-lookup"><span data-stu-id="d3881-474">However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <xref:System.Runtime.InteropServices.COMException>.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="d3881-475">找不到该对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-475">The object was not found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-476">返回一个接口指针，该接口指针表示对象的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-476">Returns an interface pointer that represents an interface for an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : obj * Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject (o, T)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("GetComInterfaceForObject(Object, Type) may be unavailable in future releases. Instead, use GetComInterfaceForObject&lt;T,T2&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296509")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-477">提供接口的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-477">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="d3881-478">所请求接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-478">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-479">返回一个指向 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口的指针，该指针表示指定对象上的指定接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-479">Returns a pointer to an <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="d3881-480">默认情况下，启用自定义查询接口访问。</span><span class="sxs-lookup"><span data-stu-id="d3881-480">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="d3881-481">表示对象的指定接口的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-481">The interface pointer that represents the specified interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-482">此方法返回一个接口指针，该指针表示指定对象上所请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-482">This method returns an interface pointer that represents the requested interface on the specified object.</span></span> <span data-ttu-id="d3881-483">如果你的非托管方法需要传递接口指针，则此方法特别有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-483">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="d3881-484">使用此方法调用对象会使引用计数在返回指针之前在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-484">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-485">使用指针完成后，始终使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-485">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="d3881-486">使用原始 COM 接口指针时，必须遵守 COM 定义的规则。</span><span class="sxs-lookup"><span data-stu-id="d3881-486">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="d3881-487"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 在调用以 <xref:System.IntPtr> 类型公开 COM 对象参数或使用自定义封送处理的方法时非常有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-487"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="d3881-488">虽然不太常见，但你可以对托管对象使用此方法，以获取指向对象的 COM 可调用包装器的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-488">Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</span></span> <span data-ttu-id="d3881-489">例如，可以对导出到 COM 的托管对象使用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>，以获取 <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-489">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-490">无法获取指向类接口的指针，因为类接口缺少相应类型要传递给第二个参数（`t`）。</span><span class="sxs-lookup"><span data-stu-id="d3881-490">You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (`t`).</span></span> <span data-ttu-id="d3881-491">请改用 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> 调用 COM 可调用包装（通常为自动调度类接口）的默认接口上的成员。</span><span class="sxs-lookup"><span data-stu-id="d3881-491">Instead, use <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</span></span>  
  
 <span data-ttu-id="d3881-492">默认情况下，<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 方法重载允许自定义查询接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-492">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="d3881-493">若要指定是否应用查询接口自定义项，请使用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="d3881-493">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="d3881-494">有关其他信息，请参阅[COM 可调用包装](~/docs/framework/interop/com-callable-wrapper.md)器和[运行时可调用包装](~/docs/framework/interop/runtime-callable-wrapper.md)器。</span><span class="sxs-lookup"><span data-stu-id="d3881-494">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) and [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) articles.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-495"><typeparamref name="T" /> 参数不是接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-495">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
<span data-ttu-id="d3881-496">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-496">-or-</span></span> 
<span data-ttu-id="d3881-497">该类型对 COM 不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-497">The type is not visible to COM.</span></span>  
  
<span data-ttu-id="d3881-498">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-498">-or-</span></span> 
<span data-ttu-id="d3881-499"><typeparamref name="T" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-499">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-500"><paramref name="o" /> 参数不支持请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-500">The <paramref name="o" /> parameter does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-501">
          <paramref name="o" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-501">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-502">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-502">-or-</span></span> 
<span data-ttu-id="d3881-503">
          <typeparamref name="T" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-503">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : obj * Type * System.Runtime.InteropServices.CustomQueryInterfaceMode -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject (o, T, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;dotnet-uwp-10.0">
          <AttributeName>System.Obsolete("GetComInterfaceForObject(Object, Type, CustomQueryInterfaceMode) and support for ICustomQueryInterface may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="T" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-504">提供接口的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-504">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="d3881-505">所请求接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-505">The type of interface that is requested.</span></span></param>
        <param name="mode"><span data-ttu-id="d3881-506">枚举值之一，用于指示是否要应用 <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /> 提供的 <see langword="IUnknown::QueryInterface" /> 自定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-506">One of the enumeration values that indicates whether to apply an <see langword="IUnknown::QueryInterface" /> customization that is supplied by an <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span></span></param>
        <summary><span data-ttu-id="d3881-507">返回一个指向 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口的指针，该指针表示指定对象上的指定接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-507">Returns a pointer to an <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="d3881-508">自定义查询接口访问由指定的自定义模式控制。</span><span class="sxs-lookup"><span data-stu-id="d3881-508">Custom query interface access is controlled by the specified customization mode.</span></span></summary>
        <returns><span data-ttu-id="d3881-509">表示对象的接口的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-509">The interface pointer that represents the interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-510"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 允许您指定是否应用查询接口自定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-510"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> lets you specify whether to apply query interface customization.</span></span> <span data-ttu-id="d3881-511">默认情况下，使用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 重载应用查询接口自定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-511">Use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> overload to apply query interface customization by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-512"><typeparamref name="T" /> 参数不是接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-512">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
<span data-ttu-id="d3881-513">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-513">-or-</span></span> 
<span data-ttu-id="d3881-514">该类型对 COM 不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-514">The type is not visible to COM.</span></span>  
  
<span data-ttu-id="d3881-515">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-515">-or-</span></span> 
<span data-ttu-id="d3881-516"><typeparamref name="T" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-516">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-517">对象 <paramref name="o" /> 不支持请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-517">The object <paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-518">
          <paramref name="o" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-518">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-519">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-519">-or-</span></span> 
<span data-ttu-id="d3881-520">
          <typeparamref name="T" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-520">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObject : 'T -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-521"><paramref name="o" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-521">The type of <paramref name="o" />.</span></span></typeparam>
        <typeparam name="TInterface"><span data-ttu-id="d3881-522">要返回的接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-522">The type of interface to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="d3881-523">提供接口的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-523">The object that provides the interface.</span></span></param>
        <summary><span data-ttu-id="d3881-524">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-524">[Supported in the .NET Framework 4.5.1 and later versions]</span></span> 
<span data-ttu-id="d3881-525">返回一个指向 [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) 接口的指针，该指针表示指定类型的对象上的指定接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-525">Returns a pointer to an [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface that represents the specified interface on an object of the specified type.</span></span> <span data-ttu-id="d3881-526">默认情况下，启用自定义查询接口访问。</span><span class="sxs-lookup"><span data-stu-id="d3881-526">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="d3881-527">表示 <paramref name="TInterface" /> 接口的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-527">The interface pointer that represents the <paramref name="TInterface" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-528">此方法返回一个接口指针，该指针表示指定对象上的 `TInterface` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-528">This method returns an interface pointer that represents the `TInterface` interface on the specified object.</span></span> <span data-ttu-id="d3881-529">如果你的非托管方法需要传递接口指针，则此方法特别有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-529">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="d3881-530">使用此方法调用对象会使引用计数在返回指针之前在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-530">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-531">使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 方法时，请始终使用方法来递减指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-531">Always use the <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> method to decrement the reference count when you have finished with the pointer.</span></span> <span data-ttu-id="d3881-532">使用原始 COM 接口指针时，必须遵守 COM 定义的规则。</span><span class="sxs-lookup"><span data-stu-id="d3881-532">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="d3881-533"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> 在调用以 <xref:System.IntPtr> 类型公开 COM 对象参数或使用自定义封送处理的方法时非常有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-533"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="d3881-534">你还可以对托管对象使用此方法，以获取指向对象的 COM 可调用包装的指针，但这种情况不太常见。</span><span class="sxs-lookup"><span data-stu-id="d3881-534">You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</span></span> <span data-ttu-id="d3881-535">例如，可以对导出到 COM 的托管对象使用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>，以获取 <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-535">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-536">默认情况下，<xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> 方法重载允许自定义查询接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-536">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="d3881-537">若要指定是否应用查询接口自定义项，请使用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="d3881-537">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="d3881-538">有关其他信息，请参阅[COM 可调用包装](~/docs/framework/interop/com-callable-wrapper.md)器和[运行时可调用包装](~/docs/framework/interop/runtime-callable-wrapper.md)器。</span><span class="sxs-lookup"><span data-stu-id="d3881-538">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) and [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) articles.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-539"><paramref name="TInterface" /> 参数不是接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-539">The <paramref name="TInterface" /> parameter is not an interface.</span></span>  
  
<span data-ttu-id="d3881-540">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-540">-or-</span></span> 
<span data-ttu-id="d3881-541">该类型对 COM 不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-541">The type is not visible to COM.</span></span>  
  
<span data-ttu-id="d3881-542">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-542">-or-</span></span> 
<span data-ttu-id="d3881-543"><typeparamref name="T" /> 参数是开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-543">The <typeparamref name="T" /> parameter is an open generic type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-544"><paramref name="o" /> 参数不支持 <paramref name="TInterface" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-544">The <paramref name="o" /> parameter does not support the <paramref name="TInterface" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-545">
          <paramref name="o" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-545">The <paramref name="o" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetComInterfaceForObjectInContext : obj * Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext (o, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-546">提供接口的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-546">The object that provides the interface.</span></span></param>
        <param name="t"><span data-ttu-id="d3881-547">所请求接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-547">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-548">返回一个接口指针，该指针表示对象的指定接口（如果调用方与对象在同一上下文中）。</span><span class="sxs-lookup"><span data-stu-id="d3881-548">Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="d3881-549">由 <paramref name="t" /> 指定的接口指针，用于表示指定对象的接口，或如果调用方与对象不在同一上下文中，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-549">The interface pointer specified by <paramref name="t" /> that represents the interface for the specified object, or <see langword="null" /> if the caller is not in the same context as the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-550">此方法与 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> 相同，不同之处在于，如果调用方与对象不在同一上下文中，它将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="d3881-550">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span> <span data-ttu-id="d3881-551">如果你的非托管方法需要传递接口指针，则此方法特别有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-551">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-552"><paramref name="t" /> 不是接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-552"><paramref name="t" /> is not an interface.</span></span>  
  
<span data-ttu-id="d3881-553">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-553">-or-</span></span> 
<span data-ttu-id="d3881-554">该类型对 COM 不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-554">The type is not visible to COM.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-555"><paramref name="o" /> 不支持请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-555"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-556"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-556"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-557">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-557">-or-</span></span> 
 <span data-ttu-id="d3881-558"><paramref name="t" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-558"><paramref name="t" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="static member GetComObjectData : obj * obj -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetComObjectData (obj, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="key" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d3881-559">包含所需数据的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-559">The COM object that contains the data that you want.</span></span></param>
        <param name="key"><span data-ttu-id="d3881-560">要从中检索数据的 <paramref name="obj" /> 的内部哈希表中的键。</span><span class="sxs-lookup"><span data-stu-id="d3881-560">The key in the internal hash table of <paramref name="obj" /> to retrieve the data from.</span></span></param>
        <summary><span data-ttu-id="d3881-561">从指定的 COM 对象检索指定键所引用的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-561">Retrieves data that is referenced by the specified key from the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-562"><paramref name="obj" /> 参数的内部哈希表中 <paramref name="key" /> 参数所表示的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-562">The data represented by the <paramref name="key" /> parameter in the internal hash table of the <paramref name="obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-563">包装在[运行时可调用包装](~/docs/framework/interop/runtime-callable-wrapper.md)中的所有 COM 对象都有一个关联的哈希表，该哈希表 <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> 检索。</span><span class="sxs-lookup"><span data-stu-id="d3881-563">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) have an associated hash table, which <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> retrieves.</span></span> <span data-ttu-id="d3881-564"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> 将数据添加到哈希表中。</span><span class="sxs-lookup"><span data-stu-id="d3881-564"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> adds data to the hash table.</span></span> <span data-ttu-id="d3881-565">决不要从代码中调用这两种方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-565">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-566"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-566"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-567">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-567">-or-</span></span> 
 <span data-ttu-id="d3881-568"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-568"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-569"><paramref name="obj" /> 不是 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-569"><paramref name="obj" /> is not a COM object.</span></span>  
  
<span data-ttu-id="d3881-570">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-570">-or-</span></span> 
 <span data-ttu-id="d3881-571"><paramref name="obj" /> 是一个 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-571"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member GetComSlotForMethodInfo : System.Reflection.MemberInfo -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="d3881-572">表示接口方法的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-572">An object that represents an interface method.</span></span></param>
        <summary><span data-ttu-id="d3881-573">检索指定的 <see cref="T:System.Reflection.MemberInfo" /> 类型向 COM 公开时该类型的虚拟功能表（v 表或 VTBL）槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-573">Retrieves the virtual function table (v-table or VTBL) slot for a specified <see cref="T:System.Reflection.MemberInfo" /> type when that type is exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="d3881-574">向 COM 公开时的 VTBL 槽 <paramref name="m" /> 标识符。</span><span class="sxs-lookup"><span data-stu-id="d3881-574">The VTBL slot <paramref name="m" /> identifier when it is exposed to COM.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-575">此方法返回的从零开始的插槽号，适用于三个[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)和四个[IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch)方法，使第一个可用槽的值为3或7。</span><span class="sxs-lookup"><span data-stu-id="d3881-575">The zero-based slot number returned by this method accounts for three [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) and possibly four [IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="d3881-576"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-576"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-577">您可以使用此方法来检索接口的成员的槽编号，这些接口在 COM 和专用接口的成员中不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-577">You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</span></span> <span data-ttu-id="d3881-578">返回的槽编号对应于在向 COM 公开类型时将保留的 v 表号。</span><span class="sxs-lookup"><span data-stu-id="d3881-578">The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</span></span> <span data-ttu-id="d3881-579">COM 不可见成员实际上在公开的 v 表中占据了槽，即使 COM 客户端无法使用该槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-579">COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</span></span> <span data-ttu-id="d3881-580">不能通过从类传递 <xref:System.Reflection.MemberInfo> 来使用类接口上的 <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-580">You cannot use <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> on a class interface by passing <xref:System.Reflection.MemberInfo> from a class.</span></span> <span data-ttu-id="d3881-581">有关其他信息，请参阅[类接口简介](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface)。</span><span class="sxs-lookup"><span data-stu-id="d3881-581">For additional information, see [Introducing the class interface](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-582">
          <paramref name="m" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-582">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-583"><paramref name="m" /> 参数不是 <see cref="T:System.Reflection.MemberInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-583">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MemberInfo" /> object.</span></span>  
  
<span data-ttu-id="d3881-584">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-584">-or-</span></span> 
<span data-ttu-id="d3881-585"><paramref name="m" /> 参数不是接口方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-585">The <paramref name="m" /> parameter is not an interface method.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetDelegateForFunctionPointer : nativeint * Type -&gt; Delegate" Usage="System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer (ptr, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("GetDelegateForFunctionPointer(IntPtr, Type) may be unavailable in future releases. Instead, use GetDelegateForFunctionPointer&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296521")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-586">要转换的非托管函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-586">The unmanaged function pointer to be converted.</span></span></param>
        <param name="t"><span data-ttu-id="d3881-587">要返回的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-587">The type of the delegate to be returned.</span></span></param>
        <summary><span data-ttu-id="d3881-588">将非托管函数指针转换为委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-588">Converts an unmanaged function pointer to a delegate.</span></span></summary>
        <returns><span data-ttu-id="d3881-589">可转换为适当的委托类型的委托实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-589">A delegate instance that can be cast to the appropriate delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-590">在 .NET Framework 的版本1.0 和1.1 中，可以将表示托管方法的委托作为函数指针传递到非托管代码，从而允许非托管代码通过函数指针调用托管方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-590">In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</span></span> <span data-ttu-id="d3881-591">此外，非托管代码还可能将该函数指针传递回托管代码，并将该指针正确解析为底层托管方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-591">It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</span></span>  
  
 <span data-ttu-id="d3881-592">在 .NET Framework 2.0 及更高版本中，可以使用 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> 和 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> 方法来封送双向委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-592">In the .NET Framework 2.0 and later versions, you can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> methods to marshal delegates in both directions.</span></span> <span data-ttu-id="d3881-593">使用 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>时，`ptr` 将作为 <xref:System.IntPtr?displayProperty=nameWithType>导入。</span><span class="sxs-lookup"><span data-stu-id="d3881-593">With <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` is imported as a <xref:System.IntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-594">可以通过调用 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> 并作为参数传递来获取托管委托的 <xref:System.IntPtr?displayProperty=nameWithType>;然后，可以从非托管方法中调用它。</span><span class="sxs-lookup"><span data-stu-id="d3881-594">A <xref:System.IntPtr?displayProperty=nameWithType> can be obtained for a managed delegate by calling <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> and passed as a parameter; it can then be called from inside the unmanaged method.</span></span> <span data-ttu-id="d3881-595">请注意，参数封送拆收器还可以将函数指针封送到 .NET Framework 2.0 及更高版本中的委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-595">Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</span></span>  
  
  <span data-ttu-id="d3881-596">`ptr` 转换为一个委托，该委托使用 Windows 上的[__stdcall](/cpp/cpp/stdcall)调用约定或 Linux 和 macOS 上的[__cdecl](/cpp/cpp/cdecl)调用约定调用非托管方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-596">`ptr` is converted to a delegate that invokes the unmanaged method using the [__stdcall](/cpp/cpp/stdcall) calling convention on Windows, or the [__cdecl](/cpp/cpp/cdecl) calling convention on Linux and macOS.</span></span> <span data-ttu-id="d3881-597">可以通过将 <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> 应用于委托来设置调用约定。</span><span class="sxs-lookup"><span data-stu-id="d3881-597">You can set the calling convention by applying the <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> to the delegate.</span></span>
  
 <span data-ttu-id="d3881-598"><xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> 方法有以下限制：</span><span class="sxs-lookup"><span data-stu-id="d3881-598">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="d3881-599">互操作方案中不支持泛型。</span><span class="sxs-lookup"><span data-stu-id="d3881-599">Generics are not supported in interop scenarios.</span></span>   
  
-   <span data-ttu-id="d3881-600">此方法只能用于纯非托管函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-600">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="d3881-601">不能将此方法用于通过C++获取的函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-601">You cannot use this method with function pointers obtained through C++.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-602"><paramref name="t" /> 参数不是委托或泛型。</span><span class="sxs-lookup"><span data-stu-id="d3881-602">The <paramref name="t" /> parameter is not a delegate or is generic.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-603">
          <paramref name="ptr" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-603">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-604">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-604">-or-</span></span> 
<span data-ttu-id="d3881-605">
          <paramref name="t" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-605">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member GetDelegateForFunctionPointer : nativeint -&gt; 'Delegate" Usage="System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="d3881-606">要返回的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-606">The type of the delegate to return.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="d3881-607">要转换的非托管函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-607">The unmanaged function pointer to convert.</span></span></param>
        <summary><span data-ttu-id="d3881-608">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-608">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-609">将非托管函数指针转换为指定类型的委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-609">Converts an unmanaged function pointer to a delegate of a specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-610">指定委托类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-610">A instance of the specified delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-611">您可以使用 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> 和 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> 方法来封送双向委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-611">You can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> methods to marshal delegates in both directions.</span></span>  
  
  <span data-ttu-id="d3881-612">`ptr` 转换为一个委托，该委托使用 Windows 上的[__stdcall](/cpp/cpp/stdcall)调用约定或 Linux 和 macOS 上的[__cdecl](/cpp/cpp/cdecl)调用约定调用非托管方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-612">`ptr` is converted to a delegate that invokes the unmanaged method using the [__stdcall](/cpp/cpp/stdcall) calling convention on Windows, or the [__cdecl](/cpp/cpp/cdecl) calling convention on Linux and macOS.</span></span> <span data-ttu-id="d3881-613">可以通过将 <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> 应用于委托来设置调用约定。</span><span class="sxs-lookup"><span data-stu-id="d3881-613">You can set the calling convention by applying the <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> to the delegate.</span></span>
  
 <span data-ttu-id="d3881-614"><xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> 方法有以下限制：</span><span class="sxs-lookup"><span data-stu-id="d3881-614">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="d3881-615">互操作方案中不支持泛型。</span><span class="sxs-lookup"><span data-stu-id="d3881-615">Generics are not supported in interop scenarios.</span></span>   
  
-   <span data-ttu-id="d3881-616">此方法只能用于纯非托管函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-616">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="d3881-617">不能将此方法用于通过C++获取的函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-617">You cannot use this method with function pointers obtained through C++.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-618"><paramref name="TDelegate" /> 泛型参数不是代理，或者它是开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-618">The <paramref name="TDelegate" /> generic parameter is not a delegate, or it is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-619">
          <paramref name="ptr" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-619">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetEndComSlot : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetEndComSlot t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-620">表示接口或类的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-620">A type that represents an interface or class.</span></span></param>
        <summary><span data-ttu-id="d3881-621">检索向 COM 公开时某个类型的虚拟功能表（v 表或 VTBL）中的最后一个槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-621">Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="d3881-622">向 COM 公开时接口的最后一个 VTBL 槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-622">The last VTBL slot of the interface when exposed to COM.</span></span> <span data-ttu-id="d3881-623">如果 <paramref name="t" /> 参数是一个类，则返回的 VTBL 槽是从该类生成的接口中的最后一个槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-623">If the <paramref name="t" /> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-624">此方法返回接口或类的从零开始的 v 表号。</span><span class="sxs-lookup"><span data-stu-id="d3881-624">This method returns the zero-based, v-table number for an interface or a class.</span></span> <span data-ttu-id="d3881-625">在类上使用时，返回的槽号码引用类的类接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-625">When used on a class, the slot number returned refers to the class interface for the class.</span></span> <span data-ttu-id="d3881-626">如果类接口是自动调度的，则此方法始终返回-1，以指示仅调度接口不向托管客户端公开 "v-表"。</span><span class="sxs-lookup"><span data-stu-id="d3881-626">If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="d3881-627">可以将 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> 和 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> 与 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> 结合使用来传递指定范围内的槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-627">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="d3881-628">有关其他信息，请参阅[类接口简介](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface)。</span><span class="sxs-lookup"><span data-stu-id="d3881-628">For additional information, see [Introducing the class interface](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberSignature Language="F#" Value="static member GetExceptionCode : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetExceptionCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("GetExceptionCode() may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-629">检索标识所发生异常的类型的代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-629">Retrieves a code that identifies the type of the exception that occurred.</span></span></summary>
        <returns><span data-ttu-id="d3881-630">异常的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-630">The type of the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-631">公开 <xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> 仅用于对结构化异常处理（SEH）的编译器支持。</span><span class="sxs-lookup"><span data-stu-id="d3881-631"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span> <span data-ttu-id="d3881-632">如果在引发异常之前调用此方法，则将返回0x0。</span><span class="sxs-lookup"><span data-stu-id="d3881-632">If this method is called before an exception is thrown, it returns 0x0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-633">将 HRESULT 错误代码转换为相应的 <see cref="T:System.Exception" />对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-633">Converts an HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberSignature Language="F#" Value="static member GetExceptionForHR : int -&gt; Exception" Usage="System.Runtime.InteropServices.Marshal.GetExceptionForHR errorCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="d3881-634">要转换的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-634">The HRESULT to be converted.</span></span></param>
        <summary><span data-ttu-id="d3881-635">将指定的 HRESULT 错误代码转换为对应的 <see cref="T:System.Exception" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-635">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="d3881-636">一个对象，表示转换后的 HRESULT；或者，如果 HRESULT 值不表示错误代码（例如，<see langword="S_OK" /> 或 <see langword="S_FALSE" />），则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-636">An object that represents the converted HRESULT, or <see langword="null" /> if the HRESULT value doesn't represent an error code (for example, <see langword="S_OK" /> or <see langword="S_FALSE" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-637">使用 <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> 方法可以基于 HRESULT 获取 <xref:System.Exception>，而无需调用 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 方法并捕获异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-637">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception.</span></span>  
  
 <span data-ttu-id="d3881-638">当前的[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口用于构造异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-638">The current [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface is used to construct the exception.</span></span>  
  
 <span data-ttu-id="d3881-639">有关从每个 HRESULT 到 .NET Framework 中的可比较异常类的映射，请参阅[如何：映射 hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-639">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
        <related type="ExternalDocumentation" href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo"><span data-ttu-id="d3881-640">IErrorInfo 接口</span><span class="sxs-lookup"><span data-stu-id="d3881-640">IErrorInfo Interface</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="F#" Value="static member GetExceptionForHR : int * nativeint -&gt; Exception" Usage="System.Runtime.InteropServices.Marshal.GetExceptionForHR (errorCode, errorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorInfo" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="d3881-641">要转换的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-641">The HRESULT to be converted.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="d3881-642">指向 <see langword="IErrorInfo" /> 接口的指针，用于提供有关错误的详细信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-642">A pointer to the <see langword="IErrorInfo" /> interface that provides more information about the error.</span></span> <span data-ttu-id="d3881-643">可以指定 <c>IntPtr(0)</c> 以使用当前 <see langword="IErrorInfo" /> 接口，或者指定 <c>IntPtr(-1)</c> 以忽略当前 <see langword="IErrorInfo" /> 接口，仅从错误代码构造异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-643">You can specify <c>IntPtr(0)</c> to use the current <see langword="IErrorInfo" /> interface, or <c>IntPtr(-1)</c> to ignore the current <see langword="IErrorInfo" /> interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="d3881-644">将指定的 HRESULT 错误代码转换为对应的 <see cref="T:System.Exception" /> 对象，其中包括通过此异常对象的 <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> 接口传递的其他错误信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-644">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object, with additional error information passed in an <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> interface for the exception object.</span></span></summary>
        <returns><span data-ttu-id="d3881-645">一个对象，表示转换后的 HRESULT 的对象和从 <paramref name="errorInfo" /> 获得的信息；或者，如果 HRESULT 值不表示错误代码（例如，<see langword="S_OK" /> 或 <see langword="S_FALSE" />），则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-645">An object that represents the converted HRESULT and information obtained from <paramref name="errorInfo" />, or <see langword="null" /> if an HRESULT value doesn't represent an error code (for example, <see langword="S_OK" /> or <see langword="S_FALSE" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-646">使用 <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> 方法可以基于 HRESULT 获取 <xref:System.Exception>，而无需调用 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 方法并捕获异常（从而避免相应的性能开销）。</span><span class="sxs-lookup"><span data-stu-id="d3881-646">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception (thus avoiding the corresponding performance overhead).</span></span> <span data-ttu-id="d3881-647">`errorInfo` 参数提供有关错误的其他信息，例如其文本说明和定义错误的接口的全局唯一标识符（GUID）。</span><span class="sxs-lookup"><span data-stu-id="d3881-647">The `errorInfo` parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</span></span>  
  
 <span data-ttu-id="d3881-648">如果你有必须在转换中提供的自定义错误信息，请使用此方法重载。</span><span class="sxs-lookup"><span data-stu-id="d3881-648">Use this method overload if you have custom error information that you have to supply in the conversion.</span></span>  
  
 <span data-ttu-id="d3881-649">有关从每个 HRESULT 到 .NET Framework 中的可比较异常类的映射，请参阅[如何：映射 hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-649">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
        <related type="ExternalDocumentation" href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo"><span data-ttu-id="d3881-650">IErrorInfo 接口</span><span class="sxs-lookup"><span data-stu-id="d3881-650">IErrorInfo Interface</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberSignature Language="F#" Value="static member GetExceptionPointers : unit -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetExceptionPointers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-651">检索与计算机无关的异常描述，以及有关异常发生时线程的状态信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-651">Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</span></span></summary>
        <returns><span data-ttu-id="d3881-652">一个指向 <see href="/windows/win32/api/winnt/ns-winnt-exception_pointers">EXCEPTION_POINTERS</see> 结构的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-652">A pointer to an <see href="/windows/win32/api/winnt/ns-winnt-exception_pointers">EXCEPTION_POINTERS</see> structure.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-653">公开 <xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> 仅用于对结构化异常处理（SEH）的编译器支持。</span><span class="sxs-lookup"><span data-stu-id="d3881-653"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member GetFunctionPointerForDelegate : Delegate -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("GetFunctionPointerForDelegate(Delegate) may be unavailable in future releases. Instead, use GetFunctionPointerForDelegate&lt;T&gt;(T). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296522")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="d3881-654">要传递给非托管代码的委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-654">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="d3881-655">将委托转换为可从非托管代码调用的函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-655">Converts a delegate into a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="d3881-656">一个可传递给非托管代码的值，非托管代码使用该值来调用基础托管委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-656">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-657">委托 `d` 转换为可以使用 Windows 上的[__stdcall](/cpp/cpp/stdcall)调用约定传递到非托管代码的函数指针，或者 Linux 和 macOS 上的[__cdecl](/cpp/cpp/cdecl)调用约定。</span><span class="sxs-lookup"><span data-stu-id="d3881-657">The delegate `d` is converted to a function pointer that can be passed to unmanaged code using the [__stdcall](/cpp/cpp/stdcall) calling convention on Windows, or the [__cdecl](/cpp/cpp/cdecl) calling convention on Linux and macOS.</span></span> <span data-ttu-id="d3881-658">可以通过将 <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> 应用于委托来设置调用约定。</span><span class="sxs-lookup"><span data-stu-id="d3881-658">You can set the calling convention by applying the <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> to the delegate.</span></span>  
  
 <span data-ttu-id="d3881-659">您必须手动阻止垃圾回收器从托管代码收集委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-659">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="d3881-660">垃圾回收器不跟踪对非托管代码的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-660">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-661"><paramref name="d" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-661">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-662">
          <paramref name="d" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-662">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberSignature Language="F#" Value="static member GetFunctionPointerForDelegate : 'Delegate -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="d3881-663">要转换的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-663">The type of delegate to convert.</span></span></typeparam>
        <param name="d"><span data-ttu-id="d3881-664">要传递给非托管代码的委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-664">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="d3881-665">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-665">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-666">将指定类型的委托转换为可从非托管代码调用的函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-666">Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="d3881-667">一个可传递给非托管代码的值，非托管代码使用该值来调用基础托管委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-667">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-668">委托 `d` 转换为可通过使用 Windows 上的[__stdcall](/cpp/cpp/stdcall)调用约定或 Linux 和 macOS 上的[__cdecl](/cpp/cpp/cdecl)调用约定传递到非托管代码的函数指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-668">The delegate `d` is converted to a function pointer that can be passed to unmanaged code by using the [__stdcall](/cpp/cpp/stdcall) calling convention on Windows, or the [__cdecl](/cpp/cpp/cdecl) calling convention on Linux and macOS.</span></span> <span data-ttu-id="d3881-669">可以通过将 <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> 应用于委托来设置调用约定。</span><span class="sxs-lookup"><span data-stu-id="d3881-669">You can set the calling convention by applying the <xref:System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute> to the delegate.</span></span>  
  
 <span data-ttu-id="d3881-670">您必须手动阻止垃圾回收器从托管代码收集委托。</span><span class="sxs-lookup"><span data-stu-id="d3881-670">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="d3881-671">垃圾回收器不跟踪对非托管代码的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-671">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-672"><paramref name="d" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-672">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-673">
          <paramref name="d" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-673">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="static member GetHINSTANCE : System.Reflection.Module -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetHINSTANCE m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="d3881-674">具有所需 HINSTANCE 的模块。</span><span class="sxs-lookup"><span data-stu-id="d3881-674">The module whose HINSTANCE is desired.</span></span></param>
        <summary><span data-ttu-id="d3881-675">返回指定模块的实例句柄 (HINSTANCE)。</span><span class="sxs-lookup"><span data-stu-id="d3881-675">Returns the instance handle (HINSTANCE) for the specified module.</span></span></summary>
        <returns><span data-ttu-id="d3881-676"><paramref name="m" /> 的 INSTANCE；如果该模块没有 HINSTANCE，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="d3881-676">The HINSTANCE for <paramref name="m" />; or -1 if the module does not have an HINSTANCE.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-677">当动态或内存中的模块没有 HINSTANCE 时。</span><span class="sxs-lookup"><span data-stu-id="d3881-677">When dynamic or in-memory, modules do not have an HINSTANCE.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-678">
          <paramref name="m" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-678">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberSignature Language="F#" Value="static member GetHRForException : Exception -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetHRForException e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d3881-679">要转换为 HRESULT 的异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-679">The exception to convert to an HRESULT.</span></span></param>
        <summary><span data-ttu-id="d3881-680">将指定异常转换为 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-680">Converts the specified exception to an HRESULT.</span></span></summary>
        <returns><span data-ttu-id="d3881-681">映射到所提供的异常的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-681">The HRESULT mapped to the supplied exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-682"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 还为异常设置[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口，该接口可通过调用 COM GetErrorInfoNEEDGUID 函数获得。</span><span class="sxs-lookup"><span data-stu-id="d3881-682"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> also sets up an [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</span></span> <span data-ttu-id="d3881-683">您可以使用此函数在应用 <xref:System.Runtime.InteropServices.PreserveSigAttribute> 特性的 COM 接口的托管类实现上返回 HRESULT 值。</span><span class="sxs-lookup"><span data-stu-id="d3881-683">You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <xref:System.Runtime.InteropServices.PreserveSigAttribute> attribute.</span></span> <span data-ttu-id="d3881-684">使特性化方法捕获所有异常并使用 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 方法返回相应的 HRESULT 值。</span><span class="sxs-lookup"><span data-stu-id="d3881-684">Have the attributed method catch all exceptions and use the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method to return the appropriate HRESULT value.</span></span> <span data-ttu-id="d3881-685">允许异常在方法外传播会产生不正确的行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-685">Allowing an exception to propagate outside the method produces incorrect behavior.</span></span> <span data-ttu-id="d3881-686">（实际上，公共语言运行时无法将异常传递给通过 v 表调用此类方法的 COM 客户端。）</span><span class="sxs-lookup"><span data-stu-id="d3881-686">(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</span></span>  
  
 <span data-ttu-id="d3881-687">请注意，<xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 方法将设置当前线程的[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-687">Note that the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method sets the [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface of the current thread.</span></span> <span data-ttu-id="d3881-688">这可能会导致 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 方法（例如，如果已设置，则默认为使用当前线程的[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) ）中出现意外的结果。</span><span class="sxs-lookup"><span data-stu-id="d3881-688">This can cause unexpected results for methods like the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> methods that default to using the [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) of the current thread if it is set.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberSignature Language="F#" Value="static member GetHRForLastWin32Error : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-689">返回 HRESULT，它对应于使用 <see cref="T:System.Runtime.InteropServices.Marshal" /> 执行的 Win32 代码引起的最后一个错误。</span><span class="sxs-lookup"><span data-stu-id="d3881-689">Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <see cref="T:System.Runtime.InteropServices.Marshal" />.</span></span></summary>
        <returns><span data-ttu-id="d3881-690">对应于最后一个 Win32 错误代码的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-690">The HRESULT corresponding to the last Win32 error code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-691">目标函数必须设置 `setLastError` 元数据标志。</span><span class="sxs-lookup"><span data-stu-id="d3881-691">The target function must have had the `setLastError` metadata flag set.</span></span> <span data-ttu-id="d3881-692">例如，必须 `true`<xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> 的 `SetLastError` 字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-692">For example, the `SetLastError` field of the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> must be `true`.</span></span> <span data-ttu-id="d3881-693">设置此标志的过程取决于所使用的源语言： C# C++默认情况下 `false`，但 Visual Basic 中的 `Declare` 语句是 `true`的。</span><span class="sxs-lookup"><span data-stu-id="d3881-693">The process for setting this flag depends on the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-694">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> 方法检索与 Win32 错误代码相对应的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-694">The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIDispatchForObject : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIDispatchForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-695">其 <see langword="IDispatch" /> 接口被请求的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-695">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-696">从托管对象返回一个 <see href="/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch</see> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-696">Returns an <see href="/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch</see> interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="d3881-697"><paramref name="o" /> 参数的 <see langword="IDispatch" /> 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-697">The <see langword="IDispatch" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-698">在托管代码中，很少直接使用 `IDispatch` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-698">In managed code, you seldom work directly with the `IDispatch` interface.</span></span> <span data-ttu-id="d3881-699">但是，当调用将 COM 对象参数作为 <xref:System.IntPtr> 类型公开的方法或使用自定义封送处理时，<xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> 非常有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-699">However, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="d3881-700">使用此方法调用对象会使引用计数在返回指针之前在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-700">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-701">使用指针完成后，始终使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-701">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span>  
  
 <span data-ttu-id="d3881-702">你还可以对托管对象使用此方法，以获取指向对象的 COM 可调用包装器的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-702">You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</span></span> <span data-ttu-id="d3881-703">有关其他信息，请参阅[COM 可调用包装](~/docs/framework/interop/com-callable-wrapper.md)器。</span><span class="sxs-lookup"><span data-stu-id="d3881-703">For additional information, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-704"><paramref name="o" /> 不支持请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-704"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIDispatchForObjectInContext : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-705">其 <see langword="IDispatch" /> 接口被请求的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-705">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-706">如果调用方与托管对象在同一上下文中，则从该对象返回一个 <see href="/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch</see> 接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-706">Returns an <see href="/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch</see> interface pointer from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="d3881-707">指定对象的 <see langword="IDispatch" /> 接口指针；如果调用方与指定对象不在同一上下文中，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-707">The <see langword="IDispatch" /> interface pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-708">此方法与 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> 相同，不同之处在于，如果调用方与对象不在同一上下文中，它将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="d3881-708">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="d3881-709"><paramref name="o" /> 不支持请求的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-709"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-710"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-710"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetITypeInfoForType : Type -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetITypeInfoForType t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-711">正在请求其 <see langword="ITypeInfo" /> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-711">The type whose <see langword="ITypeInfo" /> interface is being requested.</span></span></param>
        <summary><span data-ttu-id="d3881-712">从托管类型返回一个 <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-712">Returns a <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface from a managed type.</span></span></summary>
        <returns><span data-ttu-id="d3881-713">指向 <paramref name="t" /> 参数的 <see langword="ITypeInfo" /> 接口的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-713">A pointer to the <see langword="ITypeInfo" /> interface for the <paramref name="t" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-714">此方法返回指向基于原始类型 `ITypeInfo` 实现的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-714">This method returns a pointer to an `ITypeInfo` implementation that is based on the original type.</span></span> <span data-ttu-id="d3881-715">使用 <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> 调用对象会导致在返回指针之前，引用计数会在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-715">Calling an object with <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-716">使用指针完成后，始终使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-716">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="d3881-717">可以应用 <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> 来使用此自定义封送拆收器来替换标准互操作封送处理行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-717">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-718">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> 方法检索指向某个类型的 `ITypeInfo` 接口的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-718">The following example demonstrates how to retrieve a pointer to the `ITypeInfo` interface for a type using the <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-719"><paramref name="t" /> 不是 COM 的可见类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-719"><paramref name="t" /> is not a visible type to COM.</span></span>  
  
<span data-ttu-id="d3881-720">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-720">-or-</span></span> 
 <span data-ttu-id="d3881-721"><paramref name="t" /> 是 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-721"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="d3881-722">为包含一个类型的程序集注册了该类型的类型库，但找不到类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-722">A type library is registered for the assembly that contains the type, but the type definition cannot be found.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIUnknownForObject : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIUnknownForObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-723">其 <see langword="IUnknown" /> 接口被请求的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-723">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-724">从托管对象返回 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-724">Returns an <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="d3881-725"><paramref name="o" /> 参数的 <see langword="IUnknown" /> 指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-725">The <see langword="IUnknown" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-726">在托管代码中，很少直接使用 `IUnknown` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-726">In managed code, you seldom work directly with the `IUnknown` interface.</span></span> <span data-ttu-id="d3881-727">但是，当调用将 COM 对象参数作为 <xref:System.IntPtr> 类型公开的方法或使用自定义封送处理时，<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 非常有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-727">However, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="d3881-728">使用此方法调用对象会使引用计数在返回指针之前在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-728">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-729">使用指针完成后，始终使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-729">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="d3881-730">此方法提供 <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-730">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d3881-731">你还可以对托管对象使用此方法，以获取指向对象的 COM 可[调用包装](~/docs/framework/interop/com-callable-wrapper.md)器的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-731">You can also use this method on a managed object to obtain an interface pointer to the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) for the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-732">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 方法为托管对象检索[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-732">The following example demonstrates how to retrieve an [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetIUnknownForObjectInContext : obj -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-733">其 <see langword="IUnknown" /> 接口被请求的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-733">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="d3881-734">如果调用方与托管对象在同一上下文中，则从该对象返回一个 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-734">Returns an <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="d3881-735">指定对象的 <see langword="IUnknown" /> 指针；如果调用方与指定对象不在同一上下文中，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-735">The <see langword="IUnknown" /> pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-736">此方法与 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 相同，不同之处在于，如果调用方与对象不在同一上下文中，它将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="d3881-736">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-737">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> 方法检索托管对象的 `IUnknown` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-737">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberSignature Language="F#" Value="static member GetLastWin32Error : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetLastWin32Error " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-738">返回由上一个非托管函数返回的错误代码，该函数是使用设置了 <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> 标志的平台调用来的。</span><span class="sxs-lookup"><span data-stu-id="d3881-738">Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.</span></span></summary>
        <returns><span data-ttu-id="d3881-739">通过调用 Win32 <see href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</see> 函数设置的最后一个错误代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-739">The last error code set by a call to the Win32 <see href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</see> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d3881-740">在 Windows 系统中，<xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> 从 Kernel32.dll 公开 Win32 [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-740">On Windows systems, <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> exposes the Win32 [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function from Kernel32.DLL.</span></span> <span data-ttu-id="d3881-741">此方法存在的原因是，对 `GetLastError` 进行直接平台调用以获取此信息是不可靠的。</span><span class="sxs-lookup"><span data-stu-id="d3881-741">This method exists because it is not reliable to make a direct platform invoke call to `GetLastError` to obtain this information.</span></span> <span data-ttu-id="d3881-742">如果要访问此错误代码，则必须调用 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>，而不是编写自己的 `GetLastError` 的平台调用定义并调用它。</span><span class="sxs-lookup"><span data-stu-id="d3881-742">If you want to access this error code, you must call <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> instead of writing your own platform invoke definition for `GetLastError` and calling it.</span></span> <span data-ttu-id="d3881-743">公共语言运行时可以对覆盖操作系统维护的 `GetLastError` 的 Api 进行内部调用。</span><span class="sxs-lookup"><span data-stu-id="d3881-743">The common language runtime can make internal calls to APIs that overwrite the `GetLastError` maintained by the operating system.</span></span>  

<span data-ttu-id="d3881-744">仅当将 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> 应用到方法签名并将 <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> 字段设置为 `true`时，才能使用此方法获取错误代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-744">You can use this method to obtain error codes only if you apply the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> to the method signature and set the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> field to `true`.</span></span> <span data-ttu-id="d3881-745">此过程的过程因所使用的源语言而异C# ： C++默认情况下 `false`，但 Visual Basic 中的 `Declare` 语句是 `true`的。</span><span class="sxs-lookup"><span data-stu-id="d3881-745">The process for this varies depending upon the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
<span data-ttu-id="d3881-746">.NET Core 上的 `GetLastWin32Error` 方法的行为有所不同，并且在 `true`<xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> 时 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="d3881-746">There is a difference in the behavior of the `GetLastWin32Error` method on .NET Core and .NET Framework when <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError?displayProperty=nameWithType> is `true`.</span></span> <span data-ttu-id="d3881-747">在 .NET Framework 上，`GetLastWin32Error` 方法可将错误信息从一个 P/Invoke 调用保留到下一个。</span><span class="sxs-lookup"><span data-stu-id="d3881-747">On .NET Framework, the `GetLastWin32Error` method can retain error information from one P/Invoke call to the next.</span></span> <span data-ttu-id="d3881-748">在 .NET Core 上，在 P/Invoke 调用之前会清除错误信息，而 `GetLastWin32Error` 仅表示来自最后一个方法调用的错误信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-748">On .NET Core, error information is cleared before P/Invoke call, and the `GetLastWin32Error` represents only error information from the last method call.</span></span>

## Examples  
 <span data-ttu-id="d3881-749">下面的示例调用 `GetLastWin32Error` 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-749">The following example calls the `GetLastWin32Error` method.</span></span> <span data-ttu-id="d3881-750">该示例首先演示如何调用方法，但不会出现错误，然后说明调用方法时出现错误。</span><span class="sxs-lookup"><span data-stu-id="d3881-750">The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="F#" Value="static member GetManagedThunkForUnmanagedMethodPtr : nativeint * nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap, pbSignature, cbSignature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetManagedThunkForUnmanagedMethodPtr method has been deprecated and will be removed in a future release.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pbSignature" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cbSignature" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="d3881-751">指向要封送的方法的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-751">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="d3881-752">指向方法签名的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-752">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="d3881-753"><paramref name="pbSignature" /> 中的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-753">The number of bytes in <paramref name="pbSignature" />.</span></span></param>
        <summary><span data-ttu-id="d3881-754">获取指向运行时生成的函数的指针，该函数将调用从托管代码封送到非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-754">Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="d3881-755">指向一个函数的指针，该函数将调用从 <paramref name="pfnMethodToWrap" /> 参数封送到非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-755">A pointer to the function that will marshal a call from the <paramref name="pfnMethodToWrap" /> parameter to unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-756"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> 仅针对编译器支持公开。</span><span class="sxs-lookup"><span data-stu-id="d3881-756"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberSignature Language="F#" Value="static member GetMethodInfoForComSlot : Type * int * ComMemberType -&gt; System.Reflection.MemberInfo" Usage="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot (t, slot, memberType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="slot" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType" RefType="ref" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-757">要检索的 <see cref="T:System.Reflection.MemberInfo" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-757">The type for which the <see cref="T:System.Reflection.MemberInfo" /> is to be retrieved.</span></span></param>
        <param name="slot"><span data-ttu-id="d3881-758">VTBL 槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-758">The VTBL slot.</span></span></param>
        <param name="memberType"><span data-ttu-id="d3881-759">在成功返回时，为指定成员类型的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="d3881-759">On successful return, one of the enumeration values that specifies the type of the member.</span></span></param>
        <summary><span data-ttu-id="d3881-760">检索指定的虚拟功能表（v 表或 VTBL）槽的 <see cref="T:System.Reflection.MemberInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-760">Retrieves a <see cref="T:System.Reflection.MemberInfo" /> object for the specified virtual function table (v-table or VTBL) slot.</span></span></summary>
        <returns><span data-ttu-id="d3881-761">表示指定 VTBL 槽上成员的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-761">The object that represents the member at the specified VTBL slot.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-762">返回值可以是 <xref:System.Reflection.FieldInfo>、<xref:System.Reflection.MethodInfo>或 <xref:System.Reflection.PropertyInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-762">The return value may be a <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, or <xref:System.Reflection.PropertyInfo> object.</span></span> <span data-ttu-id="d3881-763">返回值取决于给定 COM 槽中存在的托管成员的类型（因此通用化返回类型 <xref:System.Reflection.MemberInfo> 三个派生的）。</span><span class="sxs-lookup"><span data-stu-id="d3881-763">The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <xref:System.Reflection.MemberInfo> from which all three derive).</span></span>  
  
 <span data-ttu-id="d3881-764">此方法返回的从零开始的插槽号，适用于三个[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)和四个[IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch)方法，使第一个可用槽的值为3或7。</span><span class="sxs-lookup"><span data-stu-id="d3881-764">The zero-based slot number that is returned by this method accounts for three [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) and possibly four [IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="d3881-765"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-765"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-766">可以将 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> 与 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> 结合使用来传递指定范围内的槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-766">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> to pass slots within a specified range.</span></span>  
  
 <span data-ttu-id="d3881-767">`memberType` 参数仅在返回时才重要。</span><span class="sxs-lookup"><span data-stu-id="d3881-767">The `memberType` parameter is important only on return.</span></span> <span data-ttu-id="d3881-768">它包含对应于返回 <xref:System.Reflection.MemberInfo> 对象的 COM 成员的类型（常规方法或属性访问器）。</span><span class="sxs-lookup"><span data-stu-id="d3881-768">It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <xref:System.Reflection.MemberInfo> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-769"><paramref name="t" /> 在 COM 中不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-769"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetNativeVariantForObject : obj * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject (obj, pDstNativeVariant)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetNativeVariantForObject(Object, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d3881-770">为其获取 COM VARIANT 的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-770">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="d3881-771">一个指针，接收对应于 <paramref name="obj" /> 参数的 VARIANT。</span><span class="sxs-lookup"><span data-stu-id="d3881-771">A pointer to receive the VARIANT that corresponds to the <paramref name="obj" /> parameter.</span></span></param>
        <summary><span data-ttu-id="d3881-772">将对象转换为 COM VARIANT。</span><span class="sxs-lookup"><span data-stu-id="d3881-772">Converts an object to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-773">`pDstNativeVariant` 参数必须指向足够的内存来存储生成的变体。</span><span class="sxs-lookup"><span data-stu-id="d3881-773">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="d3881-774">此外，此方法的实现在 `pDstNativeVariant` 参数指向的原始内存上调用[VariantInit](/windows/win32/api/oleauto/nf-oleauto-variantinit)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-774">Also, the implementation of this method calls the [VariantInit](/windows/win32/api/oleauto/nf-oleauto-variantinit) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-775"><paramref name="obj" /> 参数是泛型类型的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-775">The <paramref name="obj" /> parameter is an instance of a generic type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetNativeVariantForObject : 'T * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject (obj, pDstNativeVariant)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetNativeVariantForObject&lt;T&gt;(T, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-776">要转换的对象类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-776">The type of the object to convert.</span></span></typeparam>
        <param name="obj"><span data-ttu-id="d3881-777">为其获取 COM VARIANT 的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-777">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="d3881-778">一个指针，接收对应于 <paramref name="obj" /> 参数的 VARIANT。</span><span class="sxs-lookup"><span data-stu-id="d3881-778">A pointer to receive the VARIANT that corresponds to the <paramref name="obj" /> parameter.</span></span></param>
        <summary><span data-ttu-id="d3881-779">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-779">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-780">将指定类型的对象转换为 COM VARIANT。</span><span class="sxs-lookup"><span data-stu-id="d3881-780">Converts an object of a specified type to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-781">`pDstNativeVariant` 参数必须指向足够的内存来存储生成的变体。</span><span class="sxs-lookup"><span data-stu-id="d3881-781">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="d3881-782">此外，此方法的实现在 `pDstNativeVariant` 参数指向的原始内存上调用[VariantInit](/windows/win32/api/oleauto/nf-oleauto-variantinit)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-782">Also, the implementation of this method calls [VariantInit](/windows/win32/api/oleauto/nf-oleauto-variantinit) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member GetObjectForIUnknown : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="d3881-783">指向 <see langword="IUnknown" /> 接口的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-783">A pointer to the <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="d3881-784">返回一个类型实例，该实例通过指向 COM 对象的 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口的指针表示该对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-784">Returns an instance of a type that represents a COM object by a pointer to its <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface.</span></span></summary>
        <returns><span data-ttu-id="d3881-785">一个对象，表示指定的非托管 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-785">An object that represents the specified unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-786">此方法包装托管对象中的 `IUnknown`。</span><span class="sxs-lookup"><span data-stu-id="d3881-786">This method wraps `IUnknown` in a managed object.</span></span> <span data-ttu-id="d3881-787">这会增加 COM 组件的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-787">This has the effect of incrementing the reference count of the COM component.</span></span> <span data-ttu-id="d3881-788">当运行时对表示 COM 对象的托管对象执行垃圾回收时，引用计数将减少。</span><span class="sxs-lookup"><span data-stu-id="d3881-788">The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</span></span>  
  
 <span data-ttu-id="d3881-789">`pUnk` 参数表示 `IUnknown` 的接口指针;但是，因为所有 COM 接口都是直接或间接从 `IUnknown`派生的，所以你可以将任何 COM 接口传递到此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-789">The `pUnk` parameter represents an `IUnknown` interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="d3881-790"><xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> 返回的对象是一个[运行时可调用包装](~/docs/framework/interop/runtime-callable-wrapper.md)器，公共语言运行时将像管理任何其他托管对象一样管理。</span><span class="sxs-lookup"><span data-stu-id="d3881-790">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), which the common language runtime manages as it does any other managed object.</span></span> <span data-ttu-id="d3881-791">此包装的类型通常为基 `System.__ComObject` 类型，这是包装类型不明确时使用的隐藏类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-791">The type of this wrapper is often a base `System.__ComObject` type, which is a hidden type used when the wrapper type is ambiguous.</span></span> <span data-ttu-id="d3881-792">只要 COM 对象实现[IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch)接口，仍可对此类基类型进行后期绑定调用。</span><span class="sxs-lookup"><span data-stu-id="d3881-792">You can still make late-bound calls to such a base type as long as the COM object implements the [IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch) interface.</span></span> <span data-ttu-id="d3881-793">同样，您可以将返回的对象强制转换为适当的 COM 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-793">Likewise, you can cast the returned object to an appropriate COM interface.</span></span>  
  
 <span data-ttu-id="d3881-794">对于要使用特定托管类类型（而不是泛型包装类型）进行包装的对象，您必须遵守以下要求：</span><span class="sxs-lookup"><span data-stu-id="d3881-794">For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</span></span>  
  
-   <span data-ttu-id="d3881-795">实现 COM 对象的[IProvideClassInfo](https://go.microsoft.com/fwlink/?LinkID=148012)接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-795">Implement the [IProvideClassInfo](https://go.microsoft.com/fwlink/?LinkID=148012) interface for the COM object.</span></span>  
  
-   <span data-ttu-id="d3881-796">用 appcmd.exe [（程序集注册工具）](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)注册包含程序集。</span><span class="sxs-lookup"><span data-stu-id="d3881-796">Register the containing assembly with the [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span></span>  
  
 <span data-ttu-id="d3881-797">另外，还可以通过使用 <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> 方法，避免这些要求，并获得一个使用特定托管类类型进行包装的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-797">Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-798"><paramref name="pUnk" /> 为 <see cref="F:System.IntPtr.Zero" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-798"><paramref name="pUnk" /> is <see cref="F:System.IntPtr.Zero" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetObjectForNativeVariant : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant pSrcNativeVariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectForNativeVariant(IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant"><span data-ttu-id="d3881-799">指向 COM VARIANT 的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-799">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="d3881-800">将 COM VARIANT 转换为对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-800">Converts a COM VARIANT to an object.</span></span></summary>
        <returns><span data-ttu-id="d3881-801">对应于 <paramref name="pSrcNativeVariant" /> 参数的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-801">An object that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-802"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 返回一个托管对象，该对象对应于指向非托管变体类型的原始指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-802"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="d3881-803">将 VARIANT 类型公开给托管代码时，interopmarshaler 会执行相同的转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-803">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="d3881-804"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-804"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-805">当变量类型为 VT_ERROR 时，<xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 返回 `Int32` 类型的对象，而不是 `UInt32`。</span><span class="sxs-lookup"><span data-stu-id="d3881-805">When the VARIANT type is VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns an object of type `Int32` instead of `UInt32`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException"><span data-ttu-id="d3881-806"><paramref name="pSrcNativeVariant" /> 不是有效的 VARIANT 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-806"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d3881-807"><paramref name="pSrcNativeVariant" /> 包含不受支持的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-807"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="F#" Value="static member GetObjectForNativeVariant : nativeint -&gt; 'T" Usage="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant pSrcNativeVariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectForNativeVariant&lt;T&gt;(IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-808">要将 COM VARIANT 转换为的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-808">The type to which to convert the COM VARIANT.</span></span></typeparam>
        <param name="pSrcNativeVariant"><span data-ttu-id="d3881-809">指向 COM VARIANT 的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-809">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="d3881-810">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-810">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-811">将 COM VARIANT 转换为指定类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-811">Converts a COM VARIANT to an object of a specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-812">一个与 <paramref name="pSrcNativeVariant" /> 参数对应的指定类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-812">An object of the specified type that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-813"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> 返回 `T` 类型的托管对象，该对象对应于非托管变体类型的原始指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-813"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> returns a managed object of type `T` that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="d3881-814">将 VARIANT 类型公开给托管代码时，interopmarshaler 会执行相同的转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-814">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="d3881-815"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> 提供 <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-815"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException"><span data-ttu-id="d3881-816"><paramref name="pSrcNativeVariant" /> 不是有效的 VARIANT 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-816"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d3881-817"><paramref name="pSrcNativeVariant" /> 包含不受支持的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-817"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="F#" Value="static member GetObjectsForNativeVariants : nativeint * int -&gt; obj[]" Usage="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants (aSrcNativeVariant, cVars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectsForNativeVariants(IntPtr, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant"><span data-ttu-id="d3881-818">指向 COM VARIANT 数组中第一个元素的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-818">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="d3881-819"><paramref name="aSrcNativeVariant" /> 中的 COM VARIANT 的计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-819">The count of COM VARIANTs in <paramref name="aSrcNativeVariant" />.</span></span></param>
        <summary><span data-ttu-id="d3881-820">将 COM <see href="https://go.microsoft.com/fwlink/?LinkId=148670">VARIANT</see> 数组转换为对象数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-820">Converts an array of COM <see href="https://go.microsoft.com/fwlink/?LinkId=148670">VARIANTs</see> to an array of objects.</span></span></summary>
        <returns><span data-ttu-id="d3881-821">对应于 <paramref name="aSrcNativeVariant" /> 的对象数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-821">An object array that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-822"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> 返回托管对象的数组，这些对象对应于指向非托管变体类型的 C 样式数组的原始指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-822"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="d3881-823">将 VARIANT 类型公开给托管代码时，interopmarshaler 会执行相同的转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-823">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="d3881-824">如果 `cVars` 参数为0，则该方法返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-824">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="d3881-825">对象数组（返回值）照常收集垃圾。</span><span class="sxs-lookup"><span data-stu-id="d3881-825">The object array (the return value) gets garbage collected as usual.</span></span> <span data-ttu-id="d3881-826">不会释放输入数组中的非托管输入数组或单独的变量。</span><span class="sxs-lookup"><span data-stu-id="d3881-826">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="d3881-827">因此，您有责任根据需要将其释放。</span><span class="sxs-lookup"><span data-stu-id="d3881-827">Therefore it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-828"><paramref name="cVars" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="d3881-828"><paramref name="cVars" /> is a negative number.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="F#" Value="static member GetObjectsForNativeVariants : nativeint * int -&gt; 'T[]" Usage="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants (aSrcNativeVariant, cVars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetObjectsForNativeVariants&lt;T&gt;(IntPtr, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cVars" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-829">要返回的数组的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-829">The type of the array to return.</span></span></typeparam>
        <param name="aSrcNativeVariant"><span data-ttu-id="d3881-830">指向 COM VARIANT 数组中第一个元素的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-830">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="d3881-831"><paramref name="aSrcNativeVariant" /> 中的 COM VARIANT 的计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-831">The count of COM VARIANTs in <paramref name="aSrcNativeVariant" />.</span></span></param>
        <summary><span data-ttu-id="d3881-832">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-832">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-833">将 COM VARIANT 数组转换为指定类型的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-833">Converts an array of COM VARIANTs to an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-834">对应于 <paramref name="aSrcNativeVariant" /> 的 <typeparamref name="T" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-834">An array of <typeparamref name="T" /> objects that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-835"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> 返回 `T` 的数组，该数组对应于非托管变体类型的 C 样式数组的原始指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-835"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> returns an array of `T` that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="d3881-836">将 VARIANT 类型公开给托管代码时，interopmarshaler 会执行相同的转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-836">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="d3881-837">如果 `cVars` 参数为0，则该方法返回空数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-837">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="d3881-838">通常，按原样回收返回的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-838">The returned array is garbage-collected as usual.</span></span> <span data-ttu-id="d3881-839">不会释放输入数组中的非托管输入数组或单独的变量。</span><span class="sxs-lookup"><span data-stu-id="d3881-839">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="d3881-840">因此，您有责任在适当的情况下将其释放。</span><span class="sxs-lookup"><span data-stu-id="d3881-840">Therefore, it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-841"><paramref name="cVars" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="d3881-841"><paramref name="cVars" /> is a negative number.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetStartComSlot : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetStartComSlot t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-842">表示接口或类的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-842">A type that represents an interface or a class.</span></span></param>
        <summary><span data-ttu-id="d3881-843">获取虚拟功能表（v 表或 VTBL）中包含用户定义的方法的第一个槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-843">Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</span></span></summary>
        <returns><span data-ttu-id="d3881-844">包含用户定义的方法的第一个 VTBL 槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-844">The first VTBL slot that contains user-defined methods.</span></span> <span data-ttu-id="d3881-845">如果接口基于 <see href="https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see>，则第一个槽为 3；如果接口基于 [IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch)，则为 7。</span><span class="sxs-lookup"><span data-stu-id="d3881-845">The first slot is 3 if the interface is based on <see href="https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see>, and 7 if the interface is based on [IDispatch](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-846">此方法返回接口或类的从零开始的 v 表号。</span><span class="sxs-lookup"><span data-stu-id="d3881-846">This method returns the zero-based v-table number for an interface or a class.</span></span> <span data-ttu-id="d3881-847">在类上使用时，返回的槽号将引用类的类接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-847">When used on a class, the slot number that is returned refers to the class interface for the class.</span></span> <span data-ttu-id="d3881-848">如果类接口是自动调度的，则此方法始终返回-1，以指示仅调度接口不向托管客户端公开 "v-表"。</span><span class="sxs-lookup"><span data-stu-id="d3881-848">If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="d3881-849">可以将 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> 和 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> 与 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> 结合使用来传递指定范围内的槽。</span><span class="sxs-lookup"><span data-stu-id="d3881-849">You can use <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="d3881-850">有关其他信息，请参阅[类接口简介](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface)。</span><span class="sxs-lookup"><span data-stu-id="d3881-850">For additional information, see [Introducing the class interface](~/docs/framework/interop/com-callable-wrapper.md#introducing-the-class-interface).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-851"><paramref name="t" /> 在 COM 中不可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-851"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberSignature Language="F#" Value="static member GetThreadFromFiberCookie : int -&gt; System.Threading.Thread" Usage="System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetThreadFromFiberCookie method has been deprecated.  Use the hosting API to perform this operation.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cookie"><span data-ttu-id="d3881-852">表示纤程 Cookie 的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-852">An integer that represents a fiber cookie.</span></span></param>
        <summary><span data-ttu-id="d3881-853">将纤程 cookie 转换为相应的 <see cref="T:System.Threading.Thread" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-853">Converts a fiber cookie into the corresponding <see cref="T:System.Threading.Thread" /> instance.</span></span></summary>
        <returns><span data-ttu-id="d3881-854">对应于 <paramref name="cookie" /> 参数的线程。</span><span class="sxs-lookup"><span data-stu-id="d3881-854">A thread that corresponds to the <paramref name="cookie" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-855">当向公共语言运行时发出纤程计划决策时，主机使用纤程 cookie 作为不透明标记。</span><span class="sxs-lookup"><span data-stu-id="d3881-855">Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</span></span> <span data-ttu-id="d3881-856">它们由堆栈和注册上下文组成。</span><span class="sxs-lookup"><span data-stu-id="d3881-856">They consist of a stack and register context.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-857"><paramref name="cookie" /> 参数为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-857">The <paramref name="cookie" /> parameter is 0.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberSignature Language="F#" Value="static member GetTypedObjectForIUnknown : nativeint * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown (pUnk, t)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="t" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="d3881-858">指向非托管对象的 <see langword="IUnknown" /> 接口的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-858">A pointer to the <see langword="IUnknown" /> interface of the unmanaged object.</span></span></param>
        <param name="t"><span data-ttu-id="d3881-859">请求的托管类的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-859">The type of the requested managed class.</span></span></param>
        <summary><span data-ttu-id="d3881-860">返回表示 COM 对象的指定类型的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-860">Returns a managed object of a specified type that represents a COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-861">类的实例，与表示所请求的非托管 COM 对象的 <see cref="T:System.Type" /> 对象相对应。</span><span class="sxs-lookup"><span data-stu-id="d3881-861">An instance of the class corresponding to the <see cref="T:System.Type" /> object that represents the requested unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-862">`t` 参数必须是 COM 导入的类型或 COM 导入的类型的子类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-862">The `t` parameter must be either a COM-imported type or a subtype of a COM-imported type.</span></span> <span data-ttu-id="d3881-863">此外，`t` 必须是由[tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具导入元数据的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-863">In addition, `t` must be a type whose metadata was imported by the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span> <span data-ttu-id="d3881-864">此类型必须是类，而不是关联的 coclass 接口，该接口携带 COM 类的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-864">This type must be a class and not an associated coclass interface, which carries the name of the COM class.</span></span> <span data-ttu-id="d3881-865">例如，如果 Tlbimp.exe 作为名为 `MyclassClass` 的类和称为 `Myclass`的 coclass 接口导入 `Myclass`，则必须将 `MyclassClass` （而不是 `Myclass`）用于此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-865">For example, if Tlbimp.exe imports `Myclass` as a class called `MyclassClass` and as a coclass interface called `Myclass`, you must use `MyclassClass` (not `Myclass`) with this method.</span></span> <span data-ttu-id="d3881-866">有关导入的类和 coclass 接口的其他信息，请参阅[导入的类型转换](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/s8sdycxx(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="d3881-866">For additional information about imported classes and coclass interfaces, see [Imported Type Conversion](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/s8sdycxx(v=vs.100)).</span></span>  
  
 <span data-ttu-id="d3881-867">如果已为 `pUnk` 参数获取了对象，则将忽略 `t` 并返回现有对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-867">If an object has already been obtained for the `pUnk` parameter, `t` is ignored and the existing object is returned.</span></span> <span data-ttu-id="d3881-868">`pUnk` 表示[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口指针;但是，因为所有 COM 接口都是直接或间接从 `IUnknown`派生的，所以你可以将任何 COM 接口传递到此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-868">`pUnk` represents an [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="d3881-869"><xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> 返回的对象是一个[运行时可调用包装器（RCW）](~/docs/framework/interop/runtime-callable-wrapper.md)，公共语言运行时将其作为其他任何托管对象进行管理。</span><span class="sxs-lookup"><span data-stu-id="d3881-869">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> is a [Runtime Callable Wrapper (RCW)](~/docs/framework/interop/runtime-callable-wrapper.md), which the common language runtime manages as it does any other managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-870"><paramref name="t" /> 并不具有 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 特性。</span><span class="sxs-lookup"><span data-stu-id="d3881-870"><paramref name="t" /> is not attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span></span>  
  
<span data-ttu-id="d3881-871">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-871">-or-</span></span> 
 <span data-ttu-id="d3881-872"><paramref name="t" /> 是 [!INCLUDE[wrt](~/includes/wrt-md.md)] 类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-872"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberSignature Language="F#" Value="static member GetTypeForITypeInfo : nativeint -&gt; Type" Usage="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo piTypeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo"><span data-ttu-id="d3881-873">要封送的 <see langword="ITypeInfo" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-873">The <see langword="ITypeInfo" /> interface to marshal.</span></span></param>
        <summary><span data-ttu-id="d3881-874">将非托管 <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> 对象转换为托管 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-874">Converts an unmanaged <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> object into a managed <see cref="T:System.Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="d3881-875">表示非托管 <see langword="ITypeInfo" /> 对象的托管类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-875">A managed type that represents the unmanaged <see langword="ITypeInfo" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-876"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> 返回基于原始类型的 <xref:System.Type?displayProperty=nameWithType> 实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-876"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> returns a <xref:System.Type?displayProperty=nameWithType> instance that is based on the original type.</span></span> <span data-ttu-id="d3881-877">可以应用 <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> 来使用此自定义封送拆收器来替换标准互操作封送处理行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-877">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span> <span data-ttu-id="d3881-878">[Tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具使用自定义封送拆收器将 `ITypeInfo` 参数转换为 <xref:System.Type?displayProperty=nameWithType> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-878">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool uses the custom marshaler to translate `ITypeInfo` parameters to <xref:System.Type?displayProperty=nameWithType> parameters.</span></span> <span data-ttu-id="d3881-879">但是，如果通过其他方式（Tlbimp.exe 除外）获取 `ITypeInfo` 接口，则可以使用 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> 手动执行相同的转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-879">However, if you obtain an `ITypeInfo` interface by some means other than Tlbimp.exe, you can use <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> to manually perform the same translation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Runtime.InteropServices.Marshal.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="d3881-880">要返回的类型的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="d3881-880">The CLSID of the type to return.</span></span></param>
        <summary><span data-ttu-id="d3881-881">返回与指定的类标识符 (CLSID) 关联的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-881">Returns the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="d3881-882"><see langword="System.__ComObject" />，无论 CLSID 是否有效。</span><span class="sxs-lookup"><span data-stu-id="d3881-882"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-883">检索由 <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> 对象表示的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-883">Retrieves the name of the type represented by an <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="static member GetTypeInfoName : System.Runtime.InteropServices.ComTypes.ITypeInfo -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeInfoName typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="d3881-884">一个表示 <see langword="ITypeInfo" /> 指针的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-884">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="d3881-885">检索由 <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> 对象表示的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-885">Retrieves the name of the type represented by an <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> object.</span></span></summary>
        <returns><span data-ttu-id="d3881-886"><paramref name="typeInfo" /> 参数指向的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-886">The name of the type that the <paramref name="typeInfo" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-887">还可以通过调用 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 方法并为其第一个参数传递-1，来检索由 `ITypeInfo` 表示的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-887">You can also retrieve the name of the type represented by an `ITypeInfo` by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-888">
          <paramref name="typeInfo" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-888">The <paramref name="typeInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberSignature Language="F#" Value="static member GetTypeInfoName : System.Runtime.InteropServices.UCOMITypeInfo -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeInfoName pTI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeInfoName(ITypeInfo pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTI"><span data-ttu-id="d3881-889">一个表示 <see langword="ITypeInfo" /> 指针的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-889">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="d3881-890">检索由 <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> 对象表示的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-890">Retrieves the name of the type represented by an <see href="/windows/win32/api/oaidl/nn-oaidl-itypeinfo">ITypeInfo</see> object.</span></span></summary>
        <returns><span data-ttu-id="d3881-891"><paramref name="pTI" /> 参数指向的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-891">The name of the type that the <paramref name="pTI" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-892">还可以通过调用 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 方法并为其第一个参数传递-1，来检索由 `ITypeInfo` 对象表示的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-892">You can also retrieve the name of the type represented by an `ITypeInfo` object by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-893">检索类型库的库标识符 (LIBID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-893">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuid : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuid typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="d3881-894">要检索其 LIBID 的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-894">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-895">检索类型库的库标识符 (LIBID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-895">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-896">指定类型库的 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-896">The LIBID of the specified type library.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-897"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 直接从现有类型库中提取 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-897"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="d3881-898">此操作不同于 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> 方法的操作，该方法根据当前程序集计算 LIBID 应基于的内容。</span><span class="sxs-lookup"><span data-stu-id="d3881-898">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="d3881-899">有关库标识符的详细信息，请参阅[导出的程序集转换](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="d3881-899">For more information about library identifiers, see [Exported Assembly Conversion](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuid : System.Runtime.InteropServices.UCOMITypeLib -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuid pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibGuid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="d3881-900">要检索其 LIBID 的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-900">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-901">检索类型库的库标识符 (LIBID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-901">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-902"><paramref name="pTLB" /> 参数指向的类型库的 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-902">The LIBID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-903"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 直接从现有类型库中提取 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-903"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="d3881-904">此操作不同于 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> 方法的操作，该方法根据当前程序集计算 LIBID 应基于的内容。</span><span class="sxs-lookup"><span data-stu-id="d3881-904">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="d3881-905">有关库标识符的详细信息，请参阅[导出的程序集转换](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="d3881-905">For more information about library identifiers, see [Exported Assembly Conversion](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibGuidForAssembly : System.Reflection.Assembly -&gt; Guid" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly asm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asm"><span data-ttu-id="d3881-906">从其导出类型库的程序集。</span><span class="sxs-lookup"><span data-stu-id="d3881-906">The assembly from which the type library was exported.</span></span></param>
        <summary><span data-ttu-id="d3881-907">检索从指定程序集导出类型库时分配给该类型库的库标识符 (LIBID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-907">Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="d3881-908">从指定的程序集导出类型库时分配给该类型库的 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-908">The LIBID that is assigned to a type library when it is exported from the specified assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-909">将程序集导出到类型库时，将为类型库分配 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-909">When assemblies are exported to type libraries, the type library is assigned a LIBID.</span></span> <span data-ttu-id="d3881-910">您可以通过在程序集级别应用 <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> 来显式设置 LIBID，也可以自动生成。</span><span class="sxs-lookup"><span data-stu-id="d3881-910">You can set the LIBID explicitly by applying the <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> at the assembly level, or it can be generated automatically.</span></span> <span data-ttu-id="d3881-911">[Tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具基于程序集的标识计算 LIBID 值。</span><span class="sxs-lookup"><span data-stu-id="d3881-911">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool calculates a LIBID value based on the identity of the assembly.</span></span> <span data-ttu-id="d3881-912">如果应用了属性，<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 将返回与 <xref:System.Runtime.InteropServices.GuidAttribute>关联的 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-912"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> returns the LIBID that is associated with the <xref:System.Runtime.InteropServices.GuidAttribute>, if the attribute is applied.</span></span> <span data-ttu-id="d3881-913">否则，<xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> 返回计算的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-913">Otherwise, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> returns the calculated value.</span></span> <span data-ttu-id="d3881-914">或者，您可以使用 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 方法从现有类型库中提取实际的 LIBID。</span><span class="sxs-lookup"><span data-stu-id="d3881-914">Alternatively, you can use the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> method to extract the actual LIBID from an existing type library.</span></span>  
  
 <span data-ttu-id="d3881-915">有关库标识符的详细信息，请参阅[导出的程序集转换](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100))主题。</span><span class="sxs-lookup"><span data-stu-id="d3881-915">See the [Exported Assembly Conversion](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/t1ztw645(v=vs.100)) topic for more information about library identifiers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-916"><paramref name="asm" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-916"><paramref name="asm" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-917">检索类型库的 LCID。</span><span class="sxs-lookup"><span data-stu-id="d3881-917">Retrieves the LCID of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibLcid : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibLcid typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="d3881-918">要检索其 LCID 的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-918">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-919">检索类型库的 LCID。</span><span class="sxs-lookup"><span data-stu-id="d3881-919">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-920"><paramref name="typelib" /> 参数指向的类型库的 LCID。</span><span class="sxs-lookup"><span data-stu-id="d3881-920">The LCID of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibLcid : System.Runtime.InteropServices.UCOMITypeLib -&gt; int" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibLcid pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibLcid(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="d3881-921">要检索其 LCID 的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-921">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-922">检索类型库的 LCID。</span><span class="sxs-lookup"><span data-stu-id="d3881-922">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-923"><paramref name="pTLB" /> 参数指向的类型库的 LCID。</span><span class="sxs-lookup"><span data-stu-id="d3881-923">The LCID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-924">检索类型库的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-924">Retrieves the name of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibName : System.Runtime.InteropServices.ComTypes.ITypeLib -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibName typelib" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="d3881-925">要检索其名称的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-925">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-926">检索类型库的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-926">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-927"><paramref name="typelib" /> 参数指向的类型库的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-927">The name of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-928">此方法返回的名称是用于库语句的标识符，如 Microsoft ADO 类型库的 ADODB.RECORDSET。</span><span class="sxs-lookup"><span data-stu-id="d3881-928">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="d3881-929">该名称不是文件名。</span><span class="sxs-lookup"><span data-stu-id="d3881-929">The name is not a file name.</span></span>  
  
 <span data-ttu-id="d3881-930">还可以通过调用 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 方法，并为其第一个参数传递-1 来检索类型库名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-930">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-931">
          <paramref name="typelib" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-931">The <paramref name="typelib" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibName : System.Runtime.InteropServices.UCOMITypeLib -&gt; string" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibName pTLB" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.InteropServices.Marshal.GetTypeLibName(ITypeLib pTLB) instead. http://go.microsoft.com/fwlink/?linkid=14202&amp;ID=0000011.", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="d3881-932">要检索其名称的类型库。</span><span class="sxs-lookup"><span data-stu-id="d3881-932">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="d3881-933">检索类型库的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-933">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="d3881-934"><paramref name="pTLB" /> 参数指向的类型库的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-934">The name of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-935">此方法返回的名称是用于库语句的标识符，如 Microsoft ADO 类型库的 ADODB.RECORDSET。</span><span class="sxs-lookup"><span data-stu-id="d3881-935">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="d3881-936">该名称不是文件名。</span><span class="sxs-lookup"><span data-stu-id="d3881-936">The name is not a file name.</span></span>  
  
 <span data-ttu-id="d3881-937">还可以通过调用 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 方法，并为其第一个参数传递-1 来检索类型库名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-937">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberSignature Language="F#" Value="static member GetTypeLibVersionForAssembly : System.Reflection.Assembly * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly (inputAssembly, majorVersion, minorVersion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="majorVersion" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="minorVersion" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputAssembly"><span data-ttu-id="d3881-938">托管程序集。</span><span class="sxs-lookup"><span data-stu-id="d3881-938">A managed assembly.</span></span></param>
        <param name="majorVersion"><span data-ttu-id="d3881-939">主版本号。</span><span class="sxs-lookup"><span data-stu-id="d3881-939">The major version number.</span></span></param>
        <param name="minorVersion"><span data-ttu-id="d3881-940">次版本号。</span><span class="sxs-lookup"><span data-stu-id="d3881-940">The minor version number.</span></span></param>
        <summary><span data-ttu-id="d3881-941">检索将从指定程序集导出的类型库的版本号。</span><span class="sxs-lookup"><span data-stu-id="d3881-941">Retrieves the version number of a type library that will be exported from the specified assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-942">使用 `CallerResolvedReferences` 值 <xref:System.Runtime.InteropServices.TypeLibExporterFlags> 导出程序集之前，可以使用此方法从程序集检索类型库版本。</span><span class="sxs-lookup"><span data-stu-id="d3881-942">Before exporting an assembly by using <xref:System.Runtime.InteropServices.TypeLibExporterFlags> with the `CallerResolvedReferences` value, you can use this method to retrieve the type library version from the assembly.</span></span>  
  
 <span data-ttu-id="d3881-943">如果未将 <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> 特性应用于导出的程序集以显式控制生成的类型库的版本号，则类型库将具有与程序集相同的版本号。</span><span class="sxs-lookup"><span data-stu-id="d3881-943">If you do not apply the <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-944"><paramref name="inputAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-944"><paramref name="inputAssembly" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberSignature Language="F#" Value="static member GetUniqueObjectForIUnknown : nativeint -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown unknown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="unknown"><span data-ttu-id="d3881-945">指向 <see langword="IUnknown" /> 接口的托管指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-945">A managed pointer to an <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="d3881-946">为给定的 <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> 接口创建唯一的<see href="~/docs/framework/interop/runtime-callable-wrapper.md">运行时可调用包装器 (RCW)</see> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-946">Creates a unique <see href="~/docs/framework/interop/runtime-callable-wrapper.md">Runtime Callable Wrapper (RCW)</see> object for a given <see href="/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</see> interface.</span></span></summary>
        <returns><span data-ttu-id="d3881-947">指定的 <see langword="IUnknown" /> 接口的唯一 RCW。</span><span class="sxs-lookup"><span data-stu-id="d3881-947">A unique RCW for the specified <see langword="IUnknown" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-948"><xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> 方法确保接收到唯一的 RCW，因为它与现有对象的 `IUnknown` 指针不匹配。</span><span class="sxs-lookup"><span data-stu-id="d3881-948">The <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> method ensures that you receive a unique RCW, because it does not match an `IUnknown` pointer to an existing object.</span></span> <span data-ttu-id="d3881-949">当必须创建不受调用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法的其他代码影响的唯一 RCW 时，可使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-949">Use this method when you have to create a unique RCW that is not impacted by other code that calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="F#" Value="static member GetUnmanagedThunkForManagedMethodPtr : nativeint * nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap, pbSignature, cbSignature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The GetUnmanagedThunkForManagedMethodPtr method has been deprecated and will be removed in a future release.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pbSignature" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cbSignature" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="d3881-950">指向要封送的方法的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-950">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="d3881-951">指向方法签名的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-951">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="d3881-952"><paramref name="pbSignature" /> 中的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-952">The number of bytes in <paramref name="pbSignature" />.</span></span></param>
        <summary><span data-ttu-id="d3881-953">获取指向运行时生成的函数的指针，该函数将调用从非托管代码封送到托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-953">Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</span></span></summary>
        <returns><span data-ttu-id="d3881-954">指向一个函数的指针，该函数将调用从 <paramref name="pfnMethodToWrap" /> 封送到托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-954">A pointer to a function that will marshal a call from <paramref name="pfnMethodToWrap" /> to managed code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-955"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> 仅针对编译器支持公开。</span><span class="sxs-lookup"><span data-stu-id="d3881-955"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member IsComObject : obj -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.IsComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-956">要检查的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-956">The object to check.</span></span></param>
        <summary><span data-ttu-id="d3881-957">指示指定对象是否表示 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-957">Indicates whether a specified object represents a COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-958">如果 <paramref name="o" /> 参数是 COM 类型，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-958"><see langword="true" /> if the <paramref name="o" /> parameter is a COM type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-959">如果实例的类类型是使用 <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> 特性化的，或者如果它是直接或间接派生自使用 <xref:System.Runtime.InteropServices.ComImportAttribute>特性化的类，<xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> 将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d3881-959"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> returns `true` if the class type of the instance is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> or if it derives directly or indirectly from a class attributed with <xref:System.Runtime.InteropServices.ComImportAttribute>.</span></span> <span data-ttu-id="d3881-960">当导入类型库时， [tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具会为您应用此特性。</span><span class="sxs-lookup"><span data-stu-id="d3881-960">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span>  
  
 <span data-ttu-id="d3881-961">另外两个方法还确定指定的对象是否表示 COM 对象，但返回 `true` 的要求不同于此方法的要求。</span><span class="sxs-lookup"><span data-stu-id="d3881-961">Two other methods also determine whether a specified object represents a COM object, but the requirements for returning `true` differ from this method's requirements.</span></span> <span data-ttu-id="d3881-962">如果类（或接口） <xref:System.Runtime.InteropServices.ComImportAttribute> 直接特性化，则 <xref:System.Type.IsImport%2A?displayProperty=nameWithType> 返回 `true`;它不返回派生类型的 `true`。</span><span class="sxs-lookup"><span data-stu-id="d3881-962"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> returns `true` if the class (or interface) is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> directly; it does not return `true` for derived types.</span></span> <span data-ttu-id="d3881-963">如果类型具有 <xref:System.Runtime.InteropServices.ComImportAttribute> 特性或派生自具有相同 GUID 的类型，则 <xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> 返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="d3881-963"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> returns `true` if the type is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> or derives from a type with the same GUID.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-964"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-964"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member IsTypeVisibleFromCom : Type -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-965">要检查其 COM 可见性的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-965">The type to check for COM visibility.</span></span></param>
        <summary><span data-ttu-id="d3881-966">指示类型对 COM 客户端是否可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-966">Indicates whether a type is visible to COM clients.</span></span></summary>
        <returns><span data-ttu-id="d3881-967">如果该类型对 COM 可见，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-967"><see langword="true" /> if the type is visible to COM; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-968"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> 使你能够在一步中检查 COM 可见性。</span><span class="sxs-lookup"><span data-stu-id="d3881-968"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> enables you to check for COM visibility in one step.</span></span> <span data-ttu-id="d3881-969">不可见的类型不能从 COM 使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-969">Types that are not visible cannot be used from COM.</span></span> <span data-ttu-id="d3881-970">如果某一类型 `public` 并且不与 <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>隐藏，则该类型可见。</span><span class="sxs-lookup"><span data-stu-id="d3881-970">A type is visible if it is `public` and not hidden with the <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member NumParamBytes : System.Reflection.MethodInfo -&gt; int" Usage="System.Runtime.InteropServices.Marshal.NumParamBytes m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="d3881-971">要检查的方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-971">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="d3881-972">计算在非托管内存中保存指定方法的参数所需要的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-972">Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</span></span></summary>
        <returns><span data-ttu-id="d3881-973">在非托管内存中表示方法参数所需要的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-973">The number of bytes required to represent the method parameters in unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-974"><xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> 方法返回在非托管内存中表示方法签名的参数所需的堆栈大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-974">The <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</span></span>  
  
 <span data-ttu-id="d3881-975">请注意，此方法的返回值与平台相关。</span><span class="sxs-lookup"><span data-stu-id="d3881-975">Note that the return value of this method is platform-dependent.</span></span> <span data-ttu-id="d3881-976">例如，带单个 integer 参数的签名将在32位平台上返回值4，在64位平台上返回值8。</span><span class="sxs-lookup"><span data-stu-id="d3881-976">For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-977">
          <paramref name="m" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-977">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-978"><paramref name="m" /> 参数不是 <see cref="T:System.Reflection.MethodInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-978">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member OffsetOf : Type * string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.OffsetOf (t, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("OffsetOf(Type, string) may be unavailable in future releases. Instead, use OffsetOf&lt;T&gt;(string). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296511")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-979">指定托管类的值类型或格式化引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-979">A value type or formatted reference type that specifies the managed class.</span></span> <span data-ttu-id="d3881-980">必须将 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 应用于该类。</span><span class="sxs-lookup"><span data-stu-id="d3881-980">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> to the class.</span></span></param>
        <param name="fieldName"><span data-ttu-id="d3881-981"><paramref name="t" /> 参数中的字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-981">The field within the <paramref name="t" /> parameter.</span></span></param>
        <summary><span data-ttu-id="d3881-982">返回托管类的非托管形式的字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-982">Returns the field offset of the unmanaged form of the managed class.</span></span></summary>
        <returns><span data-ttu-id="d3881-983">平台调用声明的指定类中 <paramref name="fieldName" /> 参数的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-983">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-984"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 提供非托管结构布局的偏移量，而不一定对应于托管结构布局的偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-984"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="d3881-985">封送结构可以转换布局并更改偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-985">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="d3881-986">`t` 参数可以是值类型或格式化引用类型（具有顺序或显式布局）。</span><span class="sxs-lookup"><span data-stu-id="d3881-986">The `t` parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="d3881-987">您可以使用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> 方法获取整个布局的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-987">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d3881-988">有关其他信息，请参阅[值类型的默认封送处理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0t2cwe11(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="d3881-988">For additional information, see [Default Marshaling for Value Types](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0t2cwe11(v=vs.100)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-989">从 .NET Framework 版本2.0 开始，<xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 可能会公开私有字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-989">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-990">该类无法作为结构导出，或者字段为非公共字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-990">The class cannot be exported as a structure or the field is nonpublic.</span></span> <span data-ttu-id="d3881-991">从 .NET Framework 2.0 版开始，该字段可以是私有的。</span><span class="sxs-lookup"><span data-stu-id="d3881-991">Beginning with the .NET Framework version 2.0, the field may be private.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-992">
          <paramref name="t" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-992">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member OffsetOf : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.OffsetOf fieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-993">托管值类型或格式化引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-993">A managed value type or formatted reference type.</span></span> <span data-ttu-id="d3881-994">必须将 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 属性应用于该类。</span><span class="sxs-lookup"><span data-stu-id="d3881-994">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute to the class.</span></span></typeparam>
        <param name="fieldName"><span data-ttu-id="d3881-995"><paramref name="T" /> 类型中字段的名称。</span><span class="sxs-lookup"><span data-stu-id="d3881-995">The name of the field in the <paramref name="T" /> type.</span></span></param>
        <summary><span data-ttu-id="d3881-996">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-996">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-997">返回指定托管类的非托管形式的字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-997">Returns the field offset of the unmanaged form of a specified managed class.</span></span></summary>
        <returns><span data-ttu-id="d3881-998">平台调用声明的指定类中 <paramref name="fieldName" /> 参数的偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-998">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-999"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> 提供非托管结构布局的偏移量，而不一定对应于托管结构布局的偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-999"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="d3881-1000">封送结构可以转换布局并更改偏移量。</span><span class="sxs-lookup"><span data-stu-id="d3881-1000">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="d3881-1001">`T` 泛型类型参数可以是值类型或格式化引用类型（具有顺序或显式布局）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1001">The `T` generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="d3881-1002">您可以使用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> 方法获取整个布局的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1002">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method.</span></span> <span data-ttu-id="d3881-1003">有关其他信息，请参阅[值类型的默认封送处理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0t2cwe11(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="d3881-1003">For additional information, see [Default Marshaling for Value Types](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0t2cwe11(v=vs.100)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-1004">从 .NET Framework 版本2.0 开始，<xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 可能会公开私有字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-1004">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberSignature Language="F#" Value="static member Prelink : System.Reflection.MethodInfo -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.Prelink m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="d3881-1005">要检查的方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1005">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="d3881-1006">在不调用方法的情况下执行一次性方法设置任务。</span><span class="sxs-lookup"><span data-stu-id="d3881-1006">Executes one-time method setup tasks without calling the method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1007">设置任务提供早期初始化，并在调用目标方法时自动执行。</span><span class="sxs-lookup"><span data-stu-id="d3881-1007">Setup tasks provide early initialization and are performed automatically when the target method is invoked.</span></span> <span data-ttu-id="d3881-1008">第一次任务包括以下各项：</span><span class="sxs-lookup"><span data-stu-id="d3881-1008">First-time tasks include the following:</span></span>  
  
-   <span data-ttu-id="d3881-1009">验证平台调用元数据的格式是否正确。</span><span class="sxs-lookup"><span data-stu-id="d3881-1009">Verifying that the platform invoke metadata is correctly formatted.</span></span>  
  
-   <span data-ttu-id="d3881-1010">验证所有托管类型是否都是平台调用函数的有效参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1010">Verifying that all the managed types are valid parameters of platform invoke functions.</span></span>  
  
-   <span data-ttu-id="d3881-1011">将非托管 DLL 定位并加载到进程中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1011">Locating and loading the unmanaged DLL into the process.</span></span>  
  
-   <span data-ttu-id="d3881-1012">正在查找进程中的入口点。</span><span class="sxs-lookup"><span data-stu-id="d3881-1012">Locating the entry point in the process.</span></span>  
  
 <span data-ttu-id="d3881-1013">对平台调用之外的方法调用 <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> 不起作用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1013">Calling <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> on a method outside of platform invoke has no effect.</span></span> <span data-ttu-id="d3881-1014">若要对某一类型中的所有平台调用方法执行安装任务，请使用 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1014">To execute setup tasks on all platform invoke methods in a type, use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1015">
          <paramref name="m" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1015">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1016"><paramref name="m" /> 参数不是 <see cref="T:System.Reflection.MethodInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1016">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberSignature Language="F#" Value="static member PrelinkAll : Type -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PrelinkAll c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="d3881-1017">要检查其方法的类。</span><span class="sxs-lookup"><span data-stu-id="d3881-1017">The class whose methods are to be checked.</span></span></param>
        <summary><span data-ttu-id="d3881-1018">对类上的所有方法执行预链接检查。</span><span class="sxs-lookup"><span data-stu-id="d3881-1018">Performs a pre-link check for all methods on a class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1019"><xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> 方法针对给定类型的每个方法调用 <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1019">The <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> method invokes <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> on every method for a given type.</span></span> <span data-ttu-id="d3881-1020"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> 在不调用每个方法的情况下执行一次性方法设置任务。</span><span class="sxs-lookup"><span data-stu-id="d3881-1020"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> executes one-time method setup tasks without calling each method.</span></span> <span data-ttu-id="d3881-1021">只能将 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> 用于平台调用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1021">You can use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> only for platform invoke calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1022">
          <paramref name="c" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1022">The <paramref name="c" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1023">分配托管 <see cref="T:System.String" />，并向其复制所有或部分非托管 ANSI 字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1023">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged ANSI string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAnsi : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAnsi ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1024">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1024">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="d3881-1025">将非托管 ANSI 字符串中第一个空字符之前的所有字符复制到托管 <see cref="T:System.String" />，并将每个 ANSI 字符扩展为 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1025">Copies all characters up to the first null character from an unmanaged ANSI string to a managed <see cref="T:System.String" />, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="d3881-1026">包含非托管 ANSI 字符串的副本的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1026">A managed string that holds a copy of the unmanaged ANSI string.</span></span> <span data-ttu-id="d3881-1027">如果 <paramref name="ptr" /> 为 <see langword="null" />，则该方法返回一个 Null 字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1027">If <paramref name="ptr" /> is <see langword="null" />, the method returns a null string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1028"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1028"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1029">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1029">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1030">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1030">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1031">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 方法从非托管的 `char` 数组创建托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1031">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged `char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAnsi : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAnsi (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1032">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1032">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="d3881-1033">要复制的输入字符串的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1033">The byte count of the input string to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1034">分配托管 <see cref="T:System.String" />，然后从非托管 ANSI 字符串向其复制指定数目的字符，并将每个 ANSI 字符扩展为 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1034">Allocates a managed <see cref="T:System.String" />, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="d3881-1035">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />，则为包含本机 ANSI 字符串副本的托管字符串；否则，此方法返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1035">A managed string that holds a copy of the native ANSI string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1036"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1036"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1037">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1037">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1038">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1038">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1039">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 方法从非托管的`char` 数组创建托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1039">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged`char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1040"><paramref name="len" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="d3881-1040"><paramref name="len" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1041">分配托管 <see cref="T:System.String" />，并向其复制所有或部分非托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1041">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAuto : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAuto ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1042">对于 Unicode 平台，表示第一个 Unicode 字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1042">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="d3881-1043">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1043">-or-</span></span>  
  
 <span data-ttu-id="d3881-1044">对于 ANSI 平台，表示第一个 ANSI 字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1044">For ANSI platforms, the address of the first ANSI character.</span></span></param>
        <summary><span data-ttu-id="d3881-1045">分配托管 <see cref="T:System.String" />，并从非托管内存中存储的字符串向其复制第一个空字符之前的所有字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1045">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1046">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1046">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1047">如果当前平台是 Unicode，则每个 ANSI 字符将扩展为 Unicode 字符，此方法会调用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1047">If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span></span> <span data-ttu-id="d3881-1048">否则，此方法将调用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1048">Otherwise, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span>  
  
 <span data-ttu-id="d3881-1049"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1049"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1050">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1050">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1051"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1051"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringAuto : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringAuto (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="len" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1052">对于 Unicode 平台，表示第一个 Unicode 字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1052">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="d3881-1053">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1053">-or-</span></span>  
  
 <span data-ttu-id="d3881-1054">对于 ANSI 平台，表示第一个 ANSI 字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1054">For ANSI platforms, the address of the first ANSI character.</span></span></param>
        <param name="len"><span data-ttu-id="d3881-1055">要复制的字符数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1055">The number of characters to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1056">分配托管 <see cref="T:System.String" />，并从存储在非托管内存中的字符串向其复制指定数目的字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1056">Allocates a managed <see cref="T:System.String" /> and copies the specified number of characters from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1057">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为包含本机字符串副本的托管字符串；否则此，方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1057">A managed string that holds a copy of the native string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1058">在 Unicode 平台上，此方法调用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>;在 ANSI 平台上，它调用 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1058">On Unicode platforms, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; on ANSI platforms, it calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span> <span data-ttu-id="d3881-1059">在调用这些方法之前，不会进行任何转换。</span><span class="sxs-lookup"><span data-stu-id="d3881-1059">No transformations are done before these methods are called.</span></span>  
  
 <span data-ttu-id="d3881-1060"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1060"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1061">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1061">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1062"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1062"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1063"><paramref name="len" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="d3881-1063"><paramref name="len" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringBSTR : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringBSTR ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1064">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1064">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="d3881-1065">分配已托管的 <see cref="T:System.String" />，并向其中复制非托管内存中存储的 <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">二进制字符串 (BSTR)</see>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1065">Allocates a managed <see cref="T:System.String" /> and copies a <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">binary string (BSTR)</see> stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1066">一个包含非托管字符串副本的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1066">A managed string that holds a copy of the unmanaged string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1067">仅对用非托管[SysAllocString](/windows/win32/api/oleauto/nf-oleauto-sysallocstring)和[SysAllocStringLen](/windows/win32/api/oleauto/nf-oleauto-sysallocstringlen)函数分配的字符串调用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1067">Call this method only on strings that were allocated with the unmanaged [SysAllocString](/windows/win32/api/oleauto/nf-oleauto-sysallocstring) and [SysAllocStringLen](/windows/win32/api/oleauto/nf-oleauto-sysallocstringlen) functions.</span></span>  
  
 <span data-ttu-id="d3881-1068"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1068"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1069">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1069">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1070">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1070">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1071"><paramref name="ptr" /> 等于 <see cref="F:System.IntPtr.Zero" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1071"><paramref name="ptr" /> equals <see cref="F:System.IntPtr.Zero" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1072">分配托管 <see cref="T:System.String" /> 并向其复制所有或部分非托管 Unicode 字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1072">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged Unicode string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUni : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUni ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1073">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1073">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="d3881-1074">分配托管 <see cref="T:System.String" />，并从非托管 Unicode 字符串向其复制第一个空字符之前的所有字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1074">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1075">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1075">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1076"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1076"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1077">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1077">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1078">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1078">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUni : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUni (ptr, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1079">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1079">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="d3881-1080">要复制的 Unicode 字符数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1080">The number of Unicode characters to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1081">分配托管 <see cref="T:System.String" />，并从非托的 Unicode 字符串向其复制指定数目的字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1081">Allocates a managed <see cref="T:System.String" /> and copies a specified number of characters from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1082">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1082">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1083"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1083"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1084">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1084">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1085">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> 和 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1085">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUTF8 : nativeint -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUTF8 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1086">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1086">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="d3881-1087">分配托管的 <see cref="T:System.String" />，并从非托管的 UTF-8 字符串向其复制第一个空字符之前的所有字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1087">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged UTF-8 string into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1088">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1088">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d3881-1089"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1089"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1090">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1090">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1091">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1091">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A?displayProperty=nameWithType> methods.</span></span>
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberSignature Language="F#" Value="static member PtrToStringUTF8 : nativeint * int -&gt; string" Usage="System.Runtime.InteropServices.Marshal.PtrToStringUTF8 (ptr, byteLen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="byteLen" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1092">非托管字符串的第一个字符的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1092">The address of the first character of the unmanaged string.</span></span></param>
        <param name="byteLen"><span data-ttu-id="d3881-1093">要复制的字节数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1093">The number of bytes to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1094">分配托管的 <see cref="T:System.String" />，并从非托管的 UTF8 字符串向其复制指定数目的字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1094">Allocates a managed <see cref="T:System.String" /> and copies a specified number of bytes from an unmanaged UTF8 string into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1095">如果 <paramref name="ptr" /> 参数的值不是 <see langword="null" />；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1095">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d3881-1096"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1096"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1097">由于此方法创建非托管字符串的内容的副本，因此必须根据需要释放原始字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1097">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="d3881-1098">此方法提供 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A?displayProperty=nameWithType> 方法的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1098">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A?displayProperty=nameWithType> methods.</span></span>  

 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1099">将数据从非托管内存块封送到托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1099">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * obj -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("PtrToStructure(IntPtr, Object) may be unavailable in future releases. Instead, use PtrToStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296512")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1100">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1100">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="d3881-1101">将数据复制到其中的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1101">The object to which the data is to be copied.</span></span> <span data-ttu-id="d3881-1102">这必须是格式化类的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-1102">This must be an instance of a formatted class.</span></span></param>
        <summary><span data-ttu-id="d3881-1103">将数据从非托管内存块封送到托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1103">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1104">当结构参数表示为 <xref:System.IntPtr?displayProperty=nameWithType> 值时，在 COM 互操作和平台调用中通常需要 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1104"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="d3881-1105">不能将此重载方法用于值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1105">You cannot use this overload method with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1106">结构布局不是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1106">Structure layout is not sequential or explicit.</span></span>  
  
 <span data-ttu-id="d3881-1107">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1107">-or-</span></span>  
  
 <span data-ttu-id="d3881-1108">结构为装箱的值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1108">Structure is a boxed value type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * Type -&gt; obj" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structureType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("PtrToStructure(IntPtr, Type) may be unavailable in future releases. Instead, use PtrToStructure&lt;T&gt;(IntPtr). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296513")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1109">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1109">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structureType"><span data-ttu-id="d3881-1110">要创建的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1110">The type of object to be created.</span></span> <span data-ttu-id="d3881-1111">此对象必须表示格式化类或结构。</span><span class="sxs-lookup"><span data-stu-id="d3881-1111">This object must represent a formatted class or a structure.</span></span></param>
        <summary><span data-ttu-id="d3881-1112">将数据从非托管内存块封送到新分配的指定类型的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1112">Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-1113">一个包含 <paramref name="ptr" /> 参数指向的数据的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1113">A managed object containing the data pointed to by the <paramref name="ptr" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1114">当结构参数表示为 <xref:System.IntPtr?displayProperty=nameWithType> 值时，在 COM 互操作和平台调用中通常需要 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1114"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="d3881-1115">可以将值类型传递给此重载方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1115">You can pass a value type to this overload method.</span></span> <span data-ttu-id="d3881-1116">在这种情况下，返回的对象是一个装箱的实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-1116">In this case, the returned object is a boxed instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1117">下面的示例创建一个托管结构，将其传输到非托管内存，然后使用 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 方法将其传输回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1117">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 <span data-ttu-id="d3881-1118">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 方法将非托管内存块封送到托管结构。</span><span class="sxs-lookup"><span data-stu-id="d3881-1118">The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d3881-1119">此代码假定为32位编译。</span><span class="sxs-lookup"><span data-stu-id="d3881-1119">This code assumes 32-bit compilation.</span></span> <span data-ttu-id="d3881-1120">使用64位编译器之前，请将 <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> 替换为 <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1120">Before using a 64-bit compiler, replace <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> with <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1121"><paramref name="structureType" /> 参数布局不是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1121">The <paramref name="structureType" /> parameter layout is not sequential or explicit.</span></span>  
  
<span data-ttu-id="d3881-1122">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1122">-or-</span></span> 
<span data-ttu-id="d3881-1123"><paramref name="structureType" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-1123">The <paramref name="structureType" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1124"><paramref name="structureType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1124"><paramref name="structureType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="d3881-1125"><paramref name="structureType" /> 指定的类没有可访问的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1125">The class specified by <paramref name="structureType" /> does not have an accessible parameterless constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint -&gt; 'T" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1126">要将数据复制到其中的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1126">The type of the object to which the data is to be copied.</span></span> <span data-ttu-id="d3881-1127">这必须是格式化类或结构。</span><span class="sxs-lookup"><span data-stu-id="d3881-1127">This must be a formatted class or a structure.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="d3881-1128">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1128">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="d3881-1129">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1129">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1130">将数据从非托管内存块封送到泛型类型参数指定的类型的新分配托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1130">Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="d3881-1131">一个包含 <paramref name="ptr" /> 参数指向的数据的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1131">A managed object that contains the data that the <paramref name="ptr" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1132">当结构参数表示为 <xref:System.IntPtr?displayProperty=nameWithType> 值时，在 COM 互操作和平台调用中通常需要 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1132"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="d3881-1133">可以向此方法重载传递值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1133">You can pass a value type to this method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1134"><typeparamref name="T" /> 的布局不是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1134">The layout of <typeparamref name="T" /> is not sequential or explicit.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="d3881-1135"><typeparamref name="T" /> 指定的类没有可访问的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1135">The class specified by <typeparamref name="T" /> does not have an accessible parameterless constructor.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberSignature Language="F#" Value="static member PtrToStructure : nativeint * 'T -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.PtrToStructure (ptr, structure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="structure" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1136"><paramref name="structure" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1136">The type of <paramref name="structure" />.</span></span> <span data-ttu-id="d3881-1137">这必须是格式化的类。</span><span class="sxs-lookup"><span data-stu-id="d3881-1137">This must be a formatted class.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="d3881-1138">指向非托管内存块的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1138">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="d3881-1139">将数据复制到其中的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1139">The object to which the data is to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1140">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1140">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1141">将数据从非托管内存块封送到指定类型的托管内存对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1141">Marshals data from an unmanaged block of memory to a managed object of the specified type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1142">当结构参数表示为 <xref:System.IntPtr> 值时，在 COM 互操作和平台调用中通常需要 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1142"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr> values.</span></span> <span data-ttu-id="d3881-1143">不能将此方法重载用于值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1143">You cannot use this method overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1144">结构布局不是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1144">Structure layout is not sequential or explicit.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberSignature Language="F#" Value="static member QueryInterface : nativeint * Guid * nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.QueryInterface (pUnk, iid, ppv)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="d3881-1145">要查询的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-1145">The interface to be queried.</span></span></param>
        <param name="iid"><span data-ttu-id="d3881-1146">所请求的接口的接口标识符 (IID)。</span><span class="sxs-lookup"><span data-stu-id="d3881-1146">The interface identifier (IID) of the requested interface.</span></span></param>
        <param name="ppv"><span data-ttu-id="d3881-1147">此方法返回时，包含对返回接口的引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1147">When this method returns, contains a reference to the returned interface.</span></span></param>
        <summary><span data-ttu-id="d3881-1148">从 COM 对象请求指向指定接口的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1148">Requests a pointer to a specified interface from a COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-1149">一个 HRESULT，指示调用成功还是失败。</span><span class="sxs-lookup"><span data-stu-id="d3881-1149">An HRESULT that indicates the success or failure of the call.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1150"><xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> 方法公开 COM 对象的[IUnknown：： QueryInterface](https://go.microsoft.com/fwlink/?LinkID=144867)方法，该方法尝试获取特定接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1150">The <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> method exposes the [IUnknown::QueryInterface](https://go.microsoft.com/fwlink/?LinkID=144867) method of a COM object, which attempts to obtain a specific interface pointer.</span></span> <span data-ttu-id="d3881-1151">对 COM 对象使用 `QueryInterface` 与在托管代码中执行强制转换运算相同。</span><span class="sxs-lookup"><span data-stu-id="d3881-1151">Using `QueryInterface` on a COM object is the same as performing a cast operation in managed code.</span></span> <span data-ttu-id="d3881-1152">使用此方法调用对象会使引用计数在返回指针之前在接口指针上递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-1152">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="d3881-1153">使用指针完成后，始终使用 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 来递减引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1153">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="d3881-1154">若要获取表示[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口指针的 <xref:System.IntPtr> 值，可以调用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>或 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1154">To obtain an <xref:System.IntPtr> value that represents a [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface pointer, you can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1155">从非托管内存读取单个字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1155">Reads a single byte from unmanaged memory.</span></span> <span data-ttu-id="d3881-1156">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1156">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadByte : nativeint -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1157">非托管内存中开始读取的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1157">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="d3881-1158">从非托管内存读取单个字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1158">Reads a single byte from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1159">从非托管内存读取的字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1159">The byte read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1160"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 的隐含偏移量为0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1160"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> has an implied offset of 0.</span></span> <span data-ttu-id="d3881-1161">此方法使您能够与非托管 C 样式字节数组直接交互，从而消除了在读取其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的代价。</span><span class="sxs-lookup"><span data-stu-id="d3881-1161">This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1162">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1162">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1163">下面的示例创建非托管内存块，将字节写入非托管内存，从非托管内存读取字节，然后释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1163">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 <span data-ttu-id="d3881-1164">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 方法读取非托管字符的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1164">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1165"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1165"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1166">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1166">-or-</span></span> 
 <span data-ttu-id="d3881-1167"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1167"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1168">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1168">-or-</span></span> 
 <span data-ttu-id="d3881-1169"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1169"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadByte : nativeint * int -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RU1&quot; winapi)unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1170">非托管内存中开始读取的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1170">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1171">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1171">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1172">从非托管内存按给定的偏移量（或索引）读取单个字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1172">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1173">从非托管内存按给定的偏移量读取的字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1173">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1174"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1174"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1175">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1175">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1176">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1176">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 <span data-ttu-id="d3881-1177">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 方法读取非托管字符的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1177">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1178">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1178">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(object ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadByte : obj * int -&gt; byte" Usage="System.Runtime.InteropServices.Marshal.ReadByte (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RU1&quot; winapi)unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ReadByte(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1179">非托管内存中源对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1179">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1180">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1180">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1181">从非托管内存按给定的偏移量（或索引）读取单个字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1181">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1182">从非托管内存按给定的偏移量读取的字节。</span><span class="sxs-lookup"><span data-stu-id="d3881-1182">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1183"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1183"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1184">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1184">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1185">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1185">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1186"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1186"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1187">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1187">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1188">从非托管内存中读取一个 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1188">Reads a 16-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="d3881-1189">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1189">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : nativeint -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1190">非托管内存中开始读取的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1190">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="d3881-1191">从非托管内存中读取一个 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1191">Reads a 16-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1192">从非托管内存中读取的 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1192">The 16-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1193"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 的隐含偏移量为0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1193"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> has an implied offset of 0.</span></span> <span data-ttu-id="d3881-1194">此方法使您能够与非托管 C 样式的 `Int16` 数组直接交互，从而消除了将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1194">This method enables direct interaction with an unmanaged C-style `Int16` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1195">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1195">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1196">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1196">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="d3881-1197">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 方法读取非托管 `short` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1197">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1198"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1198"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1199">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1199">-or-</span></span> 
 <span data-ttu-id="d3881-1200"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1200"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1201">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1201">-or-</span></span> 
 <span data-ttu-id="d3881-1202"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1202"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : nativeint * int -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI2&quot; winapi)int16 ReadInt16(native int ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1203">非托管内存中开始读取的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1203">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1204">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1204">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1205">从非托管内存按给定的偏移量读取一个 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1205">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1206">从非托管内存按给定的偏移量读取的 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1206">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1207"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 实现与非托管16位已签名数组的直接交互，从而消除了在读取其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的代价。</span><span class="sxs-lookup"><span data-stu-id="d3881-1207"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1208">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1208">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1209">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1209">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="d3881-1210">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 方法读取非托管 `short` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1210">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1211">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1211">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(object ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt16 : obj * int -&gt; int16" Usage="System.Runtime.InteropServices.Marshal.ReadInt16 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI2&quot; winapi)int16 ReadInt16([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ReadInt16(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1212">非托管内存中源对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1212">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1213">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1213">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1214">从非托管内存按给定的偏移量读取一个 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1214">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1215">从非托管内存按给定的偏移量读取的 16 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1215">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1216"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 实现与非托管16位已签名数组的直接交互，从而消除了在读取其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的代价。</span><span class="sxs-lookup"><span data-stu-id="d3881-1216"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1217">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1217">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1218">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1218">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1219"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1219"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1220">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1220">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1221">从非托管内存中读取一个 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1221">Reads a 32-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="d3881-1222">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1222">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1223">非托管内存中开始读取的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1223">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="d3881-1224">从非托管内存中读取一个 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1224">Reads a 32-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1225">从非托管内存中读取的 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1225">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1226"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 的隐含偏移量为0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1226"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> has an implied offset of 0.</span></span> <span data-ttu-id="d3881-1227">此方法使您能够与非托管 C 样式的 `Int32` 数组直接交互，从而消除了将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1227">This method enables direct interaction with an unmanaged C-style `Int32` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1228">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1228">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1229">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1229">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="d3881-1230">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 方法读取非托管 `int` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1230">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1231"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1231"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1232">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1232">-or-</span></span> 
 <span data-ttu-id="d3881-1233"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1233"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1234">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1234">-or-</span></span> 
 <span data-ttu-id="d3881-1235"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1235"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : nativeint * int -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI4&quot; winapi)int32 ReadInt32(native int ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1236">非托管内存中开始读取的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1236">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1237">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1237">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1238">从非托管内存按给定的偏移量读取一个 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1238">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1239">从非托管内存中读取的 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1239">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1240"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 可实现与非托管32位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1240"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1241">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1241">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1242">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1242">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="d3881-1243">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 方法读取非托管 `int` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1243">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1244">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1244">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(object ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt32 : obj * int -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReadInt32 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI4&quot; winapi)int32 ReadInt32([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ReadInt32(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1245">非托管内存中源对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1245">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1246">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1246">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1247">从非托管内存按给定的偏移量读取一个 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1247">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1248">从非托管内存按给定的偏移量读取的 32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1248">The 32-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1249"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 可实现与非托管32位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1249"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1250">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1250">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1251">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1251">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1252"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1252"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1253">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1253">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1254">从非托管内存中读取一个 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1254">Reads a 64-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="d3881-1255">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1255">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : nativeint -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1256">非托管内存中开始读取的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1256">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="d3881-1257">从非托管内存中读取一个 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1257">Reads a 64-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1258">从非托管内存中读取的 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1258">The 64-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1259"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 的隐含偏移量为0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1259"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> has an implied offset of 0.</span></span> <span data-ttu-id="d3881-1260">此方法使您能够与非托管 C 样式的 `Int64` 数组直接交互，从而消除了将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1260">This method enables direct interaction with an unmanaged C-style `Int64` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1261">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1261">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1262">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1262">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="d3881-1263">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 方法读取非托管 `__int64` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1263">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1264"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1264"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1265">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1265">-or-</span></span> 
 <span data-ttu-id="d3881-1266"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1266"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1267">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1267">-or-</span></span> 
 <span data-ttu-id="d3881-1268"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1268"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : nativeint * int -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI8&quot; winapi)int64 ReadInt64(native int ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1269">非托管内存中开始读取的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1269">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1270">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1270">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1271">从非托管内存按给定的偏移量读取一个 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1271">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1272">从非托管内存按给定的偏移量读取的 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1272">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1273"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 可实现与非托管64位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1273"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1274">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1274">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1275">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1275">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="d3881-1276">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 方法读取非托管 `__int64` 变量的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1276">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1277">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1277">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(object ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadInt64 : obj * int -&gt; int64" Usage="System.Runtime.InteropServices.Marshal.ReadInt64 (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_RI8&quot; winapi)int64 ReadInt64([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ReadInt64(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1278">非托管内存中源对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1278">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1279">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1279">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1280">从非托管内存按给定的偏移量读取一个 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1280">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1281">从非托管内存按给定的偏移量读取的 64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1281">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1282"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 可实现与非托管64位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1282"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1283">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1283">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1284">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1284">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1285"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1285"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1286">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1286">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1287">从非托管内存读取处理器本机大小的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1287">Reads a processor native sized integer from unmanaged memory.</span></span> <span data-ttu-id="d3881-1288">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1288">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1289">非托管内存中开始读取的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1289">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="d3881-1290">从非托管内存读取处理器本机大小的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1290">Reads a processor native-sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1291">从非托管内存读取的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1291">The integer read from unmanaged memory.</span></span> <span data-ttu-id="d3881-1292">在 32 位计算机上返回 32 位整数，在 64 位计算机上返回 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1292">A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1293"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 的隐含偏移量为0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1293"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> has an implied offset of 0.</span></span> <span data-ttu-id="d3881-1294">此方法使您能够与非托管 C 样式的 `IntPtr` 数组直接交互，从而消除了将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再读取其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1294">This method enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1295">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1295">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1296">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1296">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1297"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1297"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1298">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1298">-or-</span></span> 
 <span data-ttu-id="d3881-1299"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1299"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1300">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1300">-or-</span></span> 
 <span data-ttu-id="d3881-1301"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1301"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr (ptr, ofs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1302">非托管内存中开始读取的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1302">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1303">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1303">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1304">从非托管内存按给定的偏移量读取处理器本机大小的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1304">Reads a processor native sized integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1305">从非托管内存按给定的偏移量读取的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1305">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1306"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 支持与非托管 C 样式的 `IntPtr` 数组直接交互，从而消除了在读取其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的费用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1306"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1307">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1307">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1308">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1308">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1309">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1309">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(object ptr, int32 ofs) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberSignature Language="F#" Value="static member ReadIntPtr : obj * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReadIntPtr (ptr, ofs)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("ReadIntPtr(Object, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1310">非托管内存中源对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1310">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1311">额外的字节偏移量，在读取前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1311">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="d3881-1312">从非托管内存读取处理器本机大小的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1312">Reads a processor native sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1313">从非托管内存按给定的偏移量读取的整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1313">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1314"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 支持与非托管 C 样式的 `IntPtr` 数组直接交互，从而消除了在读取其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的费用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1314"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="d3881-1315">支持从未对齐的内存位置进行读取。</span><span class="sxs-lookup"><span data-stu-id="d3881-1315">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1316">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1316">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1317"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1317"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1318">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1318">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberSignature Language="F#" Value="static member ReAllocCoTaskMem : nativeint * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem (pv, cb)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="d3881-1319">指向用 <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> 分配的内存的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1319">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="d3881-1320">已分配块的新大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1320">The new size of the allocated block.</span></span></param>
        <summary><span data-ttu-id="d3881-1321">调整之前用 <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> 分配的内存块的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1321">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="d3881-1322">一个整数，表示重新分配的内存块的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1322">An integer representing the address of the reallocated block of memory.</span></span> <span data-ttu-id="d3881-1323">必须使用 <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> 释放该内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1323">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1324"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> 是 <xref:System.Runtime.InteropServices.Marshal> 类中两个内存重新分配方法中的一种。</span><span class="sxs-lookup"><span data-stu-id="d3881-1324"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> is one of two memory reallocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="d3881-1325">（<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> 是另一个。）重新分配的内存内容的开头与原始内容相同;但是，整个内存块可以位于不同的位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1325">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</span></span> <span data-ttu-id="d3881-1326">此方法公开 COM [CoTaskMemRealloc](https://go.microsoft.com/fwlink/?LinkId=148778)函数，该函数称为 com 任务内存分配器。</span><span class="sxs-lookup"><span data-stu-id="d3881-1326">This method exposes the COM [CoTaskMemRealloc](https://go.microsoft.com/fwlink/?LinkId=148778) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1327">没有足够的内存来满足该请求。</span><span class="sxs-lookup"><span data-stu-id="d3881-1327">There is insufficient memory to satisfy the request.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="F#" Value="static member ReAllocHGlobal : nativeint * nativeint -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.ReAllocHGlobal (pv, cb)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="d3881-1328">指向用 <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> 分配的内存的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1328">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="d3881-1329">已分配块的新大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1329">The new size of the allocated block.</span></span> <span data-ttu-id="d3881-1330">这不是指针；它是你请求的字节计数，转换为类型 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1330">This is not a pointer; it is the byte count you are requesting, cast to type <see cref="T:System.IntPtr" />.</span></span> <span data-ttu-id="d3881-1331">如果你传递指针，则将其视为大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1331">If you pass a pointer, it is treated as a size.</span></span></param>
        <summary><span data-ttu-id="d3881-1332">调整之前用 <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> 分配的内存块的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1332">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></summary>
        <returns><span data-ttu-id="d3881-1333">指向重新分配的内存的指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1333">A pointer to the reallocated memory.</span></span> <span data-ttu-id="d3881-1334">必须使用 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> 释放该内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1334">This memory must be released using <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1335"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> 是 <xref:System.Runtime.InteropServices.Marshal> 类中两个内存重新分配 API 方法之一。</span><span class="sxs-lookup"><span data-stu-id="d3881-1335"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is one of two memory reallocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="d3881-1336">（<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> 是另一个。）</span><span class="sxs-lookup"><span data-stu-id="d3881-1336">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> is the other.)</span></span>  
  
 <span data-ttu-id="d3881-1337">此方法从 Kernel32.dll 公开 Win32 [GlobalReAlloc](https://go.microsoft.com/fwlink/?LinkId=148780)函数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1337">This method exposes the Win32 [GlobalReAlloc](https://go.microsoft.com/fwlink/?LinkId=148780) function from Kernel32.dll.</span></span> <span data-ttu-id="d3881-1338">返回的指针可能不同于原始指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1338">The returned pointer can differ from the original.</span></span> <span data-ttu-id="d3881-1339">如果不相同，则已将原始内存块的内容复制到新块，并释放原始内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1339">If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1340">没有足够的内存来满足该请求。</span><span class="sxs-lookup"><span data-stu-id="d3881-1340">There is insufficient memory to satisfy the request.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=148781"><span data-ttu-id="d3881-1341">GlobalAlloc 函数</span><span class="sxs-lookup"><span data-stu-id="d3881-1341">GlobalAlloc Function</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberSignature Language="F#" Value="static member Release : nativeint -&gt; int" Usage="System.Runtime.InteropServices.Marshal.Release pUnk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="d3881-1342">要释放的接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-1342">The interface to release.</span></span></param>
        <summary><span data-ttu-id="d3881-1343">递减指定接口上的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1343">Decrements the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="d3881-1344"><paramref name="pUnk" /> 参数指定的接口上的新引用计数值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1344">The new value of the reference count on the interface specified by the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1345">公共语言运行时管理 COM 对象的引用计数，因此无需直接使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1345">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="d3881-1346">仅将此值用于测试目的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1346">Use this value only for testing purposes.</span></span> <span data-ttu-id="d3881-1347">在极少数情况下（例如测试自定义封送拆收器），您可能会发现需要手动操作对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="d3881-1347">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="d3881-1348">只有调用 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> 的程序才能调用 <xref:System.Runtime.InteropServices.Marshal.Release%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1348">Only programs that call <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> should call <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span></span> <span data-ttu-id="d3881-1349">当引用计数达到零时调用 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 将导致未定义的行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-1349">Calling <xref:System.Runtime.InteropServices.Marshal.Release%2A> after the reference count has reached zero causes undefined behavior.</span></span>  
  
 <span data-ttu-id="d3881-1350">可以调用 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>、<xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>或 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>，以获取表示要释放的[IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown)接口指针的 <xref:System.IntPtr> 值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1350">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents a [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface pointer to release.</span></span> <span data-ttu-id="d3881-1351">你还可以对托管对象使用这些方法和 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 方法，以释放托管对象的[com 可调用包装](~/docs/framework/interop/com-callable-wrapper.md)器所表示的 com 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-1351">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method on managed objects to release the COM interfaces represented by the managed object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1352">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 方法检索托管对象的 `IUnknown` 接口。</span><span class="sxs-lookup"><span data-stu-id="d3881-1352">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span> <span data-ttu-id="d3881-1353">然后，该示例通过调用 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 方法释放接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1353">The example then releases the interface pointer by calling the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member ReleaseComObject : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.ReleaseComObject o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="d3881-1354">要释放的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1354">The COM object to release.</span></span></param>
        <summary><span data-ttu-id="d3881-1355">递减与指定的 COM 对象关联的<see href="~/docs/framework/interop/runtime-callable-wrapper.md">运行时可调用包装器 (RCW)</see> 的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1355">Decrements the reference count of the <see href="~/docs/framework/interop/runtime-callable-wrapper.md">Runtime Callable Wrapper (RCW)</see> associated with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-1356">与 <paramref name="o" /> 关联的 RCW 的新引用计数值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1356">The new value of the reference count of the RCW associated with <paramref name="o" />.</span></span> <span data-ttu-id="d3881-1357">此值通常为零，因为无论调用包装 COM 对象的托管客户端有多少，RCW 仅保留对该对象的一次引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1357">This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1358">此方法用于显式控制从托管代码使用的 COM 对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="d3881-1358">This method is used to explicitly control the lifetime of a COM object used from managed code.</span></span> <span data-ttu-id="d3881-1359">你应使用此方法免费释放包含对资源的引用的基础 COM 对象，或在对象必须按特定顺序释放时使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1359">You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</span></span>  
  
 <span data-ttu-id="d3881-1360">每当 COM 接口指针进入公共语言运行时（CLR）时，就会将其包装在 RCW 中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1360">Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</span></span>  
  
 <span data-ttu-id="d3881-1361">RCW 有一个引用计数，每次将 COM 接口指针映射到该引用计数时，它都会递增。</span><span class="sxs-lookup"><span data-stu-id="d3881-1361">The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</span></span> <span data-ttu-id="d3881-1362"><xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法递减 RCW 的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1362">The <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method decrements the reference count of an RCW.</span></span> <span data-ttu-id="d3881-1363">当引用计数达到零时，运行时将释放其对非托管 COM 对象的所有引用，如果尝试进一步使用对象，则会引发 <xref:System.NullReferenceException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1363">When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <xref:System.NullReferenceException?displayProperty=nameWithType> if you attempt to use the object further.</span></span> <span data-ttu-id="d3881-1364">如果从非托管代码向托管代码传递了同一 COM 接口，则包装上的引用计数每次都会递增，并且调用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 将返回剩余引用的数目。</span><span class="sxs-lookup"><span data-stu-id="d3881-1364">If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> returns the number of remaining references.</span></span>  
  
 <span data-ttu-id="d3881-1365">此方法使你可以强制 RCW 引用计数版本，使其在你需要时精确地进行。</span><span class="sxs-lookup"><span data-stu-id="d3881-1365">This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</span></span> <span data-ttu-id="d3881-1366">但是，不正确地使用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 可能导致应用程序失败，或者可能导致访问冲突。</span><span class="sxs-lookup"><span data-stu-id="d3881-1366">However, improper use of <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> may cause your application to fail, or may cause an access violation.</span></span>  
  
 <span data-ttu-id="d3881-1367">假设应用程序域中的托管代码持有的应用程序域中的托管代码包含在表示 COM 组件的 RCW 上。</span><span class="sxs-lookup"><span data-stu-id="d3881-1367">Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</span></span> <span data-ttu-id="d3881-1368">如果对 RCW 调用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法，托管代码将无法访问 RCW，并引发 <xref:System.Runtime.InteropServices.InvalidComObjectException> 异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1368">If you call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the RCW, the managed code will be unable to access the RCW and will raise an <xref:System.Runtime.InteropServices.InvalidComObjectException> exception.</span></span>  
  
 <span data-ttu-id="d3881-1369">如果在释放 RCW 时执行对 RCW 的调用，则可能发生更严重的错误。</span><span class="sxs-lookup"><span data-stu-id="d3881-1369">A more serious error may occur if a call to the RCW is executing when the RCW is released.</span></span> <span data-ttu-id="d3881-1370">在这种情况下，发出调用的线程很有可能会导致访问冲突。</span><span class="sxs-lookup"><span data-stu-id="d3881-1370">In this case, there is a good chance that the thread making the call will cause an access violation.</span></span> <span data-ttu-id="d3881-1371">但是，进程内存可能会损坏，进程可能会继续运行，直到由于很难调试的原因而失败。</span><span class="sxs-lookup"><span data-stu-id="d3881-1371">However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</span></span>  
  
 <span data-ttu-id="d3881-1372">如果正在使用的 COM 组件是单一实例，则此风险更加复杂，原因如下： CLR 通过调用 COM [CoCreateInstance](https://go.microsoft.com/fwlink/?LinkID=142894)函数来激活 com 组件，在每次为单独 COM 组件调用该函数时，它都会返回相同的接口指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1372">This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM [CoCreateInstance](https://go.microsoft.com/fwlink/?LinkID=142894) function, which returns the same interface pointer every time it is called for singleton COM components.</span></span> <span data-ttu-id="d3881-1373">因此，应用程序域中的单独的和独立的托管代码段可以对单独 COM 组件使用同一个 RCW，如果其中任何一个都调用 COM 组件上的 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法，则另一个将被破坏。</span><span class="sxs-lookup"><span data-stu-id="d3881-1373">Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the COM component, the other will be broken.</span></span>  
  
 <span data-ttu-id="d3881-1374">因此，仅当绝对需要时才使用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1374">Therefore, use the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> only if it is absolutely required.</span></span> <span data-ttu-id="d3881-1375">如果要调用此方法以确保在确定的时间释放 COM 组件，请考虑改用 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1375">If you want to call this method to ensure that a COM component is released at a determined time, consider using the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method instead.</span></span> <span data-ttu-id="d3881-1376"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 将释放基础 COM 组件，而不考虑它重新进入 CLR 的次数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1376"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> will release the underlying COM component regardless of how many times it has re-entered the CLR.</span></span> <span data-ttu-id="d3881-1377">每当 COM 组件重新进入 CLR 时，RCW 的内部引用计数将递增1。</span><span class="sxs-lookup"><span data-stu-id="d3881-1377">The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</span></span> <span data-ttu-id="d3881-1378">因此，可以在循环中调用 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 方法，直到返回的值为零。</span><span class="sxs-lookup"><span data-stu-id="d3881-1378">Therefore, you could call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until the value returned is zero.</span></span> <span data-ttu-id="d3881-1379">这样就实现了与 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 方法相同的结果。</span><span class="sxs-lookup"><span data-stu-id="d3881-1379">This achieves the same result as the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1380"><paramref name="o" /> 不是有效的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1380"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="d3881-1381"><paramref name="o" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1381"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberSignature Language="F#" Value="static member ReleaseThreadCache : unit -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ReleaseThreadCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API did not perform any operation and will be removed in future versions of the CLR.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3881-1382">释放线程缓存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1382">Releases the thread cache.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToBSTR : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1383">要复制的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1383">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1384">分配非托管<see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">二进制字符串 (BSTR)</see>并将托管 <see cref="T:System.Security.SecureString" /> 对象的内容复制到其中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1384">Allocates an unmanaged <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">binary string (BSTR)</see> and copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1385">非托管内存中将 <paramref name="s" /> 参数复制到的地址；如果提供了 null 对象，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1385">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1386"><xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> 方法对于自定义封送处理或混合托管代码和非托管代码很有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1386">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1387">由于此方法会分配字符串所需的非托管内存，因此在通过调用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> 方法完成后，请始终释放 `BSTR`。</span><span class="sxs-lookup"><span data-stu-id="d3881-1387">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1388">
          <paramref name="s" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1388">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1389">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1389">There is insufficient memory available.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToCoTaskMemAnsi : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1390">要复制的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1390">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1391">将托管 <see cref="T:System.Security.SecureString" /> 对象的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1391">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1392">非托管内存中将 <paramref name="s" /> 参数复制到的地址；如果提供了 null 对象，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1392">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1393"><xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 方法对于自定义封送处理或混合托管代码和非托管代码很有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1393">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1394">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1394">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span></span> <span data-ttu-id="d3881-1395">将字符串的字符复制为 ANSI 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1395">The characters of the string are copied as ANSI characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1396">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 方法将 <xref:System.Security.SecureString> 对象的内容封送到非托管内存块并对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="d3881-1396">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="d3881-1397">然后，它使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 方法为零出并释放非托管块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1397">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1398">
          <paramref name="s" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1398">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1399">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1399">There is insufficient memory available.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToCoTaskMemUnicode : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1400">要复制的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1400">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1401">将托管 <see cref="T:System.Security.SecureString" /> 对象的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1401">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1402">非托管内存中将 <paramref name="s" /> 参数复制到的地址；如果提供了 null 对象，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1402">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1403"><xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 方法对于自定义封送处理或混合托管代码和非托管代码很有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1403">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1404">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 方法来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1404">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method.</span></span> <span data-ttu-id="d3881-1405">将字符串的字符作为 Unicode 字符进行复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-1405">The characters of the string are copied as Unicode characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1406">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 方法将 <xref:System.Security.SecureString> 对象的内容封送到非托管内存块并对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="d3881-1406">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="d3881-1407">然后，它使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 方法为零出并释放非托管块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1407">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1408">
          <paramref name="s" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1408">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1409">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1409">There is insufficient memory available.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToGlobalAllocAnsi : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1410">要复制的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1410">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1411">将托管 <see cref="T:System.Security.SecureString" /> 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1411">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="d3881-1412">非托管内存中将 <paramref name="s" /> 参数复制到的地址，或者，如果提供了 null 对象，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1412">The address, in unmanaged memory, to where the <paramref name="s" /> parameter was copied, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1413"><xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 方法对于自定义封送处理或混合托管代码和非托管代码很有用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1413">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1414">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 方法来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1414">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1415">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 方法将 <xref:System.Security.SecureString> 对象的内容封送到非托管内存块并对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="d3881-1415">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="d3881-1416">然后，它使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 方法为零出并释放非托管块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1416">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1417">
          <paramref name="s" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1417">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1418">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1418">There is insufficient memory available.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberSignature Language="F#" Value="static member SecureStringToGlobalAllocUnicode : System.Security.SecureString -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1419">要复制的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1419">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="d3881-1420">将托管 <see cref="T:System.Security.SecureString" /> 对象的内容复制到非托管内存中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1420">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1421">非托管内存中复制 <paramref name="s" /> 的地址，如果 <paramref name="s" /> 是长度为 0 的 <see cref="T:System.Security.SecureString" /> 对象，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1421">The address, in unmanaged memory, where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is a <see cref="T:System.Security.SecureString" /> object whose length is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1422">当混合托管代码和非托管代码时，<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 方法适用于自定义封送处理或用于使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1422">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1423">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 方法来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1423">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1424">下面的示例演示如何将 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 方法与非托管 `LogonUser` 函数一起使用，以对 <xref:System.Security.SecureString> 类执行模拟。</span><span class="sxs-lookup"><span data-stu-id="d3881-1424">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="d3881-1425">然后，该示例使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 方法为零出并释放非托管的字符串引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1425">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1426">
          <paramref name="s" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1426">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1427">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1427">There is insufficient memory available.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetComObjectData : obj * obj * obj -&gt; bool" Usage="System.Runtime.InteropServices.Marshal.SetComObjectData (obj, key, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="key" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="data" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d3881-1428">用于存储数据的 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1428">The COM object in which to store the data.</span></span></param>
        <param name="key"><span data-ttu-id="d3881-1429">用于存储数据的 COM 对象的内部哈希表中的键。</span><span class="sxs-lookup"><span data-stu-id="d3881-1429">The key in the internal hash table of the COM object in which to store the data.</span></span></param>
        <param name="data"><span data-ttu-id="d3881-1430">要设置的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-1430">The data to set.</span></span></param>
        <summary><span data-ttu-id="d3881-1431">设置由指定 COM 对象中的指定键引用的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-1431">Sets data referenced by the specified key in the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="d3881-1432">如果数据设置成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1432"><see langword="true" /> if the data was set successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1433">在[运行时可调用包装（RCW）](~/docs/framework/interop/runtime-callable-wrapper.md)中包装的所有 COM 对象都有一个关联的哈希表，<xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> 将数据添加到该表中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1433">All COM objects wrapped in a [Runtime Callable Wrapper (RCW)](~/docs/framework/interop/runtime-callable-wrapper.md) have an associated hash table, to which <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> adds data.</span></span> <span data-ttu-id="d3881-1434"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> 从哈希表中检索数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-1434"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> retrieves data from the hash table.</span></span> <span data-ttu-id="d3881-1435">决不要从代码中调用这两种方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1435">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1436"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1436"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1437">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1437">-or-</span></span> 
 <span data-ttu-id="d3881-1438"><paramref name="key" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1438"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1439"><paramref name="obj" /> 不是 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1439"><paramref name="obj" /> is not a COM object.</span></span>  
  
<span data-ttu-id="d3881-1440">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1440">-or-</span></span> 
 <span data-ttu-id="d3881-1441"><paramref name="obj" /> 是一个 [!INCLUDE[wrt](~/includes/wrt-md.md)] 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1441"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1442">返回类的非托管大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1442">Returns the unmanaged size, in bytes, of a class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberSignature Language="F#" Value="static member SizeOf : obj -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf structure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("SizeOf(Object) may be unavailable in future releases. Instead, use SizeOf&lt;T&gt;(). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296514")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="d3881-1443">要返回其大小的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1443">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="d3881-1444">返回对象的非托管大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1444">Returns the unmanaged size of an object in bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-1445">非托管代码中指定对象的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1445">The size of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1446">此方法接受结构的实例，该实例可以是引用类型或装箱值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1446">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="d3881-1447">布局必须是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1447">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="d3881-1448">返回的大小是非托管对象的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1448">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="d3881-1449">对象的非托管和托管大小可能不同。</span><span class="sxs-lookup"><span data-stu-id="d3881-1449">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="d3881-1450">对于字符类型，大小受应用于该类的 <xref:System.Runtime.InteropServices.CharSet> 值影响。</span><span class="sxs-lookup"><span data-stu-id="d3881-1450">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="d3881-1451">您可以使用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 方法来确定要使用 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 和 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> 方法分配的非托管内存量。</span><span class="sxs-lookup"><span data-stu-id="d3881-1451">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1452">下面的示例创建一个托管结构，将其传输到非托管内存，然后将其传输回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1452">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</span></span> <span data-ttu-id="d3881-1453">此示例使用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 方法来确定要分配的非托管内存量。</span><span class="sxs-lookup"><span data-stu-id="d3881-1453">This example uses the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1454">
          <paramref name="structure" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1454">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberSignature Language="F#" Value="static member SizeOf : Type -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("SizeOf(Type) may be unavailable in future releases. Instead, use SizeOf&lt;T&gt;(). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296515")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="d3881-1455">要返回其大小的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1455">The type whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="d3881-1456">返回非托管类型的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1456">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-1457">非托管代码中指定类型的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1457">The size of the specified type in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1458">如果没有结构，可以使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1458">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="d3881-1459">布局必须是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1459">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="d3881-1460">返回的大小为非托管类型的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1460">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="d3881-1461">对象的非托管和托管大小可能不同。</span><span class="sxs-lookup"><span data-stu-id="d3881-1461">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="d3881-1462">对于字符类型，大小受应用于该类的 <xref:System.Runtime.InteropServices.CharSet> 值影响。</span><span class="sxs-lookup"><span data-stu-id="d3881-1462">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1463">下面的示例演示如何调用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1463">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method.</span></span> <span data-ttu-id="d3881-1464">此代码示例是为 <xref:System.Runtime.InteropServices.Marshal> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3881-1464">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1465"><paramref name="t" /> 参数是泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="d3881-1465">The <paramref name="t" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1466">
          <paramref name="t" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1466">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member SizeOf : unit -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf " FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1467">要返回其大小的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1467">The type whose size is to be returned.</span></span></typeparam>
        <summary><span data-ttu-id="d3881-1468">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1468">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1469">返回非托管类型的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1469">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-1470"><typeparamref name="T" /> 泛型类型参数指定的类型的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1470">The size, in bytes, of the type that is specified by the <typeparamref name="T" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1471">如果没有结构，可以使用此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1471">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="d3881-1472">布局必须是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1472">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="d3881-1473">返回的大小为非托管类型的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1473">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="d3881-1474">对象的非托管和托管大小可能不同。</span><span class="sxs-lookup"><span data-stu-id="d3881-1474">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="d3881-1475">对于字符类型，大小受应用于该类的 <xref:System.Runtime.InteropServices.CharSet> 值影响。</span><span class="sxs-lookup"><span data-stu-id="d3881-1475">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberSignature Language="F#" Value="static member SizeOf : 'T -&gt; int" Usage="System.Runtime.InteropServices.Marshal.SizeOf structure" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1476"><paramref name="structure" /> 参数的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1476">The type of the <paramref name="structure" /> parameter.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="d3881-1477">要返回其大小的对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1477">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="d3881-1478">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1478">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1479">返回指定类型的对象的非托管大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1479">Returns the unmanaged size of an object of a specified type in bytes.</span></span></summary>
        <returns><span data-ttu-id="d3881-1480">非托管代码中指定对象的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1480">The size, in bytes, of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1481">此方法接受结构的实例，该实例可以是引用类型或装箱值类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1481">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="d3881-1482">布局必须是连续或显式的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1482">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="d3881-1483">返回的大小是非托管对象的大小。</span><span class="sxs-lookup"><span data-stu-id="d3881-1483">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="d3881-1484">对象的非托管和托管大小可能不同。</span><span class="sxs-lookup"><span data-stu-id="d3881-1484">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="d3881-1485">对于字符类型，大小受应用于该类的 <xref:System.Runtime.InteropServices.CharSet> 值影响。</span><span class="sxs-lookup"><span data-stu-id="d3881-1485">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="d3881-1486">通过使用 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 和 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> 方法，你可以使用 <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> 方法来确定要分配的非托管内存量。</span><span class="sxs-lookup"><span data-stu-id="d3881-1486">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method to determine how much unmanaged memory to allocate by using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3881-1487">
          <paramref name="structure" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1487">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToBSTR : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1488">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1488">The managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1489">分配 <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</see> 并向其复制托管 <see cref="T:System.String" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="d3881-1489">Allocates a <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</see> and copies the contents of a managed <see cref="T:System.String" /> into it.</span></span></summary>
        <returns><span data-ttu-id="d3881-1490">指向 <see langword="BSTR" /> 的非托管指针；如果 <paramref name="s" /> 为 Null，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1490">An unmanaged pointer to the <see langword="BSTR" />, or 0 if <paramref name="s" /> is null.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1491"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1491"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1492">由于此方法会分配字符串所需的非托管内存，因此在通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>完成后，请始终释放 `BSTR`。</span><span class="sxs-lookup"><span data-stu-id="d3881-1492">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1493">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1493">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1494">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1494">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1495"><paramref name="s" /> 的长度超出范围。</span><span class="sxs-lookup"><span data-stu-id="d3881-1495">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemAnsi : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1496">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1496">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1497">将托管 <see cref="T:System.String" /> 的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1497">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1498">一个整数，表示指向字符串的内存块的指针；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1498">An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1499"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1499"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1500">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1500">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="d3881-1501">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1501">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1502">将字符串的字符复制为 ANSI 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1502">The characters of the string are copied as ANSI characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1503">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1503">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1504"><paramref name="s" /> 参数超过了操作系统所允许的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3881-1504">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemAuto : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1505">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1505">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1506">将托管 <see cref="T:System.String" /> 的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1506">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1507">已分配的内存块；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1507">The allocated memory block, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1508"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1508"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1509">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1509">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="d3881-1510">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1510">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1511">将字符串的字符复制为 ANSI 或 Unicode 字符，具体取决于执行代码的操作系统。</span><span class="sxs-lookup"><span data-stu-id="d3881-1511">The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</span></span> <span data-ttu-id="d3881-1512">在 Windows 98 上，字符将复制为 ANSI 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1512">On Windows 98, the characters are copied as ANSI characters.</span></span> <span data-ttu-id="d3881-1513">在 Windows NT 4.0、Windows 2000、Windows XP 和 Windows Server 2003 系列上，字符将复制为 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1513">On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1514">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1514">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1515"><paramref name="s" /> 的长度超出范围。</span><span class="sxs-lookup"><span data-stu-id="d3881-1515">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemUni : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1516">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1516">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1517">将托管 <see cref="T:System.String" /> 的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1517">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1518">一个整数，表示指向为字符串分配的内存块的指针；如果 s 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1518">An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1519"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1519"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1520">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1520">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1521">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1521">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1522">将字符串的字符作为 Unicode 字符进行复制。</span><span class="sxs-lookup"><span data-stu-id="d3881-1522">The characters of the string are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1523"><paramref name="s" /> 参数超过了操作系统所允许的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3881-1523">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1524">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1524">There is insufficient memory available.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToCoTaskMemUTF8 : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8 s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1525">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1525">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1526">将托管 <see cref="T:System.String" /> 的内容复制到从非托管 COM 任务分配器分配的内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1526">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="d3881-1527">一个整数，表示指向字符串的内存块的指针；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1527">An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d3881-1528"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1528"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1529">由于此方法会分配包含 null 终止符的字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1529">Because this method allocates the unmanaged memory required for a string including a null terminator, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1530">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1530">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUTF8%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3881-1531">将字符串的字符复制为 UTF-8 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1531">The characters of the string are copied as UTF-8 characters.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1532"><paramref name="s" /> 参数超过了操作系统所允许的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3881-1532">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1533">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1533">There is insufficient memory available.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalAnsi : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1534">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1534">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1535">将托管 <see cref="T:System.String" /> 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1535">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="d3881-1536">非托管内存中将 <paramref name="s" /> 复制到其中的地址；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1536">The address, in unmanaged memory, to where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1537"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 适用于自定义封送或混合托管和非托管代码。</span><span class="sxs-lookup"><span data-stu-id="d3881-1537"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1538">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1538">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="d3881-1539"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1539"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1540">此方法复制嵌入的 null 字符，并包含一个终止 null 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1540">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1541">下面的示例演示如何将托管 <xref:System.String> 类的内容转换为非托管内存，并在完成后释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1541">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1542">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1542">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1543"><paramref name="s" /> 参数超过了操作系统所允许的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3881-1543">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalAuto : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1544">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1544">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1545">将托管 <see cref="T:System.String" /> 的内容复制到非托管内存，并在需要时转换为 ANSI 格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1545">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format if required.</span></span></summary>
        <returns><span data-ttu-id="d3881-1546">非托管内存中将字符串复制到其中的地址；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1546">The address, in unmanaged memory, to where the string was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1547"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1547"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1548">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1548">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="d3881-1549">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1549">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1550">此方法复制嵌入的 null 字符，并包含一个终止 null 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1550">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1551">下面的示例演示如何将托管 <xref:System.String> 类的内容转换为非托管内存，并在完成后释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1551">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1552">没有足够的可用内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1552">There is insufficient memory available.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member StringToHGlobalUni : string -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.StringToHGlobalUni s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1553">要复制的托管字符串。</span><span class="sxs-lookup"><span data-stu-id="d3881-1553">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="d3881-1554">将托管 <see cref="T:System.String" /> 的内容复制到非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1554">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="d3881-1555">非托管内存中将 <paramref name="s" /> 复制到其中的地址；如果 <paramref name="s" /> 为 <see langword="null" />，则为 0。</span><span class="sxs-lookup"><span data-stu-id="d3881-1555">The address, in unmanaged memory, to where the <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1556"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> 适用于自定义封送处理，或在混合托管和非托管代码时使用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1556"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="d3881-1557">由于此方法会分配字符串所需的非托管内存，因此请始终通过调用 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>来释放内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1557">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="d3881-1558">此方法提供 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>的相反功能。</span><span class="sxs-lookup"><span data-stu-id="d3881-1558">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1559">此方法复制嵌入的 null 字符，并包含一个终止 null 字符。</span><span class="sxs-lookup"><span data-stu-id="d3881-1559">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="d3881-1560">此方法未能分配足够的本机堆内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1560">The method could not allocate enough native heap memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d3881-1561"><paramref name="s" /> 参数超过了操作系统所允许的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3881-1561">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="F#" Value="static member StructureToPtr : obj * nativeint * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.StructureToPtr (structure, ptr, fDeleteOld)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("StructureToPtr(Object, IntPtr, Boolean) may be unavailable in future releases. Instead, use StructureToPtr&lt;T&gt;(T, IntPtr, Boolean). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296516")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="d3881-1562">包含要封送的数据的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1562">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="d3881-1563">该对象必须是格式化类的结构或实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-1563">This object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="d3881-1564">指向非托管内存块的指针，必须在调用此方法之前分配该指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1564">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld"><span data-ttu-id="d3881-1565">如果在此方法复制该数据前在 <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> 参数上调用 <paramref name="ptr" />，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1565"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method on the <paramref name="ptr" /> parameter before this method copies the data.</span></span> <span data-ttu-id="d3881-1566">该块必须包含有效的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-1566">The block must contain valid data.</span></span> <span data-ttu-id="d3881-1567">请注意，在内存块已包含数据时传递 <see langword="false" /> 可能会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="d3881-1567">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="d3881-1568">将数据从托管对象封送到非托管内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1568">Marshals data from a managed object to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1569">如果 `structure` 是值类型，则可以装箱或取消装箱。</span><span class="sxs-lookup"><span data-stu-id="d3881-1569">If `structure` is a value type, it can be boxed or unboxed.</span></span> <span data-ttu-id="d3881-1570">如果已装箱，则会在复制前取消装箱。</span><span class="sxs-lookup"><span data-stu-id="d3881-1570">If it is boxed, it is unboxed before copying.</span></span>  
  
 <span data-ttu-id="d3881-1571">格式化类是一种引用类型，其布局由 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性指定，如 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 或 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1571">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1572"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 将 `structure` 的内容复制到 `ptr` 参数指向的预分配内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1572"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="d3881-1573">如果 `structure` 包含封送到 COM 接口指针的引用类型（接口、无布局的类和 <xref:System.Object?displayProperty=nameWithType>），则托管对象将与引用计数保持活动状态。</span><span class="sxs-lookup"><span data-stu-id="d3881-1573">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="d3881-1574">所有其他引用类型（如字符串和数组）都将封送到副本。</span><span class="sxs-lookup"><span data-stu-id="d3881-1574">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="d3881-1575">若要释放这些托管或非托管对象，必须先调用 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> 方法，然后再释放内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1575">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="d3881-1576">如果使用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 方法稍后将不同的实例复制到内存块，请指定 `fDeleteOld` 的 `true`，以便删除上一实例中引用类型的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1576">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="d3881-1577">否则，托管引用类型和非托管副本实际上是泄漏的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1577">Otherwise, the managed reference types and unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="d3881-1578">使用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 的整体模式如下所示：</span><span class="sxs-lookup"><span data-stu-id="d3881-1578">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> is as follows:</span></span>  
  
1.  <span data-ttu-id="d3881-1579">在分配内存块后第一次调用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 方法时，必须 `false``fDeleteOld`，因为没有要清除的内容。</span><span class="sxs-lookup"><span data-stu-id="d3881-1579">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d3881-1580">仅当块包含有效数据时，才为 `fDeleteOld` 指定 `true`。</span><span class="sxs-lookup"><span data-stu-id="d3881-1580">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="d3881-1581">如果将不同的实例复制到内存块，并且该对象包含引用类型，则必须将 `fDeleteOld` `true` 到旧内容中的引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1581">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="d3881-1582">如果对象包含引用类型，则在释放内存块之前必须调用 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1582">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-1583">若要固定现有结构而不是复制它，请使用 <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> 类型创建该结构的固定句柄。</span><span class="sxs-lookup"><span data-stu-id="d3881-1583">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="d3881-1584">有关如何固定的详细信息，请参阅[复制和锁定](~/docs/framework/interop/copying-and-pinning.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-1584">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1585">下面的示例创建一个托管结构，使用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 方法将其传输到非托管内存，然后使用 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 方法将它传输回托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1585">The following example creates a managed structure, transfers it to unmanaged memory using the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1586"><paramref name="structure" /> 为不是格式化类的引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1586"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span>  
  
<span data-ttu-id="d3881-1587">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1587">-or-</span></span> 
 <span data-ttu-id="d3881-1588"><paramref name="structure" /> 是泛型类型的实例（仅限 .NET Framework 4.5 和更低版本）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1588"><paramref name="structure" /> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="F#" Value="static member StructureToPtr : 'T * nativeint * bool -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.StructureToPtr (structure, ptr, fDeleteOld)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ptr" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1589">托管对象的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1589">The type of the managed object.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="d3881-1590">包含要封送的数据的托管对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1590">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="d3881-1591">该对象必须是格式化类的结构或实例。</span><span class="sxs-lookup"><span data-stu-id="d3881-1591">The object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="d3881-1592">指向非托管内存块的指针，必须在调用此方法之前分配该指针。</span><span class="sxs-lookup"><span data-stu-id="d3881-1592">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld"><span data-ttu-id="d3881-1593">如果在此方法复制该数据前在 <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> 参数上调用 <paramref name="ptr" />，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1593"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> method on the <paramref name="ptr" /> parameter before this method copies the data.</span></span> <span data-ttu-id="d3881-1594">该块必须包含有效的数据。</span><span class="sxs-lookup"><span data-stu-id="d3881-1594">The block must contain valid data.</span></span> <span data-ttu-id="d3881-1595">请注意，在内存块已包含数据时传递 <see langword="false" /> 可能会导致内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="d3881-1595">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="d3881-1596">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1596">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1597">将数据从指定类型的托管对象封送到非托管内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1597">Marshals data from a managed object of a specified type to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1598">格式化类是一种引用类型，其布局由 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性指定，如 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 或 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3881-1598">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3881-1599"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 将 `structure` 的内容复制到 `ptr` 参数指向的预分配内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1599"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="d3881-1600">如果 `structure` 包含封送到 COM 接口指针的引用类型（接口、无布局的类和 <xref:System.Object?displayProperty=nameWithType>），则托管对象将与引用计数保持活动状态。</span><span class="sxs-lookup"><span data-stu-id="d3881-1600">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="d3881-1601">所有其他引用类型（如字符串和数组）都将封送到副本。</span><span class="sxs-lookup"><span data-stu-id="d3881-1601">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="d3881-1602">若要释放这些托管或非托管对象，必须先调用 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> 方法，然后再释放内存块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1602">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="d3881-1603">如果使用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 方法稍后将不同的实例复制到内存块，请指定 `fDeleteOld` 的 `true`，以便删除上一实例中引用类型的引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1603">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="d3881-1604">否则，托管引用类型和非托管副本实际上是泄漏的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1604">Otherwise, the managed reference types and unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="d3881-1605">使用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 的整体模式如下所示：</span><span class="sxs-lookup"><span data-stu-id="d3881-1605">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="d3881-1606">在分配内存块后第一次调用 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 方法时，必须 `false``fDeleteOld`，因为没有要清除的内容。</span><span class="sxs-lookup"><span data-stu-id="d3881-1606">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d3881-1607">仅当块包含有效数据时，才为 `fDeleteOld` 指定 `true`。</span><span class="sxs-lookup"><span data-stu-id="d3881-1607">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="d3881-1608">如果将不同的实例复制到内存块，并且该对象包含引用类型，则必须将 `fDeleteOld` `true` 到旧内容中的引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1608">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="d3881-1609">如果对象包含引用类型，则在释放内存块之前必须调用 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1609">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3881-1610">若要固定现有结构而不是复制它，请使用 <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> 类型创建该结构的固定句柄。</span><span class="sxs-lookup"><span data-stu-id="d3881-1610">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="d3881-1611">有关如何固定的详细信息，请参阅[复制和锁定](~/docs/framework/interop/copying-and-pinning.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-1611">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1612"><paramref name="structure" /> 为不是格式化类的引用类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1612"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable SystemDefaultCharSize : int" Usage="System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3881-1613">表示系统上的默认字符大小；Unicode 系统上默认值为 2，ANSI 系统上默认值为 1。</span><span class="sxs-lookup"><span data-stu-id="d3881-1613">Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</span></span> <span data-ttu-id="d3881-1614">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d3881-1614">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d3881-1615">下面的示例演示 <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> 字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-1615">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="d3881-1616">此代码示例是为 <xref:System.Runtime.InteropServices.Marshal> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3881-1616">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable SystemMaxDBCSCharSize : int" Usage="System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3881-1617">表示用于当前操作系统的双字节字符集 (DBCS) 的最大大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1617">Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</span></span> <span data-ttu-id="d3881-1618">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="d3881-1618">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d3881-1619">下面的示例演示 <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> 字段。</span><span class="sxs-lookup"><span data-stu-id="d3881-1619">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="d3881-1620">此代码示例是为 <xref:System.Runtime.InteropServices.Marshal> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="d3881-1620">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1621">用特定的失败 HRESULT 值引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1621">Throws an exception with a specific failure HRESULT value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberSignature Language="F#" Value="static member ThrowExceptionForHR : int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR errorCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="d3881-1622">与所需异常相对应的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-1622">The HRESULT corresponding to the desired exception.</span></span></param>
        <summary><span data-ttu-id="d3881-1623">用特定的失败 HRESULT 值引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1623">Throws an exception with a specific failure HRESULT value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1624">此方法为指定的失败 HRESULT 创建异常对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1624">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="d3881-1625">如果 HRESULT 为0或正数（成功代码），则方法将返回，而不创建或引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1625">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="d3881-1626">请注意，<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> 方法返回一个异常，该异常基于当前线程的[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口（如果已设置）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1626">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> method returns an exception based on the [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface of the current thread if one is set.</span></span> <span data-ttu-id="d3881-1627">发生这种情况时，将忽略 `errorCode` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1627">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="d3881-1628">某些失败 Hresult 映射到定义的异常，而其他失败。</span><span class="sxs-lookup"><span data-stu-id="d3881-1628">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="d3881-1629">如果 HRESULT 映射到定义的异常，<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 将创建异常的实例并引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1629">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="d3881-1630">否则，它将创建一个 <xref:System.Runtime.InteropServices.COMException>实例，使用 HRESULT 初始化错误代码字段，并引发此异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1630">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="d3881-1631">调用 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 时，它会使用非托管[GetErrorInfo](/windows/win32/api/oleauto/nf-oleauto-geterrorinfo)函数尝试检索有关错误的额外信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-1631">When <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged [GetErrorInfo](/windows/win32/api/oleauto/nf-oleauto-geterrorinfo) function.</span></span>  
  
 <span data-ttu-id="d3881-1632">有关从每个 HRESULT 到 .NET Framework 中的可比较异常类的映射，请参阅[如何：映射 hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-1632">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 <span data-ttu-id="d3881-1633">偶尔，<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 可能会从以前的 COM 调用返回异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1633">Occasionally, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> might return an exception from a previous COM call.</span></span> <span data-ttu-id="d3881-1634">在这种情况下，可以使用以下解决方法并将 `IntPtr(-1)` 作为第二个参数（`errorInfo`）传递：</span><span class="sxs-lookup"><span data-stu-id="d3881-1634">In this case, you can use the following workaround and pass `IntPtr(-1)` as the second parameter (`errorInfo`):</span></span>  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="F#" Value="static member ThrowExceptionForHR : int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR (errorCode, errorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="d3881-1635">与所需异常相对应的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3881-1635">The HRESULT corresponding to the desired exception.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="d3881-1636">指向 <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> 接口的指针，该接口提供有关错误的详细信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-1636">A pointer to the <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> interface that provides more information about the error.</span></span> <span data-ttu-id="d3881-1637">可以指定 <c>IntPtr(0)</c> 以使用当前的 <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> 接口，或者 <c>IntPtr(-1)</c> 以忽略当前的 <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> 接口，并仅从错误代码构造异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1637">You can specify <c>IntPtr(0)</c> to use the current <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> interface, or <c>IntPtr(-1)</c> to ignore the current <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="d3881-1638">基于指定的 <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> 接口，用特定的失败 HRESULT 引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1638">Throws an exception with a specific failure HRESULT, based on the specified <see href="/windows/win32/api/oaidl/nn-oaidl-ierrorinfo">IErrorInfo</see> interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1639">此方法为指定的失败 HRESULT 创建异常对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1639">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="d3881-1640">如果 HRESULT 为0或正数（成功代码），则方法将返回，而不创建或引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1640">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="d3881-1641"><xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 方法释放 `errorInfo` 参数，从而降低[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口的 COM 引用计数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1641">The <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method releases the `errorInfo` parameter, decreasing the COM reference count of the [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface.</span></span>  
  
 <span data-ttu-id="d3881-1642">请注意，<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 方法返回一个异常，该异常基于当前线程的[IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo)接口（如果已设置）。</span><span class="sxs-lookup"><span data-stu-id="d3881-1642">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method returns an exception based on the [IErrorInfo](/windows/win32/api/oaidl/nn-oaidl-ierrorinfo) interface of the current thread if one is set.</span></span> <span data-ttu-id="d3881-1643">发生这种情况时，将忽略 `errorCode` 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1643">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="d3881-1644">某些失败 Hresult 映射到定义的异常，而其他失败。</span><span class="sxs-lookup"><span data-stu-id="d3881-1644">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="d3881-1645">如果 HRESULT 映射到定义的异常，<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 将创建异常的实例并引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1645">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="d3881-1646">否则，它将创建一个 <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>实例，使用 HRESULT 初始化错误代码字段，并引发此异常。</span><span class="sxs-lookup"><span data-stu-id="d3881-1646">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="d3881-1647">`errorInfo` 参数用于检索有关错误的额外信息。</span><span class="sxs-lookup"><span data-stu-id="d3881-1647">The `errorInfo` parameter is used to retrieve extra information regarding the error.</span></span>  
  
 <span data-ttu-id="d3881-1648">有关从每个 HRESULT 到 .NET Framework 中的可比较异常类的映射，请参阅[如何：映射 hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3881-1648">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberSignature Language="F#" Value="static member UnsafeAddrOfPinnedArrayElement : Array * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement (arr, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("UnsafeAddrOfPinnedArrayElement(Array, Int32) may be unavailable in future releases. Instead, use UnsafeAddrOfPinnedArrayElement&lt;T&gt;(T[], Int32). For more info, go to http://go.microsoft.com/fwlink/?LinkID=296517")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr"><span data-ttu-id="d3881-1649">包含所需元素的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1649">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="d3881-1650">所需元素的 <paramref name="arr" /> 参数中的索引。</span><span class="sxs-lookup"><span data-stu-id="d3881-1650">The index in the <paramref name="arr" /> parameter of the desired element.</span></span></param>
        <summary><span data-ttu-id="d3881-1651">获取指定数组中指定索引处的元素的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1651">Gets the address of the element at the specified index inside the specified array.</span></span></summary>
        <returns><span data-ttu-id="d3881-1652"><paramref name="arr" /> 内的 <paramref name="index" /> 地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1652">The address of <paramref name="index" /> inside <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1653">必须先使用 <xref:System.Runtime.InteropServices.GCHandle> 固定数组，然后才能将其传递到此方法。</span><span class="sxs-lookup"><span data-stu-id="d3881-1653">The array must be pinned using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="d3881-1654">为了获得最佳性能，此方法不会验证传递给它的数组;这可能会导致意外的行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-1654">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberSignature Language="F#" Value="static member UnsafeAddrOfPinnedArrayElement : 'T[] * int -&gt; nativeint" Usage="System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement (arr, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d3881-1655">数组的类型。</span><span class="sxs-lookup"><span data-stu-id="d3881-1655">The type of the array.</span></span></typeparam>
        <param name="arr"><span data-ttu-id="d3881-1656">包含所需元素的数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1656">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="d3881-1657"><paramref name="arr" /> 数组中所需元素的索引。</span><span class="sxs-lookup"><span data-stu-id="d3881-1657">The index of the desired element in the <paramref name="arr" /> array.</span></span></param>
        <summary><span data-ttu-id="d3881-1658">[在 .NET Framework 4.5.1 和更高版本中受支持]</span><span class="sxs-lookup"><span data-stu-id="d3881-1658">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="d3881-1659">获取指定类型的数组中指定索引处的元素地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1659">Gets the address of the element at the specified index in an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="d3881-1660"><paramref name="arr" /> 中的 <paramref name="index" /> 地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1660">The address of <paramref name="index" /> in <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1661">在将数组传递给此方法之前，必须使用 <xref:System.Runtime.InteropServices.GCHandle> 固定该数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1661">The array must be pinned by using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="d3881-1662">为了获得最佳性能，此方法不会验证传递给它的数组;这可能会导致意外的行为。</span><span class="sxs-lookup"><span data-stu-id="d3881-1662">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1663">将单个字节值写入到非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1663">Writes a single byte value to unmanaged memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : nativeint * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1664">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1664">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1665">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1665">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1666">将单个字节值写入到非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1666">Writes a single byte value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1667"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1667"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1668">下面的示例创建非托管内存块，将字节写入非托管内存，从非托管内存读取字节，然后释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1668">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1669"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1669"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1670">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1670">-or-</span></span> 
 <span data-ttu-id="d3881-1671"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1671"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1672">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1672">-or-</span></span> 
 <span data-ttu-id="d3881-1673"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1673"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : nativeint * int * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WU1&quot; winapi)void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1674">非托管内存中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1674">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1675">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1675">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1676">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1676">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1677">按指定偏移量将单字节值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1677">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1678"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1678"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1679">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1679">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1680">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1680">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(object ptr, int32 ofs, unsigned int8 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberSignature Language="F#" Value="static member WriteByte : obj * int * byte -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteByte (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WU1&quot; winapi)void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteByte(Object, Int32, Byte) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1681">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1681">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1682">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1682">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1683">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1683">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1684">按指定偏移量将单字节值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1684">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1685"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1685"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1686">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1686">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1687"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1687"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1688">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1688">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1689">将 16 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1689">Writes a 16-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="d3881-1690">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1690">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1691">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1691">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1692">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1692">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1693">将一个字符作为 16 位整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1693">Writes a character as a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1694"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1694"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1695">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1695">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1696">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1696">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1697"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1697"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1698">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1698">-or-</span></span> 
 <span data-ttu-id="d3881-1699"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1699"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1700">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1700">-or-</span></span> 
 <span data-ttu-id="d3881-1701"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1701"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1702">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1702">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1703">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1703">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1704">将 16 位整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1704">Writes a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1705"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1705"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1706">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1706">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1707">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1707">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1708"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1708"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1709">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1709">-or-</span></span> 
 <span data-ttu-id="d3881-1710"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1710"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1711">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1711">-or-</span></span> 
 <span data-ttu-id="d3881-1712"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1712"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1713">本机堆中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1713">The base address in the native heap to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1714">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1714">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1715">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1715">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1716">按指定偏移量将 16 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1716">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1717"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1717"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1718">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1718">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1719">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1719">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1720">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1720">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : nativeint * int * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI2&quot; winapi)void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1721">非托管内存中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1721">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1722">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1722">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1723">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1723">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1724">按指定偏移量将 16 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1724">Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1725"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1725"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1726">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1726">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1727">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1727">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1728">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1728">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(object ptr, int32 ofs, char val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : obj * int * char -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteInt16(Object, Int32, Char) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1729">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1729">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1730">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1730">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1731">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1731">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1732">按指定偏移量将 16 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1732">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1733"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1733"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1734">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1734">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1735">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1735">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1736"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1736"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1737">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1737">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(object ptr, int32 ofs, int16 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberSignature Language="F#" Value="static member WriteInt16 : obj * int * int16 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt16 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI2&quot; winapi)void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteInt16(Object, Int32, Int16) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1738">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1738">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1739">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1739">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1740">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1740">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1741">按指定偏移量将 16 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1741">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1742"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 可实现与非托管16位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1742"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1743">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1743">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1744">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1744">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1745"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1745"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1746">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1746">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1747">将 32 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1747">Writes a 32-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="d3881-1748">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1748">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : nativeint * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1749">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1749">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1750">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1750">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1751">将 32 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1751">Writes a 32-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1752"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 可实现与非托管32位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1752"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1753">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1753">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1754">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1754">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1755"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1755"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1756">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1756">-or-</span></span> 
 <span data-ttu-id="d3881-1757"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1757"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1758">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1758">-or-</span></span> 
 <span data-ttu-id="d3881-1759"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1759"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : nativeint * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI4&quot; winapi)void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1760">非托管内存中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1760">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1761">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1761">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1762">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1762">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1763">按指定偏移量将 32 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1763">Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1764"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 可实现与非托管32位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1764"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1765">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1765">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1766">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1766">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1767">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1767">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(object ptr, int32 ofs, int32 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberSignature Language="F#" Value="static member WriteInt32 : obj * int * int -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt32 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI4&quot; winapi)void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteInt32(Object, Int32, Int32) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1768">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1768">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1769">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1769">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1770">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1770">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1771">按指定偏移量将 32 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1771">Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1772"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 可实现与非托管32位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1772"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1773">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1773">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1774">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1774">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1775"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1775"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1776">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1776">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1777">将 64 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1777">Writes a 64-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="d3881-1778">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1778">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : nativeint * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1779">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1779">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1780">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1780">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1781">将 64 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1781">Writes a 64-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1782"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 可实现与非托管64位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1782"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1783">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1783">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1784">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1784">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1785"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1785"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1786">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1786">-or-</span></span> 
 <span data-ttu-id="d3881-1787"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1787"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1788">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1788">-or-</span></span> 
 <span data-ttu-id="d3881-1789"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1789"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : nativeint * int * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI8&quot; winapi)void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1790">非托管内存中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1790">The base address in unmanaged memory to write.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1791">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1791">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1792">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1792">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1793">按指定偏移量将 64 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1793">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1794"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 可实现与非托管64位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1794"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1795">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1795">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1796">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1796">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1797">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1797">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(object ptr, int32 ofs, int64 val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberSignature Language="F#" Value="static member WriteInt64 : obj * int * int64 -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteInt64 (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;mscoree.dll&quot; as &quot;ND_WI8&quot; winapi)void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteInt64(Object, Int32, Int64) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1798">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1798">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1799">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1799">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1800">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1800">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1801">按指定偏移量将 64 位带符号整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1801">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1802"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 可实现与非托管64位已签名数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1802"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1803">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1803">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1804">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1804">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1805"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1805"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1806">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1806">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3881-1807">将一个处理器本机大小的整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1807">Writes a processor native-sized integer value to unmanaged memory.</span></span> <span data-ttu-id="d3881-1808">在 32 位系统上写入 32 位整数，在 64 位系统上写入 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1808">32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</span></span> <span data-ttu-id="d3881-1809">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1809">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : nativeint * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1810">非托管内存中要写入的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1810">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1811">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1811">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1812">将一个处理器本机大小的整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1812">Writes a processor native sized integer value into unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1813"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 支持与非托管 C 样式的 `IntPtr` 数组直接交互，从而消除了在设置其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的费用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1813"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1814">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1814">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1815">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1815">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1816"><paramref name="ptr" /> 不是识别的格式。</span><span class="sxs-lookup"><span data-stu-id="d3881-1816"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
<span data-ttu-id="d3881-1817">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1817">-or-</span></span> 
 <span data-ttu-id="d3881-1818"><paramref name="ptr" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3881-1818"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d3881-1819">- 或 -</span><span class="sxs-lookup"><span data-stu-id="d3881-1819">-or-</span></span> 
 <span data-ttu-id="d3881-1820"><paramref name="ptr" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="d3881-1820"><paramref name="ptr" /> is invalid.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : nativeint * int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, ofs, val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1821">非托管内存中要写入的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1821">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1822">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1822">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1823">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1823">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1824">按指定的偏移量将一个处理器本机大小的整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1824">Writes a processor native-sized integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1825">此方法在32位系统上写入32位整数，在64位系统上写入64位整数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1825">This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</span></span>  
  
 <span data-ttu-id="d3881-1826"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 支持与非托管 C 样式的 `IntPtr` 数组直接交互，从而消除了在设置其元素值之前将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独的托管数组的费用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1826"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1827">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1827">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1828">下面的示例演示如何使用 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 和 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 方法读取和写入非托管数组。</span><span class="sxs-lookup"><span data-stu-id="d3881-1828">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1829">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1829">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(object ptr, int32 ofs, native int val) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="F#" Value="static member WriteIntPtr : obj * int * nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.WriteIntPtr (ptr, ofs, val)" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("WriteIntPtr(Object, Int32, IntPtr) may be unavailable in future releases.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="d3881-1830">非托管内存中目标对象的基址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1830">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="d3881-1831">额外的字节偏移量，在写入前添加到 <paramref name="ptr" /> 参数中。</span><span class="sxs-lookup"><span data-stu-id="d3881-1831">An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="d3881-1832">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1832">The value to write.</span></span></param>
        <summary><span data-ttu-id="d3881-1833">将一个处理器本机大小的整数值写入非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1833">Writes a processor native sized integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1834"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 实现与非托管 C 样式字节数组的直接交互，消除将整个非托管数组（使用 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>）复制到单独托管数组的开销，然后再设置其元素值。</span><span class="sxs-lookup"><span data-stu-id="d3881-1834"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="d3881-1835">支持写入未对齐的内存位置。</span><span class="sxs-lookup"><span data-stu-id="d3881-1835">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="d3881-1836">基址 (<paramref name="ptr" />) 加上偏移字节 (<paramref name="ofs" />) 可产生空或无效地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1836">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3881-1837"><paramref name="ptr" /> 是 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3881-1837"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="d3881-1838">此方法不接受 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="d3881-1838">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeBSTR : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeBSTR s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1839">要释放的 <see langword="BSTR" /> 的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1839">The address of the <see langword="BSTR" /> to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1840">释放 <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</see> 指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1840">Frees a <see href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</see> pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1841"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> 方法首先将 BSTR 的内容设置为零，然后释放 BSTR。</span><span class="sxs-lookup"><span data-stu-id="d3881-1841">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method first sets the contents of the BSTR to zero, and then frees the BSTR.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemAnsi : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1842">要释放的非托管字符串的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1842">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1843">释放非托管字符串指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1843">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1844">首先，<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 方法为零，然后释放使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 方法分配的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1844">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1845">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 方法将 <xref:System.Security.SecureString> 对象的内容封送到非托管内存块并对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="d3881-1845">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="d3881-1846">然后，它使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 方法为零出并释放非托管块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1846">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemUnicode : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1847">要释放的非托管字符串的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1847">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1848">释放非托管字符串指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1848">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1849">首先，<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 方法为零，然后释放使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 方法分配的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1849">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeCoTaskMemUTF8 : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8 s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.1">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1850">要释放的非托管字符串的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1850">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1851">释放非托管字符串指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1851">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d3881-1852">首先，<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8%2A> 方法为零，然后释放使用 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A> 方法分配的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1852">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8%2A> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeGlobalAllocAnsi : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1853">要释放的非托管字符串的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1853">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1854">释放非托管字符串指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1854">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1855">首先，<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 方法为零，然后释放使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 方法分配的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1855">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1856">下面的示例使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 方法将 <xref:System.Security.SecureString> 对象的内容封送到非托管内存块并对其进行解密。</span><span class="sxs-lookup"><span data-stu-id="d3881-1856">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="d3881-1857">然后，它使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 方法为零出并释放非托管块。</span><span class="sxs-lookup"><span data-stu-id="d3881-1857">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberSignature Language="F#" Value="static member ZeroFreeGlobalAllocUnicode : nativeint -&gt; unit" Usage="System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="d3881-1858">要释放的非托管字符串的地址。</span><span class="sxs-lookup"><span data-stu-id="d3881-1858">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="d3881-1859">释放非托管字符串指针，该指针是使用 <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> 方法分配的。</span><span class="sxs-lookup"><span data-stu-id="d3881-1859">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3881-1860">首先，<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 方法为零，然后释放使用 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 方法分配的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="d3881-1860">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3881-1861">下面的示例演示如何将 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 方法与非托管 `LogonUser` 函数一起使用，以对 <xref:System.Security.SecureString> 类执行模拟。</span><span class="sxs-lookup"><span data-stu-id="d3881-1861">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="d3881-1862">然后，该示例使用 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 方法为零出并释放非托管的字符串引用。</span><span class="sxs-lookup"><span data-stu-id="d3881-1862">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
