<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="024df7cc78d995adb3427cc15951449d2b50de7e" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102093680" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一组有助于管理 ASP.NET 应用程序编译的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager>类管理应用程序的程序集和页面的编译过程。 它是一个密封类，不能被继承。  
  
 <xref:System.Web.Compilation.BuildManager> 包含提供有关编译的程序集的信息的静态成员。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dependency">一个表示依赖项的字符串。</param>
        <summary>指定表示生成管理器使用的依赖项帮助确定是否需要干净生成的字符串。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在应用程序的阶段，必须调用方法 `Application_PreStartInit` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="dependency" /> 参数为 <see langword="null" /> 或空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">在此应用程序的 <see langword="Application_PreStartInit" /> 阶段后调用该方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddReferencedAssembly (assembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">要添加的程序集。</param>
        <summary>将一个程序集添加到应用程序所引用的一组程序集中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法等效于将程序集添加到应用程序级 Web.config 文件中。 在应用程序的阶段，必须调用方法 `Application_PreStartInit` 。  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A>方法将返回从配置文件和通过使用此方法添加的任何程序集确定的程序集集。  
  
 如果尝试添加已添加的程序集，则会忽略重复项。  
  
 `Application_Start`在 global.asax 文件中发生事件之前，必须调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 参数为 <see langword="null" /> 或为空。</exception>
        <exception cref="T:System.InvalidOperationException">此方法不在 Global.asax 文件中的 <see langword="Application_Start" /> 事件发生前调用。</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static bool? BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示是否启用批处理编译的值。</summary>
        <value>如果始终启用批处理编译，则为 <see langword="true" />；如果从不启用批处理编译，则为 <see langword="false" />；如果根据配置文件确定编译设置，则为 <see langword="null" />。 默认值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够以编程方式打开或关闭批处理编译。 它对应于 `batch` `compilation` Web.config 文件中元素的属性。 有关详细信息，请参阅 [编译元素 (ASP.NET Settings Schema) ](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/s10awwz0(v=vs.100))。  
  
 只能在方法中设置此属性 `PreApplicationStart` 。 有关 `PreApplicationStart` 方法的更多信息，请参见 <xref:System.Web.PreApplicationStartMethodAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该属性不用 <see langword="PreApplicationStart" /> 方法设置。</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取从 App_Code 目录生成的程序集的列表。</summary>
        <value>一个 <see cref="T:System.Collections.IList" /> 集合，包含从 App_Code 目录生成的程序集。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">要创建的文件的名称。</param>
        <summary>创建一个缓存文件。</summary>
        <returns>新文件的 <see cref="T:System.IO.Stream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 利用此方法和 <xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A> 方法，你可以执行在部分信任环境中跨应用程序域重新启动的缓存。 MVC 框架使用它来缓存控制器查找的结果。  
  
 若要缓存数据，你需要写入 <xref:System.IO.Stream> 由此方法返回的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要为其创建实例的文件的虚拟路径。</param>
        <param name="requiredBaseType">定义要创建的对象的基类型。</param>
        <summary>处理给定了虚拟路径的文件，并创建结果的实例。</summary>
        <returns><see cref="T:System.Object" />，表示被处理文件的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A>方法适用于编译和非编译页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从 ASP.NET 缓存中返回生成依赖项集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">请求的上下文。</param>
        <param name="virtualPath">确定生成依赖项集的虚拟路径。</param>
        <summary>如果虚拟路径位于 ASP.NET 缓存中，则为虚拟路径返回生成依赖项集。</summary>
        <returns>存储在缓存中的 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 对象，或者，如果无法从缓存中检索 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="virtualPath" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">请求的上下文。</param>
        <param name="virtualPath">确定生成依赖项集的虚拟路径。</param>
        <param name="ensureIsUpToDate">如果为 <see langword="true" />，则指定只应返回最新的生成依赖项集，或者，如果为 <see langword="false" />，则指示应返回任何可用的生成依赖项集（即使不是最新）。 默认值为 <see langword="true" />。</param>
        <summary>如果虚拟路径位于 ASP.NET 缓存中，则为虚拟路径返回生成依赖项集，即使内容不是最新也是如此。</summary>
        <returns>存储在缓存中的 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 对象，或者，如果无法从缓存中检索 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 对象，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `ensureIsUpToDate` 将参数值设置为 `true` ，则 <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> 方法重载的行为与 <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> 方法重载类似。 两个重载返回一个当前生成依赖项集（如果存在），否则返回 `null` 。  
  
 但是， <xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType> 方法重载包含用于返回任何可用的生成依赖项集（甚至是过期的）的选项。 如果将 `ensureIsUpToDate` 参数值设置为 `false` ，则该方法将返回任何可用的生成依赖项集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要生成为程序集的虚拟路径。</param>
        <summary>使用指定虚拟路径将文件编译为程序集。</summary>
        <returns>从指定的虚拟路径进行编译并缓存到内存或磁盘的 <see cref="T:System.Reflection.Assembly" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要生成的文件的虚拟路径。</param>
        <summary>编译给定了虚拟路径的文件，并返回生成提供程序保存在缓存中的自定义字符串。</summary>
        <returns>由缓存到磁盘或内存的 <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" /> 方法返回的字符串。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要生成为某个类型的虚拟路径。</param>
        <summary>编译给定了虚拟路径的文件，并返回编译类型。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示通过编译虚拟路径生成的类型。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">编译虚拟路径时发生错误。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取表示 Global.asax 文件编译的类型的对象。</summary>
        <returns>表示 Global.asax 文件编译的类型的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在编译 global.asax 文件之前调用此方法，则会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已尝试编译 Global.asax 页之前调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">虚拟路径。</param>
        <param name="throwIfNotFound">如果要在虚拟路径不存在时引发错误，则为 <see langword="true" />；否则为 <see langword="false" />。 如果虚拟路径不存在，并且 <paramref name="throwIfNotFound" /> 为 <see langword="false" />，则此方法返回 <see langword="null" />。</param>
        <summary>为指定虚拟路径获取对象工厂。</summary>
        <returns>对象工厂。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回一个对象，该对象使你可以通过编译虚拟路径生成一个类型。 它将返回一个对象，而不管是否预编译了该网站。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">虚拟路径不存在。  
  
 - 或 -  
  
 在调用该方法时已存在更高级别的异常。  
  
 - 或 -  
  
 在编译过程构建顶级文件时调用此方法。  
  
 - 或 -  
  
 这是一个预编译的应用程序，在缓存中找不到虚拟路径。  
  
 - 或 -  
  
 检测到含循环引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回所有页编译都必须引用的程序集引用的列表。</summary>
        <returns>程序集引用的 <see cref="T:System.Collections.ICollection" /> 集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从方法返回的程序集的集合 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> 包括在 Web.config 文件的 [程序集](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bfyb45k1(v=vs.100)) 元素中指定的程序集、从 App_Code 目录中的自定义代码生成的程序集和其他顶级文件夹中的程序集。  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> .NET Framework 版本3.5 中引入。  有关详细信息，请参见 [.NET Framework 版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在顶级程序集或配置中定义的程序集内查找类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顶级程序集指的是 global.asax 文件，或者是位于 App_GlobalResources、App_WebReferences、App_Code 或 App_Browsers 目录下的文件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">类型的名称。</param>
        <param name="throwOnError">如果无法为类型名称生成 <see cref="T:System.Type" /> 对象，则为 <see langword="true" /> 以引发异常；否则为 <see langword="false" />。</param>
        <summary>在顶级程序集或配置中定义的程序集内查找类型，失败时可选择引发异常。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示请求的 <paramref name="typeName" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顶级程序集指的是 global.asax 文件，或者是位于 App_GlobalResources、App_WebReferences、App_Code 或 App_Browsers 目录下的文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> 无效。  
  
- 或 - 
 <paramref name="typeName" /> 不明确。  
  
- 或 - 
 未能找到 <paramref name="typeName" />，且 <paramref name="throwOnError" /> 为 <see langword="true" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">类型的名称。</param>
        <param name="throwOnError">如果无法为类型名称生成 <see cref="T:System.Type" />，则为 <see langword="true" /> 以引发异常；否则为 <see langword="false" />。</param>
        <param name="ignoreCase">如果 <paramref name="typeName" /> 区分大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用不区分大小写的搜索，在顶级程序集或配置中定义的程序集内查找类型，失败时可选择引发异常。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示请求的 <paramref name="typeName" /> 参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顶级程序集指的是 global.asax 文件，或者是位于 App_GlobalResources、App_WebReferences、App_Code 或 App_Browsers 目录下的文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> 无效。  
  
- 或 - 
 <paramref name="typeName" /> 不明确。  
  
- 或 - 
 未能找到 <paramref name="typeName" />，且 <paramref name="throwOnError" /> 为 <see langword="true" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">用于确定依赖项的虚拟路径。</param>
        <summary>为指定虚拟路径提供虚拟路径依赖项的集合。</summary>
        <returns>缓存虚拟路径依赖项的虚拟路径所表示的文件的 <see cref="T:System.Collections.ICollection" /> 集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指定应用程序是否编译的值。</summary>
        <value>如果可以预编译应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指定应用程序是否编译为可更新的值。</summary>
        <value>如果应用程序可以更新预编译，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">要读取的文件的名称。</param>
        <summary>读取一个缓存文件。</summary>
        <returns>文件的 <see cref="T:System.IO.Stream" /> 对象；如果文件不存在，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 利用此方法和 <xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A> 方法，你可以执行在部分信任环境中跨应用程序域重新启动的缓存。 MVC 框架使用它来缓存控制器查找的结果。  
  
 若要检索缓存的数据，请从 <xref:System.IO.Stream> 该方法返回的对象读取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前网站的 .NET Framework 的目标版本。</summary>
        <value>当前网站的 .NET Framework 的目标版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性支持 ASP.NET 多目标功能，该功能使你能够使用最新版本的 Visual Studio 来开发将使用早期版本的 .NET Framework 运行的应用程序。 生成提供程序可以使用此属性来确保提供程序生成适用于 .NET Framework 目标版本的代码。 例如，你可能想要生成不同的代码，具体取决于网站是面向 .NET Framework 3.5 还是 .NET Framework 4。 有关多目标的详细信息，请参阅 [ASP.NET Web 项目 .NET Framework 多目标](https://docs.microsoft.com/previous-versions/aspnet/bb398791(v=vs.100))。  
  
 如果网站没有 Web.config 文件，ASP.NET 将假定目标 framework 版本是与运行网站的 IIS 应用程序池相关联的版本。 对于在 Visual Studio 中运行的文件系统网站，默认的框架版本是 .NET Framework 的当前版本。  
  
 如果网站确实有 Web.config 文件，ASP.NET 将通过检查 Web.config 文件确定目标框架。  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>面向 .NET Framework 2.0 的网站  
 面向 .NET Framework 2.0 的 Web 应用程序将编译为 .NET Framework 3.0 的目标。 生成过程不区分 .NET Framework 2.0 和 .NET Framework 3.0，因为 Web.config 文件在目标为这些版本之一时不指示编译器版本或目标框架。  (.NET Framework 3.5，Web.config 文件指定编译器版本，对于 .NET Framework 4，Web.config 文件指定目标框架。 ) 因此，对于面向 .NET Framework 2.0 的 Web 应用程序，此属性将返回指示 .NET Framework 3.0 的目标框架名字对象。  
  
 这通常不会导致任何问题。 Visual Studio 会阻止你创建对 .NET Framework 2.0 针对的项目中 .NET Framework 3.0 功能的引用。 例如，Visual Studio 不会为针对 .NET Framework 2.0 的项目中的 WCF 服务提供项模板，因为 WCF 是使用 .NET Framework 3.0 引入的，与 .NET Framework 2.0 不兼容。  
  
 如果计划在 .NET Framework 2.0 运行时环境中部署网站，而使用 Visual Studio 之外的工具来引用仅与 .NET Framework 3.0 兼容的功能，则项目可能会生成，而不会生成错误或警告。 但是，当网站在 .NET Framework 2.0 上运行时，应用程序可能会生成错误。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
