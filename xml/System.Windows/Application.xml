<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7058b694015356d88452b58c07456d96407700ce" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102082591" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>封装 Windows Presentation Foundation 应用程序。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 是一个类，用于封装特定于 WPF 应用程序的功能，包括以下内容：  
  
-   **应用程序生存期**： <xref:System.Windows.Application.Activated> 、 <xref:System.Windows.Application.Current%2A> 、 <xref:System.Windows.Application.Deactivated> 、、、、、、 <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit> <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding> <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.ShutdownMode%2A> 、 <xref:System.Windows.Application.Startup> 。  
  
-   **应用程序作用域窗口、属性和资源管理**： <xref:System.Windows.Application.FindResource%2A> 、 <xref:System.Windows.Application.GetContentStream%2A> 、 <xref:System.Windows.Application.GetResourceStream%2A> 、 <xref:System.Windows.Application.LoadComponent%2A> 、 <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.Resources%2A> <xref:System.Windows.Application.StartupUri%2A> 、、 <xref:System.Windows.Application.Windows%2A> 、、。  
  
-   **命令行参数和退出代码处理**： <xref:System.Windows.Application.Startup?displayProperty=nameWithType> 、 <xref:System.Windows.Application.Exit?displayProperty=nameWithType> 、 <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType> 。  
  
-   **导航**： <xref:System.Windows.Application.FragmentNavigation> 、 <xref:System.Windows.Application.LoadCompleted> 、 <xref:System.Windows.Application.Navigated> 、 <xref:System.Windows.Application.Navigating> 、 <xref:System.Windows.Application.NavigationProgress> 、 <xref:System.Windows.Application.NavigationStopped> <xref:System.Windows.Application.NavigationFailed> <xref:System.Windows.Application.SetCookie%2A> <xref:System.Windows.Application.GetCookie%2A> 、、、。  
  
 <xref:System.Windows.Application> 实现单独模式以提供对其窗口、属性和资源范围服务的共享访问。 因此，只能 <xref:System.Windows.Application> 为每个创建类的一个实例 <xref:System.AppDomain> 。  
  
 可以 <xref:System.Windows.Application> 使用标记、标记和代码隐藏来实现，也可以使用代码来实现。 如果 <xref:System.Windows.Application> 是通过标记实现的，无论标记、标记和代码隐藏，都必须将标记文件配置为 Microsoft 生成引擎 (MSBuild) `ApplicationDefinition` 项。  
  
> [!NOTE]
>  独立应用程序不需要 <xref:System.Windows.Application> 对象; 可以实现自定义 `static` 入口点方法 (`Main`) 打开窗口而不创建实例 <xref:System.Windows.Application> 。 但是，XAML 浏览器应用程序 (Xbap) 需要 <xref:System.Windows.Application> 对象。  
  
   
  
## Examples  
 下面的示例演示如何使用仅标记定义标准应用程序：  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 下面的示例演示如何使用代码仅定义标准应用程序：  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 下面的示例演示如何使用标记和代码隐藏的组合定义标准应用程序。  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see langword="static" /> <see langword="Shared" /> 此类型) 成员 Visual Basic 中的公共 (是线程安全的。 此外， <see cref="M:System.Windows.Application.FindResource(System.Object)" /> 和 <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> 方法以及 <see cref="P:System.Windows.Application.Properties" /> 和 <see cref="P:System.Windows.Application.Resources" /> 属性都是线程安全的。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Application" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只能 <xref:System.Windows.Application> 根据创建类的一个实例 <xref:System.AppDomain> ，以确保对一组应用程序范围窗口、属性和资源数据进行共享访问。 因此，类的无参数构造函数 <xref:System.Windows.Application> 检测要初始化的实例是否是中的第一个实例 <xref:System.AppDomain> ; 如果不是，则 <xref:System.InvalidOperationException> 引发。  
  
 <xref:System.Windows.Application>当前的对象 <xref:System.AppDomain> 是从静态属性公开的 <xref:System.Windows.Application.Current%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于每个 <see cref="T:System.Windows.Application" />，都会创建 <see cref="T:System.AppDomain" /> 类的多个实例。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序成为前台应用程序时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已激活一个或多个打开的 windows 的 Windows Presentation Foundation 应用程序 (成为前台应用程序) 当应用程序启动时第一次激活某个 windows，或在应用程序处于非活动状态时激活某个 windows 时：具体而言，在以下情况下会发生激活：  
  
-   应用程序打开其第一个窗口。  
  
-   用户使用 ALT + TAB 或使用任务管理器切换到该应用程序。  
  
-   用户单击应用程序中某个窗口的任务栏按钮。  
  
 需要检测激活时间的应用程序可以处理 <xref:System.Windows.Application.Activated> 事件。  
  
 第一次激活应用程序后，它可能会在其生存期内停用并多次重新激活。 如果应用程序的行为或状态取决于其激活状态，则它可以处理 <xref:System.Windows.Application.Activated> 和 <xref:System.Windows.Application.Deactivated> 事件以确定它所在的激活状态。  
  
 当应用程序激活后， <xref:System.Windows.Application.Activated> 在应用程序停用之前将不会再次引发，而不管应用程序处于活动状态时，应用程序中的多少窗口处于激活状态。  
  
 <xref:System.Windows.Application.Activated> (Xbap) 的 XAML 浏览器应用程序不会引发。  
  
   
  
## Examples  
 下面的示例演示如何在独立应用程序激活和停用时进行检测。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</summary>
        <value>当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 是一个每 <xref:System.AppDomain> 单独实现静态属性的类型， <xref:System.Windows.Application.Current%2A> 用于为当前的实例提供共享访问 <xref:System.Windows.Application> <xref:System.AppDomain> 。 此设计可确保由管理的状态 <xref:System.Windows.Application> （包括共享资源和状态）可从单个共享位置获得。  
  
 此属性是线程安全的，可从任何线程获得。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序停止作为前台应用程序时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户执行以下操作时，具有一个或多个打开的 Windows 的 Windows Presentation Foundation 应用程序 (停止成为前台应用程序) ：  
  
-   使用 ALT + TAB 或使用任务管理器切换到其他应用程序。  
  
-   单击另一应用程序中窗口的任务栏按钮。  
  
 需要检测停用的应用程序可以处理 <xref:System.Windows.Application.Deactivated> 事件。  
  
 第一次激活应用程序后，它可能会在其生存期内停用并多次重新激活。 如果应用程序的行为或状态取决于其激活状态，则它可以处理 <xref:System.Windows.Application.Deactivated> 和 <xref:System.Windows.Application.Activated> 事件以确定其所在的状态。  
  
 <xref:System.Windows.Application.Deactivated> (Xbap) 的 XAML 浏览器应用程序不会引发。  
  
   
  
## Examples  
 下面的示例演示如何在独立应用程序停用和激活时进行检测。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在异常由应用程序引发但未进行处理时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，Windows Presentation Foundation 捕获未处理的异常，并通过对话框通知用户 (异常，用户可以从中报告异常) ，并自动关闭应用程序。  
  
 但是，如果应用程序需要从集中位置执行自定义的未经处理的异常处理，则应处理 <xref:System.Windows.Application.DispatcherUnhandledException> 。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 由 <xref:System.Windows.Application> 主 UI 线程上运行的代码未处理的每个异常引发。  
  
 如果未在后台 UI 线程上处理异常 (具有自身) 的线程 <xref:System.Windows.Threading.Dispatcher> ，或 (没有) 的线程的后台工作线程 <xref:System.Windows.Threading.Dispatcher> ，则不会将异常转发到主 UI 线程。 因此， <xref:System.Windows.Application.DispatcherUnhandledException> 不会引发。 在这些情况下，你将需要编写代码来执行以下操作：  
  
1.  处理后台线程中的异常。  
  
2.  将这些异常调度到主 UI 线程。  
  
3.  在主 UI 线程上重新引发它们，而不处理它们以允许 <xref:System.Windows.Application.DispatcherUnhandledException> 引发。  
  
 有关详细信息，请参阅 [线程模型](/dotnet/framework/wpf/advanced/threading-model) 概述。  
  
 向 <xref:System.Windows.Application.DispatcherUnhandledException> 事件处理程序传递包含与异常相关的 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 上下文信息的参数，其中包括：  
  
-   )  (异常 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> 。  
  
-   <xref:System.Windows.Threading.Dispatcher>从中产生 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>) 。  
  
 您可以使用此信息来确定异常是否可恢复。 例如，可恢复的异常可能是，而无法恢复的异常可能是 <xref:System.IO.FileNotFoundException> <xref:System.StackOverflowException> 。  
  
 当处理中的未处理异常 <xref:System.Windows.Application.DispatcherUnhandledException> ，并且不希望 WPF 继续处理它时，需要将 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> 属性设置为 `true` 。  
  
 不同于引发的其他事件 <xref:System.Windows.Application> ，没有 <xref:System.Windows.Application.DispatcherUnhandledException> (OnDispatcherUnhandledException) 匹配的受保护虚拟实现。 因此，从派生的类 <xref:System.Windows.Application> 必须始终向注册事件处理程序 <xref:System.Windows.Application.DispatcherUnhandledException> 以处理未经处理的异常。  
  
   
  
## Examples  
 下面的示例演示如何通过处理事件来处理未经处理的异常 <xref:System.Windows.Application.DispatcherUnhandledException> 。  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>恰好在应用程序关闭之前发生，无法取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于以下原因之一，应用程序可能会关闭：  
  
-   <xref:System.Windows.Application.Shutdown%2A>对象的方法 <xref:System.Windows.Application> 以显式方式或由属性确定的方式调用 <xref:System.Windows.Application.ShutdownMode%2A> 。  
  
-   用户通过注销或关闭来结束该会话。  
  
 可以通过处理事件来检测应用程序关闭发生的时间 <xref:System.Windows.Application.Exit> ，并根据需要执行任何其他处理。  
  
 <xref:System.Windows.Application.Exit>当不需要显式调用时，还可以处理以检查或更改应用程序退出代码 <xref:System.Windows.Application.Shutdown%2A> 。 退出代码是从 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> <xref:System.Windows.ExitEventArgs> 传递给事件处理程序的自变量的属性公开的 <xref:System.Windows.Application.Exit> 。 当应用程序停止运行时，会将退出代码传递到操作系统以进行后续处理。  
  
 如果你的应用程序处理该 <xref:System.Windows.Application.SessionEnding> 事件并随后取消该事件， <xref:System.Windows.Application.Exit> 则不会引发该事件，应用程序会根据关闭模式继续运行。  
  
 可以从 XAML 浏览器应用程序 (XBAP) 设置退出代码，尽管该值会被忽略。  
  
 对于 Xbap， <xref:System.Windows.Application.Exit> 将在以下情况下引发：  
  
-   从中导航掉了 XBAP。  
  
-   在 Internet Explorer 7 中，当承载 XBAP 的选项卡关闭时。  
  
-   关闭浏览器时。  
  
 在所有情况下， <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 均忽略属性的值。  
  
   
  
## Examples  
 下面的示例演示如何执行以下操作：  
  
-   处理 <xref:System.Windows.Application.Exit> 事件。  
  
-   检查和更新 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 的属性 <xref:System.Windows.ExitEventArgs> 。  
  
-   在独立存储中将条目写入到应用程序日志。  
  
-   将应用程序状态保存到独立存储。  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源名。</param>
        <summary>使用指定的键搜索用户界面) 资源 (UI，如 <see cref="T:System.Windows.Style" /> 或 <see cref="T:System.Windows.Media.Brush" /> ，并在找不到请求的资源时引发异常 (参见 <see href="/dotnet/framework/wpf/advanced/xaml-resources">XAML 资源</see>) 。</summary>
        <returns>所请求的资源对象。 如果未找到所请求的资源，则引发 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 将首先查看指定资源的应用程序范围资源。 应用程序范围的资源由管理 <xref:System.Windows.Application> ，并从 <xref:System.Windows.Application.Resources%2A> 属性公开。 如果在应用程序范围的资源集中找不到指定的资源， <xref:System.Windows.Application.FindResource%2A> 则接下来会搜索系统资源。 系统资源是由用户定义的 shell 资源，包括颜色、字体和 shell 配置。 它们 <xref:System.Windows.SystemColors> 分别从、 <xref:System.Windows.SystemFonts> 和 <xref:System.Windows.SystemParameters> 类型公开为静态属性。 为了使用 <xref:System.Windows.Application.FindResource%2A> 获取它们，这些类型还会公开旨在传递到的资源键属性 <xref:System.Windows.Application.FindResource%2A> ; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A> 。  
  
 由于 <xref:System.Windows.Application.FindResource%2A> 返回对象，因此如果找到该资源，则必须将返回的值强制转换为相应的类型。  
  
> [!IMPORTANT]
>  如果对找不到的键调用此方法，则会引发异常。 如果你不想处理通过调用而导致的异常 <xref:System.Windows.Application.FindResource%2A> ，则调用 <xref:System.Windows.Application.TryFindResource%2A> ; <xref:System.Windows.Application.TryFindResource%2A> `null` 当找不到请求的资源时，将返回引用，并且不会引发异常。  
  
 此方法是线程安全的，可从任何线程调用。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Windows.Application.FindResource%2A> 来查找资源，并处理 <xref:System.Windows.ResourceReferenceKeyNotFoundException> 是否找不到资源。  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">无法找到资源。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序中的导航器开始导航到内容片段时，如果所需片段位于当前内容中，则导航会立即发生，或者，如果所需片段位于不同内容中，则会在加载源 XAML 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">映射到松散资源的相对 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的内容数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的内容数据文件。 如果未找到松散资源，则返回 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 是绝对 <see cref="T:System.Uri" />。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCookie (uri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />，它指定已为其创建 Cookie 的位置。</param>
        <summary>为由 <see cref="T:System.Uri" /> 指定的位置检索 Cookie。</summary>
        <returns>如果该 Cookie 存在，则为 <see cref="T:System.String" /> 值；否则会引发 <see cref="T:System.ComponentModel.Win32Exception" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 检索指定的的 cookie <xref:System.Uri> 。 如果无法检索该 cookie， <xref:System.ComponentModel.Win32Exception> 则会引发。 需要编写代码以将 cookie 字符串解析为名称/值对列表。  
  
 有关 WPF 中的 cookie 概述，请参阅 [导航概述](/dotnet/framework/wpf/app-development/navigation-overview)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><see langword="InternetGetCookie" /> <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> 如果在尝试检索指定的 cookie 时发生问题，则) 调用的函数会引发 Win32 错误 (。</exception>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">映射到源站点的松散资源的 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的源站点数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的源站点数据文件的资源流。 如果未找到松散资源，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://siteoforigin:,,,/</c> 格式。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">映射到嵌入资源的 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的资源数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的资源数据文件的资源流。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://application:,,,/</c> 格式。</exception>
        <exception cref="T:System.IO.IOException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 无法找到。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已经加载、分析并开始呈现应用程序中的导航器导航到的内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在 <xref:System.Windows.FrameworkElement.Loaded> <xref:System.Windows.Controls.Page> 访问导航内容的属性之前，请先侦听导航内容上的事件，例如事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载位于指定的统一资源标识符 (URI) 的 XAML 文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 文件可以是应用程序代码文件 (配置为 Microsoft 生成引擎 (MSBuild) 页项) 或应用程序数据文件 (资源文件、内容文件或源站点文件;请参阅 [WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)) 。  
  
> [!NOTE]
>  此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator"><see cref="T:System.Uri" />映射到相对 XAML 文件的。</param>
        <summary>加载位于指定的统一资源标识符 (URI) 的 XAML 文件，并将其转换为 XAML 文件的根元素指定的对象的实例。</summary>
        <returns>加载的 XAML 文件所指定的根元素的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将返回值显式转换为与 XAML 文件的根元素相同的类型。  
  
 XAML 文件可以是应用程序代码文件 (配置为 Microsoft 生成引擎 (MSBuild) 页项) 或应用程序数据文件 (资源文件、内容文件或源站点文件;请参阅 [WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)) 。  
  
> [!NOTE]
>  此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> 为绝对 URI。</exception>
        <exception cref="T:System.Exception">该文件不是 XAML 文件。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">与 XAML 文件的根元素具有相同类型的对象。</param>
        <param name="resourceLocator"><see cref="T:System.Uri" />映射到相对 XAML 文件的。</param>
        <summary>加载位于指定的统一资源标识符 (URI) 的 XAML 文件，并将其转换为 XAML 文件的根元素指定的对象的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 文件可以是应用程序代码文件 (配置为 Microsoft 生成引擎 (MSBuild) 页项) 或应用程序数据文件 (资源文件、内容文件或源站点文件;请参阅 [WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)) 。  
  
> [!NOTE]
>  此方法不是线程安全的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> 为绝对 URI。</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> 的类型与 XAML 文件的根元素不匹配。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序的主窗口。</summary>
        <value>一个指定为应用程序主窗口的 <see cref="T:System.Windows.Window" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 自动使用对要 <xref:System.Windows.Window> 在中实例化的第一个对象的引用进行设置 <xref:System.AppDomain> 。  
  
 您可以通过将 <xref:System.Windows.Application.MainWindow%2A> 其他 <xref:System.Windows.Application.Windows%2A> 对象赋给属性来指定其他主窗口 <xref:System.Windows.Application.MainWindow%2A> 。  
  
 如果 <xref:System.Windows.Application.ShutdownMode%2A> 对象的属性 <xref:System.Windows.Application> 设置为，则 <xref:System.Windows.ShutdownMode.OnMainWindowClose> 关闭主窗口将导致应用程序关闭。  
  
 <xref:System.Windows.Application.MainWindow%2A>如果应用程序的主窗口不是通过在 XAML 中设置属性生成的窗口，则可以通过 xaml 设置属性 <xref:System.Windows.Application.StartupUri%2A> 。 XAML 方法的两个限制是：  
  
-   您可以将仅 XAML <xref:System.Windows.Window> 或 xaml 指定 <xref:System.Windows.Navigation.NavigationWindow> 为主窗口。  
  
-   您必须设置 <xref:System.Windows.UIElement.Visibility%2A> 您指定的窗口的属性，否则将不会显示。  
  
 对要实例化的第一个对象的引用 <xref:System.Windows.Window> 也作为第一项添加到 <xref:System.Windows.Application.Windows%2A> 集合中。 如果 <xref:System.Windows.Application.MainWindow%2A> 随后使用对其他对象的引用进行设置 <xref:System.Windows.Window> ，则对主窗口的引用的项的位置将发生更改，而中项的顺序将保持不变 <xref:System.Windows.Application.Windows%2A> 。 因此，始终使用 <xref:System.Windows.Application.MainWindow%2A> 来引用主窗口，而不是中的第一项 <xref:System.Windows.Application.Windows%2A> 。  
  
> [!NOTE]
>  如果主窗口是 <xref:System.Windows.Navigation.NavigationWindow> ，并且您需要对成员的特定访问权限 <xref:System.Windows.Navigation.NavigationWindow> ，则需要将的值强制转换 <xref:System.Windows.Application.MainWindow%2A> 为 <xref:System.Windows.Navigation.NavigationWindow> 。  
>   
>  此属性仅在创建对象的线程中可用 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何查找主应用程序窗口。  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 下面的示例演示如何 <xref:System.Windows.Application.MainWindow%2A> 使用 XAML 设置。  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 下面的示例演示如何 <xref:System.Windows.Application.MainWindow%2A> 在应用程序启动过程中在代码中实例化。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> 是从浏览器承载的应用程序（如 XAML 浏览器应用程序 (Xbap) ）设置的。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已经找到应用程序中的导航器要导航到的内容时发生，尽管此时该内容可能尚未完成加载。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序中的导航器请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序中的导航器在导航到所请求内容时出现错误的情况下发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在由应用程序中的导航器管理的下载过程中定期发生，以提供导航进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用应用程序中的导航器的 <see langword="StopLoading" /> 方法时发生，或者当导航器在当前导航正在进行期间请求了一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame> 。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> 引发 <xref:System.Windows.Application.Activated> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnActivated%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnActivated%2A> 在基类中调用 <xref:System.Windows.Application.Activated> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Deactivated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> 引发 <xref:System.Windows.Application.Deactivated> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnDeactivated%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnDeactivated%2A> 在基类中调用 <xref:System.Windows.Application.Deactivated> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Exit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> 引发 <xref:System.Windows.Application.Exit> 事件。  
  
 从派生的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnExit%2A> 方法。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnExit%2A> 在基类中调用 <xref:System.Windows.Application.Exit> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.FragmentNavigation" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> 引发 <xref:System.Windows.Application.FragmentNavigation> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnFragmentNavigation%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnFragmentNavigation%2A> 在基类中调用 <xref:System.Windows.Application.FragmentNavigation> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.LoadCompleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> 引发 <xref:System.Windows.Application.LoadCompleted> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnLoadCompleted%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnLoadCompleted%2A> 在基类中调用 <xref:System.Windows.Application.LoadCompleted> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Navigated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> 引发 <xref:System.Windows.Application.Navigated> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnNavigated%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnNavigated%2A> 在基类中调用 <xref:System.Windows.Application.Navigated> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Navigating" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> 引发 <xref:System.Windows.Application.Navigating> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnNavigating%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnNavigating%2A> 在基类中调用 <xref:System.Windows.Application.Navigating> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationFailed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> 引发 <xref:System.Windows.Application.NavigationFailed> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnNavigationFailed%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnNavigationFailed%2A> 在基类中调用 <xref:System.Windows.Application.NavigationFailed> 。  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationProgress" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> 引发 <xref:System.Windows.Application.NavigationProgress> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnNavigationProgress%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnNavigationProgress%2A> 在基类中显式调用 <xref:System.Windows.Application.NavigationProgress> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationStopped" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> 引发 <xref:System.Windows.Application.NavigationStopped> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnNavigationStopped%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnNavigationStopped%2A> 在基类中调用 <xref:System.Windows.Application.NavigationStopped> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.SessionEndingCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.SessionEnding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> 引发 <xref:System.Windows.Application.SessionEnding> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnSessionEnding%2A> 。 如果需要引发，则重写的方法必须 <xref:System.Windows.Application.OnSessionEnding%2A> 在基类中调用 <xref:System.Windows.Application.SessionEnding> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.StartupEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Startup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> 引发 <xref:System.Windows.Application.Startup> 事件。  
  
 派生自的类型 <xref:System.Windows.Application> 可以重写 <xref:System.Windows.Application.OnStartup%2A> 。 <xref:System.Windows.Application.OnStartup%2A>如果需要引发事件，则重写的方法必须在基类中调用 <xref:System.Windows.Application.Startup> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序范围属性的集合。</summary>
        <value>一个包含应用程序范围的属性的 <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 公开 <xref:System.Windows.Application.Properties%2A> 可用于存储应用程序范围属性的字典。 这使你能够以线程安全方式在中的所有代码之间共享状态 <xref:System.AppDomain> ，而无需编写你自己的状态代码。  
  
 存储在中 <xref:System.Windows.Application.Properties%2A> 的属性必须转换为返回的相应类型。  
  
 <xref:System.Windows.Application.Properties%2A>属性是线程安全的，可从任何线程获取。  
  
   
  
## Examples  
 下面的示例演示如何使用创建和使用应用程序范围的属性 <xref:System.Windows.Application.Properties%2A> 。  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Reflection.Assembly" /> ，它为 WPF 应用程序中的资源提供包统一资源标识符 (uri) 。</summary>
        <value>一个对的引用，该引用为 <see cref="T:System.Reflection.Assembly" /> WPF 应用程序中的资源提供包统一资源标识符 (uri) 。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，将在运行时解析 WPF 资源，这与入口程序集有关，后者由方法返回的值标识 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 。  
  
 入口程序集是返回的程序集 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> ，可以是以下内容：  
  
-   默认应用程序域中的可执行程序集。  
  
-   要通过调用执行的第一个程序集 <xref:System.AppDomain.ExecuteAssembly%2A> 。  
  
 但是，在以下情况下，WPF 程序集无法获取对条目程序集的引用：  
  
-   非托管 (本机) 应用程序承载 WPF 程序集。  
  
-   托管应用程序通过使用以外的方法将 WPF 程序集加载到新应用程序域中来承载 WPF 程序集 <xref:System.AppDomain.ExecuteAssembly%2A> 。  
  
 在这两种情况下 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> ， `null` 将返回，并且无法解析 WPF 程序集的资源。 在这些情况下，只能 <xref:System.Windows.Application.ResourceAssembly%2A> 使用对应该用于解析资源的程序集的引用来设置。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 只能设置一次，因为加载 WPF 程序集后资源程序集不太可能会更改。  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 当 WPF 程序集可以发现入口程序集时，不能设置，也就是说，当 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 返回对程序集的引用而不是 `null` 。  
  
 此属性是线程安全的，可从任何线程获得。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework 版本3.5 中引入。  有关详细信息，请参见[版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">WPF 应用程序有一个入口程序集，或已 <see cref="P:System.Windows.Application.ResourceAssembly" /> 设置了。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Windows.Markup.Ambient]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Markup.Ambient&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序范围资源（如样式和画笔）的集合。</summary>
        <value>一个包含零个或多个应用程序范围资源的 <see cref="T:System.Windows.ResourceDictionary" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A>属性可用于跨应用程序的窗口和元素共享资源。 此外，该 <xref:System.Windows.Application.Resources%2A> 属性包含在资源查找路径中，按以下顺序遍历：  
  
1.  元素  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  系统  
  
 因此，用户界面 (UI) 元素可以绑定到应用程序范围的资源。 此外，如果资源发生更改，资源系统将确保绑定到这些资源的元素属性会自动更新以反映所做的更改。  
  
 应用程序范围的资源提供了一种简单的方法来支持应用程序中的一致主题。 通过使用标记，可以轻松地在 XAML 中创建主题 `Application.Resources` 。 但是，如果你的应用程序支持多个主题，其中可能包含大量主题元素，则使用 <xref:System.Windows.ResourceDictionary> 每个主题的一个实例来管理它们可能会更容易。 通过这种方式，可以通过将资源属性设置为相应的来应用新的主题 <xref:System.Windows.ResourceDictionary> 。  
  
 使用时有两个注意事项 <xref:System.Windows.Application.Resources%2A> 。 首先，字典 *键* 是一个对象，因此，如果设置和获取属性 (值，则需要使用完全相同的对象实例，请注意，使用字符串) 时，该键区分大小写。 其次，字典 *值* 是一个对象，因此在获取属性值时，需要将该值转换为所需的类型。  
  
 <xref:System.Windows.Application.Resources%2A> 是线程安全的，可从任何线程获得。  
  
   
  
## Examples  
此示例演示如何将 XAML 与应用程序范围资源一起使用来创建一致的视觉外观。 第一个示例来自 *app.xaml*;第二个（来自 *mainwindow.xaml*）。 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 下面的示例演示如何在 c # WPF 项目中的 App.config 文件中或在 Visual Basic WPF) 项目中的应用程序 .xaml 文件中设置应用程序资源 (。  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 下面的示例演示如何在代码中获取应用程序资源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>启动 Windows Presentation Foundation 应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动 Windows Presentation Foundation 应用程序。</summary>
        <returns>在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。 默认情况下，该退出代码值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 调用以启动 WPF 应用程序。 如果定义 <xref:System.Windows.Application> 使用标记，或标记和代码隐藏，则 <xref:System.Windows.Application.Run%2A> 将隐式调用。 但是，如果您 <xref:System.Windows.Application> 使用代码定义，则需要显式调用 <xref:System.Windows.Application.Run%2A> 。  
  
 <xref:System.Windows.Application.Run%2A>调用时，会将 <xref:System.Windows.Application> 新的 <xref:System.Windows.Threading.Dispatcher> 实例附加到 UI 线程。 接下来， <xref:System.Windows.Threading.Dispatcher> 调用对象的 <xref:System.Windows.Threading.Dispatcher.Run%2A> 方法，该方法启动消息泵来处理 windows 消息。 最后， <xref:System.Windows.Threading.Dispatcher> 对象调用对象的 <xref:System.Windows.Application> <xref:System.Windows.Application.OnStartup%2A> 方法来引发 <xref:System.Windows.Application.Startup> 事件。 因此，应用程序执行模型已在处理时建立 <xref:System.Windows.Application.Startup> ，此时应用程序被视为正在运行。  
  
 当调用时，应用程序停止运行 <xref:System.Windows.Application.Shutdown%2A> ; 属性的值 <xref:System.Windows.Application.ShutdownMode%2A> 确定何时 <xref:System.Windows.Application.Shutdown%2A> 调用，以及它是自动发生还是需要显式调用它。  
  
 <xref:System.Windows.Application.Run%2A> 只能从创建对象的线程调用 <xref:System.Windows.Application> 。 此外， <xref:System.Windows.Application.Run%2A> 不能从 XBAP 调用。  
  
   
  
## Examples  
 下面的示例演示一个使用自定义的应用程序， <xref:System.Windows.Application> 因此必须显式调用 <xref:System.Windows.Application.Run%2A> 。  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序中调用的 (例如，XAML 浏览器应用程序 (XBAP) ) 。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function Run (window As Window) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">在应用程序启动时自动打开的 <see cref="T:System.Windows.Window" />。</param>
        <summary>启动 Windows Presentation Foundation 应用程序并打开指定窗口。</summary>
        <returns>在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。 默认情况下，该退出代码值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载扩展 <xref:System.Windows.Application.Run%2A> 方法，以便在应用程序开始运行后打开指定窗口。  
  
 如果定义在 <xref:System.Windows.Application> 开始运行时打开窗口的代码，则显式调用 <xref:System.Windows.Application.Run%2A> 。  
  
 如果 <xref:System.Windows.Application> 使用标记或标记和代码隐藏创建，则可以在使用以下任一方法时自动打开窗口：  
  
-   以声明方式通过设置 <xref:System.Windows.Application.StartupUri%2A> 。  
  
-   以编程方式处理 <xref:System.Windows.Application.Startup> 。  
  
   
  
## Examples  
 下面的示例显示一个应用程序，该应用程序具有一个手动创建的静态入口点方法，该方法 <xref:System.Windows.Application> 在调用之前实例化 <xref:System.Windows.Application.Run%2A> 。  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序中调用的 (例如，XAML 浏览器应用程序 (XBAP) ) 。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户通过注销或关闭操作系统来结束 Windows 会话时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，当 Windows 会话结束时，应用程序会关闭，这在用户注销或关闭时发生。 发生这种情况时，Windows 会要求每个打开的应用程序关闭。 但是，在发生这种情况时，应用程序可能不能关闭。 例如，应用程序的数据可能处于不一致的状态，或者处于长时间运行的操作的中间。 在这些情况下，可能需要防止会话结束，并且可能更需要允许用户选择是否要让会话结束的情况。  
  
 可以通过处理事件来检测会话结束的时间 <xref:System.Windows.Application.SessionEnding> 。 如果应用程序需要阻止会话结束，则 <xref:System.Windows.SessionEndingCancelEventArgs> 传递到事件处理程序的参数将公开 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 设置为 `true` (默认值为 `false`) 的。  
  
 如果 <xref:System.Windows.Application.SessionEnding> 未处理或在未取消的情况下进行处理， <xref:System.Windows.Application.Shutdown%2A> 则将调用并 <xref:System.Windows.Application.Exit> 引发事件。  
  
 若要获取有关会话结束原因的详细信息，应用程序可以检查 <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A> ，这是 <xref:System.Windows.ReasonSessionEnding> 值 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> 和 <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>) 之一。  
  
 <xref:System.Windows.Application.SessionEnding> 不是由控制台应用程序引发的。  
  
 <xref:System.Windows.Application.SessionEnding> 仅在创建对象的线程上引发 <xref:System.Windows.Application> 。  
  
 <xref:System.Windows.Application.SessionEnding> (Xbap) 的 XAML 浏览器应用程序不会引发。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Windows.Application.SessionEnding> 事件并允许用户取消该事件。  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCookie (uri As Uri, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />，它指定应为其创建 Cookie 的位置。</param>
        <param name="value">包含 Cookie 数据的 <see cref="T:System.String" />。</param>
        <summary>为由 <see cref="T:System.Uri" /> 指定的位置创建一个 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是一项随机数据，在应用程序会话 (会话 cookie) 或跨应用程序会话 (持久性 cookie) 时，应用程序可以将这些数据存储在客户端计算机上。 可以通过调用创建这两种类型的 cookie <xref:System.Windows.Application.SetCookie%2A> 。  
  
 Cookie 数据通常采用以下格式的名称/值对的形式：  
  
 `Name=Value`  
  
 将此格式的字符串传递给 <xref:System.Windows.Application.SetCookie%2A> ，以及应将 cookie 设置到的 <xref:System.Uri> 位置 (通常为应用程序域) 。  
  
 Cookie 是会话 cookie 还是永久性 cookie 取决于您传递到的 cookie 字符串是否 <xref:System.Windows.Application.SetCookie%2A> 包含到期日期。 会话 cookie 的字符串不包括到期日期。 持久 cookie 的字符串具有，并且必须采用以下格式：  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 永久性 cookie 存储在当前 Windows 安装的临时 Internet 文件文件夹中，直到它们过期，在这种情况下，将删除这些 cookie。 可以通过将应用程序的到期日期设置为过去的日期/时间值，从应用程序中删除持久性 cookie。  
  
 有关 WPF 中的 cookie 概述，请参阅 [导航概述](/dotnet/framework/wpf/app-development/navigation-overview)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><see langword="InternetSetCookie" /> <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> 如果尝试创建指定的 cookie 时发生问题，则) 调用的函数会引发 Win32 错误 (。</exception>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭一个应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭一个应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Shutdown%2A>调用时，应用程序停止运行。 可以通过处理 <xref:System.Windows.Application.Exit> 事件来检测应用程序何时停止运行，以执行任何适当的处理。  
  
 <xref:System.Windows.Application.Shutdown%2A> 在以下情况下，Windows Presentation Foundation 隐式调用：  
  
-   当 <xref:System.Windows.Application.ShutdownMode%2A> 设置为时 <xref:System.Windows.ShutdownMode.OnLastWindowClose> 。  
  
-   当 <xref:System.Windows.Application.ShutdownMode%2A> 设置为时 <xref:System.Windows.ShutdownMode.OnMainWindowClose> 。  
  
-   当用户结束会话并且 <xref:System.Windows.Application.SessionEnding> 事件未处理或未取消处理时。  
  
 <xref:System.Windows.Application.Shutdown%2A>显式调用会导致应用程序关闭，而不考虑 <xref:System.Windows.Application.ShutdownMode%2A> 设置。 但是，如果将 <xref:System.Windows.Application.ShutdownMode%2A> 设置为 <xref:System.Windows.ShutdownMode.OnExplicitShutdown> ，则必须调用 <xref:System.Windows.Application.Shutdown%2A> 以关闭应用程序。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Application.Shutdown%2A>调用时，应用程序将关闭，而不考虑是否 <xref:System.Windows.Window.Closing> 已取消任何打开窗口的事件。  
  
 只能从创建了对象的线程调用此方法 <xref:System.Windows.Application> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">应用程序的一个整数退出代码。 默认退出代码为 0。</param>
        <summary>关闭将指定退出代码返回给操作系统的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以处理 <xref:System.Windows.Application.Exit> 事件以设置退出代码。 但是，如果显式调用 <xref:System.Windows.Application.Shutdown%2A> ，并且 <xref:System.Windows.Application.Exit> 仅处理以设置退出代码，则可以改为调用 <xref:System.Windows.Application.Shutdown%2A> 。  
  
 只能从创建了对象的线程调用此方法 <xref:System.Windows.Application> 。  
  
 <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType>有关退出代码的信息，请参阅。
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置导致调用 <see cref="M:System.Windows.Application.Shutdown" /> 方法的条件。</summary>
        <value>一个 <see cref="T:System.Windows.ShutdownMode" /> 枚举值。 默认值是 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有在调用应用程序的方法时，应用程序才会停止运行 <xref:System.Windows.Application.Shutdown%2A> 。 可以隐式或显式方式进行关闭，如属性的值所指定 <xref:System.Windows.Application.ShutdownMode%2A> 。  
  
 如果将设置 <xref:System.Windows.Application.ShutdownMode%2A> 为 <xref:System.Windows.ShutdownMode.OnLastWindowClose> ，则 <xref:System.Windows.Application.Shutdown%2A> 当应用程序中的最后一个窗口关闭时，Windows Presentation Foundation (WPF) 隐式调用，即使将任何当前实例化的窗口设置为主窗口 (参阅 <xref:System.Windows.Application.MainWindow%2A>) 。  
  
 <xref:System.Windows.Application.ShutdownMode%2A>的 <xref:System.Windows.ShutdownMode.OnMainWindowClose> 会导致 WPF 在关闭时隐式调用 <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.MainWindow%2A> ，即使当前打开了其他窗口也是如此。  
  
 某些应用程序的生存期可能不依赖于主窗口或最后一个窗口关闭的时间，也可能根本不依赖于 windows。 对于这些情况，需要将属性设置 <xref:System.Windows.Application.ShutdownMode%2A> 为 <xref:System.Windows.ShutdownMode.OnExplicitShutdown> ，这需要使用显式 <xref:System.Windows.Application.Shutdown%2A> 方法调用来停止应用程序。 否则，应用程序将继续在后台运行。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 可以通过 XAML 以声明方式进行配置，也可以从代码以编程方式进行配置。  
  
 此属性仅在创建对象的线程中可用 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何配置 <xref:System.Windows.Application.ShutdownMode%2A> 以指定必须显式关闭应用程序。  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Application.Run" /> 对象的 <see cref="T:System.Windows.Application" /> 方法时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的 Windows Presentation Foundation 应用程序在启动时可能会执行各种初始化任务，包括：  
  
-   处理命令行参数。  
  
-   打开主窗口。  
  
-   正在初始化应用程序范围资源。  
  
-   正在初始化应用程序范围的属性。  
  
 您可以使用 XAML (<xref:System.Windows.Application.StartupUri%2A> 和分别) 指定主窗口和应用程序范围的资源 <xref:System.Windows.Application.Resources%2A> 。 但有时，只能在运行时以编程方式确定应用程序的资源或主窗口。 此外，应用程序范围的属性和命令行参数只能以编程方式使用。 可以通过处理事件来执行编程初始化 <xref:System.Windows.Application.Startup> ，其中包括：  
  
-   获取和处理命令行参数，该参数可从 <xref:System.Windows.StartupEventArgs.Args%2A> <xref:System.Windows.StartupEventArgs> 传递给事件处理程序的类的属性中获取 <xref:System.Windows.Application.Startup> 。  
  
-   使用属性初始化应用程序范围资源 <xref:System.Windows.Application.Resources%2A> 。  
  
-   使用属性初始化应用程序范围的属性 <xref:System.Windows.Application.Properties%2A> 。  
  
-   实例化并显示一个 (或多个) windows。  
  
> [!NOTE]
>  还可以通过调用对象的静态方法来获取命令行参数 <xref:System.Environment.GetCommandLineArgs%2A> <xref:System.Environment> 。 但是， <xref:System.Environment.GetCommandLineArgs%2A> 要求完全信任才能执行。  
  
 如果使用 XAML 设置了，则在 <xref:System.Windows.Application.StartupUri%2A> <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Windows%2A> <xref:System.Windows.Application> <xref:System.Windows.Application.Startup> 处理事件之前，创建的主窗口无法从对象的属性或属性中获取。 如果在启动期间需要访问主窗口，则需要从事件处理程序中手动创建新的窗口对象 <xref:System.Windows.Application.Startup> 。  
  
> [!NOTE]
>  如果你的应用程序使用 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 来指定凭据策略，则需要 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 在引发后设置， <xref:System.Windows.Application.Startup> 否则，WPF 会在引发事件后直接将它设置为默认内部策略 <xref:System.Windows.Application.Startup> 。  
  
 传递给事件处理程序的命令行参数与 <xref:System.Windows.Application.Startup> 传递到 XAML 浏览器应用程序 (XBAP) 的 URL 查询字符串参数不同。  
  
   
  
## Examples  
 下面的示例演示如何从独立的应用程序获取和处理命令行选项。 如果提供了 **/StartMinimized** 命令行参数，则应用程序将打开处于最小化状态的主窗口。  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 XAML 浏览器应用程序 (Xbap) 无法检索和处理命令行参数，因为它们是使用 ClickOnce 部署启动的 (请参阅 [ (wpf) 部署 Wpf 应用程序 ](/dotnet/framework/wpf/app-development/deploying-a-wpf-application-wpf) 。 但是，它们可以检索和处理来自用于启动它们的 URL 的查询字符串参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用程序启动时自动显示的 UI。</summary>
        <value><see cref="T:System.Uri" />引用在应用程序启动时自动打开的 UI 的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用在 <xref:System.Windows.Application.StartupUri%2A> 应用程序启动时自动加载 UI 资源。  
  
 下表显示了可以加载的 UI 资源的类型、打开它们的窗口的类型，以及可以将这些资源设置为的应用程序的类型 <xref:System.Windows.Application.StartupUri%2A> 。  
  
|类型|窗口|应用程序类型|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|仅限独立|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|仅限独立|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器托管|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器托管|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器托管|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器托管|  
  
 通常， <xref:System.Windows.Application.StartupUri%2A> 在 XAML 中以声明方式设置属性。 但是，您可以 <xref:System.Windows.Application.StartupUri%2A> 通过编程方式进行设置，如 <xref:System.Windows.Application.Startup> 事件处理程序，如果对于只能在运行时加载必要 UI 资源的应用程序，这会很有用。 例如，如果 UI 资源的名称存储在配置文件中，应用程序可能等到运行时加载其资源。  
  
 无论是 <xref:System.Windows.Application.StartupUri%2A> 以声明方式还是以编程方式进行设置，都不会加载相应的 UI 资源，直到 <xref:System.Windows.Application.Startup> 处理事件。 因此，在处理时，不能从 <xref:System.Windows.Application.Windows%2A> 属性或属性访问生成的窗口 <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Startup> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> 设置为 null 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>查询当前范围中是否有指定的环境属性。</summary>
        <returns>如果有所请求的环境属性，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Windows.Application> 实例被强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源名。</param>
        <summary>搜索指定资源。</summary>
        <returns>所请求的资源对象。 如果未找到所请求的资源，则返回 null 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 将首先查看指定资源的应用程序范围资源。 应用程序范围的资源由管理 <xref:System.Windows.Application> ，并从 <xref:System.Windows.Application.Resources%2A> 属性公开。 如果在应用程序范围的资源集中找不到指定的资源， <xref:System.Windows.Application.TryFindResource%2A> 则接下来会搜索系统资源。 系统资源是由用户定义的 shell 资源，包括颜色、字体和 shell 配置。 它们 <xref:System.Windows.SystemColors> 分别从、 <xref:System.Windows.SystemFonts> 和 <xref:System.Windows.SystemParameters> 类型公开为静态属性。 为了使用 <xref:System.Windows.Application.TryFindResource%2A> 获取它们，这些类型还会公开旨在传递到的资源键属性 <xref:System.Windows.Application.TryFindResource%2A> ; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A> 。  
  
 由于 <xref:System.Windows.Application.TryFindResource%2A> 返回对象，因此如果找到该资源，则必须将返回的值强制转换为相应的类型。  
  
 此方法是线程安全的，可从任何线程调用。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Windows.Application.TryFindResource%2A> 获取资源。  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序中的实例化窗口。</summary>
        <value>一个 <see cref="T:System.Windows.WindowCollection" />，包含对当前 <see cref="T:System.AppDomain" /> 中的所有窗口对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window> <xref:System.Windows.Application.Windows%2A> 在用户界面上实例化窗口 (UI) 线程时，将立即自动向添加一个引用; 不会添加由工作线程创建的 windows。 在 <xref:System.Windows.Window> 处理了其 <xref:System.Windows.Window.Closing> 事件之后以及引发事件之前，将自动移除引用 <xref:System.Windows.Window.Closed> 。  
  
 默认情况下，添加到属性的第一项 <xref:System.Windows.Application.Windows%2A> 将变为 <xref:System.Windows.Application.MainWindow%2A> 。  
  
 此属性仅在创建对象的线程中可用 <xref:System.Windows.Application> 。  
  
   
  
## Examples  
 下面的示例演示如何枚举 <xref:System.Windows.Application.Windows%2A> 属性以生成顶级 Windows 菜单，该菜单对多文档界面 (MDI) 应用程序（如 Microsoft Excel）或多实例单文档界面 (SDI) 应用程序，如 Microsoft Word。  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
