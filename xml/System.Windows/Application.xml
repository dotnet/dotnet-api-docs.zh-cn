<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60fac4ff832f45c94339d7aa58750430a22e6d3d" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83968570" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="733ad-101">封装 Windows Presentation Foundation 应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-101">Encapsulates a Windows Presentation Foundation application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-102"><xref:System.Windows.Application> 是封装 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序特定功能的类，其中包括以下内容：</span><span class="sxs-lookup"><span data-stu-id="733ad-102"><xref:System.Windows.Application> is a class that encapsulates [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application-specific functionality, including the following:</span></span>  
  
-   <span data-ttu-id="733ad-103">**应用程序生存期**： <xref:System.Windows.Application.Activated>、<xref:System.Windows.Application.Current%2A>、<xref:System.Windows.Application.Deactivated>、<xref:System.Windows.Application.DispatcherUnhandledException>、<xref:System.Windows.Application.Exit>、<xref:System.Windows.Application.Run%2A>、<xref:System.Windows.Application.SessionEnding>、<xref:System.Windows.Application.Shutdown%2A>、<xref:System.Windows.Application.ShutdownMode%2A>、<xref:System.Windows.Application.Startup>。</span><span class="sxs-lookup"><span data-stu-id="733ad-103">**Application Lifetime**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.</span></span>  
  
-   <span data-ttu-id="733ad-104">**应用程序范围窗口、属性和资源管理**： <xref:System.Windows.Application.FindResource%2A>、<xref:System.Windows.Application.GetContentStream%2A>、<xref:System.Windows.Application.GetResourceStream%2A>、<xref:System.Windows.Application.LoadComponent%2A>、<xref:System.Windows.Application.MainWindow%2A>、<xref:System.Windows.Application.Properties%2A>、<xref:System.Windows.Application.Resources%2A>、<xref:System.Windows.Application.StartupUri%2A>、<xref:System.Windows.Application.Windows%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-104">**Application-Scope Window, Property, and Resource Management**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.</span></span>  
  
-   <span data-ttu-id="733ad-105">**命令行参数和退出代码处理**： <xref:System.Windows.Application.Startup?displayProperty=nameWithType>、<xref:System.Windows.Application.Exit?displayProperty=nameWithType><xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-105">**Command-Line Parameter and Exit Code Processing**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="733ad-106">**导航**： <xref:System.Windows.Application.FragmentNavigation>、<xref:System.Windows.Application.LoadCompleted>、<xref:System.Windows.Application.Navigated>、<xref:System.Windows.Application.Navigating>、<xref:System.Windows.Application.NavigationProgress>、<xref:System.Windows.Application.NavigationStopped>、<xref:System.Windows.Application.NavigationFailed>、<xref:System.Windows.Application.SetCookie%2A>、<xref:System.Windows.Application.GetCookie%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-106">**Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</span></span>  
  
 <span data-ttu-id="733ad-107"><xref:System.Windows.Application> 实现单一实例模式，以便为其窗口、属性和资源范围服务提供共享访问。</span><span class="sxs-lookup"><span data-stu-id="733ad-107"><xref:System.Windows.Application> implements the singleton pattern to provide shared access to its window, property, and resource scope services.</span></span> <span data-ttu-id="733ad-108">因此，只能为每个 <xref:System.AppDomain>创建一个 <xref:System.Windows.Application> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-108">Consequently, only one instance of the <xref:System.Windows.Application> class can be created per <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="733ad-109">可以使用标记、标记和代码隐藏或代码来实现 <xref:System.Windows.Application>。</span><span class="sxs-lookup"><span data-stu-id="733ad-109">You can implement an <xref:System.Windows.Application> using markup, markup and code-behind, or code.</span></span> <span data-ttu-id="733ad-110">如果 <xref:System.Windows.Application> 是通过标记实现的，无论标记、标记和代码隐藏，都必须将标记文件配置为 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 项。</span><span class="sxs-lookup"><span data-stu-id="733ad-110">If <xref:System.Windows.Application> is implemented with markup, whether markup or markup and code-behind, the markup file must be configured as an [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` item.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-111">独立应用程序不需要 <xref:System.Windows.Application> 对象;可以实现一个自定义 `static` 入口点方法（`Main`），该方法可打开一个窗口而不创建 <xref:System.Windows.Application>的实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-111">A standalone application does not require an <xref:System.Windows.Application> object; it is possible to implement a custom `static` entry point method (`Main`) that opens a window without creating an instance of <xref:System.Windows.Application>.</span></span> <span data-ttu-id="733ad-112">但 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 需要 <xref:System.Windows.Application> 对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-112">However, [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] require an <xref:System.Windows.Application> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-113">下面的示例演示如何使用仅标记定义标准应用程序：</span><span class="sxs-lookup"><span data-stu-id="733ad-113">The following example shows how a standard application is defined using only markup:</span></span>  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 <span data-ttu-id="733ad-114">下面的示例演示如何使用代码仅定义标准应用程序：</span><span class="sxs-lookup"><span data-stu-id="733ad-114">The following example shows how a standard application is defined using only code:</span></span>  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 <span data-ttu-id="733ad-115">下面的示例演示如何使用标记和代码隐藏的组合定义标准应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-115">The following example shows how a standard application is defined using a combination of markup and code-behind.</span></span>  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="733ad-116">此类型的公共 <see langword="static" /> （<see langword="Shared" /> Visual Basic）成员是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-116">The public <see langword="static" /> (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="733ad-117">此外，<see cref="M:System.Windows.Application.FindResource(System.Object)" /> 和 <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> 方法以及 <see cref="P:System.Windows.Application.Properties" /> 和 <see cref="P:System.Windows.Application.Resources" /> 属性都是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-117">In addition, the <see cref="M:System.Windows.Application.FindResource(System.Object)" /> and <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> methods and the <see cref="P:System.Windows.Application.Properties" /> and <see cref="P:System.Windows.Application.Resources" /> properties are thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="733ad-118">初始化 <see cref="T:System.Windows.Application" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-118">Initializes a new instance of the <see cref="T:System.Windows.Application" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-119">只能为每个 <xref:System.AppDomain>创建一个 <xref:System.Windows.Application> 类的实例，以确保对一组应用程序范围窗口、属性和资源数据进行共享访问。</span><span class="sxs-lookup"><span data-stu-id="733ad-119">Only one instance of the <xref:System.Windows.Application> class can be created per <xref:System.AppDomain>, to ensure shared access to a single set of application-scope window, property, and resource data.</span></span> <span data-ttu-id="733ad-120">因此，<xref:System.Windows.Application> 类的无参数构造函数将检测要初始化的实例是否为 <xref:System.AppDomain>中的第一个实例;如果不是，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-120">Consequently, the parameterless constructor of the <xref:System.Windows.Application> class detects whether the instance being initialized is the first instance in an <xref:System.AppDomain>; if it is not, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="733ad-121">当前 <xref:System.AppDomain> 的 <xref:System.Windows.Application> 对象从静态 <xref:System.Windows.Application.Current%2A> 属性公开。</span><span class="sxs-lookup"><span data-stu-id="733ad-121">The <xref:System.Windows.Application> object for the current <xref:System.AppDomain> is exposed from the static <xref:System.Windows.Application.Current%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="733ad-122">对于每个 <see cref="T:System.Windows.Application" />，都会创建 <see cref="T:System.AppDomain" /> 类的多个实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-122">More than one instance of the <see cref="T:System.Windows.Application" /> class is created per <see cref="T:System.AppDomain" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-123">当应用程序成为前台应用程序时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-123">Occurs when an application becomes the foreground application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-124">当应用程序启动后第一次激活某个 windows，或在应用程序处于非活动状态时激活某个 windows 时，将激活具有一个或多个打开的 windows 的 Windows Presentation Foundation 应用程序（成为前台应用程序）：具体而言，激活发生于：</span><span class="sxs-lookup"><span data-stu-id="733ad-124">A Windows Presentation Foundation application that has one or more open windows is activated (becomes the foreground application) when one of the windows is activated for the first time since the application was launched, or when one of the windows is activated while the application is inactive: Specifically, activation occurs when:</span></span>  
  
-   <span data-ttu-id="733ad-125">应用程序打开其第一个窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-125">An application opens its first window.</span></span>  
  
-   <span data-ttu-id="733ad-126">用户使用 ALT + TAB 或使用任务管理器切换到该应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-126">A user switches to the application by using ALT+TAB or by using Task Manager.</span></span>  
  
-   <span data-ttu-id="733ad-127">用户单击应用程序中某个窗口的任务栏按钮。</span><span class="sxs-lookup"><span data-stu-id="733ad-127">A user clicks the taskbar button for one of the windows in an application.</span></span>  
  
 <span data-ttu-id="733ad-128">需要检测激活何时能够处理 <xref:System.Windows.Application.Activated> 事件的应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-128">Applications that need to detect when they activate can handle the <xref:System.Windows.Application.Activated> event.</span></span>  
  
 <span data-ttu-id="733ad-129">第一次激活应用程序后，它可能会在其生存期内停用并多次重新激活。</span><span class="sxs-lookup"><span data-stu-id="733ad-129">After an application is first activated, it may be deactivated and reactivated many times during its lifetime.</span></span> <span data-ttu-id="733ad-130">如果应用程序的行为或状态取决于其激活状态，则它可以处理 <xref:System.Windows.Application.Activated> 和 <xref:System.Windows.Application.Deactivated> 事件，以确定它所在的激活状态。</span><span class="sxs-lookup"><span data-stu-id="733ad-130">If an application's behavior or state depends on its activation state, it can handle both <xref:System.Windows.Application.Activated> and <xref:System.Windows.Application.Deactivated> events to determine which activation state it's in.</span></span>  
  
 <span data-ttu-id="733ad-131">激活应用程序后，在该应用程序处于活动状态时，不会再次引发 <xref:System.Windows.Application.Activated>，而不管应用程序处于活动状态时，应用程序中的多少窗口被激活。</span><span class="sxs-lookup"><span data-stu-id="733ad-131">Once an application becomes active, <xref:System.Windows.Application.Activated> will not be raised again until the application is deactivated, irrespective of how many windows within an application are activated while the application is active.</span></span>  
  
 <span data-ttu-id="733ad-132">[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]不会引发 <xref:System.Windows.Application.Activated>。</span><span class="sxs-lookup"><span data-stu-id="733ad-132"><xref:System.Windows.Application.Activated> is not raised for [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-133">下面的示例演示如何在独立应用程序激活和停用时进行检测。</span><span class="sxs-lookup"><span data-stu-id="733ad-133">The following example shows how to detect when a standalone application activates and deactivates.</span></span>  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-134">获取当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-134">Gets the <see cref="T:System.Windows.Application" /> object for the current <see cref="T:System.AppDomain" />.</span></span></summary>
        <value><span data-ttu-id="733ad-135">当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-135">The <see cref="T:System.Windows.Application" /> object for the current <see cref="T:System.AppDomain" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-136"><xref:System.Windows.Application> 是一种每<xref:System.AppDomain> 单独类型，该类型实现静态 <xref:System.Windows.Application.Current%2A> 属性以提供对当前 <xref:System.AppDomain>的 <xref:System.Windows.Application> 实例的共享访问。</span><span class="sxs-lookup"><span data-stu-id="733ad-136"><xref:System.Windows.Application> is a per-<xref:System.AppDomain> singleton type that implements the static <xref:System.Windows.Application.Current%2A> property to provide shared access to the <xref:System.Windows.Application> instance for the current <xref:System.AppDomain>.</span></span> <span data-ttu-id="733ad-137">此设计保证 <xref:System.Windows.Application>管理的状态（包括共享资源和状态）可从单个共享位置获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-137">This design guarantees that state managed by <xref:System.Windows.Application>, including shared resources and state, is available from a single, shared location.</span></span>  
  
 <span data-ttu-id="733ad-138">此属性是线程安全的，可从任何线程获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-138">This property is thread safe and is available from any thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-139">当应用程序停止作为前台应用程序时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-139">Occurs when an application stops being the foreground application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-140">当用户执行以下操作时，具有一个或多个打开的 Windows 的 Windows Presentation Foundation 应用程序会停用（作为前台应用程序停止）：</span><span class="sxs-lookup"><span data-stu-id="733ad-140">A Windows Presentation Foundation application that has one or more open windows deactivates (stops being the foreground application) when a user does the following:</span></span>  
  
-   <span data-ttu-id="733ad-141">使用 ALT + TAB 或使用任务管理器切换到其他应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-141">Switches to another application by using ALT+TAB or by using Task Manager.</span></span>  
  
-   <span data-ttu-id="733ad-142">单击另一应用程序中窗口的任务栏按钮。</span><span class="sxs-lookup"><span data-stu-id="733ad-142">Clicks the taskbar button for a window in another application.</span></span>  
  
 <span data-ttu-id="733ad-143">需要检测停用的应用程序可以处理 <xref:System.Windows.Application.Deactivated> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-143">Applications that need to detect deactivation can handle the <xref:System.Windows.Application.Deactivated> event.</span></span>  
  
 <span data-ttu-id="733ad-144">第一次激活应用程序后，它可能会在其生存期内停用并多次重新激活。</span><span class="sxs-lookup"><span data-stu-id="733ad-144">After an application is first activated, it may be deactivated and reactivated many times during its lifetime.</span></span> <span data-ttu-id="733ad-145">如果应用程序的行为或状态取决于其激活状态，则它可以同时处理 <xref:System.Windows.Application.Deactivated> 和 <xref:System.Windows.Application.Activated> 事件，以确定它所在的状态。</span><span class="sxs-lookup"><span data-stu-id="733ad-145">If an application's behavior or state depends on its activation state, it can handle both <xref:System.Windows.Application.Deactivated> and <xref:System.Windows.Application.Activated> events to determine which state it's in.</span></span>  
  
 <span data-ttu-id="733ad-146">[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]不会引发 <xref:System.Windows.Application.Deactivated>。</span><span class="sxs-lookup"><span data-stu-id="733ad-146"><xref:System.Windows.Application.Deactivated> is not raised for [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-147">下面的示例演示如何在独立应用程序停用和激活时进行检测。</span><span class="sxs-lookup"><span data-stu-id="733ad-147">The following example shows how to detect when a standalone application deactivates and activates.</span></span>  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-148">在异常由应用程序引发但未进行处理时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-148">Occurs when an exception is thrown by an application but not handled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-149">默认情况下，Windows Presentation Foundation 捕获未经处理的异常，并向用户通知对话框（用户可在其中报告异常）发出异常，并自动关闭应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-149">By default, Windows Presentation Foundation catches unhandled exceptions, notifies users of the exception from a dialog box (from which they can report the exception), and automatically shuts down an application.</span></span>  
  
 <span data-ttu-id="733ad-150">但是，如果应用程序需要从集中的位置执行自定义的未经处理的异常处理，则应处理 <xref:System.Windows.Application.DispatcherUnhandledException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-150">However, if an application needs to perform custom unhandled exception processing from a centralized location, you should handle <xref:System.Windows.Application.DispatcherUnhandledException>.</span></span>  
  
 <span data-ttu-id="733ad-151"><xref:System.Windows.Application.DispatcherUnhandledException> 由主 UI 线程上运行的代码未处理的每个异常的 <xref:System.Windows.Application> 引发。</span><span class="sxs-lookup"><span data-stu-id="733ad-151"><xref:System.Windows.Application.DispatcherUnhandledException> is raised by an <xref:System.Windows.Application> for each exception that is unhandled by code running on the main UI thread.</span></span>  
  
 <span data-ttu-id="733ad-152">如果在后台 UI 线程（具有自身的 <xref:System.Windows.Threading.Dispatcher>的线程）或后台工作线程（没有 <xref:System.Windows.Threading.Dispatcher>的线程）上未处理异常，则不会将异常转发到主 UI 线程。</span><span class="sxs-lookup"><span data-stu-id="733ad-152">If an exception is not handled on either a background UI thread (a thread with its own <xref:System.Windows.Threading.Dispatcher>) or a background worker thread (a thread without a <xref:System.Windows.Threading.Dispatcher>), the exception is not forwarded to the main UI thread.</span></span> <span data-ttu-id="733ad-153">因此，不会引发 <xref:System.Windows.Application.DispatcherUnhandledException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-153">Consequently, <xref:System.Windows.Application.DispatcherUnhandledException> is not raised.</span></span> <span data-ttu-id="733ad-154">在这些情况下，你将需要编写代码来执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="733ad-154">In these circumstances, you will need to write code to do the following:</span></span>  
  
1.  <span data-ttu-id="733ad-155">处理后台线程中的异常。</span><span class="sxs-lookup"><span data-stu-id="733ad-155">Handle exceptions on the background thread.</span></span>  
  
2.  <span data-ttu-id="733ad-156">将这些异常调度到主 UI 线程。</span><span class="sxs-lookup"><span data-stu-id="733ad-156">Dispatch those exceptions to the main UI thread.</span></span>  
  
3.  <span data-ttu-id="733ad-157">在主 UI 线程上重新引发它们，而不处理它们以允许引发 <xref:System.Windows.Application.DispatcherUnhandledException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-157">Rethrow them on the main UI thread without handling them to allow <xref:System.Windows.Application.DispatcherUnhandledException> to be raised.</span></span>  
  
 <span data-ttu-id="733ad-158">有关详细信息，请参阅[线程模型](/dotnet/framework/wpf/advanced/threading-model)概述。</span><span class="sxs-lookup"><span data-stu-id="733ad-158">For more information, see the [Threading Model](/dotnet/framework/wpf/advanced/threading-model) overview.</span></span>  
  
 <span data-ttu-id="733ad-159">向 <xref:System.Windows.Application.DispatcherUnhandledException> 事件处理程序传递包含有关异常的上下文信息的 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 参数，其中包括：</span><span class="sxs-lookup"><span data-stu-id="733ad-159">The <xref:System.Windows.Application.DispatcherUnhandledException> event handler is passed a <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argument that contains contextual information regarding the exception, including:</span></span>  
  
-   <span data-ttu-id="733ad-160">异常（<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-160">The exception (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).</span></span>  
  
-   <span data-ttu-id="733ad-161">它所源自的 <xref:System.Windows.Threading.Dispatcher> （<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-161">The <xref:System.Windows.Threading.Dispatcher> from which it originated (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).</span></span>  
  
 <span data-ttu-id="733ad-162">您可以使用此信息来确定异常是否可恢复。</span><span class="sxs-lookup"><span data-stu-id="733ad-162">You can use this information to determine whether an exception is recoverable or not.</span></span> <span data-ttu-id="733ad-163">例如，可恢复的异常可能是 <xref:System.IO.FileNotFoundException>，而无法恢复的异常可能是一个 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-163">A recoverable exception might be a <xref:System.IO.FileNotFoundException>, for example, while an unrecoverable exception might be a <xref:System.StackOverflowException>, for example.</span></span>  
  
 <span data-ttu-id="733ad-164">如果从 <xref:System.Windows.Application.DispatcherUnhandledException>处理未经处理的异常，并且不希望 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 继续处理它，则需要将 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="733ad-164">When you process an unhandled exception from <xref:System.Windows.Application.DispatcherUnhandledException>, and you don't want [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] to continue processing it, you need to set the <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> property to `true`.</span></span>  
  
 <span data-ttu-id="733ad-165">与 <xref:System.Windows.Application> 引发的其他事件不同，<xref:System.Windows.Application.DispatcherUnhandledException> 没有匹配的受保护的虚拟实现（OnDispatcherUnhandledException）。</span><span class="sxs-lookup"><span data-stu-id="733ad-165">Unlike the other events that <xref:System.Windows.Application> raises, <xref:System.Windows.Application.DispatcherUnhandledException> does not have a matching protected virtual implementation (OnDispatcherUnhandledException).</span></span> <span data-ttu-id="733ad-166">因此，派生自 <xref:System.Windows.Application> 的类必须始终向 <xref:System.Windows.Application.DispatcherUnhandledException> 注册事件处理程序，以处理未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="733ad-166">Consequently, classes that derive from <xref:System.Windows.Application> must always register an event handler with <xref:System.Windows.Application.DispatcherUnhandledException> to process unhandled exceptions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-167">下面的示例演示如何通过处理 <xref:System.Windows.Application.DispatcherUnhandledException> 事件来处理未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="733ad-167">The following example shows how to process unhandled exceptions by handling the <xref:System.Windows.Application.DispatcherUnhandledException> event.</span></span>  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-168">恰好在应用程序关闭之前发生，且无法取消。</span><span class="sxs-lookup"><span data-stu-id="733ad-168">Occurs just before an application shuts down, and cannot be canceled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-169">由于以下原因之一，应用程序可能会关闭：</span><span class="sxs-lookup"><span data-stu-id="733ad-169">An application can shut down for either of the following reasons:</span></span>  
  
-   <span data-ttu-id="733ad-170"><xref:System.Windows.Application> 对象的 <xref:System.Windows.Application.Shutdown%2A> 方法（显式或由 <xref:System.Windows.Application.ShutdownMode%2A> 属性确定）调用。</span><span class="sxs-lookup"><span data-stu-id="733ad-170">The <xref:System.Windows.Application.Shutdown%2A> method of the <xref:System.Windows.Application> object is called, either explicitly or as determined by the <xref:System.Windows.Application.ShutdownMode%2A> property.</span></span>  
  
-   <span data-ttu-id="733ad-171">用户通过注销或关闭来结束该会话。</span><span class="sxs-lookup"><span data-stu-id="733ad-171">The user ends the session by logging off or shutting down.</span></span>  
  
 <span data-ttu-id="733ad-172">可以通过处理 <xref:System.Windows.Application.Exit> 事件来检测应用程序关闭发生的时间，并根据需要执行任何其他处理。</span><span class="sxs-lookup"><span data-stu-id="733ad-172">You can detect when application shutdown occurs by handling the <xref:System.Windows.Application.Exit> event, and perform any additional processing as required.</span></span>  
  
 <span data-ttu-id="733ad-173">当不需要显式调用 <xref:System.Windows.Application.Shutdown%2A> 时，还可以处理 <xref:System.Windows.Application.Exit> 来检查或更改应用程序退出代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-173">You can also handle <xref:System.Windows.Application.Exit> to inspect or change the application exit code when you don't need to call <xref:System.Windows.Application.Shutdown%2A> explicitly.</span></span> <span data-ttu-id="733ad-174">退出代码是从传递给 <xref:System.Windows.Application.Exit> 事件处理程序的 <xref:System.Windows.ExitEventArgs> 参数的 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 属性公开的。</span><span class="sxs-lookup"><span data-stu-id="733ad-174">The exit code is exposed from the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs> argument that's passed to the <xref:System.Windows.Application.Exit> event handler.</span></span> <span data-ttu-id="733ad-175">当应用程序停止运行时，会将退出代码传递到操作系统以进行后续处理。</span><span class="sxs-lookup"><span data-stu-id="733ad-175">When the application stops running, the exit code is passed to the operating system for subsequent processing.</span></span>  
  
 <span data-ttu-id="733ad-176">如果你的应用程序处理 <xref:System.Windows.Application.SessionEnding> 事件并随后取消该事件，则不会引发 <xref:System.Windows.Application.Exit>，并且应用程序会按照关闭模式继续运行。</span><span class="sxs-lookup"><span data-stu-id="733ad-176">If your application handles the <xref:System.Windows.Application.SessionEnding> event and subsequently cancels it, <xref:System.Windows.Application.Exit> is not raised and the application continues running in accordance with the shutdown mode.</span></span>  
  
 <span data-ttu-id="733ad-177">可以从 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]设置退出代码，但该值会被忽略。</span><span class="sxs-lookup"><span data-stu-id="733ad-177">The exit code can be set from an [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], although the value is ignored.</span></span>  
  
 <span data-ttu-id="733ad-178">对于 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]，<xref:System.Windows.Application.Exit> 在以下情况下引发：</span><span class="sxs-lookup"><span data-stu-id="733ad-178">For [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> is raised in the following circumstances:</span></span>  
  
-   <span data-ttu-id="733ad-179">离开 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="733ad-179">An [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] is navigated away from.</span></span>  
  
-   <span data-ttu-id="733ad-180">在 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]中，当宿主 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 的选项卡关闭时。</span><span class="sxs-lookup"><span data-stu-id="733ad-180">In [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], when the tab that is hosting the [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] is closed.</span></span>  
  
-   <span data-ttu-id="733ad-181">关闭浏览器时。</span><span class="sxs-lookup"><span data-stu-id="733ad-181">When the browser is closed.</span></span>  
  
 <span data-ttu-id="733ad-182">在所有情况下，都将忽略 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="733ad-182">In all cases, the value of the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property is ignored.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-183">下面的示例演示如何执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="733ad-183">The following example demonstrates how to:</span></span>  
  
-   <span data-ttu-id="733ad-184">处理 <xref:System.Windows.Application.Exit> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-184">Handle the <xref:System.Windows.Application.Exit> event.</span></span>  
  
-   <span data-ttu-id="733ad-185">检查并更新 <xref:System.Windows.ExitEventArgs>的 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-185">Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.</span></span>  
  
-   <span data-ttu-id="733ad-186">在独立存储中将条目写入到应用程序日志。</span><span class="sxs-lookup"><span data-stu-id="733ad-186">Write an entry to an application log in isolated storage.</span></span>  
  
-   <span data-ttu-id="733ad-187">将应用程序状态保存到独立存储。</span><span class="sxs-lookup"><span data-stu-id="733ad-187">Persist the application state to isolated storage.</span></span>  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="733ad-188">要查找的资源名。</span><span class="sxs-lookup"><span data-stu-id="733ad-188">The name of the resource to find.</span></span></param>
        <summary><span data-ttu-id="733ad-189">使用指定键搜索 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 资源（如 <see cref="T:System.Windows.Style" /> 或 <see cref="T:System.Windows.Media.Brush" />），并在未找到所请求的资源时引发异常（请参阅 <see href="/dotnet/framework/wpf/advanced/xaml-resources">XAML 资源</see>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-189">Searches for a [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] resource, such as a <see cref="T:System.Windows.Style" /> or <see cref="T:System.Windows.Media.Brush" />, with the specified key, and throws an exception if the requested resource is not found (see <see href="/dotnet/framework/wpf/advanced/xaml-resources">XAML Resources</see>).</span></span></summary>
        <returns><span data-ttu-id="733ad-190">所请求的资源对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-190">The requested resource object.</span></span> <span data-ttu-id="733ad-191">如果未找到所请求的资源，则引发 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-191">If the requested resource is not found, a <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> is thrown.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-192"><xref:System.Windows.Application.FindResource%2A> 将首先查看指定资源的应用程序范围资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-192"><xref:System.Windows.Application.FindResource%2A> will first look in application-scope resources for the specified resource.</span></span> <span data-ttu-id="733ad-193">应用程序范围的资源由 <xref:System.Windows.Application>管理，并从 <xref:System.Windows.Application.Resources%2A> 属性公开。</span><span class="sxs-lookup"><span data-stu-id="733ad-193">Application-scope resources are managed by <xref:System.Windows.Application>, and are exposed from the <xref:System.Windows.Application.Resources%2A> property.</span></span> <span data-ttu-id="733ad-194">如果在应用程序范围的资源集中找不到指定的资源，<xref:System.Windows.Application.FindResource%2A> 接下来会搜索系统资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-194">If the specified resource is not found in the set of application-scope resources, <xref:System.Windows.Application.FindResource%2A> then next searches the system resources.</span></span> <span data-ttu-id="733ad-195">系统资源是由用户定义的 shell 资源，包括颜色、字体和 shell 配置。</span><span class="sxs-lookup"><span data-stu-id="733ad-195">System resources are shell resources defined by the user, and include colors, fonts, and shell configurations.</span></span> <span data-ttu-id="733ad-196">它们分别从 <xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts>和 <xref:System.Windows.SystemParameters> 类型分别作为静态属性公开。</span><span class="sxs-lookup"><span data-stu-id="733ad-196">These are exposed from the <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, and <xref:System.Windows.SystemParameters> types, respectively, as static properties.</span></span> <span data-ttu-id="733ad-197">若要使用 <xref:System.Windows.Application.FindResource%2A> 获取它们，这些类型还会公开旨在传递到 <xref:System.Windows.Application.FindResource%2A>的资源键属性;例如，<xref:System.Windows.SystemParameters.IconWidthKey%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-197">To use <xref:System.Windows.Application.FindResource%2A> to acquire them, these types also expose resource key properties that are designed to be passed to <xref:System.Windows.Application.FindResource%2A>; for example, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</span></span>  
  
 <span data-ttu-id="733ad-198">由于 <xref:System.Windows.Application.FindResource%2A> 返回对象，因此如果找到该资源，则必须将返回的值强制转换为适当的类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-198">Because <xref:System.Windows.Application.FindResource%2A> returns an object, you must cast the returned value to the appropriate type if the resource is found.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="733ad-199">如果对找不到的键调用此方法，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="733ad-199">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="733ad-200">如果不想处理通过调用 <xref:System.Windows.Application.FindResource%2A>而产生的异常，请改为调用 <xref:System.Windows.Application.TryFindResource%2A>;当找不到请求的资源时，<xref:System.Windows.Application.TryFindResource%2A> 返回 `null` 引用，并且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="733ad-200">If you do not want to handle exceptions that result from calling <xref:System.Windows.Application.FindResource%2A>, call <xref:System.Windows.Application.TryFindResource%2A> instead; <xref:System.Windows.Application.TryFindResource%2A> returns a `null` reference when a requested resource cannot be found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="733ad-201">此方法是线程安全的，可从任何线程调用。</span><span class="sxs-lookup"><span data-stu-id="733ad-201">This method is thread safe and can be called from any thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-202">下面的示例演示如何使用 <xref:System.Windows.Application.FindResource%2A> 查找资源，以及在找不到资源时处理 <xref:System.Windows.ResourceReferenceKeyNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="733ad-202">The following example shows how to use <xref:System.Windows.Application.FindResource%2A> to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.</span></span>  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="733ad-203">无法找到资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-203">The resource cannot be found.</span></span></exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-204">当应用程序中的导航器开始导航至某个内容片断时发生，如果所需片段位于当前内容中，则导航会立即发生；或者，如果所需片段位于不同内容中，则导航会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-204">Occurs when a navigator in the application begins navigation to a content fragment, Navigation occurs immediately if the desired fragment is in the current content, or after the source [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] content has been loaded if the desired fragment is in different content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-205">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-205">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-206">请参阅 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-206">See <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent"><span data-ttu-id="733ad-207">映射到松散资源的相对 <see cref="T:System.Uri" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-207">The relative <see cref="T:System.Uri" /> that maps to a loose resource.</span></span></param>
        <summary><span data-ttu-id="733ad-208">返回位于指定 <see cref="T:System.Uri" /> 的内容数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-208">Returns a resource stream for a content data file that is located at the specified <see cref="T:System.Uri" /> (see <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF Application Resource, Content, and Data Files</see>).</span></span></summary>
        <returns><span data-ttu-id="733ad-209">一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的内容数据文件。</span><span class="sxs-lookup"><span data-stu-id="733ad-209">A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> that contains a content data file that is located at the specified <see cref="T:System.Uri" />.</span></span> <span data-ttu-id="733ad-210">如果未找到松散资源，则返回 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-210">If a loose resource is not found, null is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-211">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-211">This method is not thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-212">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-212">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> is null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="733ad-213">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 是绝对 <see cref="T:System.Uri" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-213">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> is an absolute <see cref="T:System.Uri" />.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCookie (uri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="733ad-214"><see cref="T:System.Uri" />，它指定已为其创建 Cookie 的位置。</span><span class="sxs-lookup"><span data-stu-id="733ad-214">The <see cref="T:System.Uri" /> that specifies the location for which a cookie was created.</span></span></param>
        <summary><span data-ttu-id="733ad-215">为由 <see cref="T:System.Uri" /> 指定的位置检索 Cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-215">Retrieves a cookie for the location specified by a <see cref="T:System.Uri" />.</span></span></summary>
        <returns><span data-ttu-id="733ad-216">如果该 Cookie 存在，则为 <see cref="T:System.String" /> 值；否则会引发 <see cref="T:System.ComponentModel.Win32Exception" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-216">A <see cref="T:System.String" /> value, if the cookie exists; otherwise, a <see cref="T:System.ComponentModel.Win32Exception" /> is thrown.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-217"><xref:System.Windows.Application.GetCookie%2A> 为指定的 <xref:System.Uri>检索 cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-217"><xref:System.Windows.Application.GetCookie%2A> retrieves a cookie for the specified <xref:System.Uri>.</span></span> <span data-ttu-id="733ad-218">如果无法检索该 cookie，则会引发 <xref:System.ComponentModel.Win32Exception>。</span><span class="sxs-lookup"><span data-stu-id="733ad-218">If the cookie can't be retrieved, a <xref:System.ComponentModel.Win32Exception> is thrown.</span></span> <span data-ttu-id="733ad-219">需要编写代码以将 cookie 字符串解析为名称/值对列表。</span><span class="sxs-lookup"><span data-stu-id="733ad-219">You need to write the code to parse the cookie string into a list of name/value pairs.</span></span>  
  
 <span data-ttu-id="733ad-220">有关 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]中的 cookie 概述，请参阅[导航概述](/dotnet/framework/wpf/app-development/navigation-overview)。</span><span class="sxs-lookup"><span data-stu-id="733ad-220">For an overview of cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], see [Navigation Overview](/dotnet/framework/wpf/app-development/navigation-overview).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="733ad-221">如果在尝试检索指定 Cookie 时发生问题，则会由 <see langword="InternetGetCookie" /> 函数（由 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> 调用）引发一个 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 错误。</span><span class="sxs-lookup"><span data-stu-id="733ad-221">A [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] error is raised by the <see langword="InternetGetCookie" /> function (called by <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) if a problem occurs when attempting to retrieve the specified cookie.</span></span></exception>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><span data-ttu-id="733ad-222">映射到源站点的松散资源的 <see cref="T:System.Uri" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-222">The <see cref="T:System.Uri" /> that maps to a loose resource at the site of origin.</span></span></param>
        <summary><span data-ttu-id="733ad-223">返回位于指定 <see cref="T:System.Uri" /> 的源站点数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-223">Returns a resource stream for a site-of-origin data file that is located at the specified <see cref="T:System.Uri" /> (see <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF Application Resource, Content, and Data Files</see>).</span></span></summary>
        <returns><span data-ttu-id="733ad-224">一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的源站点数据文件的资源流。</span><span class="sxs-lookup"><span data-stu-id="733ad-224">A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> that contains a resource stream for a site-of-origin data file that is located at the specified <see cref="T:System.Uri" />.</span></span> <span data-ttu-id="733ad-225">如果未找到松散资源，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-225">If the loose resource is not found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-226">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-226">This method is not thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-227">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-227">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> is null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="733ad-228">传递给 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://siteoforigin:,,,/</c> 格式。</span><span class="sxs-lookup"><span data-stu-id="733ad-228">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> is either not relative, or is absolute but not in the <c>pack://siteoforigin:,,,/</c> form.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><span data-ttu-id="733ad-229">映射到嵌入资源的 <see cref="T:System.Uri" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-229">The <see cref="T:System.Uri" /> that maps to an embedded resource.</span></span></param>
        <summary><span data-ttu-id="733ad-230">返回位于指定 <see cref="T:System.Uri" /> 的资源数据文件的资源流（请参阅 <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF 应用程序资源、内容和数据文件</see>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-230">Returns a resource stream for a resource data file that is located at the specified <see cref="T:System.Uri" /> (see <see href="/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files">WPF Application Resource, Content, and Data Files</see>).</span></span></summary>
        <returns><span data-ttu-id="733ad-231">一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的资源数据文件的资源流。</span><span class="sxs-lookup"><span data-stu-id="733ad-231">A <see cref="T:System.Windows.Resources.StreamResourceInfo" /> that contains a resource stream for resource data file that is located at the specified <see cref="T:System.Uri" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-232">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-232">This method is not thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-233">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-233">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> is null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="733ad-234">传递给 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://application:,,,/</c> 格式。</span><span class="sxs-lookup"><span data-stu-id="733ad-234">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> is either not relative, or is absolute but not in the <c>pack://application:,,,/</c> form.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="733ad-235">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 无法找到。</span><span class="sxs-lookup"><span data-stu-id="733ad-235">The <see cref="T:System.Uri" /> that is passed to <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> cannot be found.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-236">在已经加载、分析并开始呈现应用程序中的导航器导航到的内容时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-236">Occurs when content that was navigated to by a navigator in the application has been loaded, parsed, and has begun rendering.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-237">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-237">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-238">请参阅 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-238">See <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-239">在访问导航内容的属性之前，请先侦听导航内容上的事件，如 <xref:System.Windows.Controls.Page> 上的 <xref:System.Windows.FrameworkElement.Loaded> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-239">Listen for events on the navigated content such as the <xref:System.Windows.FrameworkElement.Loaded> event on <xref:System.Windows.Controls.Page> before you access properties of the navigated content.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="733ad-240">加载位于指定的统一资源标识符 (URI) 上的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件。</span><span class="sxs-lookup"><span data-stu-id="733ad-240">Loads a [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file that is located at the specified uniform resource identifier (URI).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-241">[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 文件可以是应用程序代码文件（配置为 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 页项）或应用程序数据文件（资源文件、内容文件或源站点文件，请参阅[WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)）。</span><span class="sxs-lookup"><span data-stu-id="733ad-241">The [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file can be an application code file (configured as an [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Page item) or an application data file (a resource file, content file, or site-of-origin file; see [WPF Application Resource, Content, and Data Files](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-242">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-242">This method is not thread-safe.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator"><span data-ttu-id="733ad-243">一个 <see cref="T:System.Uri" />，它映射到相对 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件。</span><span class="sxs-lookup"><span data-stu-id="733ad-243">A <see cref="T:System.Uri" /> that maps to a relative [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file.</span></span></param>
        <summary><span data-ttu-id="733ad-244">加载位于指定的统一资源标识符 (URI) 上的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件，并将其转换为由 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件的根元素指定的对象的实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-244">Loads a [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file that is located at the specified uniform resource identifier (URI), and converts it to an instance of the object that is specified by the root element of the [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file.</span></span></summary>
        <returns><span data-ttu-id="733ad-245">加载的 XAML 文件所指定的根元素的实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-245">An instance of the root element specified by the XAML file loaded.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-246">必须将返回值显式转换为与 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件的根元素相同的类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-246">You must explicitly convert the return value to the same type as the root element of the [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file.</span></span>  
  
 <span data-ttu-id="733ad-247">[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 文件可以是应用程序代码文件（配置为 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 页项）或应用程序数据文件（资源文件、内容文件或源站点文件，请参阅[WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)）。</span><span class="sxs-lookup"><span data-stu-id="733ad-247">The [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file can be an application code file (configured as an [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Page item) or an application data file (a resource file, content file, or site-of-origin file; see [WPF Application Resource, Content, and Data Files](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-248">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-248">This method is not thread-safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-249"><paramref name="resourceLocator" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-249"><paramref name="resourceLocator" /> is null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="733ad-250"><paramref name="resourceLocator" /> 为绝对 URI。</span><span class="sxs-lookup"><span data-stu-id="733ad-250">The <paramref name="resourceLocator" /> is an absolute URI.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="733ad-251">该文件不是 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 文件。</span><span class="sxs-lookup"><span data-stu-id="733ad-251">The file is not a [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component"><span data-ttu-id="733ad-252">一个对象，其类型与 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件的根元素相同。</span><span class="sxs-lookup"><span data-stu-id="733ad-252">An object of the same type as the root element of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file.</span></span></param>
        <param name="resourceLocator"><span data-ttu-id="733ad-253">一个 <see cref="T:System.Uri" />，它映射到相对 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件。</span><span class="sxs-lookup"><span data-stu-id="733ad-253">A <see cref="T:System.Uri" /> that maps to a relative [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file.</span></span></param>
        <summary><span data-ttu-id="733ad-254">加载位于指定的统一资源标识符 (URI) 上的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件，并将其转换为由 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件的根元素指定的对象的实例。</span><span class="sxs-lookup"><span data-stu-id="733ad-254">Loads a [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file that is located at the specified uniform resource identifier (URI) and converts it to an instance of the object that is specified by the root element of the [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-255">[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 文件可以是应用程序代码文件（配置为 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 页项）或应用程序数据文件（资源文件、内容文件或源站点文件，请参阅[WPF 应用程序资源、内容和数据文件](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)）。</span><span class="sxs-lookup"><span data-stu-id="733ad-255">The [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] file can be an application code file (configured as an [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] Page item) or an application data file (a resource file, content file, or site-of-origin file; see [WPF Application Resource, Content, and Data Files](/dotnet/framework/wpf/app-development/wpf-application-resource-content-and-data-files)).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-256">此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="733ad-256">This method is not thread-safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-257"><paramref name="resourceLocator" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="733ad-257"><paramref name="resourceLocator" /> is null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="733ad-258"><paramref name="resourceLocator" /> 为绝对 URI。</span><span class="sxs-lookup"><span data-stu-id="733ad-258">The <paramref name="resourceLocator" /> is an absolute URI.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="733ad-259"><paramref name="component" /> 的类型与 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件的根元素不匹配。</span><span class="sxs-lookup"><span data-stu-id="733ad-259"><paramref name="component" /> is of a type that does not match the root element of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] file.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-260">获取或设置应用程序的主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-260">Gets or sets the main window of the application.</span></span></summary>
        <value><span data-ttu-id="733ad-261">一个指定为应用程序主窗口的 <see cref="T:System.Windows.Window" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-261">A <see cref="T:System.Windows.Window" /> that is designated as the main application window.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-262"><xref:System.Windows.Application.MainWindow%2A> 自动设置为要在 <xref:System.AppDomain>中实例化的第一个 <xref:System.Windows.Window> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="733ad-262"><xref:System.Windows.Application.MainWindow%2A> is automatically set with a reference to the first <xref:System.Windows.Window> object to be instantiated in the <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="733ad-263">可以通过设置 <xref:System.Windows.Application.MainWindow%2A> 将其他 <xref:System.Windows.Application.Windows%2A> 对象分配到 <xref:System.Windows.Application.MainWindow%2A> 属性来指定其他主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-263">You can specify a different main window by setting <xref:System.Windows.Application.MainWindow%2A> assigning another <xref:System.Windows.Application.Windows%2A> object to the <xref:System.Windows.Application.MainWindow%2A> property.</span></span>  
  
 <span data-ttu-id="733ad-264">如果 <xref:System.Windows.Application> 对象的 <xref:System.Windows.Application.ShutdownMode%2A> 属性设置为 <xref:System.Windows.ShutdownMode.OnMainWindowClose>，则关闭主窗口会导致应用程序关闭。</span><span class="sxs-lookup"><span data-stu-id="733ad-264">If the <xref:System.Windows.Application.ShutdownMode%2A> property of the <xref:System.Windows.Application> object is set to <xref:System.Windows.ShutdownMode.OnMainWindowClose>, closing the main window causes the application to shut down.</span></span>  
  
 <span data-ttu-id="733ad-265">如果应用程序的主窗口并不是通过在 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]中设置 <xref:System.Windows.Application.StartupUri%2A> 属性生成的窗口，则可以从 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]设置 <xref:System.Windows.Application.MainWindow%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-265">It is possible to set the <xref:System.Windows.Application.MainWindow%2A> property from [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], if an application's main window is not the window that is produced by setting the <xref:System.Windows.Application.StartupUri%2A> property in [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</span></span> <span data-ttu-id="733ad-266">[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 方法的两个限制是：</span><span class="sxs-lookup"><span data-stu-id="733ad-266">The two limitations of the [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] approach are:</span></span>  
  
-   <span data-ttu-id="733ad-267">你可以指定仅限 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]的 <xref:System.Windows.Window> 或仅 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]的 <xref:System.Windows.Navigation.NavigationWindow> 作为主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-267">You can specify either a [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-only <xref:System.Windows.Window> or a [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-only <xref:System.Windows.Navigation.NavigationWindow> as the main window.</span></span>  
  
-   <span data-ttu-id="733ad-268">您必须设置指定窗口的 <xref:System.Windows.UIElement.Visibility%2A> 属性，否则将不会显示该属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-268">You must set the <xref:System.Windows.UIElement.Visibility%2A> property of the window you specify, otherwise it won't be shown.</span></span>  
  
 <span data-ttu-id="733ad-269">对要实例化的第一个 <xref:System.Windows.Window> 对象的引用也作为第一项添加到 <xref:System.Windows.Application.Windows%2A> 集合。</span><span class="sxs-lookup"><span data-stu-id="733ad-269">The reference to the first <xref:System.Windows.Window> object to be instantiated is also added as the first item to the <xref:System.Windows.Application.Windows%2A> collection.</span></span> <span data-ttu-id="733ad-270">如果随后使用对其他 <xref:System.Windows.Window>的引用设置 <xref:System.Windows.Application.MainWindow%2A>，则引用主窗口的项的位置将发生变化，而 <xref:System.Windows.Application.Windows%2A> 中项的顺序保持不变。</span><span class="sxs-lookup"><span data-stu-id="733ad-270">If <xref:System.Windows.Application.MainWindow%2A> is subsequently set with a reference to a different <xref:System.Windows.Window>, the position of the item with the reference to the main window will change, while the order of items in <xref:System.Windows.Application.Windows%2A> remains the same.</span></span> <span data-ttu-id="733ad-271">因此，始终使用 <xref:System.Windows.Application.MainWindow%2A> 引用主窗口，而不是 <xref:System.Windows.Application.Windows%2A>中的第一项。</span><span class="sxs-lookup"><span data-stu-id="733ad-271">Consequently, always use <xref:System.Windows.Application.MainWindow%2A> to refer to the main window instead of the first item in <xref:System.Windows.Application.Windows%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-272">如果主窗口是一个 <xref:System.Windows.Navigation.NavigationWindow>，需要对 <xref:System.Windows.Navigation.NavigationWindow> 成员的特定访问权限，则需要将 <xref:System.Windows.Application.MainWindow%2A> 的值强制转换为 <xref:System.Windows.Navigation.NavigationWindow>。</span><span class="sxs-lookup"><span data-stu-id="733ad-272">If the main window is a <xref:System.Windows.Navigation.NavigationWindow>, and you need specific access to <xref:System.Windows.Navigation.NavigationWindow> members, you will need to cast the value of <xref:System.Windows.Application.MainWindow%2A> to <xref:System.Windows.Navigation.NavigationWindow>.</span></span>  
>   
>  <span data-ttu-id="733ad-273">此属性仅在创建 <xref:System.Windows.Application> 对象的线程中可用。</span><span class="sxs-lookup"><span data-stu-id="733ad-273">This property is available only from the thread that created the <xref:System.Windows.Application> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-274">下面的示例演示如何查找主应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-274">The following example shows how to find the main application window.</span></span>  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 <span data-ttu-id="733ad-275">下面的示例演示如何使用 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]设置 <xref:System.Windows.Application.MainWindow%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-275">The following example shows how to set <xref:System.Windows.Application.MainWindow%2A> using [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</span></span>  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 <span data-ttu-id="733ad-276">下面的示例演示如何在应用程序启动过程中实例化 <xref:System.Windows.Application.MainWindow%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-276">The following example shows how to instantiate the <xref:System.Windows.Application.MainWindow%2A> in code during application startup.</span></span>  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="733ad-277"><see cref="P:System.Windows.Application.MainWindow" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]）设置的。</span><span class="sxs-lookup"><span data-stu-id="733ad-277"><see cref="P:System.Windows.Application.MainWindow" /> is set from an application that's hosted in a browser, such as an [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</span></span></exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-278">在已经找到应用程序中的导航器要导航到的内容时发生，尽管此时该内容可能尚未完成加载。</span><span class="sxs-lookup"><span data-stu-id="733ad-278">Occurs when the content that is being navigated to by a navigator in the application has been found, although it may not have completed loading.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-279">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-279">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-280">请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-280">See <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-281">在应用程序中的导航器请求新导航时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-281">Occurs when a new navigation is requested by a navigator in the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-282">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-282">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-283">请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-283">See <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-284">在应用程序中的导航器在导航到所请求内容时出现错误的情况下发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-284">Occurs when an error occurs while a navigator in the application is navigating to the requested content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-285">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-285">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-286">请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-286">See <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-287">在由应用程序中的导航器管理的下载过程中定期发生，以提供导航进度信息。</span><span class="sxs-lookup"><span data-stu-id="733ad-287">Occurs periodically during a download that is being managed by a navigator in the application to provide navigation progress information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-288">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-288">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-289">请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-289">See <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-290">在调用应用程序中的导航器的 <see langword="StopLoading" /> 方法时发生，或者当导航器在当前导航正在进行期间请求了一个新导航时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-290">Occurs when the <see langword="StopLoading" /> method of a navigator in the application is called, or when a new navigation is requested by a navigator while a current navigation is in progress.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-291">导航器可以是 <xref:System.Windows.Navigation.NavigationWindow> 或 <xref:System.Windows.Controls.Frame>。</span><span class="sxs-lookup"><span data-stu-id="733ad-291">A navigator is either a <xref:System.Windows.Navigation.NavigationWindow> or a <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="733ad-292">请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-292">See <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-293">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-293">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-294">引发 <see cref="E:System.Windows.Application.Activated" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-294">Raises the <see cref="E:System.Windows.Application.Activated" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-295"><xref:System.Windows.Application.OnActivated%2A> 引发 <xref:System.Windows.Application.Activated> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-295"><xref:System.Windows.Application.OnActivated%2A> raises the <xref:System.Windows.Application.Activated> event.</span></span>  
  
 <span data-ttu-id="733ad-296">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnActivated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-296">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnActivated%2A>.</span></span> <span data-ttu-id="733ad-297">如果需要引发 <xref:System.Windows.Application.Activated>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnActivated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-297">The overridden method must call <xref:System.Windows.Application.OnActivated%2A> in the base class if <xref:System.Windows.Application.Activated> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-298">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-298">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-299">引发 <see cref="E:System.Windows.Application.Deactivated" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-299">Raises the <see cref="E:System.Windows.Application.Deactivated" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-300"><xref:System.Windows.Application.OnDeactivated%2A> 引发 <xref:System.Windows.Application.Deactivated> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-300"><xref:System.Windows.Application.OnDeactivated%2A> raises the <xref:System.Windows.Application.Deactivated> event.</span></span>  
  
 <span data-ttu-id="733ad-301">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnDeactivated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-301">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnDeactivated%2A>.</span></span> <span data-ttu-id="733ad-302">如果需要引发 <xref:System.Windows.Application.Deactivated>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnDeactivated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-302">The overridden method must call <xref:System.Windows.Application.OnDeactivated%2A> in the base class if <xref:System.Windows.Application.Deactivated> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-303">包含事件数据的 <see cref="T:System.Windows.ExitEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-303">An <see cref="T:System.Windows.ExitEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-304">引发 <see cref="E:System.Windows.Application.Exit" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-304">Raises the <see cref="E:System.Windows.Application.Exit" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-305"><xref:System.Windows.Application.OnExit%2A> 引发 <xref:System.Windows.Application.Exit> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-305"><xref:System.Windows.Application.OnExit%2A> raises the <xref:System.Windows.Application.Exit> event.</span></span>  
  
 <span data-ttu-id="733ad-306">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnExit%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="733ad-306">A type that derives from <xref:System.Windows.Application> may override the <xref:System.Windows.Application.OnExit%2A> method.</span></span> <span data-ttu-id="733ad-307">如果需要引发 <xref:System.Windows.Application.Exit>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnExit%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-307">The overridden method must call <xref:System.Windows.Application.OnExit%2A> in the base class if <xref:System.Windows.Application.Exit> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-308">一个包含事件数据的 <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-308">A <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-309">引发 <see cref="E:System.Windows.Application.FragmentNavigation" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-309">Raises the <see cref="E:System.Windows.Application.FragmentNavigation" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-310"><xref:System.Windows.Application.OnFragmentNavigation%2A> 引发 <xref:System.Windows.Application.FragmentNavigation> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-310"><xref:System.Windows.Application.OnFragmentNavigation%2A> raises the <xref:System.Windows.Application.FragmentNavigation> event.</span></span>  
  
 <span data-ttu-id="733ad-311">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnFragmentNavigation%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-311">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnFragmentNavigation%2A>.</span></span> <span data-ttu-id="733ad-312">如果需要引发 <xref:System.Windows.Application.FragmentNavigation>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnFragmentNavigation%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-312">The overridden method must call <xref:System.Windows.Application.OnFragmentNavigation%2A> in the base class if <xref:System.Windows.Application.FragmentNavigation> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-313">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-313">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-314">引发 <see cref="E:System.Windows.Application.LoadCompleted" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-314">Raises the <see cref="E:System.Windows.Application.LoadCompleted" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-315"><xref:System.Windows.Application.OnLoadCompleted%2A> 引发 <xref:System.Windows.Application.LoadCompleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-315"><xref:System.Windows.Application.OnLoadCompleted%2A> raises the <xref:System.Windows.Application.LoadCompleted> event.</span></span>  
  
 <span data-ttu-id="733ad-316">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnLoadCompleted%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-316">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnLoadCompleted%2A>.</span></span> <span data-ttu-id="733ad-317">如果需要引发 <xref:System.Windows.Application.LoadCompleted>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnLoadCompleted%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-317">The overridden method must call <xref:System.Windows.Application.OnLoadCompleted%2A> in the base class if <xref:System.Windows.Application.LoadCompleted> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-318">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-318">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-319">引发 <see cref="E:System.Windows.Application.Navigated" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-319">Raises the <see cref="E:System.Windows.Application.Navigated" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-320"><xref:System.Windows.Application.OnNavigated%2A> 引发 <xref:System.Windows.Application.Navigated> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-320"><xref:System.Windows.Application.OnNavigated%2A> raises the <xref:System.Windows.Application.Navigated> event.</span></span>  
  
 <span data-ttu-id="733ad-321">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnNavigated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-321">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnNavigated%2A>.</span></span> <span data-ttu-id="733ad-322">如果需要引发 <xref:System.Windows.Application.Navigated>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnNavigated%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-322">The overridden method must call <xref:System.Windows.Application.OnNavigated%2A> in the base class if <xref:System.Windows.Application.Navigated> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-323">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-323">A <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-324">引发 <see cref="E:System.Windows.Application.Navigating" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-324">Raises the <see cref="E:System.Windows.Application.Navigating" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-325"><xref:System.Windows.Application.OnNavigating%2A> 引发 <xref:System.Windows.Application.Navigating> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-325"><xref:System.Windows.Application.OnNavigating%2A> raises the <xref:System.Windows.Application.Navigating> event.</span></span>  
  
 <span data-ttu-id="733ad-326">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnNavigating%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-326">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnNavigating%2A>.</span></span> <span data-ttu-id="733ad-327">如果需要引发 <xref:System.Windows.Application.Navigating>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnNavigating%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-327">The overridden method must call <xref:System.Windows.Application.OnNavigating%2A> in the base class if <xref:System.Windows.Application.Navigating> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-328">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-328">A <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-329">引发 <see cref="E:System.Windows.Application.NavigationFailed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-329">Raises the <see cref="E:System.Windows.Application.NavigationFailed" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-330"><xref:System.Windows.Application.OnNavigationFailed%2A> 引发 <xref:System.Windows.Application.NavigationFailed> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-330"><xref:System.Windows.Application.OnNavigationFailed%2A> raises the <xref:System.Windows.Application.NavigationFailed> event.</span></span>  
  
 <span data-ttu-id="733ad-331">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnNavigationFailed%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-331">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnNavigationFailed%2A>.</span></span> <span data-ttu-id="733ad-332">如果需要引发 <xref:System.Windows.Application.NavigationFailed>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnNavigationFailed%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-332">The overridden method must call <xref:System.Windows.Application.OnNavigationFailed%2A> in the base class if <xref:System.Windows.Application.NavigationFailed> needs to be raised.</span></span>  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-333">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-333">A <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-334">引发 <see cref="E:System.Windows.Application.NavigationProgress" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-334">Raises the <see cref="E:System.Windows.Application.NavigationProgress" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-335"><xref:System.Windows.Application.OnNavigationProgress%2A> 引发 <xref:System.Windows.Application.NavigationProgress> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-335"><xref:System.Windows.Application.OnNavigationProgress%2A> raises the <xref:System.Windows.Application.NavigationProgress> event.</span></span>  
  
 <span data-ttu-id="733ad-336">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnNavigationProgress%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-336">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnNavigationProgress%2A>.</span></span> <span data-ttu-id="733ad-337">如果需要引发 <xref:System.Windows.Application.NavigationProgress>，则重写的方法必须显式调用基类中的 <xref:System.Windows.Application.OnNavigationProgress%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-337">The overridden method must explicitly call <xref:System.Windows.Application.OnNavigationProgress%2A> in the base class if <xref:System.Windows.Application.NavigationProgress> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-338">一个包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-338">A <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-339">引发 <see cref="E:System.Windows.Application.NavigationStopped" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-339">Raises the <see cref="E:System.Windows.Application.NavigationStopped" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-340"><xref:System.Windows.Application.OnNavigationStopped%2A> 引发 <xref:System.Windows.Application.NavigationStopped> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-340"><xref:System.Windows.Application.OnNavigationStopped%2A> raises the <xref:System.Windows.Application.NavigationStopped> event.</span></span>  
  
 <span data-ttu-id="733ad-341">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnNavigationStopped%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-341">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnNavigationStopped%2A>.</span></span> <span data-ttu-id="733ad-342">如果需要引发 <xref:System.Windows.Application.NavigationStopped>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnNavigationStopped%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-342">The overridden method must call <xref:System.Windows.Application.OnNavigationStopped%2A> in the base class if <xref:System.Windows.Application.NavigationStopped> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-343">一个包含事件数据的 <see cref="T:System.Windows.SessionEndingCancelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-343">A <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-344">引发 <see cref="E:System.Windows.Application.SessionEnding" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-344">Raises the <see cref="E:System.Windows.Application.SessionEnding" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-345"><xref:System.Windows.Application.OnSessionEnding%2A> 引发 <xref:System.Windows.Application.SessionEnding> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-345"><xref:System.Windows.Application.OnSessionEnding%2A> raises the <xref:System.Windows.Application.SessionEnding> event.</span></span>  
  
 <span data-ttu-id="733ad-346">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnSessionEnding%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-346">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnSessionEnding%2A>.</span></span> <span data-ttu-id="733ad-347">如果需要引发 <xref:System.Windows.Application.SessionEnding>，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnSessionEnding%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-347">The overridden method must call <xref:System.Windows.Application.OnSessionEnding%2A> in the base class if <xref:System.Windows.Application.SessionEnding> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="733ad-348">一个包含事件数据的 <see cref="T:System.Windows.StartupEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-348">A <see cref="T:System.Windows.StartupEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="733ad-349">引发 <see cref="E:System.Windows.Application.Startup" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-349">Raises the <see cref="E:System.Windows.Application.Startup" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-350"><xref:System.Windows.Application.OnStartup%2A> 引发 <xref:System.Windows.Application.Startup> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-350"><xref:System.Windows.Application.OnStartup%2A> raises the <xref:System.Windows.Application.Startup> event.</span></span>  
  
 <span data-ttu-id="733ad-351">派生自 <xref:System.Windows.Application> 的类型可能会重写 <xref:System.Windows.Application.OnStartup%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-351">A type that derives from <xref:System.Windows.Application> may override <xref:System.Windows.Application.OnStartup%2A>.</span></span> <span data-ttu-id="733ad-352">如果需要引发 <xref:System.Windows.Application.Startup> 事件，则重写的方法必须调用基类中的 <xref:System.Windows.Application.OnStartup%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-352">The overridden method must call <xref:System.Windows.Application.OnStartup%2A> in the base class if the <xref:System.Windows.Application.Startup> event needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-353">获取应用程序范围属性的集合。</span><span class="sxs-lookup"><span data-stu-id="733ad-353">Gets a collection of application-scope properties.</span></span></summary>
        <value><span data-ttu-id="733ad-354">一个包含应用程序范围的属性的 <see cref="T:System.Collections.IDictionary" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-354">An <see cref="T:System.Collections.IDictionary" /> that contains the application-scope properties.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-355"><xref:System.Windows.Application> 通过可用于存储应用程序范围属性的 <xref:System.Windows.Application.Properties%2A> 公开字典。</span><span class="sxs-lookup"><span data-stu-id="733ad-355"><xref:System.Windows.Application> exposes a dictionary via <xref:System.Windows.Application.Properties%2A> which you can use to store application-scope properties.</span></span> <span data-ttu-id="733ad-356">这使你能够以线程安全方式在 <xref:System.AppDomain> 中的所有代码之间共享状态，而无需编写你自己的状态代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-356">This allows you to share state amongst all code in an <xref:System.AppDomain> in a thread-safe fashion, without the need to write your own state code.</span></span>  
  
 <span data-ttu-id="733ad-357">存储在 <xref:System.Windows.Application.Properties%2A> 中的属性必须转换为返回的相应类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-357">Properties stored in <xref:System.Windows.Application.Properties%2A> must be converted to the appropriate type returned.</span></span>  
  
 <span data-ttu-id="733ad-358"><xref:System.Windows.Application.Properties%2A> 属性是线程安全的，可从任何线程获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-358">The <xref:System.Windows.Application.Properties%2A> property is thread safe and is available from any thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-359">下面的示例演示如何使用 <xref:System.Windows.Application.Properties%2A>创建和使用应用程序范围属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-359">The following example shows how create and use an application-scope property using <xref:System.Windows.Application.Properties%2A>.</span></span>  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-360">获取或设置为 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序中的资源提供包统一资源标识符 (URI) 的<see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-360">Gets or sets the <see cref="T:System.Reflection.Assembly" /> that provides the pack uniform resource identifiers (URIs) for resources in a [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application.</span></span></summary>
        <value><span data-ttu-id="733ad-361">对 <see cref="T:System.Reflection.Assembly" /> 的引用，该引用为 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序中的资源提供包统一资源标识符（Uri）。</span><span class="sxs-lookup"><span data-stu-id="733ad-361">A reference to the <see cref="T:System.Reflection.Assembly" /> that provides the pack uniform resource identifiers (URIs) for resources in a [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-362">默认情况下，将在运行时解析 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 资源，与入口程序集有关，后者由 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 方法返回的值标识。</span><span class="sxs-lookup"><span data-stu-id="733ad-362">By default, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] resources are resolved at run time with respect to the entry assembly, which is identified by the value returned from the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="733ad-363">入口程序集是 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 返回的程序集，可以是以下内容：</span><span class="sxs-lookup"><span data-stu-id="733ad-363">The entry assembly is the assembly that is returned by <xref:System.Reflection.Assembly.GetEntryAssembly%2A> and could be the following:</span></span>  
  
-   <span data-ttu-id="733ad-364">默认应用程序域中的可执行程序集。</span><span class="sxs-lookup"><span data-stu-id="733ad-364">The executable assembly in the default application domain.</span></span>  
  
-   <span data-ttu-id="733ad-365">要通过调用 <xref:System.AppDomain.ExecuteAssembly%2A>执行的第一个程序集。</span><span class="sxs-lookup"><span data-stu-id="733ad-365">The first assembly to be executed by calling <xref:System.AppDomain.ExecuteAssembly%2A>.</span></span>  
  
 <span data-ttu-id="733ad-366">但是，在以下情况下，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集无法获取对条目程序集的引用：</span><span class="sxs-lookup"><span data-stu-id="733ad-366">In the following cases, however, a [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly cannot get a reference to the entry assembly:</span></span>  
  
-   <span data-ttu-id="733ad-367">非托管（本机）应用程序承载 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集。</span><span class="sxs-lookup"><span data-stu-id="733ad-367">An unmanaged (native) application hosts the [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly.</span></span>  
  
-   <span data-ttu-id="733ad-368">托管应用程序通过使用除 <xref:System.AppDomain.ExecuteAssembly%2A>以外的方法将 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集加载到新应用程序域中来承载该程序集。</span><span class="sxs-lookup"><span data-stu-id="733ad-368">A managed application hosts the [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly by loading it into a new application domain using a method other than <xref:System.AppDomain.ExecuteAssembly%2A>.</span></span>  
  
 <span data-ttu-id="733ad-369">在这两种情况下，<xref:System.Reflection.Assembly.GetEntryAssembly%2A> 返回 `null`，并且无法解析 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集的资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-369">In both of these cases, <xref:System.Reflection.Assembly.GetEntryAssembly%2A> returns `null`, and the [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly's resources cannot be resolved.</span></span> <span data-ttu-id="733ad-370">在这些情况下，只能将 <xref:System.Windows.Application.ResourceAssembly%2A> 设置为引用应用于解析资源的程序集。</span><span class="sxs-lookup"><span data-stu-id="733ad-370">In these cases, <xref:System.Windows.Application.ResourceAssembly%2A> can be set, once only, with a reference to the assembly that should be used to resolve resources.</span></span>  
  
 <span data-ttu-id="733ad-371"><xref:System.Windows.Application.ResourceAssembly%2A> 只能设置一次，因为在加载 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集之后，资源程序集不太可能会更改。</span><span class="sxs-lookup"><span data-stu-id="733ad-371"><xref:System.Windows.Application.ResourceAssembly%2A> can only be set once because it is unlikely that the resource assembly will change after the [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly is loaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-372">当 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 程序集可以发现入口程序集时，<xref:System.Windows.Application.ResourceAssembly%2A> 无法设置，即，<xref:System.Reflection.Assembly.GetEntryAssembly%2A> 返回对程序集的引用，而不是 `null`。</span><span class="sxs-lookup"><span data-stu-id="733ad-372"><xref:System.Windows.Application.ResourceAssembly%2A> cannot be set when a [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly can discover the entry assembly - that is, when <xref:System.Reflection.Assembly.GetEntryAssembly%2A> returns a reference to an assembly rather than `null`.</span></span>  
  
 <span data-ttu-id="733ad-373">此属性是线程安全的，可从任何线程获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-373">This property is thread safe and is available from any thread.</span></span>  
  
 <span data-ttu-id="733ad-374"><xref:System.Windows.Application.ResourceAssembly%2A> 在 .NET Framework 版本3.5 中引入。</span><span class="sxs-lookup"><span data-stu-id="733ad-374"><xref:System.Windows.Application.ResourceAssembly%2A> is introduced in the .NET Framework version 3.5.</span></span>  <span data-ttu-id="733ad-375">有关详细信息，请参见[版本和依赖关系](/dotnet/framework/migration-guide/versions-and-dependencies)。</span><span class="sxs-lookup"><span data-stu-id="733ad-375">For more information, see [Versions and Dependencies](/dotnet/framework/migration-guide/versions-and-dependencies).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="733ad-376">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序具有入口程序集，或者已设置 <see cref="P:System.Windows.Application.ResourceAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-376">A [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application has an entry assembly, or <see cref="P:System.Windows.Application.ResourceAssembly" /> has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-377">获取或设置应用程序范围资源（如样式和画笔）的集合。</span><span class="sxs-lookup"><span data-stu-id="733ad-377">Gets or sets a collection of application-scope resources, such as styles and brushes.</span></span></summary>
        <value><span data-ttu-id="733ad-378">一个包含零个或多个应用程序范围资源的 <see cref="T:System.Windows.ResourceDictionary" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-378">A <see cref="T:System.Windows.ResourceDictionary" /> object that contains zero or more application-scope resources.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-379"><xref:System.Windows.Application.Resources%2A> 属性可用于跨应用程序的窗口和元素共享资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-379">The <xref:System.Windows.Application.Resources%2A> property can be used to share resources across the windows and elements of an application.</span></span> <span data-ttu-id="733ad-380">此外，<xref:System.Windows.Application.Resources%2A> 属性包括在资源查找路径中，按以下顺序遍历该路径：</span><span class="sxs-lookup"><span data-stu-id="733ad-380">Additionally, the <xref:System.Windows.Application.Resources%2A> property is included in the resource lookup path, which is traversed in the following order:</span></span>  
  
1.  <span data-ttu-id="733ad-381">元素</span><span class="sxs-lookup"><span data-stu-id="733ad-381">Elements</span></span>  
  
2.  <span data-ttu-id="733ad-382">Windows</span><span class="sxs-lookup"><span data-stu-id="733ad-382">Windows</span></span>  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  <span data-ttu-id="733ad-383">System</span><span class="sxs-lookup"><span data-stu-id="733ad-383">System</span></span>  
  
 <span data-ttu-id="733ad-384">因此，[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 元素可以绑定到应用程序范围的资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-384">Consequently, [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elements can bind to application-scope resources.</span></span> <span data-ttu-id="733ad-385">此外，如果资源发生更改，资源系统将确保绑定到这些资源的元素属性会自动更新以反映所做的更改。</span><span class="sxs-lookup"><span data-stu-id="733ad-385">Additionally, if resources change, the resource system ensures that element properties which are bound to those resources are automatically updated to reflect the change.</span></span>  
  
 <span data-ttu-id="733ad-386">应用程序范围的资源提供了一种简单的方法来支持应用程序中的一致主题。</span><span class="sxs-lookup"><span data-stu-id="733ad-386">Application-scope resources provide a simple way to support a consistent theme across your application.</span></span> <span data-ttu-id="733ad-387">使用 `Application.Resources` 标记可以轻松地在 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 中创建主题。</span><span class="sxs-lookup"><span data-stu-id="733ad-387">You can easily create a theme in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] by using the `Application.Resources` tag.</span></span> <span data-ttu-id="733ad-388">但是，如果您的应用程序支持多个主题，其中可能包含大量主题元素，则使用每个主题的一个 <xref:System.Windows.ResourceDictionary> 实例管理它们可能会更容易。</span><span class="sxs-lookup"><span data-stu-id="733ad-388">However, if your application supports multiple themes, which may contain a large number of theme elements, it might be easier to manage them using one <xref:System.Windows.ResourceDictionary> instance for each theme.</span></span> <span data-ttu-id="733ad-389">通过这种方式，可以通过将资源属性设置为相应的 <xref:System.Windows.ResourceDictionary>来应用新的主题。</span><span class="sxs-lookup"><span data-stu-id="733ad-389">In this way, a new theme can be applied by setting the Resources property to the appropriate <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="733ad-390">使用 <xref:System.Windows.Application.Resources%2A>时有两个注意事项。</span><span class="sxs-lookup"><span data-stu-id="733ad-390">There are two considerations to make when using <xref:System.Windows.Application.Resources%2A>.</span></span> <span data-ttu-id="733ad-391">首先，字典*键*是一个对象，因此，如果设置和获取属性值，则需要使用完全相同的对象实例（请注意，使用字符串时，该键区分大小写）。</span><span class="sxs-lookup"><span data-stu-id="733ad-391">First, the dictionary *key* is an object, so you need to use exactly the same object instance when both setting and getting a property value (note that the key is case-sensitive when using a string).</span></span> <span data-ttu-id="733ad-392">其次，字典*值*是一个对象，因此在获取属性值时，需要将该值转换为所需的类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-392">Second, the dictionary *value* is an object, so you will need to convert the value to the desired type when getting a property value.</span></span>  
  
 <span data-ttu-id="733ad-393"><xref:System.Windows.Application.Resources%2A> 是线程安全的，可从任何线程获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-393"><xref:System.Windows.Application.Resources%2A> is thread safe and is available from any thread.</span></span>  
  
   
  
## Examples  
<span data-ttu-id="733ad-394">此示例演示如何将 XAML 与应用程序范围资源一起使用来创建一致的视觉外观。</span><span class="sxs-lookup"><span data-stu-id="733ad-394">This example illustrates how to use XAML together with application-scope resources to create a consistent visual appearance.</span></span> <span data-ttu-id="733ad-395">第一个示例来自*app.xaml*;第二个（来自*mainwindow.xaml*）。</span><span class="sxs-lookup"><span data-stu-id="733ad-395">The first example is from *App.xaml*; the second, from *MainWindow.xaml*.</span></span> 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 <span data-ttu-id="733ad-396">下面的示例演示如何在代码和 XAML 中设置应用程序资源（在C# wpf 项目中的 app.config 文件中，或在 Visual Basic wpf 项目中的 application .xaml 文件中）。</span><span class="sxs-lookup"><span data-stu-id="733ad-396">The following example shows how to set an application resource in code and XAML (in the App.xaml file in a C# WPF project or the Application.xaml file in a Visual Basic WPF project).</span></span>  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 <span data-ttu-id="733ad-397">下面的示例演示如何在代码中获取应用程序资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-397">The following example shows how to get an application resource in code.</span></span>  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="733ad-398">启动 Windows Presentation Foundation 应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-398">Starts a Windows Presentation Foundation application.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="733ad-399">启动 Windows Presentation Foundation 应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-399">Starts a Windows Presentation Foundation application.</span></span></summary>
        <returns><span data-ttu-id="733ad-400">在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-400">The <see cref="T:System.Int32" /> application exit code that is returned to the operating system when the application shuts down.</span></span> <span data-ttu-id="733ad-401">默认情况下，该退出代码值为 0。</span><span class="sxs-lookup"><span data-stu-id="733ad-401">By default, the exit code value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-402">调用 <xref:System.Windows.Application.Run%2A> 以启动 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-402"><xref:System.Windows.Application.Run%2A> is called to start a [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application.</span></span> <span data-ttu-id="733ad-403">如果使用标记或标记和代码隐藏定义 <xref:System.Windows.Application>，则 <xref:System.Windows.Application.Run%2A> 将被隐式调用。</span><span class="sxs-lookup"><span data-stu-id="733ad-403">If you define your <xref:System.Windows.Application> using markup, or markup and code-behind, <xref:System.Windows.Application.Run%2A> will be called implicitly.</span></span> <span data-ttu-id="733ad-404">但是，如果使用代码定义 <xref:System.Windows.Application>，则需要显式调用 <xref:System.Windows.Application.Run%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-404">However, if you define your <xref:System.Windows.Application> using code, you will need to explicitly call <xref:System.Windows.Application.Run%2A>.</span></span>  
  
 <span data-ttu-id="733ad-405">调用 <xref:System.Windows.Application.Run%2A> 时，<xref:System.Windows.Application> 会将新的 <xref:System.Windows.Threading.Dispatcher> 实例附加到 UI 线程。</span><span class="sxs-lookup"><span data-stu-id="733ad-405">When <xref:System.Windows.Application.Run%2A> is called, <xref:System.Windows.Application> attaches a new <xref:System.Windows.Threading.Dispatcher> instance to the UI thread.</span></span> <span data-ttu-id="733ad-406">接下来，调用 <xref:System.Windows.Threading.Dispatcher> 对象的 <xref:System.Windows.Threading.Dispatcher.Run%2A> 方法，该方法启动消息泵来处理 windows 消息。</span><span class="sxs-lookup"><span data-stu-id="733ad-406">Next, the <xref:System.Windows.Threading.Dispatcher> object's <xref:System.Windows.Threading.Dispatcher.Run%2A> method is called, which starts a message pump to process windows messages.</span></span> <span data-ttu-id="733ad-407">最后，<xref:System.Windows.Threading.Dispatcher> 对象将调用 <xref:System.Windows.Application> 对象的 <xref:System.Windows.Application.OnStartup%2A> 方法来引发 <xref:System.Windows.Application.Startup> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-407">Finally, the <xref:System.Windows.Threading.Dispatcher> object calls the <xref:System.Windows.Application> object's the <xref:System.Windows.Application.OnStartup%2A> method to raise the <xref:System.Windows.Application.Startup> event.</span></span> <span data-ttu-id="733ad-408">因此，应用程序执行模型已在处理 <xref:System.Windows.Application.Startup>时建立，此时应用程序被视为正在运行。</span><span class="sxs-lookup"><span data-stu-id="733ad-408">Consequently, the application execution model has been established by the time you handle <xref:System.Windows.Application.Startup>, at which point the application is considered to be running.</span></span>  
  
 <span data-ttu-id="733ad-409">调用 <xref:System.Windows.Application.Shutdown%2A> 时，应用程序停止运行;<xref:System.Windows.Application.ShutdownMode%2A> 属性的值将确定调用 <xref:System.Windows.Application.Shutdown%2A> 的时间，以及它是自动发生还是需要显式调用它。</span><span class="sxs-lookup"><span data-stu-id="733ad-409">An application stops running when <xref:System.Windows.Application.Shutdown%2A> is called; the value of the <xref:System.Windows.Application.ShutdownMode%2A> property determines when <xref:System.Windows.Application.Shutdown%2A> is called, and whether it happens automatically or you need to explicitly call it.</span></span>  
  
 <span data-ttu-id="733ad-410">只能从创建 <xref:System.Windows.Application> 对象的线程调用 <xref:System.Windows.Application.Run%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-410"><xref:System.Windows.Application.Run%2A> can be called only from the thread that creates the <xref:System.Windows.Application> object.</span></span> <span data-ttu-id="733ad-411">此外，不能从 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]中调用 <xref:System.Windows.Application.Run%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-411">Also, <xref:System.Windows.Application.Run%2A> cannot be called from a [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-412">下面的示例演示一个使用自定义 <xref:System.Windows.Application> 的应用程序，因此必须显式调用 <xref:System.Windows.Application.Run%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-412">The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.</span></span>  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="733ad-413"><see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]）调用的。</span><span class="sxs-lookup"><span data-stu-id="733ad-413"><see cref="M:System.Windows.Application.Run" /> is called from a browser-hosted application (for example, an [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</span></span></exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function Run (window As Window) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window"><span data-ttu-id="733ad-414">在应用程序启动时自动打开的 <see cref="T:System.Windows.Window" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-414">A <see cref="T:System.Windows.Window" /> that opens automatically when an application starts.</span></span></param>
        <summary><span data-ttu-id="733ad-415">启动 Windows Presentation Foundation 应用程序并打开指定窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-415">Starts a Windows Presentation Foundation application and opens the specified window.</span></span></summary>
        <returns><span data-ttu-id="733ad-416">在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-416">The <see cref="T:System.Int32" /> application exit code that is returned to the operating system when the application shuts down.</span></span> <span data-ttu-id="733ad-417">默认情况下，该退出代码值为 0。</span><span class="sxs-lookup"><span data-stu-id="733ad-417">By default, the exit code value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-418">此重载扩展 <xref:System.Windows.Application.Run%2A> 方法，以便在应用程序开始运行后打开指定窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-418">This overload extends the <xref:System.Windows.Application.Run%2A> method to open the specified window after an application starts running.</span></span>  
  
 <span data-ttu-id="733ad-419">如果定义一个在开始运行时打开窗口的代码 <xref:System.Windows.Application>，则显式调用 <xref:System.Windows.Application.Run%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-419">If you define a code <xref:System.Windows.Application> that opens a window when it starts running, you explicitly call <xref:System.Windows.Application.Run%2A>.</span></span>  
  
 <span data-ttu-id="733ad-420">如果使用标记或标记和代码隐藏创建 <xref:System.Windows.Application>，可以在使用以下任一方法时自动打开窗口：</span><span class="sxs-lookup"><span data-stu-id="733ad-420">If you create your <xref:System.Windows.Application> using markup, or markup and code-behind, you can automatically open a window during using either of the following techniques:</span></span>  
  
-   <span data-ttu-id="733ad-421">通过将 <xref:System.Windows.Application.StartupUri%2A>设置为以声明方式。</span><span class="sxs-lookup"><span data-stu-id="733ad-421">Declaratively, by setting <xref:System.Windows.Application.StartupUri%2A>.</span></span>  
  
-   <span data-ttu-id="733ad-422">通过以编程方式处理 <xref:System.Windows.Application.Startup>。</span><span class="sxs-lookup"><span data-stu-id="733ad-422">Programmatically, by handling <xref:System.Windows.Application.Startup>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-423">下面的示例显示一个应用程序，该应用程序具有一个手动创建的静态入口点方法，该方法在调用 <xref:System.Windows.Application.Run%2A>之前实例化 <xref:System.Windows.Application>。</span><span class="sxs-lookup"><span data-stu-id="733ad-423">The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.</span></span>  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="733ad-424"><see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]）调用的。</span><span class="sxs-lookup"><span data-stu-id="733ad-424"><see cref="M:System.Windows.Application.Run" /> is called from a browser-hosted application (for example, an [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</span></span></exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-425">当用户通过注销或关闭操作系统来结束 Windows 会话时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-425">Occurs when the user ends the Windows session by logging off or shutting down the operating system.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-426">默认情况下，当 Windows 会话结束时，应用程序会关闭，这在用户注销或关闭时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-426">By default, an application shuts down when the Windows session ends, which occurs when a user logs off or shuts down.</span></span> <span data-ttu-id="733ad-427">发生这种情况时，Windows 会要求每个打开的应用程序关闭。</span><span class="sxs-lookup"><span data-stu-id="733ad-427">When this happens, Windows asks each open application to shut down.</span></span> <span data-ttu-id="733ad-428">但是，在发生这种情况时，应用程序可能不能关闭。</span><span class="sxs-lookup"><span data-stu-id="733ad-428">However, it is possible that an application may not be ready to shut down when this occurs.</span></span> <span data-ttu-id="733ad-429">例如，应用程序的数据可能处于不一致的状态，或者处于长时间运行的操作的中间。</span><span class="sxs-lookup"><span data-stu-id="733ad-429">For example, an application may have data that is in an inconsistent state, or in the middle of a long-running operation.</span></span> <span data-ttu-id="733ad-430">在这些情况下，可能需要防止会话结束，并且可能更需要允许用户选择是否要让会话结束的情况。</span><span class="sxs-lookup"><span data-stu-id="733ad-430">In these situations, it may be desirable to prevent the session from ending, and may be more desirable to allow users the option to decide whether or not to let the session to end.</span></span>  
  
 <span data-ttu-id="733ad-431">可以通过处理 <xref:System.Windows.Application.SessionEnding> 事件来检测会话结束的时间。</span><span class="sxs-lookup"><span data-stu-id="733ad-431">You can detect when a session ends by handling the <xref:System.Windows.Application.SessionEnding> event.</span></span> <span data-ttu-id="733ad-432">如果应用程序需要阻止会话结束，则传递到事件处理程序的 <xref:System.Windows.SessionEndingCancelEventArgs> 参数将公开您设置为 `true` 的 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> （默认值为 `false`）。</span><span class="sxs-lookup"><span data-stu-id="733ad-432">If an application needs to prevent the session from ending, the <xref:System.Windows.SessionEndingCancelEventArgs> argument that is passed to the event handler exposes the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> that you set to `true` (the default value is `false`).</span></span>  
  
 <span data-ttu-id="733ad-433">如果 <xref:System.Windows.Application.SessionEnding> 未处理，或在未取消的情况下进行处理，则将调用 <xref:System.Windows.Application.Shutdown%2A> 并引发 <xref:System.Windows.Application.Exit> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-433">If <xref:System.Windows.Application.SessionEnding> is unhandled, or is handled without being cancelled, <xref:System.Windows.Application.Shutdown%2A> is called and the <xref:System.Windows.Application.Exit> event is raised.</span></span>  
  
 <span data-ttu-id="733ad-434">若要获取有关会话结束原因的详细信息，应用程序可以检查 <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，这是 <xref:System.Windows.ReasonSessionEnding> 值（<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> 和 <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>）之一。</span><span class="sxs-lookup"><span data-stu-id="733ad-434">To obtain more information about why the session is ending, an application can inspect <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, which is one of the <xref:System.Windows.ReasonSessionEnding> values (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> and <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="733ad-435">控制台应用程序不会引发 <xref:System.Windows.Application.SessionEnding>。</span><span class="sxs-lookup"><span data-stu-id="733ad-435"><xref:System.Windows.Application.SessionEnding> is not raised by console applications.</span></span>  
  
 <span data-ttu-id="733ad-436">仅在创建 <xref:System.Windows.Application> 对象的线程上引发 <xref:System.Windows.Application.SessionEnding>。</span><span class="sxs-lookup"><span data-stu-id="733ad-436"><xref:System.Windows.Application.SessionEnding> is raised only on the thread that creates the <xref:System.Windows.Application> object.</span></span>  
  
 <span data-ttu-id="733ad-437">XAML 浏览器应用程序（Xbap）不会引发 <xref:System.Windows.Application.SessionEnding>。</span><span class="sxs-lookup"><span data-stu-id="733ad-437"><xref:System.Windows.Application.SessionEnding> is not raised for XAML browser applications (XBAPs).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-438">下面的示例演示如何处理 <xref:System.Windows.Application.SessionEnding> 事件并允许用户取消它。</span><span class="sxs-lookup"><span data-stu-id="733ad-438">The following example demonstrates how to handle the <xref:System.Windows.Application.SessionEnding> event and allow the user to cancel it.</span></span>  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCookie (uri As Uri, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="733ad-439"><see cref="T:System.Uri" />，它指定应为其创建 Cookie 的位置。</span><span class="sxs-lookup"><span data-stu-id="733ad-439">The <see cref="T:System.Uri" /> that specifies the location for which the cookie should be created.</span></span></param>
        <param name="value"><span data-ttu-id="733ad-440">包含 Cookie 数据的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-440">The <see cref="T:System.String" /> that contains the cookie data.</span></span></param>
        <summary><span data-ttu-id="733ad-441">为由 <see cref="T:System.Uri" /> 指定的位置创建一个 Cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-441">Creates a cookie for the location specified by a <see cref="T:System.Uri" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-442">Cookie 是在应用程序会话（会话 cookie）或跨应用程序会话（持久性 cookie）期间，客户端计算机上的应用程序可以存储的数据的任意部分。</span><span class="sxs-lookup"><span data-stu-id="733ad-442">A cookie is an arbitrary piece of data that can be stored by an application on the client machine during application sessions (session cookies) or across application sessions (persistent cookies).</span></span> <span data-ttu-id="733ad-443">可以通过调用 <xref:System.Windows.Application.SetCookie%2A>来创建这两种类型的 cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-443">You can create both types of cookies by calling <xref:System.Windows.Application.SetCookie%2A>.</span></span>  
  
 <span data-ttu-id="733ad-444">Cookie 数据通常采用以下格式的名称/值对的形式：</span><span class="sxs-lookup"><span data-stu-id="733ad-444">Cookie data typically takes the form of a name/value pair in the following format:</span></span>  
  
 `Name=Value`  
  
 <span data-ttu-id="733ad-445">将此格式的字符串传递到 <xref:System.Windows.Application.SetCookie%2A>，以及应设置 cookie 的位置的 <xref:System.Uri> （通常为应用程序域）。</span><span class="sxs-lookup"><span data-stu-id="733ad-445">You pass a string of this format to <xref:System.Windows.Application.SetCookie%2A>, along with the <xref:System.Uri> of the location for which the cookie should be set (typically, the application domain).</span></span>  
  
 <span data-ttu-id="733ad-446">Cookie 是会话 cookie 还是永久性 cookie 取决于您传递给 <xref:System.Windows.Application.SetCookie%2A> 的 cookie 字符串是否包含到期日期。</span><span class="sxs-lookup"><span data-stu-id="733ad-446">Whether a cookie is a session cookie or a persistent cookie depends on whether the cookie string that you pass to <xref:System.Windows.Application.SetCookie%2A> includes an expiry date.</span></span> <span data-ttu-id="733ad-447">会话 cookie 的字符串不包括到期日期。</span><span class="sxs-lookup"><span data-stu-id="733ad-447">The string for a session cookie does not include an expiry date.</span></span> <span data-ttu-id="733ad-448">持久 cookie 的字符串具有，并且必须采用以下格式：</span><span class="sxs-lookup"><span data-stu-id="733ad-448">The string for a persistent cookie does, and must be in the following format:</span></span>  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 <span data-ttu-id="733ad-449">永久性 cookie 存储在当前 [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] 安装的 Internet 临时文件文件夹中，直到它们过期，在这种情况下，将删除这些 cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-449">Persistent cookies are stored in the current [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] installation's Temporary Internet Files folder until they expire, in which case they are deleted.</span></span> <span data-ttu-id="733ad-450">可以通过将应用程序的到期日期设置为过去的日期/时间值，从应用程序中删除持久性 cookie。</span><span class="sxs-lookup"><span data-stu-id="733ad-450">You can delete a persistent cookie from your application by setting its expiry date to a date/time value that is in the past.</span></span>  
  
 <span data-ttu-id="733ad-451">有关 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]中的 cookie 概述，请参阅[导航概述](/dotnet/framework/wpf/app-development/navigation-overview)。</span><span class="sxs-lookup"><span data-stu-id="733ad-451">For an overview of cookies in [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], see [Navigation Overview](/dotnet/framework/wpf/app-development/navigation-overview).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="733ad-452">如果在尝试创建指定的 Cookie 时发生问题，则会由 <see langword="InternetSetCookie" /> 函数（由 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> 调用）引发一个 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 错误。</span><span class="sxs-lookup"><span data-stu-id="733ad-452">A [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] error is raised by the <see langword="InternetSetCookie" /> function (called by <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) if a problem occurs when attempting to create the specified cookie.</span></span></exception>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="733ad-453">关闭一个应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-453">Shuts down an application.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="733ad-454">关闭一个应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-454">Shuts down an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-455">调用 <xref:System.Windows.Application.Shutdown%2A> 时，应用程序将停止运行。</span><span class="sxs-lookup"><span data-stu-id="733ad-455">When <xref:System.Windows.Application.Shutdown%2A> is called, an application stops running.</span></span> <span data-ttu-id="733ad-456">可以通过处理 <xref:System.Windows.Application.Exit> 事件来检测应用程序何时停止运行，以执行任何适当的处理。</span><span class="sxs-lookup"><span data-stu-id="733ad-456">You can handle the <xref:System.Windows.Application.Exit> event to detect when an application is about to stop running, to perform any appropriate processing.</span></span>  
  
 <span data-ttu-id="733ad-457">在以下情况下，Windows Presentation Foundation 隐式调用 <xref:System.Windows.Application.Shutdown%2A>：</span><span class="sxs-lookup"><span data-stu-id="733ad-457"><xref:System.Windows.Application.Shutdown%2A> is implicitly called by Windows Presentation Foundation in the following situations:</span></span>  
  
-   <span data-ttu-id="733ad-458">如果 <xref:System.Windows.Application.ShutdownMode%2A> 设置为 <xref:System.Windows.ShutdownMode.OnLastWindowClose>。</span><span class="sxs-lookup"><span data-stu-id="733ad-458">When <xref:System.Windows.Application.ShutdownMode%2A> is set to <xref:System.Windows.ShutdownMode.OnLastWindowClose>.</span></span>  
  
-   <span data-ttu-id="733ad-459">如果 <xref:System.Windows.Application.ShutdownMode%2A> 设置为 <xref:System.Windows.ShutdownMode.OnMainWindowClose>。</span><span class="sxs-lookup"><span data-stu-id="733ad-459">When the <xref:System.Windows.Application.ShutdownMode%2A> is set to <xref:System.Windows.ShutdownMode.OnMainWindowClose>.</span></span>  
  
-   <span data-ttu-id="733ad-460">当用户结束会话并且 <xref:System.Windows.Application.SessionEnding> 事件未处理或未取消处理时。</span><span class="sxs-lookup"><span data-stu-id="733ad-460">When a user ends a session and the <xref:System.Windows.Application.SessionEnding> event is either unhandled, or handled without cancellation.</span></span>  
  
 <span data-ttu-id="733ad-461">调用 <xref:System.Windows.Application.Shutdown%2A> 会显式导致应用程序关闭，而不考虑 <xref:System.Windows.Application.ShutdownMode%2A> 设置。</span><span class="sxs-lookup"><span data-stu-id="733ad-461">Calling <xref:System.Windows.Application.Shutdown%2A> explicitly causes an application to shut down, regardless of the <xref:System.Windows.Application.ShutdownMode%2A> setting.</span></span> <span data-ttu-id="733ad-462">但是，如果 <xref:System.Windows.Application.ShutdownMode%2A> 设置为 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>，则必须调用 <xref:System.Windows.Application.Shutdown%2A> 关闭应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-462">However, if <xref:System.Windows.Application.ShutdownMode%2A> is set to <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, you must call <xref:System.Windows.Application.Shutdown%2A> to shut down an application.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="733ad-463">调用 <xref:System.Windows.Application.Shutdown%2A> 时，应用程序将关闭，而不考虑任何打开窗口的 <xref:System.Windows.Window.Closing> 事件是否已取消。</span><span class="sxs-lookup"><span data-stu-id="733ad-463">When <xref:System.Windows.Application.Shutdown%2A> is called, the application will shut down irrespective of whether the <xref:System.Windows.Window.Closing> event of any open windows is canceled.</span></span>  
  
 <span data-ttu-id="733ad-464">只能从创建 <xref:System.Windows.Application> 对象的线程调用此方法。</span><span class="sxs-lookup"><span data-stu-id="733ad-464">This method can be called only from the thread that created the <xref:System.Windows.Application> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode"><span data-ttu-id="733ad-465">应用程序的一个整数退出代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-465">An integer exit code for an application.</span></span> <span data-ttu-id="733ad-466">默认退出代码为 0。</span><span class="sxs-lookup"><span data-stu-id="733ad-466">The default exit code is 0.</span></span></param>
        <summary><span data-ttu-id="733ad-467">关闭将指定退出代码返回给操作系统的应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-467">Shuts down an application that returns the specified exit code to the operating system.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-468">可以处理 <xref:System.Windows.Application.Exit> 事件以设置退出代码。</span><span class="sxs-lookup"><span data-stu-id="733ad-468">You can handle the <xref:System.Windows.Application.Exit> event to set an exit code.</span></span> <span data-ttu-id="733ad-469">但是，如果显式调用 <xref:System.Windows.Application.Shutdown%2A>，且仅处理 <xref:System.Windows.Application.Exit> 设置退出代码，则可以改为调用 <xref:System.Windows.Application.Shutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-469">However, if you explicitly call <xref:System.Windows.Application.Shutdown%2A>, and you handle <xref:System.Windows.Application.Exit> only to set an exit code, you can call <xref:System.Windows.Application.Shutdown%2A> instead.</span></span>  
  
 <span data-ttu-id="733ad-470">只能从创建 <xref:System.Windows.Application> 对象的线程调用此方法。</span><span class="sxs-lookup"><span data-stu-id="733ad-470">This method can be called only from the thread that created the <xref:System.Windows.Application> object.</span></span>  
  
 <span data-ttu-id="733ad-471">有关退出代码的信息，请参阅 <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="733ad-471">See <xref:System.Environment.ExitCode%2A?displayProperty=nameWithType> for information on exit codes.</span></span>
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-472">获取或设置导致调用 <see cref="M:System.Windows.Application.Shutdown" /> 方法的条件。</span><span class="sxs-lookup"><span data-stu-id="733ad-472">Gets or sets the condition that causes the <see cref="M:System.Windows.Application.Shutdown" /> method to be called.</span></span></summary>
        <value><span data-ttu-id="733ad-473">一个 <see cref="T:System.Windows.ShutdownMode" /> 枚举值。</span><span class="sxs-lookup"><span data-stu-id="733ad-473">A <see cref="T:System.Windows.ShutdownMode" /> enumeration value.</span></span> <span data-ttu-id="733ad-474">默认值是 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-474">The default value is <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-475">只有在调用应用程序的 <xref:System.Windows.Application.Shutdown%2A> 方法时，应用程序才会停止运行。</span><span class="sxs-lookup"><span data-stu-id="733ad-475">Applications stop running only when the <xref:System.Windows.Application.Shutdown%2A> method of the Application is called.</span></span> <span data-ttu-id="733ad-476">关机可以隐式或显式方式发生，如 <xref:System.Windows.Application.ShutdownMode%2A> 属性的值所指定。</span><span class="sxs-lookup"><span data-stu-id="733ad-476">Shut down can occur implicitly or explicitly, as specified by the value of the <xref:System.Windows.Application.ShutdownMode%2A> property.</span></span>  
  
 <span data-ttu-id="733ad-477">如果将 <xref:System.Windows.Application.ShutdownMode%2A> 设置为 <xref:System.Windows.ShutdownMode.OnLastWindowClose>，则当应用程序中的最后一个窗口关闭时，Windows Presentation Foundation （WPF）会隐式调用 <xref:System.Windows.Application.Shutdown%2A> （即使将当前实例化的任何窗口设置为主窗口）（请参阅 <xref:System.Windows.Application.MainWindow%2A>）。</span><span class="sxs-lookup"><span data-stu-id="733ad-477">If you set <xref:System.Windows.Application.ShutdownMode%2A> to <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) implicitly calls <xref:System.Windows.Application.Shutdown%2A> when the last window in an application closes, even if any currently instantiated windows are set as the main window (see <xref:System.Windows.Application.MainWindow%2A>).</span></span>  
  
 <span data-ttu-id="733ad-478">当 <xref:System.Windows.Application.MainWindow%2A> 关闭时，<xref:System.Windows.Application.ShutdownMode%2A> <xref:System.Windows.ShutdownMode.OnMainWindowClose> 会导致 WPF 隐式调用 <xref:System.Windows.Application.Shutdown%2A>，即使当前打开了其他窗口也是如此。</span><span class="sxs-lookup"><span data-stu-id="733ad-478">A <xref:System.Windows.Application.ShutdownMode%2A> of <xref:System.Windows.ShutdownMode.OnMainWindowClose> causes WPF to implicitly call <xref:System.Windows.Application.Shutdown%2A> when the <xref:System.Windows.Application.MainWindow%2A> closes, even if other windows are currently open.</span></span>  
  
 <span data-ttu-id="733ad-479">某些应用程序的生存期可能不依赖于主窗口或最后一个窗口关闭的时间，也可能根本不依赖于 windows。</span><span class="sxs-lookup"><span data-stu-id="733ad-479">The lifetime of some applications may not be dependent on when the main window or last window is closed, or may not be dependent on windows at all.</span></span> <span data-ttu-id="733ad-480">对于这些情况，需要将 <xref:System.Windows.Application.ShutdownMode%2A> 属性设置为 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>，这需要使用显式 <xref:System.Windows.Application.Shutdown%2A> 方法调用来停止应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-480">For these scenarios you need to set the <xref:System.Windows.Application.ShutdownMode%2A> property to <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, which requires an explicit <xref:System.Windows.Application.Shutdown%2A> method call to stop the application.</span></span> <span data-ttu-id="733ad-481">否则，应用程序将继续在后台运行。</span><span class="sxs-lookup"><span data-stu-id="733ad-481">Otherwise, the application continues running in the background.</span></span>  
  
 <span data-ttu-id="733ad-482">可以通过代码以声明方式从 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 或以编程方式配置 <xref:System.Windows.Application.ShutdownMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-482"><xref:System.Windows.Application.ShutdownMode%2A> can be configured declaratively from [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] or programmatically from code.</span></span>  
  
 <span data-ttu-id="733ad-483">此属性仅在创建 <xref:System.Windows.Application> 对象的线程中可用。</span><span class="sxs-lookup"><span data-stu-id="733ad-483">This property is available only from the thread that created the <xref:System.Windows.Application> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-484">下面的示例演示如何配置 <xref:System.Windows.Application.ShutdownMode%2A> 以指定必须显式关闭应用程序。</span><span class="sxs-lookup"><span data-stu-id="733ad-484">The following example shows how to configure <xref:System.Windows.Application.ShutdownMode%2A> to specify that an application must be closed explicitly.</span></span>  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-485">在调用 <see cref="M:System.Windows.Application.Run" /> 对象的 <see cref="T:System.Windows.Application" /> 方法时发生。</span><span class="sxs-lookup"><span data-stu-id="733ad-485">Occurs when the <see cref="M:System.Windows.Application.Run" /> method of the <see cref="T:System.Windows.Application" /> object is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-486">典型的 Windows Presentation Foundation 应用程序在启动时可能会执行各种初始化任务，包括：</span><span class="sxs-lookup"><span data-stu-id="733ad-486">A typical Windows Presentation Foundation application may perform a variety of initialization tasks when it starts up, including:</span></span>  
  
-   <span data-ttu-id="733ad-487">处理命令行参数。</span><span class="sxs-lookup"><span data-stu-id="733ad-487">Processing command-line parameters.</span></span>  
  
-   <span data-ttu-id="733ad-488">打开主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-488">Opening the main window.</span></span>  
  
-   <span data-ttu-id="733ad-489">正在初始化应用程序范围资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-489">Initializing application-scope resources.</span></span>  
  
-   <span data-ttu-id="733ad-490">正在初始化应用程序范围的属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-490">Initializing application-scope properties.</span></span>  
  
 <span data-ttu-id="733ad-491">可以使用 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] （分别为<xref:System.Windows.Application.StartupUri%2A> 和 <xref:System.Windows.Application.Resources%2A>）以声明方式指定主窗口和应用程序范围的资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-491">You can declaratively specify the main window and application-scope resources using [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> and <xref:System.Windows.Application.Resources%2A>, respectively).</span></span> <span data-ttu-id="733ad-492">但有时，只能在运行时以编程方式确定应用程序的资源或主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-492">Sometimes, however, the resources or main window of your application can only be determined programmatically at run time.</span></span> <span data-ttu-id="733ad-493">此外，应用程序范围的属性和命令行参数只能以编程方式使用。</span><span class="sxs-lookup"><span data-stu-id="733ad-493">Additionally, application-scope properties and command-line parameters can only be used programmatically.</span></span> <span data-ttu-id="733ad-494">可以通过处理 <xref:System.Windows.Application.Startup> 事件来执行编程初始化，其中包括：</span><span class="sxs-lookup"><span data-stu-id="733ad-494">Programmatic initialization can be performed by handling the <xref:System.Windows.Application.Startup> event, including the following:</span></span>  
  
-   <span data-ttu-id="733ad-495">获取和处理命令行参数，该参数可从传递到 <xref:System.Windows.Application.Startup> 事件处理程序的 <xref:System.Windows.StartupEventArgs> 类的 <xref:System.Windows.StartupEventArgs.Args%2A> 属性中获取。</span><span class="sxs-lookup"><span data-stu-id="733ad-495">Acquire and process command-line parameters, which are available from the <xref:System.Windows.StartupEventArgs.Args%2A> property of the <xref:System.Windows.StartupEventArgs> class that is passed to the <xref:System.Windows.Application.Startup> event handler.</span></span>  
  
-   <span data-ttu-id="733ad-496">使用 <xref:System.Windows.Application.Resources%2A> 属性初始化应用程序范围资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-496">Initialize application-scope resources by using the <xref:System.Windows.Application.Resources%2A> property.</span></span>  
  
-   <span data-ttu-id="733ad-497">使用 <xref:System.Windows.Application.Properties%2A> 属性初始化应用程序范围的属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-497">Initialize application-scope properties by using the <xref:System.Windows.Application.Properties%2A> property.</span></span>  
  
-   <span data-ttu-id="733ad-498">实例化并显示一个（或多个）窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-498">Instantiate and show one (or more) windows.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-499">还可以通过调用 <xref:System.Environment> 对象的静态 <xref:System.Environment.GetCommandLineArgs%2A> 方法来获取命令行参数。</span><span class="sxs-lookup"><span data-stu-id="733ad-499">Command-line parameters can also be acquired by calling the static <xref:System.Environment.GetCommandLineArgs%2A> method of the <xref:System.Environment> object.</span></span> <span data-ttu-id="733ad-500">但 <xref:System.Environment.GetCommandLineArgs%2A> 需要完全信任才能执行。</span><span class="sxs-lookup"><span data-stu-id="733ad-500">However, <xref:System.Environment.GetCommandLineArgs%2A> requires full trust to execute.</span></span>  
  
 <span data-ttu-id="733ad-501">如果使用 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]设置 <xref:System.Windows.Application.StartupUri%2A>，则在处理 <xref:System.Windows.Application> 事件之前，创建的主窗口无法从 <xref:System.Windows.Application.Startup> 对象的 <xref:System.Windows.Application.MainWindow%2A> 属性或 <xref:System.Windows.Application.Windows%2A> 属性中获得。</span><span class="sxs-lookup"><span data-stu-id="733ad-501">If you set <xref:System.Windows.Application.StartupUri%2A> using [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], the main window that is created is not available from either the <xref:System.Windows.Application.MainWindow%2A> property or the <xref:System.Windows.Application.Windows%2A> property of the <xref:System.Windows.Application> object until after the <xref:System.Windows.Application.Startup> event is processed.</span></span> <span data-ttu-id="733ad-502">如果在启动期间需要访问主窗口，则需要从 <xref:System.Windows.Application.Startup> 事件处理程序中手动创建新的窗口对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-502">If you need access to the main window during startup, you need to manually create a new window object from your <xref:System.Windows.Application.Startup> event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="733ad-503">如果你的应用程序使用 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 来指定凭据策略，则需要在引发 <xref:System.Windows.Application.Startup> 后设置 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>;否则，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 在引发 <xref:System.Windows.Application.Startup> 事件之后直接将它设置为默认内部策略。</span><span class="sxs-lookup"><span data-stu-id="733ad-503">If your application uses <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> to specify a credential policy, you need to set <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> after <xref:System.Windows.Application.Startup> is raised; otherwise, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] sets it to a default internal policy directly after the <xref:System.Windows.Application.Startup> event has been raised.</span></span>  
  
 <span data-ttu-id="733ad-504">传递给 <xref:System.Windows.Application.Startup> 事件处理程序的命令行参数与传递到 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]的 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 查询字符串参数不同。</span><span class="sxs-lookup"><span data-stu-id="733ad-504">The command-line arguments that are passed to the <xref:System.Windows.Application.Startup> event handler are not the same as the [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] query string parameters that are passed to an [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-505">下面的示例演示如何从独立的应用程序获取和处理命令行选项。</span><span class="sxs-lookup"><span data-stu-id="733ad-505">The following example shows how to acquire and process command-line options from a standalone application.</span></span> <span data-ttu-id="733ad-506">如果提供了 **/StartMinimized**命令行参数，则应用程序将打开处于最小化状态的主窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-506">If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.</span></span>  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] <span data-ttu-id="733ad-507">无法检索和处理命令行参数，因为它们是使用 [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] 部署启动的（请参阅[部署 Wpf 应用程序（wpf）](/dotnet/framework/wpf/app-development/deploying-a-wpf-application-wpf)）。</span><span class="sxs-lookup"><span data-stu-id="733ad-507">cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](/dotnet/framework/wpf/app-development/deploying-a-wpf-application-wpf)).</span></span> <span data-ttu-id="733ad-508">但是，它们可以检索和处理来自用于启动它们的 URL 的查询字符串参数。</span><span class="sxs-lookup"><span data-stu-id="733ad-508">However, they can retrieve and process query string parameters from the URLs that are used to launch them.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-509">获取或设置在应用程序启动时自动显示的 UI。</span><span class="sxs-lookup"><span data-stu-id="733ad-509">Gets or sets a UI that is automatically shown when an application starts.</span></span></summary>
        <value><span data-ttu-id="733ad-510">引用在应用程序启动时自动打开的 UI 的 <see cref="T:System.Uri" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-510">A <see cref="T:System.Uri" /> that refers to the UI that automatically opens when an application starts.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-511">当应用程序启动时，可以使用 <xref:System.Windows.Application.StartupUri%2A> 自动加载 UI 资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-511">You can use <xref:System.Windows.Application.StartupUri%2A> to automatically load a UI resource when an application starts.</span></span>  
  
 <span data-ttu-id="733ad-512">下表显示了可以加载的 UI 资源的类型、打开它们的窗口的类型，以及可以将这些资源设置为 <xref:System.Windows.Application.StartupUri%2A>的应用程序的类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-512">The following table shows the types of UI resources that can be loaded, the type of window they are opened into, and the type of application that these resources can be set as the <xref:System.Windows.Application.StartupUri%2A>.</span></span>  
  
|<span data-ttu-id="733ad-513">类型</span><span class="sxs-lookup"><span data-stu-id="733ad-513">Type</span></span>|<span data-ttu-id="733ad-514">窗口</span><span class="sxs-lookup"><span data-stu-id="733ad-514">Window</span></span>|<span data-ttu-id="733ad-515">应用程序类型</span><span class="sxs-lookup"><span data-stu-id="733ad-515">Application type</span></span>|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|<span data-ttu-id="733ad-516">仅限独立</span><span class="sxs-lookup"><span data-stu-id="733ad-516">Standalone only</span></span>|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|<span data-ttu-id="733ad-517">仅限独立</span><span class="sxs-lookup"><span data-stu-id="733ad-517">Standalone only</span></span>|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|<span data-ttu-id="733ad-518">独立/浏览器托管</span><span class="sxs-lookup"><span data-stu-id="733ad-518">Standalone/browser-hosted</span></span>|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|<span data-ttu-id="733ad-519">独立/浏览器托管</span><span class="sxs-lookup"><span data-stu-id="733ad-519">Standalone/browser-hosted</span></span>|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|<span data-ttu-id="733ad-520">独立/浏览器托管</span><span class="sxs-lookup"><span data-stu-id="733ad-520">Standalone/browser-hosted</span></span>|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|<span data-ttu-id="733ad-521">独立/浏览器托管</span><span class="sxs-lookup"><span data-stu-id="733ad-521">Standalone/browser-hosted</span></span>|  
  
 <span data-ttu-id="733ad-522">通常，在 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]中以声明方式设置 <xref:System.Windows.Application.StartupUri%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-522">Typically, you set the <xref:System.Windows.Application.StartupUri%2A> property declaratively in [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</span></span> <span data-ttu-id="733ad-523">不过，您可以通过编程方式设置 <xref:System.Windows.Application.StartupUri%2A> （如从 <xref:System.Windows.Application.Startup> 事件处理程序），这对于在运行时只能加载必要 UI 资源的应用程序很有用。</span><span class="sxs-lookup"><span data-stu-id="733ad-523">However, you can set <xref:System.Windows.Application.StartupUri%2A> programmatically, such as from a <xref:System.Windows.Application.Startup> event handler, which is useful if for applications that can only load the necessary UI resources at run time.</span></span> <span data-ttu-id="733ad-524">例如，如果 UI 资源的名称存储在配置文件中，应用程序可能等到运行时加载其资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-524">For example, an application might wait until run time to load its resources if the name of the UI resource is stored in a configuration file.</span></span>  
  
 <span data-ttu-id="733ad-525">无论是以声明方式还是以编程方式设置 <xref:System.Windows.Application.StartupUri%2A>，都不会加载相应的 UI 资源，直到处理 <xref:System.Windows.Application.Startup> 事件。</span><span class="sxs-lookup"><span data-stu-id="733ad-525">Whether you set <xref:System.Windows.Application.StartupUri%2A> declaratively or programmatically, the corresponding UI resource is not loaded until after the <xref:System.Windows.Application.Startup> event is handled.</span></span> <span data-ttu-id="733ad-526">因此，在处理 <xref:System.Windows.Application.Startup>时，不能从 <xref:System.Windows.Application.Windows%2A> 属性或 <xref:System.Windows.Application.MainWindow%2A> 属性访问生成的窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-526">Consequently, you won't have access to the resulting window from either the <xref:System.Windows.Application.Windows%2A> property or the <xref:System.Windows.Application.MainWindow%2A> property when handling <xref:System.Windows.Application.Startup>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="733ad-527"><see cref="P:System.Windows.Application.StartupUri" /> 设置为 null 值。</span><span class="sxs-lookup"><span data-stu-id="733ad-527"><see cref="P:System.Windows.Application.StartupUri" /> is set with a value of null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="733ad-528">请求的环境属性的名称。</span><span class="sxs-lookup"><span data-stu-id="733ad-528">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="733ad-529">查询当前范围中是否有指定的环境属性。</span><span class="sxs-lookup"><span data-stu-id="733ad-529">Queries for whether a specified ambient property is available in the current scope.</span></span></summary>
        <returns><span data-ttu-id="733ad-530">如果有所请求的环境属性，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="733ad-530"><see langword="true" /> if the requested ambient property is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-531">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="733ad-531">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="733ad-532">它只能在 <xref:System.Windows.Application> 实例被强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="733ad-532">It can be used only when the <xref:System.Windows.Application> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="733ad-533">要查找的资源名。</span><span class="sxs-lookup"><span data-stu-id="733ad-533">The name of the resource to find.</span></span></param>
        <summary><span data-ttu-id="733ad-534">搜索指定资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-534">Searches for the specified resource.</span></span></summary>
        <returns><span data-ttu-id="733ad-535">所请求的资源对象。</span><span class="sxs-lookup"><span data-stu-id="733ad-535">The requested resource object.</span></span> <span data-ttu-id="733ad-536">如果未找到所请求的资源，则返回 null 引用。</span><span class="sxs-lookup"><span data-stu-id="733ad-536">If the requested resource is not found, a null reference is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-537"><xref:System.Windows.Application.TryFindResource%2A> 将首先查看指定资源的应用程序范围资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-537"><xref:System.Windows.Application.TryFindResource%2A> will first look in application-scope resources for the specified resource.</span></span> <span data-ttu-id="733ad-538">应用程序范围的资源由 <xref:System.Windows.Application>管理，并从 <xref:System.Windows.Application.Resources%2A> 属性公开。</span><span class="sxs-lookup"><span data-stu-id="733ad-538">Application-scope resources are managed by <xref:System.Windows.Application>, and are exposed from the <xref:System.Windows.Application.Resources%2A> property.</span></span> <span data-ttu-id="733ad-539">如果在应用程序范围的资源集中找不到指定的资源，<xref:System.Windows.Application.TryFindResource%2A> 接下来会搜索系统资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-539">If the specified resource is not found in the set of application-scope resources, <xref:System.Windows.Application.TryFindResource%2A> then next searches the system resources.</span></span> <span data-ttu-id="733ad-540">系统资源是由用户定义的 shell 资源，包括颜色、字体和 shell 配置。</span><span class="sxs-lookup"><span data-stu-id="733ad-540">System resources are shell resources defined by the user, and include colors, fonts, and shell configurations.</span></span> <span data-ttu-id="733ad-541">它们分别从 <xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts>和 <xref:System.Windows.SystemParameters> 类型分别作为静态属性公开。</span><span class="sxs-lookup"><span data-stu-id="733ad-541">These are exposed from the <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, and <xref:System.Windows.SystemParameters> types, respectively, as static properties.</span></span> <span data-ttu-id="733ad-542">若要使用 <xref:System.Windows.Application.TryFindResource%2A> 获取它们，这些类型还会公开旨在传递到 <xref:System.Windows.Application.TryFindResource%2A>的资源键属性;例如，<xref:System.Windows.SystemParameters.IconWidthKey%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-542">To use <xref:System.Windows.Application.TryFindResource%2A> to acquire them, these types also expose resource key properties that are designed to be passed to <xref:System.Windows.Application.TryFindResource%2A>; for example, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</span></span>  
  
 <span data-ttu-id="733ad-543">由于 <xref:System.Windows.Application.TryFindResource%2A> 返回对象，因此如果找到该资源，则必须将返回的值强制转换为适当的类型。</span><span class="sxs-lookup"><span data-stu-id="733ad-543">Because <xref:System.Windows.Application.TryFindResource%2A> returns an object, you must cast the returned value to the appropriate type if the resource is found.</span></span>  
  
 <span data-ttu-id="733ad-544">此方法是线程安全的，可从任何线程调用。</span><span class="sxs-lookup"><span data-stu-id="733ad-544">This method is thread safe and can be called from any thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-545">下面的示例演示如何使用 <xref:System.Windows.Application.TryFindResource%2A> 获取资源。</span><span class="sxs-lookup"><span data-stu-id="733ad-545">The following example shows how to use <xref:System.Windows.Application.TryFindResource%2A> to acquire a resource.</span></span>  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="733ad-546">获取应用程序中的实例化窗口。</span><span class="sxs-lookup"><span data-stu-id="733ad-546">Gets the instantiated windows in an application.</span></span></summary>
        <value><span data-ttu-id="733ad-547">一个 <see cref="T:System.Windows.WindowCollection" />，包含对当前 <see cref="T:System.AppDomain" /> 中的所有窗口对象的引用。</span><span class="sxs-lookup"><span data-stu-id="733ad-547">A <see cref="T:System.Windows.WindowCollection" /> that contains references to all window objects in the current <see cref="T:System.AppDomain" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="733ad-548">当在 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 线程上实例化窗口时，<xref:System.Windows.Window> 引用会自动添加到 <xref:System.Windows.Application.Windows%2A> 中;不会添加由工作线程创建的 windows。</span><span class="sxs-lookup"><span data-stu-id="733ad-548">A <xref:System.Windows.Window> reference is automatically added to <xref:System.Windows.Application.Windows%2A> as soon as a window is instantiated on the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] thread; windows that are created by worker threads are not added.</span></span> <span data-ttu-id="733ad-549">在处理 <xref:System.Windows.Window.Closing> 事件并引发其 <xref:System.Windows.Window.Closed> 事件之前，将自动删除 <xref:System.Windows.Window> 引用。</span><span class="sxs-lookup"><span data-stu-id="733ad-549">A <xref:System.Windows.Window> reference is automatically removed after its <xref:System.Windows.Window.Closing> event has been handled and before its <xref:System.Windows.Window.Closed> event is raised.</span></span>  
  
 <span data-ttu-id="733ad-550">默认情况下，添加到 <xref:System.Windows.Application.Windows%2A> 属性中的第一项将成为 <xref:System.Windows.Application.MainWindow%2A>。</span><span class="sxs-lookup"><span data-stu-id="733ad-550">By default, the first item added to the <xref:System.Windows.Application.Windows%2A> property becomes the <xref:System.Windows.Application.MainWindow%2A>.</span></span>  
  
 <span data-ttu-id="733ad-551">此属性仅在创建 <xref:System.Windows.Application> 对象的线程中可用。</span><span class="sxs-lookup"><span data-stu-id="733ad-551">This property is available only from the thread that created the <xref:System.Windows.Application> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="733ad-552">下面的示例演示如何枚举 <xref:System.Windows.Application.Windows%2A> 属性以生成顶级 Windows 菜单，该菜单 [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] 对诸如 [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]之类的应用程序或多实例单文档界面（SDI）应用程序（如 [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)]）是通用的。</span><span class="sxs-lookup"><span data-stu-id="733ad-552">The following example demonstrates how to enumerate the <xref:System.Windows.Application.Windows%2A> property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].</span></span>  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
