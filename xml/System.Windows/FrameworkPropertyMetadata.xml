<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdd84f72675390d1c868ff5904a4ccc72cfa84f5" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82487006" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="2f7dd-101">为依赖属性报告或应用元数据（从而专门添加特定于框架的属性系统特征）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-101">Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-102">此类派生自 <xref:System.Windows.PropertyMetadata> （通过 <xref:System.Windows.UIPropertyMetadata>）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-102">This class derives from <xref:System.Windows.PropertyMetadata> (through <xref:System.Windows.UIPropertyMetadata>) .</span></span> <span data-ttu-id="2f7dd-103">对于大多数 WPF 框架级别的应用程序开发，<xref:System.Windows.FrameworkPropertyMetadata> 是用于依赖项属性元数据的类型，而不是 <xref:System.Windows.PropertyMetadata> 或 <xref:System.Windows.UIPropertyMetadata>的基本元数据类型。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-103">For most WPF framework-level application development purposes, <xref:System.Windows.FrameworkPropertyMetadata> is the type used for dependency property metadata, rather than the base metadata types <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="2f7dd-104">这对于现有依赖属性和大多数自定义依赖属性方案都是如此。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-104">This is true both for existing dependency properties and for most custom dependency property scenarios.</span></span>  
  
 <span data-ttu-id="2f7dd-105">此类声明的用于补充 <xref:System.Windows.PropertyMetadata> 基类的成员包括各种指定或报告 WPF 框架级别属性系统行为（如属性继承、数据绑定和布局）的布尔属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-105">The members declared by this class that supplement the <xref:System.Windows.PropertyMetadata> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</span></span>  
  
 <span data-ttu-id="2f7dd-106">用于创建 <xref:System.Windows.FrameworkPropertyMetadata> 实例的多个构造函数签名采用 <xref:System.Windows.FrameworkPropertyMetadataOptions> 参数。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-106">Several constructor signatures for creating a <xref:System.Windows.FrameworkPropertyMetadata> instance take a <xref:System.Windows.FrameworkPropertyMetadataOptions> parameter.</span></span> <span data-ttu-id="2f7dd-107"><xref:System.Windows.FrameworkPropertyMetadataOptions> 枚举仅用于指定构造函数中的初始行为，在构造 <xref:System.Windows.FrameworkPropertyMetadata> 后，不会公开。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-107">The <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <xref:System.Windows.FrameworkPropertyMetadata> is constructed.</span></span> <span data-ttu-id="2f7dd-108">从构造的实例中，可以通过各种属性获取或设置相应信息，这些属性共享构造函数调用中使用的枚举值的名称。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-108">From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</span></span>  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-109">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-109">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-110">此类通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-110">This class is not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-111">下面的示例获取特定所有者的依赖属性的元数据作为初始基 <xref:System.Windows.PropertyMetadata> 类型。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-111">The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type.</span></span> <span data-ttu-id="2f7dd-112">该元数据将强制转换为 <xref:System.Windows.FrameworkPropertyMetadata>。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-112">That metadata is cast to <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="2f7dd-113">如果强制转换返回有效的 <xref:System.Windows.FrameworkPropertyMetadata>，则会通过简单的 UI （未显示）报告各种 <xref:System.Windows.FrameworkPropertyMetadata> 属性值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-113">If the cast returned a valid <xref:System.Windows.FrameworkPropertyMetadata>, then various <xref:System.Windows.FrameworkPropertyMetadata> property values are reported through a simple UI (not shown).</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f7dd-114">初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-114">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span></span></summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f7dd-115">初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-115">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-116">此签名将 <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> 的所有值初始化为其属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-116">This signature initializes all values of <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> to their property defaults.</span></span> <span data-ttu-id="2f7dd-117">将 `null`<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，并 `false`各种 <xref:System.Windows.FrameworkPropertyMetadata> 的布尔属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> will be `null`, and the various <xref:System.Windows.FrameworkPropertyMetadata> Boolean properties will be `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-118">依赖项属性的默认值，通常作为特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-118">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <summary><span data-ttu-id="2f7dd-119">使用指定的默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-119">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified default value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-120">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-120">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-121">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-121">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-122">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-122">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-123"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-123">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-124">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-124">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-125"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-125"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-126">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-126">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="2f7dd-127">用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-127">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2f7dd-128">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-128">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-129">依赖项属性的默认值，通常作为特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-129">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="2f7dd-130">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-130">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="2f7dd-131">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-131">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <summary><span data-ttu-id="2f7dd-132">使用提供的默认值和框架级别的元数据选项初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-132">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework-level metadata options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-133">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-133">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-134">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-134">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-135">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-135">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-136"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-136">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="2f7dd-137">在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-137">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="2f7dd-138">您随后可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-138">You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-139">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-139">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-140"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-140"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-141">依赖项属性的默认值，通常作为特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-141">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-142">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-142">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="2f7dd-143">使用提供的默认值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-143">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-144">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-144">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-145">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-145">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-146">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-146">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-147"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-147">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-148">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-148">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-149"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-149"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-150">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-150">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="2f7dd-151">对处理程序实现的引用，每当属性系统调用此依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-151">A reference to a handler implementation will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span></span></param>
        <summary><span data-ttu-id="2f7dd-152">用指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-152">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-153">此实现调用基初始值设定项，然后通过在基实例上设置属性来添加 `coerceValueCallback`。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-153">This implementation calls a base initializer and then adds the `coerceValueCallback` by setting the property on the base instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-154">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-154">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-155">依赖项属性的默认值，通常作为特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-155">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="2f7dd-156">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-156">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="2f7dd-157">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-157">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-158">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-158">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="2f7dd-159">使用提供的默认值和框架元数据选项及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-159">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-160">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-160">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-161">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-161">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-162">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-162">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-163"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-163">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="2f7dd-164">在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-164">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="2f7dd-165">你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-165">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-166">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-166">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-167"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-167"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-168">依赖项属性的默认值，通常作为特定类型提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-168">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-169">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-169">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="2f7dd-170">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-170">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span></span></param>
        <summary><span data-ttu-id="2f7dd-171">使用提供的默认值和指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-171">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-172">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-172">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-173">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-173">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-174">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-174">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-175"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-175">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-176">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-176">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-177"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-177"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-178">依赖项属性的默认值，通常作为特定类型提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-178">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="2f7dd-179">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-179">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="2f7dd-180">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-180">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-181">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-181">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="2f7dd-182">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-182">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="2f7dd-183">使用提供的默认值和框架元数据选项及指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-183">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-184">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-184">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-185">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-185">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-186">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-186">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-187"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-187">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="2f7dd-188">在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-188">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="2f7dd-189">你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-189">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-190">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-190">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-191"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-191"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-192">依赖项属性的默认值，通常作为特定类型提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-192">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="2f7dd-193">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-193">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="2f7dd-194">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-194">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-195">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-195">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="2f7dd-196">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-196">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> on this dependency property.</span></span></param>
        <param name="isAnimationProhibited"><span data-ttu-id="2f7dd-197">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-197"><see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span></span> <span data-ttu-id="2f7dd-198">如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-198">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span></span> <span data-ttu-id="2f7dd-199">若为 <see langword="false" />，则允许对属性进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-199"><see langword="false" /> to permit animating the property.</span></span> <span data-ttu-id="2f7dd-200">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-200">The default is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="2f7dd-201">使用提供的默认值和框架元数据选项、指定的回调及可以用来防止属性动画的布尔值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-201">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-202">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-202">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-203">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-203">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-204">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-204">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-205"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-205">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="2f7dd-206">`isAnimationProhibited` 参数设置由直接基 <xref:System.Windows.UIPropertyMetadata> 类声明的 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 属性的初始值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-206">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="2f7dd-207">在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-207">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="2f7dd-208">你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-208">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-209">下面的示例将调用此构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="2f7dd-209">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-210"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-210"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean, defaultUpdateSourceTrigger As UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="2f7dd-211">依赖项属性的默认值，通常作为特定类型提供。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-211">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="2f7dd-212">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-212">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="2f7dd-213">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-213">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="2f7dd-214">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-214">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="2f7dd-215">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-215">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <param name="isAnimationProhibited"><span data-ttu-id="2f7dd-216">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-216"><see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span></span> <span data-ttu-id="2f7dd-217">如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-217">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span></span> <span data-ttu-id="2f7dd-218">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-218">The default is <see langword="false" />.</span></span></param>
        <param name="defaultUpdateSourceTrigger"><span data-ttu-id="2f7dd-219">应用此属性的绑定时使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />，其 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-219">The <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for this property are applied that have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></param>
        <summary><span data-ttu-id="2f7dd-220">使用提供的默认值和框架元数据选项、指定的回调、可以用来防止属性动画的布尔值及数据绑定更新触发器默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-220">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-221">为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-221">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="2f7dd-222">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-222">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="2f7dd-223">在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-223">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="2f7dd-224"><xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-224">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="2f7dd-225">`isAnimationProhibited` 参数设置由直接基 <xref:System.Windows.UIPropertyMetadata> 类声明的 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 属性的初始值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-225">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="2f7dd-226">有关绑定的更新源行为的详细信息，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-226">For more information about the update source behavior for bindings, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
 <span data-ttu-id="2f7dd-227">在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-227">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="2f7dd-228">你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-228">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-229"><paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-229"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-230">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的排列过程。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-230">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="2f7dd-231">如果此元数据所在的依赖属性可能会影响排列过程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-231"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-232">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-232">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-233"><xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-233"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="2f7dd-234">作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使该元素的视觉对象（调用 <xref:System.Windows.UIElement.InvalidateArrange%2A>）失效。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-234">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element (a call to <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span></span> <span data-ttu-id="2f7dd-235">由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-235">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="2f7dd-236">自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true`的依赖项属性更改具有类似的行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-236">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-237">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-237">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-238">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-238">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-239">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-239">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-240">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-240">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-241">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-241">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-242">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-242">Members of this class are either not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-243">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-243">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-244">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-244">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-245">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的测量过程。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-245">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="2f7dd-246">如果此元数据所在的依赖属性可能会影响测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-246"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-247">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-247">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-248"><xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-248"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="2f7dd-249">作为该逻辑的一部分，将更改有效值并且将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，使该元素的视觉对象无效。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-249">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="2f7dd-250">由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-250">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="2f7dd-251">自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> `true`的依赖项属性更改具有类似的行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-251">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-252">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-252">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-253">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-253">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-254">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-254">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-255">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-255">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-256">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-256">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-257">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-257">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-258">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-258">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-259">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-259">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-260">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间父元素布局的排列处理过程。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-260">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="2f7dd-261">如果此元数据所在的依赖属性可能会特别影响其父元素上的排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-261"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-262">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-262">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-263"><xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-263"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="2f7dd-264">作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使父元素的视觉对象无效。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-264">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span>  
  
 <span data-ttu-id="2f7dd-265">通常情况下，不需要使用 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 将 <xref:System.Windows.FrameworkElement> 属性的更改报告给父元素，因为元素本身的 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-265">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true`.</span></span> <span data-ttu-id="2f7dd-266">这通常是足够的，因为在适当的情况下，子元素中的更改通常会启动父排列。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-266">That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</span></span> <span data-ttu-id="2f7dd-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有时用于 <xref:System.Windows.FrameworkContentElement> 派生类。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="2f7dd-268">在这种情况下，子元素设置属性，但 <xref:System.Windows.FrameworkContentElement> 派生类不会控制自身的呈现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-268">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="2f7dd-269">呈现由充当内容宿主 <xref:System.Windows.FrameworkElement> 父元素处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-269">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="2f7dd-270">例如，对子元素对 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 附加属性的值所做的更改将会使父元素的排列失效，因为父元素在父级中的位置必须更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-270">For instance, a change to the value of the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</span></span> <span data-ttu-id="2f7dd-271">因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 附加属性具有 `true`<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 的元数据。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-271">Therefore, the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span> <span data-ttu-id="2f7dd-272">另一个示例是 <xref:System.Windows.Controls.Control.Padding%2A>;此属性发生更改时，父项可能会根据可用空间更改子节点的位置。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-272">Another example is <xref:System.Windows.Controls.Control.Padding%2A>; when this property changes, the parent might change the positioning of the child, depending on available space.</span></span>  
  
 <span data-ttu-id="2f7dd-273">由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-273">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="2f7dd-274">自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> `true`的依赖项属性更改具有类似的行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-274">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-275"><xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-275">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-276">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-276">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-277">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-277">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-278">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-278">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-279">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-279">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-280">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-280">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-281">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-281">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-282">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间其父元素布局的测量过程。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-282">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="2f7dd-283"><see langword="true" /> 如果此元数据所在的依赖属性可能会影响其父元素上的测量过程，则为;否则，<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-283"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-284">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-284">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-285"><xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-285"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="2f7dd-286">作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使父元素的视觉对象无效。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-286">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span> <span data-ttu-id="2f7dd-287">由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-287">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="2f7dd-288">通常情况下，不需要使用 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 将 <xref:System.Windows.FrameworkElement> 属性的更改报告给父元素，因为元素本身的 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-288">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> as `true`.</span></span> <span data-ttu-id="2f7dd-289">这通常是足够的，因为子元素中的更改通常会在适当的时候启动父度量值处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-289">That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</span></span> <span data-ttu-id="2f7dd-290"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有时用于 <xref:System.Windows.FrameworkContentElement> 派生类。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-290"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="2f7dd-291">在这种情况下，子元素设置属性，但 <xref:System.Windows.FrameworkContentElement> 派生类不会控制自身的呈现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-291">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="2f7dd-292">呈现由充当内容宿主 <xref:System.Windows.FrameworkElement> 父元素处理。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-292">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="2f7dd-293">例如，对子元素对 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 属性的值所做的更改将使父级的度量值失效，因为段落的相对间距可能会更改，并且可能会增加或减小内容宿主大小。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-293">For instance, a change to the value of the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</span></span> <span data-ttu-id="2f7dd-294">因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 属性具有 `true`<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 的元数据。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-294">Therefore, the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-295">内容宿主元素还经常查找依赖属性中的更改，其中 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`，作为内容宿主呈现逻辑的一部分。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-295">Content host elements also frequently look for changes in dependency properties where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`, as part of content host rendering logic.</span></span> <span data-ttu-id="2f7dd-296">例如，<xref:System.Windows.Controls.TextBox> 元素必须响应文本中的某些更改，这些更改可能要求更改 <xref:System.Windows.Controls.TextBox> 自身的边界框。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-296">For instance, the <xref:System.Windows.Controls.TextBox> element must respond to certain changes within text that might require that the bounding box of the <xref:System.Windows.Controls.TextBox> itself be changed.</span></span>  
  
 <span data-ttu-id="2f7dd-297">自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`的依赖项属性更改具有类似的行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-297">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-298"><xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-298">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-299">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-299">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-300">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-300">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-301">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-301">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-302">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-302">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-303">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-303">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-304">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-304">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-305">获取或设置一个值，该值指示依赖属性是否会以某种方式（这种方式不会具体影响排列或测量，但将请求重绘）对常规布局造成潜在影响。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-305">Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</span></span></summary>
        <value><span data-ttu-id="2f7dd-306">如果该元数据所在的依赖属性会影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-306"><see langword="true" /> if the dependency property on which this metadata exists affects rendering; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-307">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-307">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-308"><xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-308"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="2f7dd-309">作为该逻辑的一部分，将更改有效值并且将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，使该元素的视觉对象无效。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-309">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="2f7dd-310">由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-310">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="2f7dd-311">自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> `true`的依赖项属性更改具有类似的行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-311">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> is `true`.</span></span>  
  
 <span data-ttu-id="2f7dd-312"><xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-312">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-313">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-313">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-314">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-314">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-315">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-315">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-316">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-316">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-317">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-317">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-318">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-318">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-319">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-319">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-320">获取或设置一个值，该值指示默认情况下属性是否双向绑定。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-320">Gets or sets a value that indicates whether the property binds two-way by default.</span></span></summary>
        <value><span data-ttu-id="2f7dd-321">如果此元数据所在的依赖属性默认情况下为双向绑定，则为 <see langword="true" />，否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-321"><see langword="true" /> if the dependency property on which this metadata exists binds two-way by default; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-322">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-322">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-323">如果没有 `true`此属性，则默认情况下，基于 <xref:System.Windows.Data.Binding> 构造函数或等效 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法的默认行为，绑定更新是单向的。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-323">In absence of this property being `true`, binding updates are one-way by default, based on the default behavior of the <xref:System.Windows.Data.Binding> constructors or equivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="2f7dd-324">在现有元素中，通常会将此属性设置为在报表状态和可由用户操作修改的依赖属性的元数据中 `true`，例如 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-324">In existing elements, you will usually find this property set to `true` in metadata for dependency properties that both report state and are modifiable by user action, for example <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2f7dd-325">此属性仅报告依赖属性的默认绑定更新特征。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-325">This property only reports the default binding update characteristics of the dependency property in general.</span></span> <span data-ttu-id="2f7dd-326">为实例上的此属性设置的任何绑定都可以在本地设置绑定的 <xref:System.Windows.Data.Binding.Mode%2A> 属性并更改此默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-326">Any binding set to this property on an instance can locally set the <xref:System.Windows.Data.Binding.Mode%2A> property of the binding and change this default.</span></span>  
  
 <span data-ttu-id="2f7dd-327"><xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-327">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-328">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-328">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-329">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-329">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-330">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-330">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-331">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-331">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-332">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-332">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-333">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-333">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-334">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-334">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-335">获取或设置在应用具有该元数据的属性的绑定时要使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 的默认值，这些绑定的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-335">Gets or sets the default for <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for the property with this metadata are applied, which have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></summary>
        <value><span data-ttu-id="2f7dd-336">除 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外的枚举值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-336">A value of the enumeration, other than <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-337">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-337">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-338">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-338">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-339">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-339">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-340">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-340">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-341">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-341">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-342">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-342">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f7dd-343">该属性设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />；您设置的值应成为绑定请求时的默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-343">This property is set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; the value you set is supposed to become the default when requested by bindings.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-344">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-344">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-345">获取或设置一个值，该值指示依赖属性的值是否可继承。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-345">Gets or sets a value that indicates whether the value of the dependency property is inheritable.</span></span></summary>
        <value><span data-ttu-id="2f7dd-346">如果属性值可继承，则为 <see langword="true" />否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-346"><see langword="true" /> if the property value is inheritable; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-347">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-347">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-348">属性值继承是 WPF 框架级别的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统的一项功能，因此，某些依赖属性可以本地设置到 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 元素树的根处或附近的元素，然后将其值继承给也具有该属性的子元素的逻辑树中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-348">Property value inheritance is a feature of the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</span></span> <span data-ttu-id="2f7dd-349">默认情况下不启用属性值继承，并且启用它确实会影响性能。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-349">Property value inheritance is not enabled by default, and enabling it does have some performance implications.</span></span> <span data-ttu-id="2f7dd-350">有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-350">For details, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2f7dd-351">尽管属性值继承可能看不到非附加依赖项属性，但通过运行时树中的某些对象-对象分段不确定非附加属性的继承行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-351">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</span></span> <span data-ttu-id="2f7dd-352">始终使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 来注册在元数据中指定 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 的属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-352">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span>  
  
 <span data-ttu-id="2f7dd-353">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-353">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-354">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-354">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-355">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-355">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-356">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-356">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-357">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-357">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-358">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-358">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-359">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-359">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-360">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-360">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-361">获取一个值，该值指示依赖属性是否支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-361">Gets a value that indicates whether data binding is supported for the dependency property.</span></span></summary>
        <value><span data-ttu-id="2f7dd-362">如果要应用该元数据的依赖属性支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-362"><see langword="true" /> if data binding is supported on the dependency property to which this metadata applies; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-363">默认为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-363">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-364">此属性报告两个可能条件之一 `false`：不允许将数据绑定到依赖项属性，因为依赖属性是只读的（如依赖项属性标识符中所报告，而不是元数据），或者其他元数据属性的值 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>在此元数据中设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-364">This property reports `false` for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, is set to `true` in this metadata.</span></span> <span data-ttu-id="2f7dd-365">此属性是为了方便起见而公开的，因此调用方不必同时检查 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 和 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-365">This property is exposed as a convenience so that callers do not have to check both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span>  
  
 <span data-ttu-id="2f7dd-366">如果尝试创建的元数据指定另一个读/写属性不应支持数据绑定，则指定标志 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> （请注意细微的命名约定差异与 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-366">If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (note the slight naming convention difference versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span></span>  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-367">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-367">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-368">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-368">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f7dd-369">下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-369">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-370">获取或设置一个值，该值指示依赖属性是否支持数据绑定。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-370">Gets or sets a value that indicates whether the dependency property supports data binding.</span></span></summary>
        <value><span data-ttu-id="2f7dd-371">如果属性不支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-371"><see langword="true" /> if the property does not support data binding; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-372">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-372">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-373">请注意，此元数据属性设置为 `true` 专用于不应支持数据绑定的属性（尽管是读写属性）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-373">Note that this metadata property is set to `true` specifically for properties that should not support data binding, despite being read-write properties.</span></span> <span data-ttu-id="2f7dd-374">预期是，在大多数情况下，如果声明了依赖属性，则需要进行数据绑定，因为数据绑定是依赖属性有用的关键方案之一。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-374">The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</span></span> <span data-ttu-id="2f7dd-375">与 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>不同，这并不只是更改稍后可在特定绑定上更改的默认值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-375">Unlike <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, this does not merely change a default that can later be changed on a specific binding.</span></span> <span data-ttu-id="2f7dd-376">如果将此属性设置 `true` 在依赖项属性元数据的元数据中，将禁止所有绑定通过表达式将其值应用于该依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-376">Setting this property `true` in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</span></span>  
  
 <span data-ttu-id="2f7dd-377">只读依赖属性不支持数据绑定（因为它们没有可应用更改值的 setter），但仍将报告 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>`false`。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-377">Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report `false` for <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span> <span data-ttu-id="2f7dd-378">这是因为，与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 值相对应的属性将报告与实际建立元数据的方式的奇偶校验，而不是始终报告属性命名可能暗示的最终结果行为。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-378">This is because properties that correspond to a <xref:System.Windows.FrameworkPropertyMetadataOptions> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</span></span> <span data-ttu-id="2f7dd-379">若要确定给定的依赖属性是否允许数据绑定，通常应改为选中 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-379">To determine whether a given dependency property permits data binding, you should usually check <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> instead.</span></span> <span data-ttu-id="2f7dd-380"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 是将 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 和 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 同时作为单个操作进行检查的便利，从而生成预期结果。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-380"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> is a convenience for checking both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> as a single operation, yielding the expected result.</span></span>  
  
 <span data-ttu-id="2f7dd-381">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-381">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-382">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-382">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-383">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-383">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-384">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-384">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-385">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-385">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-386">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-386">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-387">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-387">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-388">获取或设置一个值，该值表示该属性是否包含应用程序可以或应该作为日记功能实现的一部分而存储的日记信息。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-388">Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</span></span></summary>
        <value><span data-ttu-id="2f7dd-389">如果应对应用此元数据的依赖属性执行日记记录，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-389"><see langword="true" /> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-390">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-390">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-391">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-391">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-392">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-392">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-393">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-393">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-394">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-394">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-395">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-395">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-396">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-396">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-397">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-397">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="2f7dd-398">要合并的基本元数据。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-398">The base metadata to merge.</span></span></param>
        <param name="dp"><span data-ttu-id="2f7dd-399">此元数据被应用到的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-399">The dependency property this metadata is being applied to.</span></span></param>
        <summary><span data-ttu-id="2f7dd-400">允许合并源元数据和基本元数据。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-400">Enables a merge of the source metadata with base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-401">重写元数据时，将在内部使用此方法。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-401">This method is used internally when metadata is being overridden.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f7dd-402">派生自 <see cref="T:System.Windows.PropertyMetadata" /> （或此类）的类应重写此方法，以考虑它们在实现中添加的任何元数据属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-402">Classes that derive from <see cref="T:System.Windows.PropertyMetadata" /> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="2f7dd-403">例如，你的实现可能已添加了一个新的 flagwise 枚举值，<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 实现应能正确组合这些标志。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-403">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="2f7dd-404">在您自己的实现之前始终调用基实现，因为基实现负责合并已在层次结构中的以前类型上定义的所有属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-404">Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</span></span>  
  
<span data-ttu-id="2f7dd-405"><see cref="T:System.Windows.FrameworkPropertyMetadata" /> 中的 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 实现添加的行为是元数据中的特定 WPF 框架级属性（如 <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />）在位或运算中组合在一起。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-405">The behavior added by the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> is that specific WPF framework-level properties in the metadata such as <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> are combined in a bitwise or operation.</span></span>  
  
<span data-ttu-id="2f7dd-406">当你通过调用 <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />来重写现有依赖属性的属性元数据时，<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 行为还实现了该行为，并使用 <see cref="T:System.Windows.FrameworkPropertyMetadata" />的重写元数据。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-406">The <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, using override metadata that is <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</span></span></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="2f7dd-407">已应用了元数据的依赖项对象。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-407">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="2f7dd-408">与此元数据关联的类型（如果这是特定于类型的元数据）。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-408">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="2f7dd-409">如果这是默认的元数据，则此值可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-409">If this is default metadata, this value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="2f7dd-410">当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-410">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-411">调用此方法时，应将 <xref:System.Windows.FrameworkPropertyMetadata> 实例的数据结构的任何可变性标记为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-411">Any mutability of the data structure of a <xref:System.Windows.FrameworkPropertyMetadata> instance should be marked as immutable when this method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f7dd-412">此方法的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 实现除了调用基实现外，不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-412">The <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementation of this method does nothing beyond calling the base implementation.</span></span></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-413">获取或设置一个值，该值指示属性值继承计算是否应跨越元素逻辑树中的某些内容边界。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-413">Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</span></span></summary>
        <value><span data-ttu-id="2f7dd-414">如果属性值继承应跨越某些内容边界，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-414"><see langword="true" /> if the property value inheritance should span across certain content boundaries; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-415">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-415">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-416">此元数据可报告极少应用于跨特殊父元素-子元素边界的属性值继承行为的修改。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-416">This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</span></span> <span data-ttu-id="2f7dd-417">此类边界的规范示例是 <xref:System.Windows.Controls.Frame>的内容，其中，<xref:System.Windows.Controls.Frame> 的内容可能会独立于存在 <xref:System.Windows.Controls.Frame>而重新加载。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-417">The canonical example of such a boundary is the contents of a <xref:System.Windows.Controls.Frame>, where the <xref:System.Windows.Controls.Frame> content might get reloaded independently of the existence of the <xref:System.Windows.Controls.Frame>.</span></span> <span data-ttu-id="2f7dd-418">所需的属性系统行为是属性值继承不应遍历到 <xref:System.Windows.Controls.Frame>的内容，因为这些内容可能是承载框架的应用程序不拥有或控制的元素。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-418">The desired property system behavior is that property value inheritance should not traverse into the contents of the <xref:System.Windows.Controls.Frame>, because these contents might be elements that the application hosting the frame does not own or control.</span></span> <span data-ttu-id="2f7dd-419">将 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 设置为 `true`的元数据以及将 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 指定为 `true`将导致应用元数据的属性可继承，即使是在 <xref:System.Windows.Controls.Frame> 边界或类似边界内。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-419">Specifying metadata with <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> set to `true`, as well as specifying <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> as `true`, will cause the property on which the metadata is applied to be inheritable even across the <xref:System.Windows.Controls.Frame> boundary or similar boundaries.</span></span>  
  
 <span data-ttu-id="2f7dd-420">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-420">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-421">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-421">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-422">但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-422">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-423">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-423">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-424">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-424">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-425">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-425">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-426">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-426">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f7dd-427">获取或设置一个值，该值指示依赖属性的子属性是否影响包含对象的呈现。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-427">Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</span></span></summary>
        <value><span data-ttu-id="2f7dd-428">如果更改后，对子属性值的更改不影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-428"><see langword="true" /> if changes to sub-property values do not affect rendering if changed; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="2f7dd-429">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-429">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f7dd-430">此元数据选项与作为引用类型的依赖项属性相关，其中，该类型具有其自己的属性值。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-430">This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</span></span> <span data-ttu-id="2f7dd-431">通常，布局系统逻辑假设具有子属性的任何依赖属性可能会影响布局，因为检查更改的所有子属性比实际运行另一个呈现处理的时间更长。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-431">Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</span></span> <span data-ttu-id="2f7dd-432">将此选项设置为 "`true`" 对于优化 WPF 框架级别布局系统实现的性能十分有用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-432">Setting this option to `true` is useful for optimizing performance of the WPF framework level layout system implementation.</span></span>  
  
 <span data-ttu-id="2f7dd-433">派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-433">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="2f7dd-434">这样就可以在实例初始化后进行调整。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-434">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="2f7dd-435">但是，一旦将元数据用作对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用的一部分，属性系统就会密封该元数据实例，传达元数据细节的属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-435">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="2f7dd-436">在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-436">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="2f7dd-437">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="2f7dd-437">XAML Text Usage</span></span>  
 <span data-ttu-id="2f7dd-438">此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-438">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f7dd-439">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</span><span class="sxs-lookup"><span data-stu-id="2f7dd-439">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
