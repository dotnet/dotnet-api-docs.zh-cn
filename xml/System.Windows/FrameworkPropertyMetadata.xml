<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ce96c7f17159e18230483df6ba5137fe0a7bd166" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78836685" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>为依赖属性报告或应用元数据（从而专门添加特定于框架的属性系统特征）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类派生自 <xref:System.Windows.PropertyMetadata> （通过 <xref:System.Windows.UIPropertyMetadata>）。 对于大多数 WPF 框架级别的应用程序开发，<xref:System.Windows.FrameworkPropertyMetadata> 是用于依赖项属性元数据的类型，而不是 <xref:System.Windows.PropertyMetadata> 或 <xref:System.Windows.UIPropertyMetadata>的基本元数据类型。 这对于现有依赖属性和大多数自定义依赖属性方案都是如此。  
  
 此类声明的用于补充 <xref:System.Windows.PropertyMetadata> 基类的成员包括各种指定或报告 WPF 框架级别属性系统行为（如属性继承、数据绑定和布局）的布尔属性。  
  
 用于创建 <xref:System.Windows.FrameworkPropertyMetadata> 实例的多个构造函数签名采用 <xref:System.Windows.FrameworkPropertyMetadataOptions> 参数。 <xref:System.Windows.FrameworkPropertyMetadataOptions> 枚举仅用于指定构造函数中的初始行为，在构造 <xref:System.Windows.FrameworkPropertyMetadata> 后，不会公开。 从构造的实例中，可以通过各种属性获取或设置相应信息，这些属性共享构造函数调用中使用的枚举值的名称。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例获取特定所有者的依赖属性的元数据作为初始基 <xref:System.Windows.PropertyMetadata> 类型。 该元数据将强制转换为 <xref:System.Windows.FrameworkPropertyMetadata>。 如果强制转换返回有效的 <xref:System.Windows.FrameworkPropertyMetadata>，则会通过简单的 UI （未显示）报告各种 <xref:System.Windows.FrameworkPropertyMetadata> 属性值。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名将 <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> 的所有值初始化为其属性默认值。 将 `null`<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，并 `false`各种 <xref:System.Windows.FrameworkPropertyMetadata> 的布尔属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <summary>使用指定的默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <summary>使用提供的默认值和框架级别的元数据选项初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
 在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。 您随后可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用此依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>用指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现调用基初始值设定项，然后通过在基实例上设置属性来添加 `coerceValueCallback`。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
 在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。 你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
 在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。 你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 若为 <see langword="false" />，则允许对属性进行动画处理。 默认值为 <see langword="false" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调及可以用来防止属性动画的布尔值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
 `isAnimationProhibited` 参数设置由直接基 <xref:System.Windows.UIPropertyMetadata> 类声明的 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 属性的初始值。  
  
 在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。 你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。  
  
   
  
## Examples  
 下面的示例将调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback, isAnimationProhibited As Boolean, defaultUpdateSourceTrigger As UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 默认值为 <see langword="false" />。</param>
        <param name="defaultUpdateSourceTrigger">应用此属性的绑定时使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />，其 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调、可以用来防止属性动画的布尔值及数据绑定更新触发器默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为 `defaultValue` 提供的值的类型必须与此元数据将应用到的依赖属性的原始注册中指定的类型匹配或相关。 如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配。 在运行时之前，属性系统不会计算属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 的值在属性系统中具有特殊含义，不能用作依赖属性默认值。  
  
 `isAnimationProhibited` 参数设置由直接基 <xref:System.Windows.UIPropertyMetadata> 类声明的 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 属性的初始值。  
  
 有关绑定的更新源行为的详细信息，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 在 `flags` 参数中标记为 "设置标志" 的值将设置与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 标志的名称 `true`的 <xref:System.Windows.FrameworkPropertyMetadata> 属性的布尔值。 你仍可以在元数据中更改属性的值，前提是元数据尚未应用到特定的属性系统操作。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的排列过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响排列过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。 作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使该元素的视觉对象（调用 <xref:System.Windows.UIElement.InvalidateArrange%2A>）失效。 由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。  
  
 自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true`的依赖项属性更改具有类似的行为。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。 作为该逻辑的一部分，将更改有效值并且将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，使该元素的视觉对象无效。 由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。  
  
 自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> `true`的依赖项属性更改具有类似的行为。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间父元素布局的排列处理过程。</summary>
        <value>如果此元数据所在的依赖属性可能会特别影响其父元素上的排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。 作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使父元素的视觉对象无效。  
  
 通常情况下，不需要使用 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 将 <xref:System.Windows.FrameworkElement> 属性的更改报告给父元素，因为元素本身的 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 为 `true`。 这通常是足够的，因为在适当的情况下，子元素中的更改通常会启动父排列。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有时用于 <xref:System.Windows.FrameworkContentElement> 派生类。 在这种情况下，子元素设置属性，但 <xref:System.Windows.FrameworkContentElement> 派生类不会控制自身的呈现。 呈现由充当内容宿主 <xref:System.Windows.FrameworkElement> 父元素处理。 例如，对子元素对 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 附加属性的值所做的更改将会使父元素的排列失效，因为父元素在父级中的位置必须更改。 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 附加属性具有 `true`<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 的元数据。 另一个示例是 <xref:System.Windows.Controls.Control.Padding%2A>;此属性发生更改时，父项可能会根据可用空间更改子节点的位置。  
  
 由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。  
  
 自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> `true`的依赖项属性更改具有类似的行为。  
  
 <xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间其父元素布局的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响其父元素上的测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。 作为该逻辑的一部分，将更改有效值并将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，以使父元素的视觉对象无效。 由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。  
  
 通常情况下，不需要使用 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 将 <xref:System.Windows.FrameworkElement> 属性的更改报告给父元素，因为元素本身的 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 为 `true`。 这通常是足够的，因为子元素中的更改通常会在适当的时候启动父度量值处理。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有时用于 <xref:System.Windows.FrameworkContentElement> 派生类。 在这种情况下，子元素设置属性，但 <xref:System.Windows.FrameworkContentElement> 派生类不会控制自身的呈现。 呈现由充当内容宿主 <xref:System.Windows.FrameworkElement> 父元素处理。 例如，对子元素对 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 属性的值所做的更改将使父级的度量值失效，因为段落的相对间距可能会更改，并且可能会增加或减小内容宿主大小。 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 属性具有 `true`<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 的元数据。  
  
 内容宿主元素还经常查找依赖属性中的更改，其中 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`，作为内容宿主呈现逻辑的一部分。 例如，<xref:System.Windows.Controls.TextBox> 元素必须响应文本中的某些更改，这些更改可能要求更改 <xref:System.Windows.Controls.TextBox> 自身的边界框。  
  
 自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> `true`的依赖项属性更改具有类似的行为。  
  
 <xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否会以某种方式（这种方式不会具体影响排列或测量，但将请求重绘）对常规布局造成潜在影响。</summary>
        <value>如果该元数据所在的依赖属性会影响呈现，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和 <xref:System.Windows.FrameworkContentElement> 包括 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 的实现，该实现监视某个元素上存在的所有依赖属性的有效值更改。 作为该逻辑的一部分，将更改有效值并且将 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 设置为 `true` 的元数据的依赖项属性将启动延迟请求，使该元素的视觉对象无效。 由于已存在此 WPF 框架级别的实现，因此通常不需要 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 查找依赖项属性，除非确实要替换或修改 WPF 框架级别布局行为。  
  
 自定义 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 实现可能会选择对 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> `true`的依赖项属性更改具有类似的行为。  
  
 <xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示默认情况下属性是否双向绑定。</summary>
        <value>如果此元数据所在的依赖属性默认情况下为双向绑定，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有 `true`此属性，则默认情况下，基于 <xref:System.Windows.Data.Binding> 构造函数或等效 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法的默认行为，绑定更新是单向的。  
  
 在现有元素中，通常会将此属性设置为在报表状态和可由用户操作修改的依赖属性的元数据中 `true`，例如 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。  
  
 此属性仅报告依赖属性的默认绑定更新特征。 为实例上的此属性设置的任何绑定都可以在本地设置绑定的 <xref:System.Windows.Data.Binding.Mode%2A> 属性并更改此默认值。  
  
 <xref:System.Windows.PropertyMetadata> 的任何派生类上的属性通常在对象模型中定义为可读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用具有该元数据的属性的绑定时要使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 的默认值，这些绑定的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</summary>
        <value>除 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外的枚举值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该属性设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />；您设置的值应成为绑定请求时的默认值。</exception>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的值是否可继承。</summary>
        <value>如果属性值可继承，则为<see langword="true" /> 否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性值继承是 WPF 框架级别的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统的一项功能，因此，某些依赖属性可以本地设置到 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 元素树的根处或附近的元素，然后将其值继承给也具有该属性的子元素的逻辑树中的所有元素。 默认情况下不启用属性值继承，并且启用它确实会影响性能。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
> [!NOTE]
>  尽管属性值继承可能看不到非附加依赖项属性，但通过运行时树中的某些对象-对象分段不确定非附加属性的继承行为。 始终使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 来注册在元数据中指定 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 的属性。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果要应用该元数据的依赖属性支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性报告两个可能条件之一 `false`：不允许将数据绑定到依赖项属性，因为依赖属性是只读的（如依赖项属性标识符中所报告，而不是元数据），或者其他元数据属性的值 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>在此元数据中设置为 `true`。 此属性是为了方便起见而公开的，因此调用方不必同时检查 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 和 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。  
  
 如果尝试创建的元数据指定另一个读/写属性不应支持数据绑定，则指定标志 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> （请注意细微的命名约定差异与 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>）。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认元数据，查询其上不同 <xref:System.Windows.FrameworkPropertyMetadata> 属性的值，并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果属性不支持数据绑定，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此元数据属性设置为 `true` 专用于不应支持数据绑定的属性（尽管是读写属性）。 预期是，在大多数情况下，如果声明了依赖属性，则需要进行数据绑定，因为数据绑定是依赖属性有用的关键方案之一。 与 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>不同，这并不只是更改稍后可在特定绑定上更改的默认值。 如果将此属性设置 `true` 在依赖项属性元数据的元数据中，将禁止所有绑定通过表达式将其值应用于该依赖属性。  
  
 只读依赖属性不支持数据绑定（因为它们没有可应用更改值的 setter），但仍将报告 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>`false`。 这是因为，与 <xref:System.Windows.FrameworkPropertyMetadataOptions> 值相对应的属性将报告与实际建立元数据的方式的奇偶校验，而不是始终报告属性命名可能暗示的最终结果行为。 若要确定给定的依赖属性是否允许数据绑定，通常应改为选中 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 是将 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 和 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 同时作为单个操作进行检查的便利，从而生成预期结果。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示该属性是否包含应用程序可以或应该作为日记功能实现的一部分而存储的日记信息。</summary>
        <value>如果应对应用此元数据的依赖属性执行日记记录，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要合并的基本元数据。</param>
        <param name="dp">此元数据被应用到的依赖属性。</param>
        <summary>允许合并源元数据和基本元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写元数据时，将在内部使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生自 <see cref="T:System.Windows.PropertyMetadata" /> （或此类）的类应重写此方法，以考虑它们在实现中添加的任何元数据属性。 例如，你的实现可能已添加了一个新的 flagwise 枚举值，<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 实现应能正确组合这些标志。  
  
在您自己的实现之前始终调用基实现，因为基实现负责合并已在层次结构中的以前类型上定义的所有属性。  
  
<see cref="T:System.Windows.FrameworkPropertyMetadata" /> 中的 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 实现添加的行为是元数据中的特定 WPF 框架级属性（如 <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />）在位或运算中组合在一起。  
  
当你通过调用 <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />来重写现有依赖属性的属性元数据时，<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 行为还实现了该行为，并使用 <see cref="T:System.Windows.FrameworkPropertyMetadata" />的重写元数据。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已应用了元数据的依赖项对象。</param>
        <param name="targetType">与此元数据关联的类型（如果这是特定于类型的元数据）。 如果这是默认的元数据，则此值可以为 <see langword="null" />。</param>
        <summary>当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法时，应将 <xref:System.Windows.FrameworkPropertyMetadata> 实例的数据结构的任何可变性标记为不可变。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 实现除了调用基实现外，不执行任何操作。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示属性值继承计算是否应跨越元素逻辑树中的某些内容边界。</summary>
        <value>如果属性值继承应跨越某些内容边界，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据可报告极少应用于跨特殊父元素-子元素边界的属性值继承行为的修改。 此类边界的规范示例是 <xref:System.Windows.Controls.Frame>的内容，其中，<xref:System.Windows.Controls.Frame> 的内容可能会独立于存在 <xref:System.Windows.Controls.Frame>而重新加载。 所需的属性系统行为是属性值继承不应遍历到 <xref:System.Windows.Controls.Frame>的内容，因为这些内容可能是承载框架的应用程序不拥有或控制的元素。 将 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 设置为 `true`的元数据以及将 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 指定为 `true`将导致应用元数据的属性可继承，即使是在 <xref:System.Windows.Controls.Frame> 边界或类似边界内。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，在对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用中使用元数据后，属性系统将会密封用于传递元数据的细节的元数据实例和属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的子属性是否影响包含对象的呈现。</summary>
        <value>如果更改后，对子属性值的更改不影响呈现，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据选项与作为引用类型的依赖项属性相关，其中，该类型具有其自己的属性值。 通常，布局系统逻辑假设具有子属性的任何依赖属性可能会影响布局，因为检查更改的所有子属性比实际运行另一个呈现处理的时间更长。 将此选项设置为 "`true`" 对于优化 WPF 框架级别布局系统实现的性能十分有用。  
  
 派生类 <xref:System.Windows.PropertyMetadata> 的属性通常在对象模型中定义为读写。 这样就可以在实例初始化后进行调整。 但是，一旦将元数据用作对 <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>或 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>的调用的一部分，属性系统就会密封该元数据实例，传达元数据细节的属性现在被视为不可变。 在此元数据实例 `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> 之后尝试设置此属性将引发异常。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>
