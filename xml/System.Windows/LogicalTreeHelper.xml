<Type Name="LogicalTreeHelper" FullName="System.Windows.LogicalTreeHelper">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa987173cae01f0349100bb7794a8a3344944595" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="83883756" /></Metadata><TypeSignature Language="C#" Value="public static class LogicalTreeHelper" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LogicalTreeHelper extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.LogicalTreeHelper" />
  <TypeSignature Language="VB.NET" Value="Public Class LogicalTreeHelper" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogicalTreeHelper abstract sealed" />
  <TypeSignature Language="F#" Value="type LogicalTreeHelper = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="1df17-101">提供用于查询逻辑树中的对象的静态帮助器方法。</span><span class="sxs-lookup"><span data-stu-id="1df17-101">Provides static helper methods for querying objects in the logical tree.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1df17-102"><xref:System.Windows.LogicalTreeHelper>类提供的方法可用于返回对象的子集合，或从逻辑树的子节点内返回特定对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-102">The <xref:System.Windows.LogicalTreeHelper> class provides methods that you can use to return child collections of objects, or specific objects from within subnodes of the logical tree.</span></span> <span data-ttu-id="1df17-103">但是，您通常执行的大多数对象树操作也由或上的类似方法或属性公开 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="1df17-103">However, most of the object tree operations that you typically perform are also exposed by similar methods or properties on <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="1df17-104">例如，尝试下列操作：</span><span class="sxs-lookup"><span data-stu-id="1df17-104">For example, try the following:</span></span>  
  
-   <span data-ttu-id="1df17-105">不调用 <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> 返回逻辑子对象的枚举器的静态方法，而是使用在该对象的内容模型中公开的专用集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-105">Instead of calling the static <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method, which returns an enumerator for the logical child objects, use the dedicated collection exposed in the content model for that object.</span></span> <span data-ttu-id="1df17-106">几乎所有支持内容模型的对象都公开了某些包含子对象集合的属性，并直接在该集合上提供集合接口支持。</span><span class="sxs-lookup"><span data-stu-id="1df17-106">Nearly all objects that support a content model expose some property that contains the collection of child objects, and provides collection interface support directly on that collection.</span></span>  
  
-   <span data-ttu-id="1df17-107">不是调用静态 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 方法来通过指定子对象的名称来获取子对象，而是对 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> 特定对象调用或方法。</span><span class="sxs-lookup"><span data-stu-id="1df17-107">Instead of calling the static <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> method to obtain a child object by specifying its name, call the <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> method on specific objects.</span></span>  
  
 <span data-ttu-id="1df17-108"><xref:System.Windows.LogicalTreeHelper>对于分析方案非常有用，在这种情况下，将以递归方式遍历逻辑树，并使用一致的方法检查各种父对象或子对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-108"><xref:System.Windows.LogicalTreeHelper> is most useful for analysis scenarios where you are traveling up or down the logical tree recursively through multiple levels, and want to use a consistent approach for examining the various parent or child objects.</span></span> <span data-ttu-id="1df17-109">在这种情况下，你可能会访问混合内容模型，使用更多内容模型的特定 Api 会过于复杂。</span><span class="sxs-lookup"><span data-stu-id="1df17-109">In this case, you might be accessing a mixture of content models, and using the more content-model specific APIs would be too complex.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public static void BringIntoView (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BringIntoView(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BringIntoView (current As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BringIntoView(System::Windows::DependencyObject ^ current);" />
      <MemberSignature Language="F#" Value="static member BringIntoView : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.LogicalTreeHelper.BringIntoView current" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current"><span data-ttu-id="1df17-110">要使其可见的 UI 元素。</span><span class="sxs-lookup"><span data-stu-id="1df17-110">The UI element to bring into view.</span></span></param>
        <summary><span data-ttu-id="1df17-111">尝试使所请求的 UI 元素可见，并在目标上引发 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 事件以报告结果。</span><span class="sxs-lookup"><span data-stu-id="1df17-111">Attempts to bring the requested UI element into view and raises the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> event on the target in order to report the results.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1df17-112">通常，调用实例方法 <xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType> 或 <xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType> 而不是此静态实用工具方法更方便。</span><span class="sxs-lookup"><span data-stu-id="1df17-112">It is typically more convenient to call the instance methods <xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType> rather than this static utility method.</span></span> <span data-ttu-id="1df17-113">实例方法的行为等效于静态方法的行为。</span><span class="sxs-lookup"><span data-stu-id="1df17-113">The behavior of the instance methods is equivalent to the behavior of the static method.</span></span>  
  
 <span data-ttu-id="1df17-114">即使提供的 `current` UI 元素是 <xref:System.Windows.FrameworkContentElement> ，生成的事件仍为同一 <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> 事件，并 <xref:System.Windows.FrameworkContentElement> 通过检查事件的事件数据来进行源标识。</span><span class="sxs-lookup"><span data-stu-id="1df17-114">Even if the `current` UI element provided was a <xref:System.Windows.FrameworkContentElement>, the resulting event is still the same <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> event, with the originating <xref:System.Windows.FrameworkContentElement> identifiable by checking the event data of the event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      </Docs>
    </Member>
    <Member MemberName="FindLogicalNode">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject FindLogicalNode (System.Windows.DependencyObject logicalTreeNode, string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject FindLogicalNode(class System.Windows.DependencyObject logicalTreeNode, string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLogicalNode (logicalTreeNode As DependencyObject, elementName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ FindLogicalNode(System::Windows::DependencyObject ^ logicalTreeNode, System::String ^ elementName);" />
      <MemberSignature Language="F#" Value="static member FindLogicalNode : System.Windows.DependencyObject * string -&gt; System.Windows.DependencyObject" Usage="System.Windows.LogicalTreeHelper.FindLogicalNode (logicalTreeNode, elementName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalTreeNode" Type="System.Windows.DependencyObject" />
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logicalTreeNode"><span data-ttu-id="1df17-115">从其开始搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-115">The object to start searching from.</span></span> <span data-ttu-id="1df17-116">此对象必须是 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="1df17-116">This object must be either a <see cref="T:System.Windows.FrameworkElement" /> or a <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></param>
        <param name="elementName"><span data-ttu-id="1df17-117">要查找的对象的名称。</span><span class="sxs-lookup"><span data-stu-id="1df17-117">The name of the object to find.</span></span></param>
        <summary><span data-ttu-id="1df17-118">尝试查找并返回具有指定名称的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-118">Attempts to find and return an object that has the specified name.</span></span> <span data-ttu-id="1df17-119">搜索从指定对象开始，并持续到逻辑树的子节点中。</span><span class="sxs-lookup"><span data-stu-id="1df17-119">The search starts from the specified object and continues into subnodes of the logical tree.</span></span></summary>
        <returns><span data-ttu-id="1df17-120">如果找到一个，则为具有匹配名称的元素；如果没有在逻辑树中找到匹配名称，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="1df17-120">The object with the matching name, if one is found; returns <see langword="null" /> if no matching name was found in the logical tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1df17-121">方法 <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> 和在 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> 表面上类似于 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> ，但使用不同的逻辑进行操作：</span><span class="sxs-lookup"><span data-stu-id="1df17-121">The methods <xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType> and <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> are superficially similar to <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>, but operate by different logic:</span></span>  
  
-   <span data-ttu-id="1df17-122">的搜索方向 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 朝向子对象（沿树向下）; 方法的搜索方向 `FindName` 朝向父对象（向上滚动树）。</span><span class="sxs-lookup"><span data-stu-id="1df17-122">The search direction for <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> is toward child objects (down the tree); the search direction for the `FindName` methods is towards parent objects (up the tree).</span></span>  
  
-   <span data-ttu-id="1df17-123">`FindName`方法由 XAML 名称范围的概念控制。</span><span class="sxs-lookup"><span data-stu-id="1df17-123">The `FindName` methods are governed by the concept of a XAML namescope.</span></span> <span data-ttu-id="1df17-124">使用 `FindName` 可以保证只存在一个同名的对象，因为 XAML 名称范围强制执行唯一性。</span><span class="sxs-lookup"><span data-stu-id="1df17-124">Using `FindName` you are guaranteed that only one object of that name exists, because XAML namescopes enforce uniqueness.</span></span> <span data-ttu-id="1df17-125">相反， <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 忽略 xaml 名称范围，并可能在搜索期间跨越 xaml 名称范围边界。</span><span class="sxs-lookup"><span data-stu-id="1df17-125">In contrast, <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> ignores XAML namescope and might cross XAML namescope boundaries during the search.</span></span> <span data-ttu-id="1df17-126">同样，一旦超出边界，就不能保证名称的唯一性 `elementName` 。</span><span class="sxs-lookup"><span data-stu-id="1df17-126">As such, there is no guarantee of uniqueness of the `elementName` name once boundaries are crossed.</span></span> <span data-ttu-id="1df17-127">有关 XAML 名称范围的详细信息，请参阅[WPF XAML 名称范围](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes)。</span><span class="sxs-lookup"><span data-stu-id="1df17-127">For more information about XAML namescopes, see [WPF XAML Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildren">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1df17-128">通过处理逻辑树，返回指定对象的直接子对象的集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-128">Returns the collection of immediate child objects of the specified object by processing the logical tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As DependencyObject) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::DependencyObject ^ current);" />
      <MemberSignature Language="F#" Value="static member GetChildren : System.Windows.DependencyObject -&gt; System.Collections.IEnumerable" Usage="System.Windows.LogicalTreeHelper.GetChildren current" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current"><span data-ttu-id="1df17-129">要从中开始处理逻辑树的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-129">The object from which to start processing the logical tree.</span></span> <span data-ttu-id="1df17-130">此元素应为 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="1df17-130">This is expected to be either a <see cref="T:System.Windows.FrameworkElement" /> or <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></param>
        <summary><span data-ttu-id="1df17-131">通过处理逻辑树返回指定的对象的即时子对象集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-131">Returns the collection of immediate child objects of the specified object, by processing the logical tree.</span></span></summary>
        <returns><span data-ttu-id="1df17-132">来自指定对象逻辑树的即时子对象的可枚举集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-132">The enumerable collection of immediate child objects from the logical tree of the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1df17-133">如果您不确定 `current` 是 <xref:System.Windows.FrameworkElement> 还是 <xref:System.Windows.FrameworkContentElement> ，也不确定该对象的类是否支持其自己的内容模型集合，请主要使用此签名和帮助器方法。</span><span class="sxs-lookup"><span data-stu-id="1df17-133">Use this signature and helper method primarily when you are unsure whether `current` is a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> and are also unsure whether that object's class supports its own content model collection.</span></span> <span data-ttu-id="1df17-134">如果你可以确定要查询的对象的类型，请检查你知道在该类型上存在的特定内容属性。</span><span class="sxs-lookup"><span data-stu-id="1df17-134">If you can determine the type of the object you are querying, check the specific content property that you know exists on that type.</span></span> <span data-ttu-id="1df17-135">例如，如果您知道您正在查询的对象是 <xref:System.Windows.Controls.ItemsControl> ，则检查 <xref:System.Windows.Controls.ItemsControl.Items%2A> 属性以获取强类型集合，该集合具有集合接口支持并且可能比枚举器更有用。</span><span class="sxs-lookup"><span data-stu-id="1df17-135">For example, if you know that the object you are querying is an <xref:System.Windows.Controls.ItemsControl>, check the <xref:System.Windows.Controls.ItemsControl.Items%2A> property to get a strongly typed collection, which has collection interface support and is probably more useful than an enumerator.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkContentElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkContentElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkContentElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkContentElement ^ current);" />
      <MemberSignature Language="F#" Value="static member GetChildren : System.Windows.FrameworkContentElement -&gt; System.Collections.IEnumerable" Usage="System.Windows.LogicalTreeHelper.GetChildren current" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="current"><span data-ttu-id="1df17-136">要从中开始处理逻辑树的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-136">The object from which to start processing the logical tree.</span></span></param>
        <summary><span data-ttu-id="1df17-137">通过处理逻辑树，返回指定 <see cref="T:System.Windows.FrameworkContentElement" /> 的直接子对象的集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-137">Returns the collection of immediate child objects of the specified <see cref="T:System.Windows.FrameworkContentElement" /> by processing the logical tree.</span></span></summary>
        <returns><span data-ttu-id="1df17-138">逻辑树中从 <paramref name="current" /> 开始的直接子对象的可枚举集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-138">The enumerable collection of immediate child objects starting from <paramref name="current" /> in the logical tree.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable GetChildren (System.Windows.FrameworkElement current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerable GetChildren(class System.Windows.FrameworkElement current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetChildren (current As FrameworkElement) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerable ^ GetChildren(System::Windows::FrameworkElement ^ current);" />
      <MemberSignature Language="F#" Value="static member GetChildren : System.Windows.FrameworkElement -&gt; System.Collections.IEnumerable" Usage="System.Windows.LogicalTreeHelper.GetChildren current" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="current"><span data-ttu-id="1df17-139">要从中开始处理逻辑树的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-139">The object from which to start processing the logical tree.</span></span></param>
        <summary><span data-ttu-id="1df17-140">通过处理逻辑树，返回指定 <see cref="T:System.Windows.FrameworkElement" /> 的直接子对象的集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-140">Returns the collection of immediate child objects of the specified <see cref="T:System.Windows.FrameworkElement" /> by processing the logical tree.</span></span></summary>
        <returns><span data-ttu-id="1df17-141">从逻辑树中 <paramref name="current" /> 开始的即时子对象的枚举集合。</span><span class="sxs-lookup"><span data-stu-id="1df17-141">The enumerable collection of immediate child objects starting from <paramref name="current" /> in the logical tree.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetParent (System.Windows.DependencyObject current);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetParent(class System.Windows.DependencyObject current) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (current As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetParent(System::Windows::DependencyObject ^ current);" />
      <MemberSignature Language="F#" Value="static member GetParent : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.LogicalTreeHelper.GetParent current" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="current" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="current"><span data-ttu-id="1df17-142">要查找其父对象的对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-142">The object to find the parent object for.</span></span> <span data-ttu-id="1df17-143">这应为 <see cref="T:System.Windows.FrameworkElement" /> 或 <see cref="T:System.Windows.FrameworkContentElement" />。</span><span class="sxs-lookup"><span data-stu-id="1df17-143">This is expected to be either a <see cref="T:System.Windows.FrameworkElement" /> or a <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></param>
        <summary><span data-ttu-id="1df17-144">通过处理逻辑树，返回指定对象的父对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-144">Returns the parent object of the specified object by processing the logical tree.</span></span></summary>
        <returns><span data-ttu-id="1df17-145">所请求的父对象。</span><span class="sxs-lookup"><span data-stu-id="1df17-145">The requested parent object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1df17-146">此方法只是一个包装器，用于获取或属性的相应类型版本（ <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement> ） <xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType> <xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType> ; 因此，除非您无法确定该 `current` 类型，否则您可能希望改为检查相应的实例属性。</span><span class="sxs-lookup"><span data-stu-id="1df17-146">This method is merely a wrapper that gets the appropriate type version (<xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>) of the <xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType> property; so unless you are unable to determine the `current` type, you might want to check the respective instance properties instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
