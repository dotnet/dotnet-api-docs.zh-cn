<Type Name="CoerceValueCallback" FullName="System.Windows.CoerceValueCallback">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3549f194d7f55a1cd29ab7244ea240a4064e7850" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="82342563" /></Metadata><TypeSignature Language="C#" Value="public delegate object CoerceValueCallback(DependencyObject d, object baseValue);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CoerceValueCallback extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.CoerceValueCallback" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function CoerceValueCallback(d As DependencyObject, baseValue As Object) As Object " />
  <TypeSignature Language="C++ CLI" Value="public delegate System::Object ^ CoerceValueCallback(DependencyObject ^ d, System::Object ^ baseValue);" />
  <TypeSignature Language="F#" Value="type CoerceValueCallback = delegate of DependencyObject * obj -&gt; obj" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="d" Type="System.Windows.DependencyObject" />
    <Parameter Name="baseValue" Type="System.Object" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Object</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="d"><span data-ttu-id="60bd1-101">该属性所在的对象。</span><span class="sxs-lookup"><span data-stu-id="60bd1-101">The object that the property exists on.</span></span> <span data-ttu-id="60bd1-102">在调用该回调时，属性系统将会传递该值。</span><span class="sxs-lookup"><span data-stu-id="60bd1-102">When the callback is invoked, the property system will pass this value.</span></span></param>
    <param name="baseValue"><span data-ttu-id="60bd1-103">该属性在尝试执行任何强制转换之前的新值。</span><span class="sxs-lookup"><span data-stu-id="60bd1-103">The new value of the property, prior to any coercion attempt.</span></span></param>
    <summary><span data-ttu-id="60bd1-104">为只要重新计算依赖项属性值或专门请求强制转换时就调用的方法提供一个模板。</span><span class="sxs-lookup"><span data-stu-id="60bd1-104">Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</span></span></summary>
    <returns><span data-ttu-id="60bd1-105">强制转换后的值（采用适当的类型）。</span><span class="sxs-lookup"><span data-stu-id="60bd1-105">The coerced value (with appropriate type).</span></span></returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bd1-106"><xref:System.Windows.CoerceValueCallback>可以通过多种不同的方法将基于的回调分配给依赖属性。</span><span class="sxs-lookup"><span data-stu-id="60bd1-106">Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques.</span></span> <span data-ttu-id="60bd1-107">每种方法都需要首先创建新的属性元数据对象（ <xref:System.Windows.PropertyMetadata> 或派生类，如 <xref:System.Windows.FrameworkPropertyMetadata> ）。</span><span class="sxs-lookup"><span data-stu-id="60bd1-107">Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>).</span></span> <span data-ttu-id="60bd1-108">使用采用参数的构造函数签名创建元数据对象 `coerceValueCallback` ，并将该参数分配给回调处理程序。</span><span class="sxs-lookup"><span data-stu-id="60bd1-108">Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler.</span></span> <span data-ttu-id="60bd1-109">或按任何签名构造元数据，并 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 在将元数据投入使用之前设置属性。</span><span class="sxs-lookup"><span data-stu-id="60bd1-109">Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.</span></span>  
  
 <span data-ttu-id="60bd1-110">具有此元数据时，可以：</span><span class="sxs-lookup"><span data-stu-id="60bd1-110">When you have this metadata, you can:</span></span>  
  
-   <span data-ttu-id="60bd1-111">使用的任一签名为新类定义新的依赖项属性 <xref:System.Windows.DependencyProperty.Register%2A> ，并将元数据作为 `typeMetadata` 值提供。</span><span class="sxs-lookup"><span data-stu-id="60bd1-111">Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.</span></span>  
  
-   <span data-ttu-id="60bd1-112"><xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>当从拥有依赖项属性的类派生时，重写现有依赖属性的元数据（调用）。</span><span class="sxs-lookup"><span data-stu-id="60bd1-112">Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.</span></span>  
  
-   <span data-ttu-id="60bd1-113"><xref:System.Windows.DependencyObject>通过调用，使用新的元数据将现有依赖项属性添加到新类中 <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> 。</span><span class="sxs-lookup"><span data-stu-id="60bd1-113">Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="60bd1-114">此回调的实现应检查中的值 `baseValue` ，并根据值或类型确定这是否是需要进一步强制转换的值。</span><span class="sxs-lookup"><span data-stu-id="60bd1-114">Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.</span></span>  
  
 <span data-ttu-id="60bd1-115">每当 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 属性系统或任何其他调用方对实例调用时，都将调用依赖属性的 <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.DependencyObject> ，同时将该属性的标识符指定为 `dp` 。</span><span class="sxs-lookup"><span data-stu-id="60bd1-115">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.</span></span>  
  
 <span data-ttu-id="60bd1-116">对属性值的更改可能来自属性系统中任何可能的参与者。</span><span class="sxs-lookup"><span data-stu-id="60bd1-116">Changes to the property value may have come from any possible participant in the property system.</span></span> <span data-ttu-id="60bd1-117">这包括样式、泛型失效、触发器、属性值继承和本地值设置。</span><span class="sxs-lookup"><span data-stu-id="60bd1-117">This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</span></span>  
  
 <span data-ttu-id="60bd1-118">通常，应避免 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 为任何给定的依赖属性指定多个（对于已经具有的依赖属性，重写或添加新的元数据 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> ）。</span><span class="sxs-lookup"><span data-stu-id="60bd1-118">Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</span></span> <span data-ttu-id="60bd1-119">只有其中一个回调才能执行操作。与调用方相比，操作回调将应用于继承中派生程度最高的类 <xref:System.Windows.DependencyObject> 。</span><span class="sxs-lookup"><span data-stu-id="60bd1-119">Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller.</span></span> <span data-ttu-id="60bd1-120">当元数据被重写时，将替换分配给依赖项属性的元数据的其他回调，因为它已存在于所有者层次结构中。</span><span class="sxs-lookup"><span data-stu-id="60bd1-120">Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bd1-121">下面的示例包括此回调的一个实现，该实现基于其他输入（如其他属性的值）强制转换依赖属性存储的值。</span><span class="sxs-lookup"><span data-stu-id="60bd1-121">The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</span></span> <span data-ttu-id="60bd1-122">在这种情况下，回调会检查属性是否 `ShirtType` 对应于具有按钮的衬衫类型; 如果为，则它将为设置起始默认颜色; 如果 `ButtonColor` 衬衫类型没有按钮，则会将该值强制转换 `ButtonColor` 为起始值，这会导致 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] （未显示）从有效选项中删除该下拉列表。</span><span class="sxs-lookup"><span data-stu-id="60bd1-122">In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (not shown) to remove that dropdown from the effective choices.</span></span>  
  
 [!code-csharp[DPCustom#CoerceValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#coercevaluecallback)]
 [!code-vb[DPCustom#CoerceValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#coercevaluecallback)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
</Type>
