<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66da6cc74ec069a24005bed9b891ae7bd2aafcb9" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102063119" /></Metadata><TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f845e-101">为内容元素提供 WPF 核心级基类。</span><span class="sxs-lookup"><span data-stu-id="f845e-101">Provides a WPF core-level base class for content elements.</span></span> <span data-ttu-id="f845e-102">内容元素设计用于流样式显示，它们使用面向标记的直观布局模型和精心设计的简单对象模型。</span><span class="sxs-lookup"><span data-stu-id="f845e-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-103"><xref:System.Windows.ContentElement> 定义以下常见内容特征：</span><span class="sxs-lookup"><span data-stu-id="f845e-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="f845e-104">输入：所有 <xref:System.Windows.ContentElement> 派生类都为键盘、鼠标、拖放操作、触笔控件和快捷键提供基本的输入捕获支持。</span><span class="sxs-lookup"><span data-stu-id="f845e-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="f845e-105">重点：所有 <xref:System.Windows.ContentElement> 派生类都有可能获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="f845e-106"> (但基类的默认可设定焦点状态 <xref:System.Windows.ContentElement> 为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="f845e-107">若要详细了解如何创建可 <xref:System.Windows.ContentElement> 设定焦点的，请参阅 <xref:System.Windows.ContentElement.Focusable%2A> 。此外，此类包含可用于遍历相关元素的焦点的 api （) ）。</span><span class="sxs-lookup"><span data-stu-id="f845e-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains APIs that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="f845e-108">事件： <xref:System.Windows.ContentElement> 包括与输入和焦点相关的事件; 它还包括状态更改的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="f845e-109">在许多情况下， <xref:System.Windows.ContentElement> 事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="f845e-110">在某些情况下，路由事件同时具有隧道和冒泡路由策略，作为响应相同状态或条件的单独事件而引发。</span><span class="sxs-lookup"><span data-stu-id="f845e-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="f845e-111">此外，还 <xref:System.Windows.ContentElement> 定义了可引发路由事件并且可以添加或删除事件处理程序的 api。</span><span class="sxs-lookup"><span data-stu-id="f845e-111">Also, <xref:System.Windows.ContentElement> defines APIs that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="f845e-112"><xref:System.Windows.ContentElement> 与共享许多常见 Api <xref:System.Windows.UIElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-112"><xref:System.Windows.ContentElement> shares many common APIs with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="f845e-113">这些公共 Api 不来自共享类继承。</span><span class="sxs-lookup"><span data-stu-id="f845e-113">These common APIs do not come from a shared class inheritance.</span></span> <span data-ttu-id="f845e-114">但在每个类中，它们共享公共命名、类似行为和相似的 Api 内部实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-114">But they do share common naming, similar behavior, and similar internal implementation of APIs in each class.</span></span> <span data-ttu-id="f845e-115">相似性是因为 <xref:System.Windows.ContentElement> 和 <xref:System.Windows.UIElement> 都是元素基的每个类，但对于其标记对象模型行为，每个类都有不同的意图。</span><span class="sxs-lookup"><span data-stu-id="f845e-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="f845e-116">具体而言， <xref:System.Windows.UIElement> 从开始 <xref:System.Windows.Media.Visual> ，后者为在复合窗口内的矩形区域提供更低级别的图形支持 <xref:System.Windows.ContentElement> ，而 <xref:System.Windows.ContentElement> 延迟呈现，以便更轻松地支持更常见的文档方案（如 flow 和包装）。</span><span class="sxs-lookup"><span data-stu-id="f845e-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="f845e-117">这两个相关的类还实现了公共接口 <xref:System.Windows.IInputElement> 和 <xref:System.Windows.Media.Animation.IAnimatable> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  

 ## <a name="notes-to-inheritors"></a><span data-ttu-id="f845e-118">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="f845e-118">Notes to inheritors</span></span>

 <span data-ttu-id="f845e-119"><xref:System.Windows.ContentElement>类尚未定义流样式演示的完整内容元素的所有方面。</span><span class="sxs-lookup"><span data-stu-id="f845e-119">The <xref:System.Windows.ContentElement> class does not yet define all aspects of a complete content element for flow-style presentation.</span></span> <span data-ttu-id="f845e-120"><xref:System.Windows.FrameworkContentElement> 是的直接派生类 <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-120"><xref:System.Windows.FrameworkContentElement> is an immediately derived class of <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="f845e-121"><xref:System.Windows.FrameworkContentElement> 包括一组更完整的附加成员，它们支持 <xref:System.Windows.FrameworkContentElement> 在内容宿主内呈现，并使用 WPF 框架级别布局系统。</span><span class="sxs-lookup"><span data-stu-id="f845e-121"><xref:System.Windows.FrameworkContentElement> includes a more complete set of additional members that support rendering a <xref:System.Windows.FrameworkContentElement> within a content host and using the WPF framework-level layout system.</span></span>

 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-122">初始化 <see cref="T:System.Windows.ContentElement" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-122">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f845e-123">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span><span class="sxs-lookup"><span data-stu-id="f845e-123">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="f845e-124">要处理的路由事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-124">An identifier for the routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="f845e-125">对处理程序实现的引用。</span><span class="sxs-lookup"><span data-stu-id="f845e-125">A reference to the handler implementation.</span></span></param>
        <summary><span data-ttu-id="f845e-126">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span><span class="sxs-lookup"><span data-stu-id="f845e-126">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-127">可以多次为同一事件添加同一处理程序，而不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f845e-127">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="f845e-128">不过，处理事件时，处理程序实际上被多次调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-128">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="f845e-129">因此，请考虑此行为在处理程序实现中应考虑的副作用。</span><span class="sxs-lookup"><span data-stu-id="f845e-129">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="f845e-130">通常使用此方法为自定义路由事件的 Microsoft .NET 事件访问模式提供 "add" 访问器的实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-130">You typically use this method to provide the implementation of the "add" accessor for the Microsoft .NET event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate, handledEventsToo As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="f845e-131">要处理的路由事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-131">An identifier for the.routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="f845e-132">对处理程序实现的引用。</span><span class="sxs-lookup"><span data-stu-id="f845e-132">A reference to the handler implementation.</span></span></param>
        <param name="handledEventsToo"><span data-ttu-id="f845e-133">如果为 <see langword="true" />，则将按以下方式注册处理程序：即使路由事件在其事件数据中标记为已处理，也会调用处理程序；如果为 <see langword="false" />，则使用默认条件注册处理程序，即当路由事件被标记为已处理时，将不调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-133"><see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span></span>  
  
<span data-ttu-id="f845e-134">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-134">The default is <see langword="false" />.</span></span>  
  
<span data-ttu-id="f845e-135">请勿定期请求重新处理路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-135">Do not routinely ask to rehandle a routed event.</span></span></param>
        <summary><span data-ttu-id="f845e-136">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span><span class="sxs-lookup"><span data-stu-id="f845e-136">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span> <span data-ttu-id="f845e-137">将 <paramref name="handledEventsToo" /> 指定为 <see langword="true" />，可为已标记为由事件路由中的其他元素处理的路由事件调用所提供的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-137">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-138">以切实可行的方式处理低级别的输入事件是一项复杂的任务。</span><span class="sxs-lookup"><span data-stu-id="f845e-138">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="f845e-139">许多控件都实现了某个事件被标记为已处理的行为，并将其替换为另一个更直观的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-139">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="f845e-140">通常，如果有某些设计意图，控件只会将平台输入事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-140">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="f845e-141">在某些情况下，这些设计意图可能并不是您特定的输入事件处理要求。</span><span class="sxs-lookup"><span data-stu-id="f845e-141">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="f845e-142">这适用于将处理程序注册为的 `handledEventsToo` 情况 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-142">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="f845e-143">但不应定期执行此操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-143">But you should not do this routinely.</span></span> <span data-ttu-id="f845e-144">调用处理程序以响应所有事件（即使处理）会使你自己的应用程序事件处理逻辑变得复杂。</span><span class="sxs-lookup"><span data-stu-id="f845e-144">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="f845e-145">如果处理程序逻辑很大，则可能会出现性能下降的情况。</span><span class="sxs-lookup"><span data-stu-id="f845e-145">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="f845e-146">如果在开发过程中已发现某些控件处理仍要使用应用程序逻辑处理的事件，则应为已处理的事件保留使用附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-146">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="f845e-147">避免某些事件控制组合的类处理行为的另一种方法是使用该事件的预览替代项。</span><span class="sxs-lookup"><span data-stu-id="f845e-147">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="f845e-148">例如，如果 <xref:System.Windows.ContentElement.MouseLeftButtonDown> 标记为已由类处理进行处理，则可以改为添加处理程序 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-148">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="f845e-149">可以多次为同一事件添加同一处理程序，而不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f845e-149">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="f845e-150">不过，处理事件时，处理程序实际上被多次调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-150">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="f845e-151">因此，请考虑此行为在处理程序实现中应考虑的副作用。</span><span class="sxs-lookup"><span data-stu-id="f845e-151">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="f845e-152">通常使用此方法为自定义路由事件的 Microsoft .NET 事件访问模式提供 "add" 访问器的实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-152">You typically use this method to provide the implementation of the "add" accessor for the Microsoft .NET event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f845e-153">下面的示例实现了一个处理程序，该处理程序在页面上调用的 <xref:System.Windows.FrameworkElement.Initialized> 事件，该事件使用将定义的处理程序附加到页面上的某个命名元素 `handledEventsToo` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-153">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="f845e-154">即使路由中的另一个元素将共享事件数据标记为已处理，然后再到达路由中的处理元素，也会调用该处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-154">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route"><span data-ttu-id="f845e-155">要向其添加处理程序的事件路由。</span><span class="sxs-lookup"><span data-stu-id="f845e-155">The event route that handlers are added to.</span></span></param>
        <param name="e"><span data-ttu-id="f845e-156">用于添加处理程序的事件数据。</span><span class="sxs-lookup"><span data-stu-id="f845e-156">The event data that is used to add the handlers.</span></span> <span data-ttu-id="f845e-157">此方法使用参数的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性来创建处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-157">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span></span></param>
        <summary><span data-ttu-id="f845e-158">将处理程序添加到当前 <see cref="T:System.Windows.EventRoute" /> 事件处理程序集合的指定 <see cref="T:System.Windows.ContentElement" /> 中。</span><span class="sxs-lookup"><span data-stu-id="f845e-158">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-159">无论内容宿主元素是否实现) ，都要将此方法用于 (内容宿主元素， <xref:System.Windows.IContentHost> 以将内容宿主子元素的处理程序添加到主机 <xref:System.Windows.EventRoute> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-159">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-160">获取或设置一个值，该值指示此元素能否用作拖放操作的目标。</span><span class="sxs-lookup"><span data-stu-id="f845e-160">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span></span></summary>
        <value><span data-ttu-id="f845e-161">如果此元素可用作拖放操作的目标，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-161"><see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-162">默认值是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-162">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-163">默认情况下不启用拖放操作，并且必须通过将设置 <xref:System.Windows.ContentElement.AllowDrop%2A> 为来特意启用  `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-163">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="f845e-164">除了此基本设置外，拖放行为完全是特定实现的，并且不是由 <xref:System.Windows.ContentElement> 或任何其他基元素类定义的。</span><span class="sxs-lookup"><span data-stu-id="f845e-164">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="f845e-165">某些控件（例如） <xref:System.Windows.Controls.RichTextBox> 具有默认行为，但没有 <xref:System.Windows.ContentElement> 派生类具有这样的行为。</span><span class="sxs-lookup"><span data-stu-id="f845e-165">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="f845e-166">有关拖放的详细信息，请参阅 [拖放概述](/dotnet/framework/wpf/advanced/drag-and-drop-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-166">For more information on drag and drop, see [Drag and Drop Overview](/dotnet/framework/wpf/advanced/drag-and-drop-overview).</span></span>  
  
 <span data-ttu-id="f845e-167"><xref:System.Windows.FrameworkContentElement> 在其实现中重写此依赖项属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="f845e-167"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="f845e-168">具体而言， <xref:System.Windows.FrameworkContentElement> 指定此属性允许 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> `true` 在元数据)  (的属性值继承。</span><span class="sxs-lookup"><span data-stu-id="f845e-168">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="f845e-169">此上下文中的属性值继承表示，如果有子元素没有任何其他值可 <xref:System.Windows.ContentElement.AllowDrop%2A> 通过本地值或样式进行分配，则使用此值指定的最接近的父元素的值 (再次，无论是在样式、默认值或本地值) 中，该父元素的值被属性系统分配给所有未分配的子元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-169">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="f845e-170">这意味着，你可以指定是否在根元素处允许放置操作，然后将该值传播到所有 <xref:System.Windows.FrameworkContentElement> 未向其分配值的子元素 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-170">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-171">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-171">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-172">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-172">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="f845e-173">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-173">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-174">无</span><span class="sxs-lookup"><span data-stu-id="f845e-174">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f845e-175">下面的示例 <xref:System.Windows.ContentElement.AllowDrop%2A> 在 XAML 中设置。</span><span class="sxs-lookup"><span data-stu-id="f845e-175">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in XAML.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-176">标识 <see cref="P:System.Windows.ContentElement.AllowDrop" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-176">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f845e-177">将动画应用到此元素的指定依赖属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-177">Applies an animation to a specified dependency property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="f845e-178">要进行动画处理的属性的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-178">The identifier for the property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="f845e-179">控制和声明动画的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f845e-179">The animation clock that controls and declares the animation.</span></span></param>
        <summary><span data-ttu-id="f845e-180">将动画应用到此元素的指定依赖属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-180">Applies an animation to a specified dependency property on this element.</span></span> <span data-ttu-id="f845e-181">任何现有动画均停止并替换为新动画。</span><span class="sxs-lookup"><span data-stu-id="f845e-181">Any existing animations are stopped and replaced with the new animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-182">若要从属性中删除动画，请将该属性的标识符指定为， `dp` 并将指定 `clock` 为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-182">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="f845e-183">这将删除动画并将动画属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="f845e-183">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="f845e-184">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f845e-184">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="f845e-185">分配给该时钟的任何其他动画都将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f845e-185">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="f845e-186">要进行动画处理的属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-186">The property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="f845e-187">控制和声明动画的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f845e-187">The animation clock that controls and declares the animation.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="f845e-188">枚举的一个值。</span><span class="sxs-lookup"><span data-stu-id="f845e-188">A value of the enumeration.</span></span> <span data-ttu-id="f845e-189">默认值为 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，这会停止任何现有动画并将其替换为新动画。</span><span class="sxs-lookup"><span data-stu-id="f845e-189">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span></span></param>
        <summary><span data-ttu-id="f845e-190">向此元素的指定依赖属性应用动画，并且可以指定当该属性已有正在运行的动画时所要执行的操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-190">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-191">若要从属性中删除动画，请将该属性的标识符指定为， `dp` 并将指定 `clock` 为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-191">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="f845e-192">这将删除动画并将动画属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="f845e-192">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="f845e-193">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="f845e-193">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="f845e-194">分配给该时钟的任何其他动画都将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f845e-194">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-195">获取一个值，该值指示在此元素上是否至少捕获了一次触摸。</span><span class="sxs-lookup"><span data-stu-id="f845e-195">Gets a value that indicates whether at least one touch is captured to this element.</span></span></summary>
        <value><span data-ttu-id="f845e-196">如果在此元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-196"><see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-197">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-197">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-198">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少捕获了一次触摸。</span><span class="sxs-lookup"><span data-stu-id="f845e-198">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="f845e-199">如果在此元素或其可视化树中的任何子元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-199"><see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-200">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-200">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-201">获取一个值，该值指示在此元素上是否至少按下了一次触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-201">Gets a value that indicates whether at least one touch is pressed over this element.</span></span></summary>
        <value><span data-ttu-id="f845e-202">如果在此元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-202"><see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-203">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-203">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-204">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少按下了一次触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-204">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="f845e-205">如果在此元素或其可视化树中的任何子元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-205"><see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-206">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-206">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f845e-207">为此元素的指定要进行动画处理的属性启动动画。</span><span class="sxs-lookup"><span data-stu-id="f845e-207">Starts an animation for a specified animated property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="f845e-208">要进行动画处理的属性，它被指定为依赖项属性标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-208">The property to animate, which is specified as a dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="f845e-209">要启动的动画的时间线。</span><span class="sxs-lookup"><span data-stu-id="f845e-209">The timeline of the animation to start.</span></span></param>
        <summary><span data-ttu-id="f845e-210">为此元素的指定要进行动画处理的属性启动动画。</span><span class="sxs-lookup"><span data-stu-id="f845e-210">Starts an animation for a specified animated property on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-211">检查属性是否已进行动画处理时，请注意，当呈现非动画起始点之外的第一个帧时，动画将开始，并被视为已进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-211">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="f845e-212">如果的 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> 为 `animation` ，则将 `null` 移除当前的任何动画，并保持该属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="f845e-212">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="f845e-213">如果整个 `animation` 值为 `null` ，则从属性中移除所有动画，并且属性值将恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="f845e-213">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="f845e-214">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="f845e-214">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="f845e-215">分配给该时间线的任何其他动画都将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f845e-215">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="f845e-216">要进行动画处理的属性，它被指定为依赖项属性标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-216">The property to animate, which is specified as the dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="f845e-217">要应用的动画的时间线。</span><span class="sxs-lookup"><span data-stu-id="f845e-217">The timeline of the animation to be applied.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="f845e-218">一个枚举值，用来指定新动画如何与已在影响属性值的任何当前（正在运行的）动画进行交互。</span><span class="sxs-lookup"><span data-stu-id="f845e-218">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span></span></param>
        <summary><span data-ttu-id="f845e-219">为此元素的指定要进行动画处理的属性启动特定的动画，并可以指定当该属性已有正在运行的动画时所要执行的操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-219">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-220">检查属性是否已进行动画处理时，请注意，当呈现非动画起始点之外的第一个帧时，动画将开始，并被视为已进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-220">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="f845e-221">如果的 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> 为 `animation` ，则将 `null` 移除当前的任何动画，并保持该属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="f845e-221">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="f845e-222">如果整个 `animation` 值为 `null` ，则从属性中移除所有动画，并且属性值将恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="f845e-222">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="f845e-223">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="f845e-223">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="f845e-224">分配给该时间线的任何其他动画都将继续运行。</span><span class="sxs-lookup"><span data-stu-id="f845e-224">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-225">尝试将鼠标强制捕获到此元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-225">Attempts to force capture of the mouse to this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-226">如果成功捕获了鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-226"><see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-227">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-227">To be captured, an element must be enabled.</span></span> <span data-ttu-id="f845e-228">在 <xref:System.Windows.ContentElement.IsEnabled%2A> `true` 调用之前检查是否为 <xref:System.Windows.ContentElement.CaptureMouse%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-228">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="f845e-229">如果调用 <xref:System.Windows.ContentElement.CaptureMouse%2A> 返回 `true` ，则 <xref:System.Windows.ContentElement.IsMouseCaptured%2A> 也是 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="f845e-230">如果调用 <xref:System.Windows.ContentElement.CaptureMouse%2A> 返回 `true` ，则 <xref:System.Windows.ContentElement.GotMouseCapture> <xref:System.Windows.ContentElement.IsMouseCapturedChanged> 会引发和事件，并将 <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> 在事件数据中报告为调用方法的元素 <xref:System.Windows.ContentElement.CaptureMouse%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-230">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="f845e-231">如果强制捕获，则可能会干扰现有捕获，尤其是与用鼠标拖放相关的捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-231">If you force capture, you might interfere with existing captures - especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="f845e-232">若要从所有元素中清除鼠标捕获，请 <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> 用 `element` 提供的参数调用 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-232">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f845e-233">下面的示例根据鼠标是否已由元素捕获来捕获鼠标或释放捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-233">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="f845e-234">请注意，此示例将预期的捕获目标元素强制转换为 <xref:System.Windows.IInputElement> 接口，因而最初调用 <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-234">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f845e-235"><xref:System.Windows.IInputElement>如果您不确定要捕获鼠标的元素是否为或，则强制转换为很有用 <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-235">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="f845e-236">然后，接口强制转换和接口方法调用在内部调用适当的特定于类型的 CaptureMouse 实现，而无需将试验强制转换为 <xref:System.Windows.UIElement> 或 <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-236">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="f845e-237">此相同的强制转换技术适用于 <xref:System.Windows.IInputElement> 定义多个输入相关事件和其他输入相关方法的其他成员。</span><span class="sxs-lookup"><span data-stu-id="f845e-237">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-238">尝试将触笔强制捕获到此元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-238">Attempts to force capture of the stylus to this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-239">如果成功捕获了触笔，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-239"><see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-240">基于基础默认触笔设备的默认实现始终返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-240">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="f845e-241">但是，如果你要扩展为输入系统提供设备实现的输入设备，则可以使用可能返回不同结果的备用触笔设备实现创建系统。</span><span class="sxs-lookup"><span data-stu-id="f845e-241">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="f845e-242">当某个元素捕获触笔时，它将接收触笔输入，即使触笔位于其边界之外。</span><span class="sxs-lookup"><span data-stu-id="f845e-242">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="f845e-243">通常仅在拖放操作期间捕获触笔。</span><span class="sxs-lookup"><span data-stu-id="f845e-243">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f845e-244">调用此方法将调用基础静态 <xref:System.Windows.Input.Stylus> 方法 <xref:System.Windows.Input.Stylus.Capture%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-244">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="f845e-245">实际捕获行为是由活动的触笔设备实现实现的。</span><span class="sxs-lookup"><span data-stu-id="f845e-245">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="f845e-246">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-246">To be captured, an element must be enabled.</span></span> <span data-ttu-id="f845e-247">检查是否 <xref:System.Windows.ContentElement.IsEnabled%2A> 在 `true` 调用之前返回 <xref:System.Windows.ContentElement.CaptureStylus%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-247">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="f845e-248">如果调用 <xref:System.Windows.ContentElement.CaptureStylus%2A> 返回 `true` ， <xref:System.Windows.ContentElement.IsStylusCaptured%2A> 则也是 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-248">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureTouch (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="f845e-249">要捕获的设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-249">The device to capture.</span></span></param>
        <summary><span data-ttu-id="f845e-250">尝试将触摸屏输入强制捕获到此元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-250">Attempts to force capture of a touch to this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-251">如果将指定触摸屏输入捕获到此元素，则为 <see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-251"><see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-252"><xref:System.Windows.ContentElement.CaptureTouch%2A>`false`如果 <xref:System.Windows.Input.TouchDevice> 当前已捕获到另一个元素，则将返回。</span><span class="sxs-lookup"><span data-stu-id="f845e-252"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="f845e-253">如果 <xref:System.Windows.ContentElement.CaptureTouch%2A> 返回 `true` ，则 <xref:System.Windows.ContentElement.GotTouchCapture> 引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-253">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="f845e-254">若要从此元素中释放单个触摸的捕获，请使用 <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> 方法并指定要释放的触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-254">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="f845e-255">若要释放此元素的所有接触，请使用 <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-255">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f845e-256"><paramref name="touchDevice" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-256"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-257">获取与此元素关联的 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span><span class="sxs-lookup"><span data-stu-id="f845e-257">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="f845e-258">所有 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span><span class="sxs-lookup"><span data-stu-id="f845e-258">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-259"><xref:System.Windows.Input.CommandBinding>允许命令处理此元素的特定命令，并声明命令、其事件和由此元素附加的处理程序之间的链接。</span><span class="sxs-lookup"><span data-stu-id="f845e-259">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="f845e-260">填充集合的另一种典型方法 <xref:System.Windows.ContentElement.CommandBindings%2A> 是以 <xref:System.Windows.Input.CommandManager> 编程方式使用方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-260">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="f845e-261">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="f845e-261">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="f845e-262">XAML 值</span><span class="sxs-lookup"><span data-stu-id="f845e-262">XAML Values</span></span>  
 <span data-ttu-id="f845e-263">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="f845e-263">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="f845e-264">一个或多个 <xref:System.Windows.Input.CommandBinding> 元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-264">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="f845e-265">其中每个都应将 <xref:System.Windows.Input.CommandBinding.Command%2A> 属性设置为已知命令，并为 <xref:System.Windows.Input.CommandBinding.CanExecute> 和 <xref:System.Windows.Input.CommandBinding.Executed> 处理程序实现设置特性。</span><span class="sxs-lookup"><span data-stu-id="f845e-265">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="f845e-266">有关更多信息，请参见<xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="f845e-266">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-267">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-267">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-268">此事件将为 <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-268">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-269">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.DragEnter> 附加到基础 <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-269">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-270">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-270">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-271">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-271">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="f845e-272">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-272">Routing strategy</span></span>|<span data-ttu-id="f845e-273">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-273">Bubbling</span></span>|  
|<span data-ttu-id="f845e-274">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-274">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-275">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewDragEnter> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-275">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="f845e-276">重写 <xref:System.Windows.ContentElement.OnDragEnter%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-276">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-277">标识 <see cref="E:System.Windows.ContentElement.DragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-277">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-278">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-278">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-279">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-279">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-280">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-280">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-281">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-281">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-282">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-282">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-283">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-283">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-284">此事件将为 <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-284">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-285">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.DragLeave> 附加到基础 <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-285">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-286">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-286">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-287">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-287">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="f845e-288">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-288">Routing strategy</span></span>|<span data-ttu-id="f845e-289">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-289">Bubbling</span></span>|  
|<span data-ttu-id="f845e-290">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-290">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-291">对应的隧道事件为 <xref:System.Windows.DragDrop.PreviewDragLeave> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-291">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="f845e-292">重写 <xref:System.Windows.ContentElement.OnDragLeave%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-292">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-293">标识 <see cref="E:System.Windows.ContentElement.DragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-293">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-294">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-294">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-295">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-295">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-296">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-296">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-297">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-297">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-298">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-298">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-299">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-299">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-300">即使拖动源自元素边界，也会发生此事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-300">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="f845e-301">如果拖动从边界外开始，并在内部移动，则还会引发此事件，以及 <xref:System.Windows.ContentElement.DragEnter> 和相关的预览事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-301">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="f845e-302">此事件将为 <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-302">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-303">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.DragOver> 附加到基础 <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-303">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-304">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-305">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-305">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="f845e-306">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-306">Routing strategy</span></span>|<span data-ttu-id="f845e-307">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-307">Bubbling</span></span>|  
|<span data-ttu-id="f845e-308">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-308">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-309">对应的隧道事件为 <xref:System.Windows.DragDrop.PreviewDragOver> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-309">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="f845e-310">重写 <xref:System.Windows.ContentElement.OnDragOver%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-310">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-311">标识 <see cref="E:System.Windows.ContentElement.DragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-311">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-312">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-313">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-314">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-315">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-316">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-317">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-317">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-318">此事件将为 <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-318">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-319">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.Drop> 附加到基础 <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-319">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-320">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-320">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-321">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-321">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="f845e-322">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-322">Routing strategy</span></span>|<span data-ttu-id="f845e-323">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-323">Bubbling</span></span>|  
|<span data-ttu-id="f845e-324">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-324">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-325">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewDrop> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-325">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="f845e-326">重写 <xref:System.Windows.ContentElement.OnDrop%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-326">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-327">标识 <see cref="E:System.Windows.ContentElement.Drop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-327">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-328">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-328">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-329">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-329">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-330">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-330">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-331">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-331">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-332">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-332">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-333">尝试将焦点设定到此元素上。</span><span class="sxs-lookup"><span data-stu-id="f845e-333">Attempts to set focus to this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-334">如果键盘焦点可设定到此元素上，则为 <see langword="true" />；如果此方法调用未强制设置焦点，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-334"><see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-335">可获得焦点， <xref:System.Windows.ContentElement.Focusable%2A> 且 <xref:System.Windows.ContentElement.IsEnabled%2A> 必须都为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-335">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="f845e-336">请注意， <xref:System.Windows.ContentElement> 默认情况下，几乎所有派生类都不是 <xref:System.Windows.ContentElement.Focusable%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-336">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="f845e-337">即使某个元素可设定焦点并已启用，特定树中的事件处理 (例如对于复合控件) 可能会通过不允许焦点来响应预览焦点事件，因此此方法将返回 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-337">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="f845e-338">重点是由两个不同的概念控制的：键盘焦点和逻辑焦点，它们并非始终相同。</span><span class="sxs-lookup"><span data-stu-id="f845e-338">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="f845e-339">此方法设置逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-339">This method sets the logical focus.</span></span> <span data-ttu-id="f845e-340">无编程方式来专门设置键盘焦点;键盘焦点由用户输入确定。</span><span class="sxs-lookup"><span data-stu-id="f845e-340">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="f845e-341">有关详细信息，请参阅 " [焦点概述](/dotnet/framework/wpf/advanced/focus-overview) " 和 " [输入概述](/dotnet/framework/wpf/advanced/input-overview)"。</span><span class="sxs-lookup"><span data-stu-id="f845e-341">For more information, see [Focus Overview](/dotnet/framework/wpf/advanced/focus-overview) and [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
 <span data-ttu-id="f845e-342">如果调用 <xref:System.Windows.ContentElement.Focus%2A> 返回 `true` ， <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> 则和也为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-342">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="f845e-343">如果没有相关属性 `true` ，则在调用时，将 <xref:System.Windows.ContentElement.Focus%2A> 按以下顺序引发以下一个或多个事件： <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> ， <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (源是新的焦点目标) ， <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> ，， <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> <xref:System.Windows.ContentElement.LostKeyboardFocus> <xref:System.Windows.ContentElement.GotKeyboardFocus> (源是新的焦点目标) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-343">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f845e-344">下面的示例是一个页面加载的事件处理程序，它在文档中查找指定的命名段落并将焦点设置到该段落。</span><span class="sxs-lookup"><span data-stu-id="f845e-344">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="f845e-345">段落默认情况下不可设定焦点;此特定段落应用了样式， (未显示) 使用样式 <xref:System.Windows.Setter> 使其可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-345">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-346">获取或设置一个值，该值指示元素能否得到焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-346">Gets or sets a value that indicates whether the element can receive focus.</span></span></summary>
        <value><span data-ttu-id="f845e-347">如果元素能得到焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-347"><see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span></span> <span data-ttu-id="f845e-348">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-348">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-349">只有聚焦元素接收键盘输入。</span><span class="sxs-lookup"><span data-stu-id="f845e-349">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="f845e-350">某些派生类可能会重写此依赖项属性的元数据，以使派生类默认可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-350">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="f845e-351">当由 <xref:System.Windows.Documents.Hyperlink> 或其派生类继承时，将 <xref:System.Windows.Documents.Hyperlink> 重写此依赖属性的元数据，并将此属性的默认值重新定义为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-351">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
### <a name="dependency-property-information"></a><span data-ttu-id="f845e-352">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-352">Dependency property information</span></span>
  
|||  
|-|-|  
|<span data-ttu-id="f845e-353">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-353">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="f845e-354">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-354">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-355">无</span><span class="sxs-lookup"><span data-stu-id="f845e-355">None</span></span>|  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="f845e-356">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="f845e-356">Notes to inheritors</span></span>

<span data-ttu-id="f845e-357">从派生时 <xref:System.Windows.ContentElement> ，请考虑你是否希望元素可获得焦点，因为默认情况下，它将无法获得焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-357">When you derive from <xref:System.Windows.ContentElement>, consider whether you want your element to be focusable, because by default it will not be focusable.</span></span> <span data-ttu-id="f845e-358">如果希望元素可设定焦点，请在派生类静态构造函数中重写此属性的元数据，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f845e-358">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span></span>  

[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
[!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
<span data-ttu-id="f845e-359">其中 `myElement` ，是要重写元数据值的类型的类名。</span><span class="sxs-lookup"><span data-stu-id="f845e-359">where `myElement` is the class name of the type that you are overriding the metadata value on.</span></span>
  
## Examples  
 <span data-ttu-id="f845e-360">下面的示例创建一个样式，该样式在 <xref:System.Windows.Documents.Paragraph> 默认情况下可设定焦点，并在收到焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="f845e-360">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-361">当 <see cref="P:System.Windows.ContentElement.Focusable" /> 属性的值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-361">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-362">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-362">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-363">标识 <see cref="P:System.Windows.ContentElement.Focusable" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-363">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="f845e-364">要选中的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-364">The.dependency property to check.</span></span></param>
        <summary><span data-ttu-id="f845e-365">为此元素上的指定属性返回基属性值，忽略任何可能来自正在运行或已停止的动画的动画值。</span><span class="sxs-lookup"><span data-stu-id="f845e-365">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span></span></summary>
        <returns><span data-ttu-id="f845e-366">就像没有动画被附加到指定的依赖属性一样的属性值。</span><span class="sxs-lookup"><span data-stu-id="f845e-366">The property value as if no animations are attached to the specified dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-367">如果没有任何动画附加到属性，则 <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> 返回值始终与 <xref:System.Windows.DependencyObject.GetValue%2A> 返回值相同。</span><span class="sxs-lookup"><span data-stu-id="f845e-367">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="f845e-368">如果附加了动画，则将忽略所有可能的动画派生值（包括开始值和结束值），并根据所有其他可能的输入来确定属性值。</span><span class="sxs-lookup"><span data-stu-id="f845e-368">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="f845e-369">有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。</span><span class="sxs-lookup"><span data-stu-id="f845e-369">For more information, see [Dependency Property Value Precedence](/dotnet/framework/wpf/advanced/dependency-property-value-precedence).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-370">当在派生类中重写时，如果不存在任何视觉父级，则返回 (UI) 父级的备用用户界面。</span><span class="sxs-lookup"><span data-stu-id="f845e-370">When overridden in a derived class, returns an alternative user interface (UI) parent for this element if no visual parent exists.</span></span></summary>
        <returns><span data-ttu-id="f845e-371">如果派生类的实现具有要报告的替代父级连接，则为一个对象。</span><span class="sxs-lookup"><span data-stu-id="f845e-371">An object, if implementation of a derived class has an alternate parent connection to report.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-372">此方法的默认虚拟实现返回 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-372">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="f845e-373"><xref:System.Windows.FrameworkContentElement> 提供一个实际实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-373"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="f845e-374">备用父级用于事件路由，在这种情况下，元素创建备用父结构，使其事件以与其分离从可视化树向上路由到标准父级的标准模式，或在预览路由策略中向下传递。</span><span class="sxs-lookup"><span data-stu-id="f845e-374">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-375">在输入系统报告出现涉及此元素的基础拖放操作时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-375">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-376"><xref:System.Windows.ContentElement.GiveFeedback>事件允许拖动事件的源修改鼠标指针的外观，以便在拖放操作过程中为用户提供视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="f845e-376">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="f845e-377">视觉对象反馈强调正在处理拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-377">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="f845e-378">此事件将为 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.GiveFeedback> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-378">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-379">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.GiveFeedback> 附加到基础 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-379">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-380">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-380">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-381">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-381">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="f845e-382">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-382">Routing strategy</span></span>|<span data-ttu-id="f845e-383">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-383">Bubbling</span></span>|  
|<span data-ttu-id="f845e-384">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-384">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="f845e-385">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewGiveFeedback> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-385">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="f845e-386">重写 <xref:System.Windows.ContentElement.OnGiveFeedback%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-386">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-387">标识 <see cref="E:System.Windows.ContentElement.GiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-387">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-388">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-388">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-389">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-389">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-390">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-390">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-391">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-391">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-392">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-392">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-393">在此元素获得逻辑焦点时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-393">Occurs when this element gets logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-394">如果通过使用方法调用有意强制焦点，但上一个键盘焦点存在于不同的范围内，则逻辑焦点不同于键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-394">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="f845e-395">在这种情况下，键盘焦点将保留在其中，而调用方法的元素仍会获得 <xref:System.Windows.ContentElement.Focus%2A> 逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-395">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="f845e-396">此事件的更精确解释是：当 <xref:System.Windows.ContentElement.IsFocused%2A> 路由中某个元素的属性的值从更改为时，将引发此事件 `false` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-396">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="f845e-397">因为此事件使用冒泡路由，所以接收焦点的元素可能是一个子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-397">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-398">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定获得焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-398">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-399">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-400">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-400">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="f845e-401">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-401">Routing strategy</span></span>|<span data-ttu-id="f845e-402">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-402">Bubbling</span></span>|  
|<span data-ttu-id="f845e-403">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-403">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="f845e-404">没有相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-404">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-405">重写 <xref:System.Windows.ContentElement.OnGotFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-405">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-406">标识 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-406">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-407">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-408">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-409">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-410">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-411">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-412">在此元素聚焦于键盘时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-412">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-413"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 是一个类似的事件，用于跟踪维护元素的焦点状态的属性中的状态更改; <xref:System.Windows.ContentElement.GotKeyboardFocus> 在许多相同的情况下都会引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-413"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="f845e-414">由于此事件使用冒泡路由，因此具有焦点的元素可以是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-414">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-415">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定具有焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-415">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="f845e-416">此事件将为 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.GotKeyboardFocus> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-416">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-417">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.GotKeyboardFocus> 附加到基础 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-417">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-418">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-418">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-419">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-419">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="f845e-420">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-420">Routing strategy</span></span>|<span data-ttu-id="f845e-421">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-421">Bubbling</span></span>|  
|<span data-ttu-id="f845e-422">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-422">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f845e-423">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-423">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f845e-424">重写 <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-424">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-425">标识 <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-425">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-426">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-426">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-427">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-427">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-428">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-428">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-429">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-429">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-430">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-430">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-431">在此元素捕获鼠标时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-431">Occurs when this element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-432">当某个元素捕获鼠标时，它将接收鼠标输入，即使鼠标指针在其边界之外也是如此。</span><span class="sxs-lookup"><span data-stu-id="f845e-432">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="f845e-433">通常仅在拖放操作期间捕获鼠标，并在拖放操作的删除操作发生之前捕获该鼠标。</span><span class="sxs-lookup"><span data-stu-id="f845e-433">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="f845e-434">由于此事件使用冒泡路由，因此具有捕获的元素可以是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-434">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-435">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定具有鼠标捕获的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-435">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="f845e-436">此事件将为 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.GotMouseCapture> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-436">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-437">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.GotMouseCapture> 附加到基础 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-437">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-438">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-438">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-439">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-439">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="f845e-440">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-440">Routing strategy</span></span>|<span data-ttu-id="f845e-441">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-441">Bubbling</span></span>|  
|<span data-ttu-id="f845e-442">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-442">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-443">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-443">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-444">重写 <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-444">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-445">标识 <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-445">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-446">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-446">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-447">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-447">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-448">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-448">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-449">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-449">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-450">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-450">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-451">在此元素捕获触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-451">Occurs when this element captures the stylus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-452">当某个元素捕获触笔时，它将接收触笔输入，即使指针在其边界之外也是如此。</span><span class="sxs-lookup"><span data-stu-id="f845e-452">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f845e-453">通常仅在拖放操作期间捕获触笔，并保留捕获，直到拖放操作的删除操作发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-453">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="f845e-454">由于此事件使用冒泡路由，因此具有捕获的元素可以是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-454">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-455">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定具有捕获的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-455">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="f845e-456">此事件将为此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.GotStylusCapture> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-456">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-457">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.GotStylusCapture> 附加到基础 <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-457">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-458">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-458">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-459">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-459">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="f845e-460">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-460">Routing strategy</span></span>|<span data-ttu-id="f845e-461">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-461">Bubbling</span></span>|  
|<span data-ttu-id="f845e-462">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-462">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-463">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-463">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-464">重写 <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-464">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-465">标识 <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-465">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-466">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-466">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-467">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-467">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-468">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-468">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-469">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-469">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-470">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-470">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-471">在此元素上捕获触摸屏输入时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-471">Occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-472">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-472">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-473">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-473">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="f845e-474">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-474">Routing strategy</span></span>|<span data-ttu-id="f845e-475">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-475">Bubbling</span></span>|  
|<span data-ttu-id="f845e-476">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-476">Delegate</span></span>|<span data-ttu-id="f845e-477"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-477"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-478">重写 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-478">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-479">标识 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-479">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-480">获取一个值，该值指示此元素是否具有任何进行动画处理的属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-480">Gets a value that indicates whether this element has any animated properties.</span></span></summary>
        <value><span data-ttu-id="f845e-481">如果此元素具有附加到其任何属性的动画，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-481"><see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-482">此属性 `true` 为持久性 (unclocked、始终运行的) 动画或具有特定时间线的动画返回。</span><span class="sxs-lookup"><span data-stu-id="f845e-482">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-483">获取与此元素关联的输入绑定的集合。</span><span class="sxs-lookup"><span data-stu-id="f845e-483">Gets the collection of input bindings that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="f845e-484">输入绑定的集合。</span><span class="sxs-lookup"><span data-stu-id="f845e-484">The collection of input bindings.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-485">输入绑定支持将命令绑定到输入设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-485">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="f845e-486">例如， <xref:System.Windows.Input.MouseBinding> 实现包含特定于鼠标设备的属性的输入绑定。</span><span class="sxs-lookup"><span data-stu-id="f845e-486">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="f845e-487">输入绑定集合包含与该类型相关的输入绑定，以及在该实例上声明的输入绑定。</span><span class="sxs-lookup"><span data-stu-id="f845e-487">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="f845e-488">相关属性， <xref:System.Windows.ContentElement.CommandBindings%2A> 维护命令绑定的集合。</span><span class="sxs-lookup"><span data-stu-id="f845e-488">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="f845e-489">这些绑定不同于输入绑定，因为它们表示命令处理下一级别的操作，这些操作与已知命令和类特定的处理程序关联。</span><span class="sxs-lookup"><span data-stu-id="f845e-489">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="f845e-490">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="f845e-490">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="f845e-491">XAML 值</span><span class="sxs-lookup"><span data-stu-id="f845e-491">XAML Values</span></span>  
 <span data-ttu-id="f845e-492">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="f845e-492">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="f845e-493"><xref:System.Windows.Input.InputBinding> (通常为 <xref:System.Windows.Input.KeyBinding> 或 <xref:System.Windows.Input.MouseBinding> 派生类) 一个或多个元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-493">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="f845e-494">其中每个都应具有 <xref:System.Windows.Input.InputBinding.Command%2A> 和 <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性集。</span><span class="sxs-lookup"><span data-stu-id="f845e-494">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-495">获取或设置一个值，该值指示是否在用户界面中 (UI) 启用此元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-495">Gets or sets a value that indicates whether this element is enabled in the user interface (UI).</span></span></summary>
        <value><span data-ttu-id="f845e-496">如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-496"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-497">默认值是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-497">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-498">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-498">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-499">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-499">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="f845e-500">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-500">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-501">无</span><span class="sxs-lookup"><span data-stu-id="f845e-501">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f845e-502">下面的示例创建一个样式，该样式包含在设置为时提供替换可视行为的属性 setter <xref:System.Windows.Documents.Hyperlink> <xref:System.Windows.ContentElement.IsEnabled%2A> `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-502">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-503">在此元素的 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-503">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-504">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-504">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-505">获取一个值，该值成为派生类中 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 的返回值。</span><span class="sxs-lookup"><span data-stu-id="f845e-505">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span></span></summary>
        <value><span data-ttu-id="f845e-506">如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-506"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## <a name="notes-to-inheritors"></a><span data-ttu-id="f845e-507">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="f845e-507">Notes to inheritors</span></span>

<span data-ttu-id="f845e-508">此属性的默认实现会缓存值，还会计算是否已启用此元素的父元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-508">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span></span> <span data-ttu-id="f845e-509">如果未启用父元素，则不能在实际用户界面中有效启用子元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-509">If the parent is not enabled, the child element cannot be effectively enabled in practical user interface.</span></span> <span data-ttu-id="f845e-510">如果选择重写此实现，请确保调用基实现以保留此行为。</span><span class="sxs-lookup"><span data-stu-id="f845e-510">If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-511">标识 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-511">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-512">获取一个值，该值确定此元素是否具有逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-512">Gets a value that determines whether this element has logical focus.</span></span></summary>
        <value><span data-ttu-id="f845e-513">如果此元素具有逻辑焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-513"><see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-514">如果应用程序有多个焦点区域（例如菜单内容和应用程序的其余部分之间），则逻辑焦点可能与键盘焦点不同。</span><span class="sxs-lookup"><span data-stu-id="f845e-514">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="f845e-515">在此方案中，键盘焦点只能在应用程序 UI 的一个元素上，但是，其他焦点部门中的某些元素可能仍会保留逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-515">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="f845e-516">有关逻辑焦点的详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview) 和 [焦点概述](/dotnet/framework/wpf/advanced/focus-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-516">For more information on logical focus, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview) and [Focus Overview](/dotnet/framework/wpf/advanced/focus-overview).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-517">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-517">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-518">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-518">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="f845e-519">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-519">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-520">无</span><span class="sxs-lookup"><span data-stu-id="f845e-520">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f845e-521">下面的示例创建一个样式，该样式在 <xref:System.Windows.Documents.Paragraph> 默认情况下可设定焦点，并在收到焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="f845e-521">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-522">标识 <see cref="P:System.Windows.ContentElement.IsFocused" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-522">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-523">获取一个值，该值指示是否启用输入法系统（如输入法编辑器 (IME) ）来处理此元素的输入。</span><span class="sxs-lookup"><span data-stu-id="f845e-523">Gets a value that indicates whether an input method system, such as an Input Method Editor (IME), is enabled for processing the input to this element.</span></span></summary>
        <value><span data-ttu-id="f845e-524">如果输入法处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-524"><see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-525">基础附加属性的默认值为 <see langword="true" />；但在运行时该值会受到输入法状态的影响。</span><span class="sxs-lookup"><span data-stu-id="f845e-525">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-526">此属性返回当前启用的输入法的附加属性返回的值 <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> (键盘、语音和其他输入设备) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-526">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-527">获取一个值，该值表示此元素是否具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-527">Gets a value that indicates whether this element has keyboard focus.</span></span></summary>
        <value><span data-ttu-id="f845e-528">如果此元素具有键盘焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-528"><see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-529">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-530">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-531">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-531">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="f845e-532">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-532">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-533">无</span><span class="sxs-lookup"><span data-stu-id="f845e-533">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-534">在此元素的 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-534">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-535">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-535">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-536">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-536">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-537">获取一个值，该值指示键盘焦点是否位于元素或子元素内的任意位置。</span><span class="sxs-lookup"><span data-stu-id="f845e-537">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span></span></summary>
        <value><span data-ttu-id="f845e-538">如果键盘焦点在元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-538"><see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-539">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-539">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-540"><xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>除非派生类已重写以禁止显示事件，否则，对此属性的值所做的更改通常会引发事件 <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-540">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="f845e-541">不会直接设置此属性，但可以通过调用 <xref:System.Windows.ContentElement.Focus%2A> 或发出请求，将焦点设置到元素 <xref:System.Windows.ContentElement.MoveFocus%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-541">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="f845e-542">这两种方法调用可能会更改此属性值。</span><span class="sxs-lookup"><span data-stu-id="f845e-542">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-543">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-543">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-544">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-544">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="f845e-545">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-545">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-546">无</span><span class="sxs-lookup"><span data-stu-id="f845e-546">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-547">在此元素的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-547">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-548">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-548">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-549">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-549">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-550">获取一个值，该值指示此元素是否捕获了鼠标。</span><span class="sxs-lookup"><span data-stu-id="f845e-550">Gets a value that indicates whether the mouse is captured by this element.</span></span></summary>
        <value><span data-ttu-id="f845e-551">如果元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-551"><see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-552">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-552">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-553">鼠标捕获状态与进程内拖放操作相关。</span><span class="sxs-lookup"><span data-stu-id="f845e-553">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-554">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-554">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-555">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-555">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="f845e-556">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-556">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-557">无</span><span class="sxs-lookup"><span data-stu-id="f845e-557">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f845e-558">下面的示例根据鼠标是否已由元素捕获来打开或关闭鼠标捕获状态。</span><span class="sxs-lookup"><span data-stu-id="f845e-558">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-559">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-559">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-560">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-560">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-561">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-561">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-562">获取一个值，该值确定此元素或其元素树中的子元素是否有鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-562">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span></span></summary>
        <value><span data-ttu-id="f845e-563">如果此元素或包含的元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-563"><see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-564">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-564">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-565">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-565">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-566">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-566">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="f845e-567">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-567">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-568">无</span><span class="sxs-lookup"><span data-stu-id="f845e-568">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-569">在此元素的 <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> 值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-569">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-570">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-570">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-571">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-571">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-572">获取一个值，该值指示在考虑元素组合的情况下，鼠标指针的位置是否与命中测试结果相对应。</span><span class="sxs-lookup"><span data-stu-id="f845e-572">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="f845e-573">如果鼠标指针位于与命中测试相同的元素结果上，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-573"><see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-574">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-574">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-575">与不同的是 <xref:System.Windows.ContentElement.IsMouseOver%2A> ，仅 `true` 当鼠标指针位于文本元素上时，此属性才是用于命中测试。</span><span class="sxs-lookup"><span data-stu-id="f845e-575">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element - as it is for a hit test.</span></span> <span data-ttu-id="f845e-576">如果鼠标指针在子元素上，而不是作为元素的更深层模板和组合的一部分的元素，则此属性将为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-576">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="f845e-577">除非你知道控件是如何组合的 (例如，你在定义) 的控件的自定义控件模板中使用此属性，则此属性可能会返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="f845e-577">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="f845e-578">对于不是创作控件的大多数情况，请改用 <xref:System.Windows.ContentElement.IsMouseOver%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-578">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="f845e-579">如果此元素捕获鼠标并且此属性 `true` 在捕获时，则此属性将继续返回， `true` 直到鼠标捕获丢失并且指针不在其边界上。</span><span class="sxs-lookup"><span data-stu-id="f845e-579">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-580">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-580">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-581">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-581">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="f845e-582">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-582">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-583">无</span><span class="sxs-lookup"><span data-stu-id="f845e-583">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-584">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-584">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-585">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-585">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-586">标识 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-586">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-587">获取一个值，该值指示鼠标指针是否位于此元素（包括可视子元素或其控件组合）上。</span><span class="sxs-lookup"><span data-stu-id="f845e-587">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span></span></summary>
        <value><span data-ttu-id="f845e-588">如果鼠标指针位于该元素或其子元素上方，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-588"><see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-589">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-589">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-590">尽管不存在类似的 "IsMouseOverChanged" 事件，但有几个类似的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-590">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="f845e-591">例如，可以使用 <xref:System.Windows.ContentElement.MouseEnter> 、 <xref:System.Windows.ContentElement.MouseMove> 和 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-591">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="f845e-592">如果此元素捕获鼠标，则此属性将保留， `true` 直到鼠标捕获丢失，并且鼠标指针离开元素边界。</span><span class="sxs-lookup"><span data-stu-id="f845e-592">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-593">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-593">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-594">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-594">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="f845e-595">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-595">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-596">无</span><span class="sxs-lookup"><span data-stu-id="f845e-596">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f845e-597">下面的示例创建一个样式，该样式包含在报表中提供替换可视行为的属性 <xref:System.Windows.Documents.Hyperlink> setter <xref:System.Windows.ContentElement.IsMouseOver%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-597">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-598">标识 <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-598">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-599">获取一个值，该值指示是否将触笔捕获到此元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-599">Gets a value that indicates whether the stylus is captured to this element.</span></span></summary>
        <value><span data-ttu-id="f845e-600">如果元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-600"><see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-601">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-601">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-602">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-602">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-603">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-603">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-604">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-604">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-605">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-605">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="f845e-606">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-606">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-607">无</span><span class="sxs-lookup"><span data-stu-id="f845e-607">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-608">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-608">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-609">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-609">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-610">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-610">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-611">获取一个值，该值确定此元素（包括子元素和控件组合）是否具有触笔捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-611">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span></span></summary>
        <value><span data-ttu-id="f845e-612">如果在此元素中具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-612"><see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-613">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-613">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-614">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-614">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-615">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-615">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-616">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-616">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="f845e-617">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-617">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-618">无</span><span class="sxs-lookup"><span data-stu-id="f845e-618">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-619">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-619">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-620">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-620">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-621">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-621">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-622">获取一个值，该值指示在考虑元素组合的情况下，触笔的位置是否与命中测试结果相对应。</span><span class="sxs-lookup"><span data-stu-id="f845e-622">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="f845e-623">如果触笔与命中测试位于同一元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-623"><see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-624">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-624">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-625">与不同的 <xref:System.Windows.ContentElement.IsStylusOver%2A> 是，仅 `true` 当触笔位于元素上时，此属性才适用。</span><span class="sxs-lookup"><span data-stu-id="f845e-625">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="f845e-626">如果触笔位于子元素上或属于元素的更深层组合的元素，则此属性将为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-626">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="f845e-627">除非你知道控件是如何组合的 (例如，你在定义) 的控件的自定义控件模板中使用此属性，则此属性可能会返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="f845e-627">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="f845e-628">对于不是创作控件的大多数情况，请改用 <xref:System.Windows.ContentElement.IsStylusOver%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-628">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="f845e-629">如果此元素具有触笔捕获，而此属性 `true` 在捕获时，则此属性将保留， `true` 直到触笔捕获丢失并且触笔不在其边界上。</span><span class="sxs-lookup"><span data-stu-id="f845e-629">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="f845e-630">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-630">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-631">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-631">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-632">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-632">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-633">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-633">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="f845e-634">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-634">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-635">无</span><span class="sxs-lookup"><span data-stu-id="f845e-635">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-636">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 属性值更改时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-636">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-637">此成员是 CLR 事件，而不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-637">This member is a CLR event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-638">标识 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-638">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-639">获取一个值，该值指示触笔是否位于此元素（包括可视子元素）上。</span><span class="sxs-lookup"><span data-stu-id="f845e-639">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span></span></summary>
        <value><span data-ttu-id="f845e-640">如果触笔位于此元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-640"><see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f845e-641">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-641">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-642">如果此元素具有触笔捕获，则此属性将保留， `true` 直到失去触笔捕获并超出其边界。</span><span class="sxs-lookup"><span data-stu-id="f845e-642">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="f845e-643">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-644">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-644">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="f845e-645">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="f845e-645">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-646">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-646">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="f845e-647">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="f845e-647">Metadata properties set to `true`</span></span>|<span data-ttu-id="f845e-648">无</span><span class="sxs-lookup"><span data-stu-id="f845e-648">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-649">标识 <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-649">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-650">当焦点在该元素上时按下某个键后发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-650">Occurs when a key is pressed while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-651">键处理与其他平台功能（如命令和文本撰写）交互。</span><span class="sxs-lookup"><span data-stu-id="f845e-651">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f845e-652"><xref:System.Windows.ContentElement.KeyDown>事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="f845e-652">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f845e-653">这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-653">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="f845e-654">此事件将为 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> 此类创建附加事件的别名，以便 <xref:System.Windows.ContentElement.KeyDown> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-654">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-655">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.KeyDown> 附加到基础 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-655">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-656">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-656">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-657">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-657">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="f845e-658">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-658">Routing strategy</span></span>|<span data-ttu-id="f845e-659">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-659">Bubbling</span></span>|  
|<span data-ttu-id="f845e-660">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-660">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f845e-661">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewKeyDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-661">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="f845e-662">重写 <xref:System.Windows.ContentElement.OnKeyDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-662">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-663">标识 <see cref="E:System.Windows.ContentElement.KeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-663">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-664">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-664">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-665">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-665">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-666">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-666">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-667">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-667">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-668">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-668">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-669">当焦点在该元素上时松开某个键后发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-669">Occurs when a key is released while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-670">此事件将为 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> 此类创建附加事件的别名，以便  <xref:System.Windows.ContentElement.KeyUp> 在 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-670">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-671">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.KeyUp> 附加到基础 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-671">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-672">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-672">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-673">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-673">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="f845e-674">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-674">Routing strategy</span></span>|<span data-ttu-id="f845e-675">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-675">Bubbling</span></span>|  
|<span data-ttu-id="f845e-676">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-676">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f845e-677">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewKeyUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-677">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="f845e-678">重写 <xref:System.Windows.ContentElement.OnKeyUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-678">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-679">标识 <see cref="E:System.Windows.ContentElement.KeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-679">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-680">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-680">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-681">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-681">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-682">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-682">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-683">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-683">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-684">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-684">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-685">在此元素丢失逻辑焦点时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-685">Occurs when this element loses logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-686">如果有意通过某个方法调用强制失去了焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。</span><span class="sxs-lookup"><span data-stu-id="f845e-686">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="f845e-687">在此方案中，键盘焦点仍保留在何处，而 <xref:System.Windows.ContentElement.Focus%2A> 调用方法的元素仍获得逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="f845e-687">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="f845e-688">此事件的更精确解释是：当 <xref:System.Windows.ContentElement.IsFocused%2A> 路由中某个元素的属性的值从更改为时，将引发此事件 `true` `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-688">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="f845e-689">由于此事件使用冒泡路由，失去焦点的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-689">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-690">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定获得焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-690">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-691">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-691">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-692">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-692">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="f845e-693">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-693">Routing strategy</span></span>|<span data-ttu-id="f845e-694">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-694">Bubbling</span></span>|  
|<span data-ttu-id="f845e-695">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-695">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="f845e-696">没有相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-696">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-697">重写 <xref:System.Windows.ContentElement.OnLostFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-697">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-698">标识 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-698">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-699">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-699">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-700">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-700">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-701">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-701">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-702">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-702">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-703">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-703">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-704">在此元素不再聚焦于键盘时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-704">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-705">由于此事件使用冒泡路由，失去焦点的元素可能是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-705">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-706">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定失去焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-706">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f845e-707">此事件将为 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.LostKeyboardFocus> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-707">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-708">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.LostKeyboardFocus> 附加到基础 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-708">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-709">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-710">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-710">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="f845e-711">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-711">Routing strategy</span></span>|<span data-ttu-id="f845e-712">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-712">Bubbling</span></span>|  
|<span data-ttu-id="f845e-713">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-713">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f845e-714">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-714">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f845e-715">重写 <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-715">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-716">标识 <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-716">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-717">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-717">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-718">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-718">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-719">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-719">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-720">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-720">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-721">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-721">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-722">在此元素丢失鼠标捕获时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-722">Occurs when this element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-723">当某个元素捕获鼠标时，它将接收鼠标输入，即使指针在其边界之外也是如此。</span><span class="sxs-lookup"><span data-stu-id="f845e-723">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f845e-724">通常仅在拖放操作期间捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="f845e-724">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f845e-725">由于此事件使用冒泡路由，失去捕获的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-725">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-726">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定丢失捕获的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-726">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="f845e-727">此事件将为 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.LostMouseCapture> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-727">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-728">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.LostMouseCapture> 附加到基础 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-728">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-729">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-729">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-730">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-730">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="f845e-731">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-731">Routing strategy</span></span>|<span data-ttu-id="f845e-732">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-732">Bubbling</span></span>|  
|<span data-ttu-id="f845e-733">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-733">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-734">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-734">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-735">重写 <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-735">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-736">标识 <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-736">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-737">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-737">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-738">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-738">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-739">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-739">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-740">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-740">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-741">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-741">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-742">在此元素丢失触笔捕获时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-742">Occurs when this element loses stylus capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-743">当某个元素捕获触笔时，它将接收触笔输入，即使指针在其边界之外也是如此。</span><span class="sxs-lookup"><span data-stu-id="f845e-743">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="f845e-744">通常仅在拖放操作期间捕获触笔。</span><span class="sxs-lookup"><span data-stu-id="f845e-744">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="f845e-745">由于此事件使用冒泡路由，失去焦点的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-745">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-746">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定失去焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-746">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f845e-747">此事件将为 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.LostStylusCapture> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-747">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-748">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.LostStylusCapture> 附加到基础 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-748">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-749">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-749">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-750">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-750">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="f845e-751">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-751">Routing strategy</span></span>|<span data-ttu-id="f845e-752">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-752">Bubbling</span></span>|  
|<span data-ttu-id="f845e-753">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-753">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-754">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-754">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-755">重写 <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-755">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-756">标识 <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-756">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-757">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-757">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-758">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-758">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-759">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-759">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-760">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-760">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-761">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-761">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-762">在此元素失去触摸屏输入捕获时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-762">Occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-763">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-763">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-764">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-764">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="f845e-765">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-765">Routing strategy</span></span>|<span data-ttu-id="f845e-766">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-766">Bubbling</span></span>|  
|<span data-ttu-id="f845e-767">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-767">Delegate</span></span>|<span data-ttu-id="f845e-768"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-768"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-769">重写 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-769">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-770">标识 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-770">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-771">在指针位于此元素上并且按下任意鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-771">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-772">此事件将为 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-772">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-773">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseDown> 附加到基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-773">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-774"><xref:System.Windows.ContentElement.MouseDown>事件通常与或一起引发 <xref:System.Windows.ContentElement.MouseLeftButtonDown> <xref:System.Windows.ContentElement.MouseRightButtonDown> ，这对应于按下这两个标准鼠标按钮之一。</span><span class="sxs-lookup"><span data-stu-id="f845e-774">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f845e-775"><xref:System.Windows.ContentElement.MouseLeftButtonDown> 和 <xref:System.Windows.ContentElement.MouseRightButtonDown> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-775"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f845e-776">请参阅或的 "备注" <xref:System.Windows.ContentElement.MouseLeftButtonDown> <xref:System.Windows.ContentElement.MouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-776">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f845e-777">有些 <xref:System.Windows.ContentElement> 具有类似于控件的行为的派生类（例如， <xref:System.Windows.Documents.Hyperlink> ）可能具有鼠标按钮事件的固有类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-777">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="f845e-778">鼠标左键按下事件是在控件中具有类处理的最可能的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-778">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="f845e-779">类处理通常将基础 <xref:System.Windows.Input.Mouse> 类事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-779">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="f845e-780">将该事件标记为已处理后，通常不会引发附加到该元素的其他实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-780">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="f845e-781">通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-781">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="f845e-782">您可以 <xref:System.Windows.ContentElement.MouseDown> 通过使用以下任一解决方案解决在具有类处理的派生类上的 "上一重要" 和 "接收鼠标左键按下事件" 事件中所述的问题：</span><span class="sxs-lookup"><span data-stu-id="f845e-782">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="f845e-783">为事件附加处理程序 <xref:System.Windows.ContentElement.PreviewMouseDown> ，这些处理程序未标记为由控件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-783">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="f845e-784">请注意，因为这是预览事件，所以路由从根节点开始，向下隧道到控件。</span><span class="sxs-lookup"><span data-stu-id="f845e-784">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="f845e-785">通过调用 <xref:System.Windows.ContentElement.AddHandler%2A> 并选择允许处理程序侦听事件的签名选项（即使它们已在路由事件数据中标记为已处理），在控件过程上注册处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-785">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-786">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-786">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-787">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-787">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="f845e-788">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-788">Routing strategy</span></span>|<span data-ttu-id="f845e-789">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-789">Bubbling</span></span>|  
|<span data-ttu-id="f845e-790">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-790">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-791">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewMouseDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-791">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="f845e-792">重写 <xref:System.Windows.ContentElement.OnMouseDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-792">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-793">标识 <see cref="E:System.Windows.ContentElement.MouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-793">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-794">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-794">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-795">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-795">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-796">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-796">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-797">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-797">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-798">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-798">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-799">在鼠标指针进入此元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-799">Occurs when the mouse pointer enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-800"><xref:System.Windows.ContentElement.MouseEnter> 是使用直接事件处理路由策略的 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-800"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f845e-801">直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。</span><span class="sxs-lookup"><span data-stu-id="f845e-801">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f845e-802">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="f845e-802">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f845e-803">尽管 <xref:System.Windows.ContentElement.MouseEnter> 跟踪鼠标指针进入元素边界的时间，但此事件更确切地报告 <xref:System.Windows.ContentElement.IsMouseOver%2A> 此元素的属性值已从更改 `false` 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-803">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="f845e-804">此事件将为 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseEnter> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-804">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-805">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseEnter> 附加到基础 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-805">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-806">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-806">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-807">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-807">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="f845e-808">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-808">Routing strategy</span></span>|<span data-ttu-id="f845e-809">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-809">Direct</span></span>|  
|<span data-ttu-id="f845e-810">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-810">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-811">重写 <xref:System.Windows.ContentElement.OnMouseEnter%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-811">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-812">标识 <see cref="E:System.Windows.ContentElement.MouseEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-812">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-813">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-813">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-814">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-814">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-815">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-815">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-816">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-816">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-817">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-817">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-818">在鼠标指针离开此元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-818">Occurs when the mouse pointer leaves the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-819"><xref:System.Windows.ContentElement.MouseLeave> 是使用直接事件处理路由策略的 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-819"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f845e-820">直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。</span><span class="sxs-lookup"><span data-stu-id="f845e-820">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f845e-821">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="f845e-821">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f845e-822">尽管 <xref:System.Windows.ContentElement.MouseLeave> 跟踪鼠标离开元素的时间，但此事件更确切地报告 <xref:System.Windows.ContentElement.IsMouseOver%2A> `true` 此元素上的属性值已从更改为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-822">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="f845e-823">此事件将为 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseLeave> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-823">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-824">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseLeave> 附加到基础 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-824">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-825">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-825">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-826">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-826">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="f845e-827">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-827">Routing strategy</span></span>|<span data-ttu-id="f845e-828">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-828">Direct</span></span>|  
|<span data-ttu-id="f845e-829">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-829">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-830">重写 <xref:System.Windows.ContentElement.OnMouseLeave%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-830">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-831">标识 <see cref="E:System.Windows.ContentElement.MouseLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-831">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-832">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-832">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-833">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-833">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-834">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-834">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-835">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-835">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-836">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-836">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-837">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-837">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-838">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树执行冒泡路由，但实际上它是一个直接路由事件，每个事件都沿着元素树进行 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-838">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-839">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-839">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-840">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-840">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-841">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-841">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-842">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-842">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-843">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-843">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-844">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-844">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f845e-845">有些 <xref:System.Windows.ContentElement> 具有类似于控件的行为的派生类（例如， <xref:System.Windows.Documents.Hyperlink> ）可能具有鼠标按钮事件的固有类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-845">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="f845e-846">鼠标左键按下事件是在控件中具有类处理的最可能的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-846">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="f845e-847">类处理通常将基础 <xref:System.Windows.Input.Mouse> 类事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-847">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="f845e-848">将该事件标记为已处理后，通常不会引发附加到该元素的其他实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-848">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="f845e-849">通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-849">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="f845e-850">您可以 <xref:System.Windows.ContentElement.MouseLeftButtonDown> 通过使用以下任一解决方案解决在具有类处理的派生类上的 "上一重要" 和 "接收鼠标左键按下事件" 事件中所述的问题：</span><span class="sxs-lookup"><span data-stu-id="f845e-850">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="f845e-851">为事件附加处理程序 <xref:System.Windows.ContentElement.PreviewMouseDown> ，这些处理程序未标记为由控件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-851">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="f845e-852">请注意，因为这是预览事件，所以路由从根节点开始，向下隧道到控件。</span><span class="sxs-lookup"><span data-stu-id="f845e-852">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="f845e-853">通过调用 <xref:System.Windows.ContentElement.AddHandler%2A> 并选择允许处理程序侦听事件的签名选项（即使它们已在路由事件数据中标记为已处理），在控件过程上注册处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-853">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-854">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-854">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-855">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-855">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="f845e-856">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-856">Routing strategy</span></span>|<span data-ttu-id="f845e-857">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-857">Direct</span></span>|  
|<span data-ttu-id="f845e-858">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-858">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-859">重写 <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-859">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-860">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-860">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-861">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-861">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-862">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-862">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-863">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-863">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-864">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-864">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-865">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-865">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-866">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-866">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-867">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树执行冒泡路由，但实际上它是一个直接路由事件，每个事件都沿着元素树进行 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-867">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-868">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-868">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-869">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-869">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-870">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-870">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-871">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-871">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-872">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-872">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-873">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-873">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-874">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-874">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-875">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-875">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="f845e-876">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-876">Routing strategy</span></span>|<span data-ttu-id="f845e-877">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-877">Direct</span></span>|  
|<span data-ttu-id="f845e-878">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-878">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-879">重写 <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-879">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-880">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-880">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-881">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-881">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-882">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-882">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-883">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-883">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-884">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-884">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-885">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-885">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-886">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-886">Occurs when the mouse pointer moves while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-887">此事件将为 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-887">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-888">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseMove> 附加到基础 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-888">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-889">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-890">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-890">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="f845e-891">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-891">Routing strategy</span></span>|<span data-ttu-id="f845e-892">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-892">Bubbling</span></span>|  
|<span data-ttu-id="f845e-893">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-893">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-894">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewMouseMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-894">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="f845e-895">重写 <xref:System.Windows.ContentElement.OnMouseMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-895">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-896">标识 <see cref="E:System.Windows.ContentElement.MouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-896">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-897">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-897">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-898">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-898">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-899">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-899">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-900">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-900">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-901">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-901">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-902">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-902">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-903">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树执行冒泡路由，但实际上它是一个直接路由事件，每个事件都沿着元素树进行 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-903">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-904">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-904">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-905">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-905">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-906">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-906">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-907">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-907">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-908">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-908">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-909">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-909">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-910">鼠标右键事件通常在应用程序方案中具有本机处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-910">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="f845e-911">例如，按下鼠标右键可能会显示上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="f845e-911">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="f845e-912">请参阅 [ContextMenu 概述](/dotnet/framework/wpf/controls/contextmenu-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-912">See [ContextMenu Overview](/dotnet/framework/wpf/controls/contextmenu-overview).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-913">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-913">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-914">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-914">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="f845e-915">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-915">Routing strategy</span></span>|<span data-ttu-id="f845e-916">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-916">Direct</span></span>|  
|<span data-ttu-id="f845e-917">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-917">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-918">重写 <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-918">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-919">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-919">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-920">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-920">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-921">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-921">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-922">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-922">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-923">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-923">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-924">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-924">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-925">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-925">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-926">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树执行冒泡路由，但实际上它是一个直接路由事件，每个事件都沿着元素树进行 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-926">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-927">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-927">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-928">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-928">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-929">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-929">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-930">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-930">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-931">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-931">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-932">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-932">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-933">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-933">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-934">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-934">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="f845e-935">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-935">Routing strategy</span></span>|<span data-ttu-id="f845e-936">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-936">Direct</span></span>|  
|<span data-ttu-id="f845e-937">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-937">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-938">重写 <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-938">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-939">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-939">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-940">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-940">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-941">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-941">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-942">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-942">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-943">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-943">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-944">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-944">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-945">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-945">Occurs when any mouse button is released over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-946">此事件将为 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-946">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-947">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseUp> 附加到基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-947">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-948"><xref:System.Windows.ContentElement.MouseUp>事件通常与或一起引发 <xref:System.Windows.ContentElement.MouseLeftButtonUp> <xref:System.Windows.ContentElement.MouseRightButtonUp> ，这对应于两个标准鼠标按钮之一的版本。</span><span class="sxs-lookup"><span data-stu-id="f845e-948">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f845e-949"><xref:System.Windows.ContentElement.MouseLeftButtonUp> 和 <xref:System.Windows.ContentElement.MouseRightButtonUp> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-949"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f845e-950">请参阅或的 "备注" <xref:System.Windows.ContentElement.MouseLeftButtonUp> <xref:System.Windows.ContentElement.MouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-950">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-951">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-951">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-952">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-952">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="f845e-953">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-953">Routing strategy</span></span>|<span data-ttu-id="f845e-954">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-954">Bubbling</span></span>|  
|<span data-ttu-id="f845e-955">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-955">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-956">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewMouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-956">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="f845e-957">重写 <xref:System.Windows.ContentElement.OnMouseUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-957">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-958">标识 <see cref="E:System.Windows.ContentElement.MouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-958">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-959">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-959">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-960">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-960">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-961">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-961">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-962">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-962">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-963">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-963">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-964">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-964">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-965">焦点或鼠标捕获优先于鼠标指针所在的位置;因此，如果 <xref:System.Windows.ContentElement.MouseWheel> 从焦点或捕获的元素接收事件，则鼠标指针实际上可能位于另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="f845e-965">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="f845e-966">此事件将为 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.MouseWheel> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-966">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-967">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.MouseWheel> 附加到基础 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-967">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-968">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-968">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-969">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-969">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="f845e-970">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-970">Routing strategy</span></span>|<span data-ttu-id="f845e-971">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-971">Bubbling</span></span>|  
|<span data-ttu-id="f845e-972">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-972">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="f845e-973">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewMouseWheel> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-973">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="f845e-974">重写 <xref:System.Windows.ContentElement.OnMouseWheel%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-974">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-975">标识 <see cref="E:System.Windows.ContentElement.MouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-975">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-976">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-976">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-977">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-977">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-978">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-978">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-979">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-979">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-980">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-980">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="f845e-981">一个遍历请求，其中包含一个属性，该属性指示以现有 Tab 键顺序遍历的模式或视觉移动的方向。</span><span class="sxs-lookup"><span data-stu-id="f845e-981">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span></span></param>
        <summary><span data-ttu-id="f845e-982">尝试将焦点从此元素移到其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-982">Attempts to move focus from this element to another element.</span></span> <span data-ttu-id="f845e-983">移动焦点的方向由指导方向指定，该方向在此元素的可视父级的组织结构中解释。</span><span class="sxs-lookup"><span data-stu-id="f845e-983">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-984">如果执行了请求的遍历，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-984"><see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-985">请确保选中此方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="f845e-985">Make sure you check the return value of this method.</span></span> <span data-ttu-id="f845e-986">`false`如果遍历运行到由控件的组合定义的制表位，并且遍历请求未请求换行，则可能会返回的返回值。</span><span class="sxs-lookup"><span data-stu-id="f845e-986">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-987">针对 Windows Presentation Foundation (WPF) 基础结构返回特定于类的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-987">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the Windows Presentation Foundation (WPF) infrastructure.</span></span></summary>
        <returns><span data-ttu-id="f845e-988">特定于类型的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-988">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="f845e-989">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="f845e-989">Notes to inheritors</span></span>

<span data-ttu-id="f845e-990">此方法的实现通常是调用特定实现的构造函数 <xref:System.Windows.Automation.Peers.AutomationPeer> ，并将其作为返回值返回。</span><span class="sxs-lookup"><span data-stu-id="f845e-990">The implementation of this method is typically to call the constructor of a specific <xref:System.Windows.Automation.Peers.AutomationPeer> implementation, and return it as the return value.</span></span>  
  
 <span data-ttu-id="f845e-991">所有 <xref:System.Windows.ContentElement> 派生类都应该实现此方法，以便为 WPF 基础结构提供自己的特定 <xref:System.Windows.Automation.Peers.AutomationPeer> 实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-991">All <xref:System.Windows.ContentElement> derived classes should implement this method in order to provide their own specific <xref:System.Windows.Automation.Peers.AutomationPeer> implementations to the WPF infrastructure.</span></span> <span data-ttu-id="f845e-992">有关实现此模式的详细信息，请参阅 <xref:System.Windows.Automation.Peers.AutomationPeer> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-992">For details on implementing this pattern, see <xref:System.Windows.Automation.Peers.AutomationPeer>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-993">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-993">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-994">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-994">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-995">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-995">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-996">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-996">This method has no default implementation.</span></span> <span data-ttu-id="f845e-997">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-997">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-998">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-998">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-999">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-999">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1000">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1000">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1001">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1001">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1002">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1002">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1003">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1003">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1004">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1004">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1005">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1005">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1006">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1006">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1007">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1007">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1008">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1008">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1009">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1009">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1010">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1010">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1011">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1011">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1012">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1012">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1013">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1013">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1014">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1014">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1015">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1015">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1016">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1016">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1017">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1017">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1018">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1018">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1019">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1019">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1020">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1020">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1021">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1021">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1022">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1022">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1023">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1023">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1024">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1024">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1025">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1025">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1026">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1026">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1027">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1027">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1028">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1028">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1029">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1029">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1030">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1030">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1031">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1031">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1032">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1032">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1033">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1033">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1034">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1034">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1035">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1035">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1036">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1036">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1037">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1037">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1038">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1038">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1039">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1039">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1040">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1040">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1041">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1041">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1042">当某个未处理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1042">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1043">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1043">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1044">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1044">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1045">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1045">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1046">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1046">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1047">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1047">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1048">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1048">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1049">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1049">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1050">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1050">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1051">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1051">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1052">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1052">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1053">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1053">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="f845e-1054">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-1054">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="f845e-1055">使用所提供的事件数据引发 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1055">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1056">虽然虚拟，但这种方法具有引发事件的默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1056">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="f845e-1057">此 \* 方法实现的目的是引发事件，并在内部调用此同一方法实现，以在 <xref:System.Windows.ContentElement.IsFocused%2A> 属性值更改时引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1057">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="f845e-1058"><xref:System.Windows.ContentElement.OnGotFocus%2A>实现不同于一些其他 Windows Presentation Foundation (WPF) \* 实现，后者仅提供一种简便的方法来为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1058">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other Windows Presentation Foundation (WPF) On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="f845e-1059">对继承者的说明</span><span class="sxs-lookup"><span data-stu-id="f845e-1059">Notes to inheritors</span></span>

<span data-ttu-id="f845e-1060">除非您有意且异常地需要不引发焦点事件，否则请确保您的实现调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1060">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="f845e-1061">否则，在 <xref:System.Windows.ContentElement.GotFocus> 通常将焦点设置到此元素的典型用户操作期间，不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1061">Otherwise, the <xref:System.Windows.ContentElement.GotFocus> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="f845e-1062">如果不想让元素获得可设定焦点的元素，则可以通过将设置为来防止元素获得焦点 <xref:System.Windows.ContentElement.Focusable> `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1062">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <xref:System.Windows.ContentElement.Focusable> to `false`.</span></span>
<span data-ttu-id="f845e-1063">请注意，默认情况下 <xref:System.Windows.ContentElement.Focusable> 无法获得焦点，因此 <xref:System.Windows.ContentElement.Focusable> 可能不需要特意设置。</span><span class="sxs-lookup"><span data-stu-id="f845e-1063">Note that by default a <xref:System.Windows.ContentElement.Focusable> is not focusable, therefore setting <xref:System.Windows.ContentElement.Focusable> deliberately might not be necessary.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1064">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1064">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1065">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1065">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1066">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1066">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1067">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1067">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1068">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1068">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1069">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1069">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1070">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1070">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1071">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1071">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1072">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1072">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1073">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1073">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1074">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1074">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1075">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1075">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1076">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1076">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1077">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1077">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1078">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1078">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1079">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1079">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1080">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1080">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1081">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1081">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1082">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1082">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1083">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1083">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1084">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1084">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1085">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1085">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1086">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1086">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1087">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1087">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1088">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1088">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1089">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1089">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1090">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1090">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1091">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1091">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1092">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1092">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1093">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1093">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1094">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1094">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1095">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1095">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1096">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1096">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1097">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1097">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1098">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1098">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1099">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1099">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1100">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1100">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1101">为在此元素上捕获触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1101">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1102">此 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1102">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1103"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.GotTouchCapture> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1103">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="f845e-1104">请确保调用基类的 <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1104">Be sure to call the base class' <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1105">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1105">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1106">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1106">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1107">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1107">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1108">当依赖项属性的值更改时，将引发此虚方法 <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1108">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="f845e-1109">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1109">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1110">然后 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1110">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1111">请注意，该  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1111">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="f845e-1112">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1112">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1113">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1113">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1114">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1114">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1115">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1115">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1116">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1116">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1117">在此元素即将引发 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 事件前调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1117">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span></span> <span data-ttu-id="f845e-1118">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1118">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1119">当 <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1119">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1120">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1120">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1121">然后 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1121">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1122">请注意，该 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> 事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1122">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="f845e-1123">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1123">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1124">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1124">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1125">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1125">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1126">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1126">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1127">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1127">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1128">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1128">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1129">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1129">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1130">当 <xref:System.Windows.ContentElement.IsMouseCaptured%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1130">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1131">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1131">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1132">然后 <xref:System.Windows.ContentElement.IsMouseCapturedChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1132">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1133">请注意，该 <xref:System.Windows.ContentElement.IsMouseCapturedChanged> 事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1133">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="f845e-1134">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1134">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1135">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1135">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1136">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1136">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1137">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1137">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1138">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1138">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1139">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1139">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1140">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1140">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f845e-1141">当 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1141">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1142">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1142">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1143">然后 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1143">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1144">请注意，该事件不是路由事件;因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1144">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span></span>  
  
<span data-ttu-id="f845e-1145">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1145">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1146">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1146">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1147">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1147">You may call base either before or after your special handling, depending on your requirements.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1148">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1148">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1149">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1149">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1150">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1150">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1151">当 <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1151">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1152">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1152">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1153">然后 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1153">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1154">请注意，该 <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> 事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1154">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="f845e-1155">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1155">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1156">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1156">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1157">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1157">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1158">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1158">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1159">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1159">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1160">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1160">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1161">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1161">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1162">当 <xref:System.Windows.ContentElement.IsStylusCaptured%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1162">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1163">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1163">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1164">然后 <xref:System.Windows.ContentElement.IsStylusCapturedChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1164">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1165">请注意，该事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1165">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f845e-1166">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1166">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1167">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1167">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1168">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1168">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1169">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1169">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1170">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1170">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1171">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1171">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1172">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1172">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1173">当 <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1173">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1174">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1174">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1175">然后 <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1175">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1176">请注意，该事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1176">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f845e-1177">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1177">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1178">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1178">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1179">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1179">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1180">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1180">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1181">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1181">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1182">当针对此元素引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> 事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1182">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="f845e-1183">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1183">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1184">当 <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> 依赖项属性的值更改其值时，将引发此虚方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1184">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="f845e-1185">首先引发虚方法，并在必要时对事件数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-1185">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="f845e-1186">然后 <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> ，将用相同的事件数据实例引发该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1186">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="f845e-1187">请注意，该事件不是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1187">Notice that the event is not a routed event.</span></span> <span data-ttu-id="f845e-1188">因此，不能在类处理程序中将其标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1188">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="f845e-1189">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1189">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1190">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1190">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1191">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1191">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1192">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1192">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1193">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1193">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1194">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1194">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1195">击键由专用的输入管理器处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1195">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1196">依赖于击键的其他编程功能（例如，输入和命令绑定）可能会处理击键，然后将其作为一般击键公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1196">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="f845e-1197">如果这些输入系统功能将事件标记为已处理，则 <xref:System.Windows.ContentElement.OnKeyDown%2A> 不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1197">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1198">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1198">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1199">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1199">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1200">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1200">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1201">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1201">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1202">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1202">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1203">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1203">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1204">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1204">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1205">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1205">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1206">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1206">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1207">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1207">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1208">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1208">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1209">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1209">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1210">击键由专用的输入管理器处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1210">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1211">依赖于击键的其他编程功能（例如，输入和命令绑定）可能会处理击键，然后将其作为一般击键公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1211">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="f845e-1212">如果这些输入系统功能将事件标记为已处理，则 <xref:System.Windows.ContentElement.OnKeyUp%2A> 不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1212">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1213">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1213">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1214">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1214">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1215">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1215">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1216">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1216">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1217">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1217">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1218">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1218">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1219">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1219">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1220">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1220">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1221">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1221">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1222">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1222">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="f845e-1223">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.LostFocus" /> 事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-1223">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="f845e-1224">使用提供的事件数据引发 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1224">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1225">虽然虚拟，但这种方法具有引发事件的默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1225">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="f845e-1226">此 \* 方法实现的目的是引发事件，并在内部调用此同一方法实现，以在 <xref:System.Windows.ContentElement.IsFocused%2A> 属性值更改时引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1226">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="f845e-1227">此实现不同于一些其他 Windows Presentation Foundation (WPF) \* 实现，后者仅提供一种简便的方法来为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1227">This implementation differs from some other Windows Presentation Foundation (WPF) On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f845e-1228">除非您有意且异常地需要不引发焦点事件，否则请确保您的实现调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1228">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="f845e-1229">否则，在 <see cref="E:System.Windows.ContentElement.LostFocus" /> 通常将焦点设置到此元素的典型用户操作期间，不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1229">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="f845e-1230">如果不想让元素获得可设定焦点的元素，则可以通过将设置为来防止元素获得焦点 <see cref="P:System.Windows.ContentElement.Focusable" /> <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1230">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1231">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1231">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1232">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1232">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1233">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1233">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1234">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1234">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1235">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1235">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1236">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1236">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1237">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1237">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1238">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1238">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1239">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1239">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1240">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1240">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1241">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1241">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1242">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1242">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1243">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1243">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1244">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1244">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1245">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1245">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1246">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1246">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1247">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1247">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1248">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1248">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1249">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1249">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1250">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1250">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1251">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1251">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1252">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1252">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1253">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1253">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1254">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1254">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1255">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1255">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1256">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1256">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1257">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1257">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1258">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1258">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1259">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1259">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1260">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1260">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1261">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1261">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1262">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1262">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1263">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1263">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1264">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1264">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1265">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1265">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1266">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1266">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1267">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1267">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1268">为在此元素失去触摸屏输入捕获时发生的 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1268">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1269">此 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1269">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1270"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.LostTouchCapture> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1270">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="f845e-1271">请确保调用基类的 <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1271">Be sure to call the base class' <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1272">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1272">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1273">此事件数据报告有关按下鼠标按钮和已处理状态的详细信息。</span><span class="sxs-lookup"><span data-stu-id="f845e-1273">This event data reports details about the mouse button that was pressed and the handled state.</span></span></param>
        <summary><span data-ttu-id="f845e-1274">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1274">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1275">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1275">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1276">鼠标按钮操作也由专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1276">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1277">依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1277">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f845e-1278">如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件标记为已处理， <xref:System.Windows.ContentElement.OnMouseDown%2A> 则不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1278">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1279">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.ContentElement.MouseLeftButtonDown> 和 <xref:System.Windows.ContentElement.MouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1279">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f845e-1280">收到时，可能会在接收元素上引发这些事件中的任何一个 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1280">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f845e-1281">如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。</span><span class="sxs-lookup"><span data-stu-id="f845e-1281">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f845e-1282">如果在类处理中处理该事件，则不会调用 subevents 的实例处理程序，除非您显式使用 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with 以便 `handledEventsToo` `true` 附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1282">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f845e-1283">类处理程序也不会被调用，除非这些类处理程序已注册到 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名 `handledEventsToo` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1283">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f845e-1284">通过处理 <xref:System.Windows.ContentElement.OnMouseDown%2A> ，你可以保证类处理对所有可能的鼠标按钮按下操作都适用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1284">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="f845e-1285">此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1285">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f845e-1286">每个特定于按钮的直接事件还具有一个虚拟 On \* 方法; 请考虑是否可以更适当地重写这些按钮特定的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1286">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f845e-1287">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1287">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1288">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1288">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1289">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1289">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1290">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1290">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1291">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1291">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1292">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1292">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1293">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1293">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1294">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1294">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1295">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1295">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1296">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1296">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1297">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1297">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span></span> <span data-ttu-id="f845e-1298">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1298">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1299">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1299">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1300">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1300">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1301">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1301">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f845e-1302">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1302">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1303">在这种情况下，匹配事件是路由事件，其中包含直接路由策略。</span><span class="sxs-lookup"><span data-stu-id="f845e-1303">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="f845e-1304">将事件标记为已处理仍然有助于防止典型的实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1304">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1305">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1305">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1306">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1306">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span></span> <span data-ttu-id="f845e-1307">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1307">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1308">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1308">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1309">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1309">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1310">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1310">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f845e-1311">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1311">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1312">在这种情况下，匹配事件是路由事件，其中包含直接路由策略。</span><span class="sxs-lookup"><span data-stu-id="f845e-1312">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="f845e-1313">将事件标记为已处理仍然有助于防止典型的实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1313">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1314">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1314">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1315">事件数据报告称已按下鼠标左键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1315">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="f845e-1316">当此元素引发未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1316">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span></span> <span data-ttu-id="f845e-1317">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1317">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1318"><xref:System.Windows.ContentElement.MouseLeftButtonDown>事件看起来像是以冒泡路线旅行，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1318">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1319"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是进行冒泡路由的基础事件，每个 <xref:System.Windows.ContentElement> 事件路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.MouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1319"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="f845e-1320">虽然您可以将 <xref:System.Windows.ContentElement.MouseLeftButtonDown> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1320">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1321">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1321">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1322">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1322">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1323">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1323">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1324">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1324">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1325">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1325">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f845e-1326">或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1326">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f845e-1327">是否选择调用基实现取决于方案。</span><span class="sxs-lookup"><span data-stu-id="f845e-1327">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f845e-1328">如果无法调用 base，将禁用对也需要调用的上级类上的鼠标事件的默认输入处理 <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1328">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="f845e-1329">例如，你可以 <xref:System.Windows.Controls.Button> <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> 在派生类中派生，而不调用基实现; 但是，此重写将禁用 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1329">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1330">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1330">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1331">事件数据报告称已松开鼠标左键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1331">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="f845e-1332">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1332">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1333">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1333">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1334"><xref:System.Windows.ContentElement.MouseLeftButtonUp>事件看起来像是以冒泡路线旅行，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1334">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1335"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是进行冒泡路由的基础事件，每个 <xref:System.Windows.ContentElement> 事件路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.MouseLeftButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1335"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="f845e-1336">虽然您可以将 <xref:System.Windows.ContentElement.MouseLeftButtonUp> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1336">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1337">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1337">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1338">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1338">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1339">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1339">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1340">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1340">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1341">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1341">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1342">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1342">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1343">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1343">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1344">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1344">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1345">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1345">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1346">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1346">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1347">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1347">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1348">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1348">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1349">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1349">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1350">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1350">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1351">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1351">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1352">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1352">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1353">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1353">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1354">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1354">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1355">事件数据报告称已按下鼠标右键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1355">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="f845e-1356">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1356">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1357">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1357">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1358"><xref:System.Windows.ContentElement.MouseRightButtonDown>事件看起来像是以冒泡路线旅行，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1358">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1359"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是进行冒泡路由的基础事件，每个 <xref:System.Windows.ContentElement> 事件路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.MouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1359"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f845e-1360">虽然您可以将 <xref:System.Windows.ContentElement.MouseRightButtonDown> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1360">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1361">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1361">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1362">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1362">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1363">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1363">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1364">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1364">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1365">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1365">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f845e-1366">或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1366">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f845e-1367">是否选择调用基实现取决于方案。</span><span class="sxs-lookup"><span data-stu-id="f845e-1367">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f845e-1368">如果无法调用 base，将禁用对也需要调用的上级类上的鼠标事件的默认输入处理 <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1368">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="f845e-1369">例如，你可以 <xref:System.Windows.Controls.Control> <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> 在派生类中派生，而在不调用 base 的情况下进行重写; 但是，此替代禁用控件上的上下文菜单服务，这是 <xref:System.Windows.Controls.Control> 默认行为的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-1369">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1370">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1370">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1371">事件数据报告称已释放鼠标右键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1371">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="f845e-1372">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1372">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1373">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1373">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1374"><xref:System.Windows.ContentElement.MouseRightButtonUp>事件看起来像是以冒泡路线旅行，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1374">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1375"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是进行冒泡路由的基础事件，每个 <xref:System.Windows.ContentElement> 事件路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.MouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1375"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="f845e-1376">虽然您可以将 <xref:System.Windows.ContentElement.MouseRightButtonUp> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1376">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1377">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1377">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1378">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1378">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1379">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1379">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1380">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1380">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1381">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1381">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1382">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1382">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1383">事件数据将报告已松开了鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="f845e-1383">The event data reports that the mouse button was released.</span></span></param>
        <summary><span data-ttu-id="f845e-1384">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1384">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1385">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1385">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1386">鼠标按钮操作也由专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1386">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1387">依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1387">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f845e-1388">如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件标记为已处理， <xref:System.Windows.ContentElement.OnMouseUp%2A> 则不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1388">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1389">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.ContentElement.MouseLeftButtonUp> 和 <xref:System.Windows.ContentElement.MouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1389">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="f845e-1390">收到时，可能会在接收元素上引发这些事件中的任何一个 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1390">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f845e-1391">如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。</span><span class="sxs-lookup"><span data-stu-id="f845e-1391">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f845e-1392">如果在类处理中处理该事件，则不会调用 subevents 的实例处理程序，除非您显式使用 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with 以便 `handledEventsToo` `true` 附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1392">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f845e-1393">类处理程序也不会被调用，除非这些类处理程序已注册到 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名 `handledEventsToo` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1393">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f845e-1394">通过处理 <xref:System.Windows.ContentElement.OnMouseUp%2A> ，可以确保类处理对所有可能的鼠标按钮向上操作都进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1394">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="f845e-1395">此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1395">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f845e-1396">每个特定于按钮的直接事件还具有一个虚拟 On \* 方法; 请考虑是否可以更适当地重写这些按钮特定的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1396">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f845e-1397">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1397">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1398">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1398">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1399">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1399">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1400">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1400">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1401">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1401">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1402">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1402">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1403">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1403">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1404">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1404">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1405">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1405">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1406">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1406">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1407">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1407">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1408">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1408">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1409">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1409">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1410">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1410">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1411">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1411">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1412">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1412">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1413">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1413">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1414">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1414">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1415">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1415">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1416">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1416">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1417">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1417">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1418">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1418">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1419">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1419">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1420">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1420">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1421">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1421">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1422">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1422">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1423">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1423">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1424">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1424">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1425">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1425">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1426">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1426">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1427">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1427">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1428">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1428">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1429">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1429">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1430">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1430">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1431">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1431">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1432">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1432">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1433">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1433">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1434">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1434">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1435">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1435">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1436">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1436">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1437">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1437">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1438">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1438">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1439">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1439">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1440">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1440">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1441">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1441">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1442">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1442">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1443">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1443">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1444">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1444">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1445">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1445">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1446">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1446">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1447">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1447">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1448">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1448">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1449">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1449">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1450">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1450">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1451">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1451">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1452">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1452">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1453">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1453">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1454">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1454">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1455">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1455">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1456">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1456">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1457">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1457">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1458">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1458">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1459">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1459">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1460">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1460">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1461">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1461">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1462">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1462">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1463">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1463">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1464">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1464">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1465">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1465">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1466">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1466">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1467">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1467">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1468">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1468">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1469">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1469">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1470">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1470">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1471">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1471">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1472">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1472">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1473">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1473">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1474">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1474">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1475">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1475">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1476">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1476">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1477">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1477">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1478">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1478">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1479">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1479">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1480">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1480">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1481">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1481">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1482">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1482">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1483">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1483">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1484">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1484">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1485">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1485">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1486">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1486">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1487">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1487">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1488">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1488">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1489">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1489">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1490">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1490">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1491">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1491">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1492">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1492">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1493">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1493">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1494">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1494">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1495">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1495">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1496">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1496">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1497">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1497">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1498">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1498">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1499">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1499">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1500">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1500">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1501">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1501">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1502">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1502">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1503">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1503">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1504">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1504">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1505">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1505">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1506">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1506">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1507">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1507">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1508">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1508">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1509">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1509">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1510">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1510">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1511">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1511">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1512">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1512">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1513">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1513">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1514">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1514">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1515">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1515">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1516">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1516">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1517">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1517">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1518">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1518">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1519">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1519">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1520">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1520">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1521">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1521">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1522">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1522">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1523">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1523">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1524">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1524">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1525">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1525">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1526">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1526">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1527">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1527">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1528">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1528">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1529">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1529">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1530">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1530">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1531">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1531">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1532">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1532">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1533">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1533">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1534">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1534">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1535">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1535">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1536">事件数据报告称已按下一个或多个鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="f845e-1536">The event data reports that one or more mouse buttons were pressed.</span></span></param>
        <summary><span data-ttu-id="f845e-1537">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1537">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1538">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1538">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1539">鼠标按钮操作也由专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1539">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1540">依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1540">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f845e-1541">如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件标记为已处理， <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> 则不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1541">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1542">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 和 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1542">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="f845e-1543">收到时，可能会在接收元素上引发这些事件中的任何一个 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1543">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f845e-1544">如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。</span><span class="sxs-lookup"><span data-stu-id="f845e-1544">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f845e-1545">如果在类处理中处理该事件，则不会调用 subevents 的实例处理程序，除非您显式使用 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with 以便 `handledEventsToo` `true` 附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1545">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f845e-1546">类处理程序也不会被调用，除非这些类处理程序已注册到 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名 `handledEventsToo` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1546">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f845e-1547">通过处理 <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> ，你可以保证类处理对所有可能的鼠标按钮按下操作都适用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1547">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="f845e-1548">此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1548">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f845e-1549">每个特定于按钮的直接事件还具有一个虚拟 On \* 方法; 请考虑是否可以更适当地重写这些按钮特定的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1549">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f845e-1550">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1550">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1551">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1551">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1552">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1552">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1553">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1553">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1554">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1554">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1555">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1555">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1556">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1556">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1557">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1557">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1558">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1558">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1559">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1559">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1560">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1560">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1561">事件数据报告称已按下鼠标左键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1561">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="f845e-1562">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1562">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1563">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1563">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1564"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件看起来是传递隧道路由，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1564">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1565"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是隧道路由的基础事件，每个事件 <xref:System.Windows.ContentElement> 路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1565"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="f845e-1566">虽然您可以将 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1566">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1567">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1567">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1568">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1568">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1569">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1569">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1570">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1570">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1571">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1571">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f845e-1572">或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1572">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f845e-1573">是否选择调用基实现取决于方案。</span><span class="sxs-lookup"><span data-stu-id="f845e-1573">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f845e-1574">如果无法调用 base，将禁用对也需要调用的上级类上的鼠标事件的默认输入处理 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1574">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="f845e-1575">例如，你可以 <xref:System.Windows.Controls.Button> <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> 在派生类中派生，而不调用基实现; 但是，此重写将禁用 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1575">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1576">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1576">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1577">事件数据报告称已松开鼠标左键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1577">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="f845e-1578">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1578">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1579">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1579">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1580"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件看起来是传递隧道路由，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1580">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1581"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是隧道路由的基础事件，每个事件 <xref:System.Windows.ContentElement> 路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1581"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="f845e-1582">虽然您可以将 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1582">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1583">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1583">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1584">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1584">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1585">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1585">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1586">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1586">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1587">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1587">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1588">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1588">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1589">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1589">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1590">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1590">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1591">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1591">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1592">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1592">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1593">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1593">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1594">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1594">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1595">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1595">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1596">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1596">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1597">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1597">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1598">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1598">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1599">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1599">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1600">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1600">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1601">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1601">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1602">事件数据报告称已按下鼠标右键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1602">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="f845e-1603">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1603">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1604">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1604">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1605"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件看起来是传递隧道路由，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1605">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1606"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是隧道路由的基础事件，每个事件 <xref:System.Windows.ContentElement> 路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.MouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1606"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="f845e-1607">虽然您可以将 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1607">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1608">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1608">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1609">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1609">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1610">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1610">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1611">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1611">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1612">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1612">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="f845e-1613">或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1613">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="f845e-1614">是否选择调用基实现取决于方案。</span><span class="sxs-lookup"><span data-stu-id="f845e-1614">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="f845e-1615">如果无法调用 base，将禁用对也需要调用的上级类上的鼠标事件的默认输入处理 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1615">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="f845e-1616">例如，你可以 <xref:System.Windows.Controls.Control> <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> 在派生类中派生，而在不调用 base 的情况下进行重写; 但是，此替代禁用控件上的上下文菜单服务，这是 <xref:System.Windows.Controls.Control> 默认行为的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-1616">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1617">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1617">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1618">事件数据报告称已释放鼠标右键。</span><span class="sxs-lookup"><span data-stu-id="f845e-1618">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="f845e-1619">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1619">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1620">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1620">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1621"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件看起来是传递隧道路由，但实际以间接方式传播。</span><span class="sxs-lookup"><span data-stu-id="f845e-1621">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="f845e-1622"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是隧道路由的基础事件，每个事件 <xref:System.Windows.ContentElement> 路由沿事件路由都使用相同的处理来引发直接路由事件 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1622"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="f845e-1623">虽然您可以将 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> 事件标记为已处理，以便进行此元素，但已处理状态并不保持事件路由中的其他元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1623">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="f845e-1624">但是，你可能需要将事件标记为已处理，以防止常规实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1624">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="f845e-1625">中的常规鼠标事件处理的默认实现 <xref:System.Windows.ContentElement> 将侦听 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1625">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="f845e-1626">如果要重写此逻辑，必须创建派生类。</span><span class="sxs-lookup"><span data-stu-id="f845e-1626">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="f845e-1627">在派生类的静态构造函数中，为注册替代类处理程序 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1627">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f845e-1628">不能 <xref:System.Windows.ContentElement> 通过重写来更改的鼠标处理行为 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1628">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1629">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1629">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="f845e-1630">事件数据将报告已释放了一个或多个鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="f845e-1630">The event data reports that one or more mouse buttons were released.</span></span></param>
        <summary><span data-ttu-id="f845e-1631">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1631">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1632">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1632">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1633">鼠标按钮操作也由专用的输入管理器进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1633">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="f845e-1634">依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。</span><span class="sxs-lookup"><span data-stu-id="f845e-1634">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="f845e-1635">如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件标记为已处理， <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> 则不会调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1635">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="f845e-1636">如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 和 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1636">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="f845e-1637">收到时，可能会在接收元素上引发这些事件中的任何一个 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1637">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="f845e-1638">如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。</span><span class="sxs-lookup"><span data-stu-id="f845e-1638">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="f845e-1639">如果在类处理中处理该事件，则不会调用 subevents 的实例处理程序，除非您显式使用 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with 以便 `handledEventsToo` `true` 附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1639">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="f845e-1640">类处理程序也不会被调用，除非这些类处理程序已注册到 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名 `handledEventsToo` `true` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1640">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="f845e-1641">通过处理 <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> ，可以确保类处理对所有可能的鼠标按钮向上操作都进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1641">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="f845e-1642">此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1642">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="f845e-1643">每个特定于按钮的直接事件还具有一个虚拟 On \* 方法; 请考虑是否可以更适当地重写这些按钮特定的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1643">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="f845e-1644">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1644">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1645">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1645">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1646">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1646">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1647">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1647">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1648">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1648">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1649">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1649">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1650">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1650">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1651">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1651">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1652">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1652">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1653">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1653">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1654">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1654">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1655">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1655">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1656">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1656">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1657">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1657">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1658">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1658">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1659">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1659">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1660">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1660">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1661">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1661">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1662">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1662">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1663">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1663">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1664">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1664">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1665">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1665">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1666">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1666">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1667">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1667">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1668">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1668">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1669">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1669">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1670">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1670">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1671">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1671">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1672">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1672">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1673">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1673">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1674">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1674">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1675">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1675">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1676">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1676">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1677">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1677">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1678">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1678">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1679">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1679">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1680">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1680">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1681">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1681">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1682">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1682">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1683">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1683">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1684">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1684">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1685">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1685">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1686">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1686">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1687">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1687">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1688">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1688">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1689">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1689">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1690">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1690">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1691">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1691">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1692">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1692">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1693">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1693">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1694">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1694">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1695">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1695">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1696">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1696">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1697">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1697">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1698">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1698">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1699">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1699">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1700">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1700">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1701">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1701">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1702">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1702">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1703">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1703">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1704">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1704">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1705">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1705">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1706">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1706">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1707">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1707">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1708">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1708">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1709">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1709">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1710">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1710">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1711">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1711">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1712">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1712">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1713">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1713">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1714">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1714">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1715">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1715">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1716">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1716">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1717">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1717">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1718">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1718">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1719">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1719">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1720">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1720">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1721">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1721">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1722">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1722">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1723">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1723">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1724">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1724">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1725">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1725">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1726">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1726">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1727">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1727">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1728">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1728">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1729">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1729">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1730">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1730">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1731">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1731">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1732">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1732">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1733">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1733">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1734">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1734">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1735">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1735">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1736">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1736">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1737">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1737">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1738">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1738">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1739">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1739">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1740">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1740">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1741">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1741">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1742">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1742">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1743">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1743">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1744">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1744">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1745">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1745">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1746">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1746">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1747">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1747">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1748">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1748">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1749">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1749">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1750">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1750">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1751">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1751">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1752">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1752">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1753">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1753">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1754">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1754">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1755">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1755">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1756">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1756">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1757">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1757">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1758">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1758">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1759">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1759">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1760">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1760">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1761">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1761">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1762">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1762">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1763">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1763">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1764">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1764">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1765">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1765">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1766">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1766">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1767">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1767">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1768">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1768">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1769">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1769">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1770">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1770">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1771">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1771">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1772">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1772">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1773">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1773">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1774">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1774">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1775">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1775">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1776">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1776">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1777">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1777">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1778">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1778">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1779">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1779">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1780">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1780">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1781">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1781">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1782">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1782">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1783">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1783">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1784">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1784">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1785">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1785">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1786">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1786">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1787">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1787">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1788">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1788">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1789">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1789">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1790">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1790">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1791">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1791">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1792">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1792">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1793">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1793">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1794">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1794">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1795">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1795">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1796">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1796">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1797">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1797">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1798">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1798">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1799">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1799">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1800">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1800">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1801">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1801">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1802">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1802">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1803">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1803">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1804">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1804">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1805">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1805">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1806">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1806">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1807">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1807">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="f845e-1808">专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-1808">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1809">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1809">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1810">为在触摸屏输入按下此元素时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1810">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1811">此 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1811">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1812"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.PreviewTouchDown> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1812">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="f845e-1813">请确保调用基类的 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1813">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1814">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1814">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1815">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1815">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1816">此 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1816">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1817"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.PreviewTouchMove> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1817">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="f845e-1818">请确保调用基类的 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1818">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1819">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1819">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1820">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1820">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1821">此 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1821">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1822"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.PreviewTouchUp> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1822">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="f845e-1823">请确保调用基类的 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1823">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1824">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1824">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1825">当某个未处理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1825">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1826">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1826">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1827">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1827">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1828">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1828">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1829">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1829">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1830">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1830">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1831">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1831">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1832">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1832">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1833">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1833">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1834">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1834">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1835">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1835">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1836">包含事件数据的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1836">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1837">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1837">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1838">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1838">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1839">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1839">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1840">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1840">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1841">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1841">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1842">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1842">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1843">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1843">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1844">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1844">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1845">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1845">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1846">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1846">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1847">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1847">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1848">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1848">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1849">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1849">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1850">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1850">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1851">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1851">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1852">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1852">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1853">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1853">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1854">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1854">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1855">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1855">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1856">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1856">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1857">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1857">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1858">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1858">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1859">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1859">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1860">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1860">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1861">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1861">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1862">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1862">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1863">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1863">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1864">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1864">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1865">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1865">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1866">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1866">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1867">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1867">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1868">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1868">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1869">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1869">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1870">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1870">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1871">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1871">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1872">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1872">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1873">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1873">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1874">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1874">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1875">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1875">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1876">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1876">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1877">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1877">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1878">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1878">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1879">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1879">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1880">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1880">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1881">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1881">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1882">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1882">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1883">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1883">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1884">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1884">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1885">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1885">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span></span> <span data-ttu-id="f845e-1886">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1886">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1887">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1887">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1888">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1888">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1889">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1889">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f845e-1890">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1890">The purpose of this method is similar to common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1891">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1891">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1892">将事件标记为已处理仍然有助于防止典型的实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1892">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1893">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1893">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1894">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1894">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1895">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1895">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1896">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1896">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1897">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1897">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1898">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1898">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1899">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1899">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1900">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1900">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1901">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1901">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1902">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1902">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1903">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1903">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1904">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1904">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1905">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1905">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1906">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1906">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1907">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1907">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1908">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1908">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1909">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1909">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1910">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1910">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1911">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1911">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1912">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1912">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1913">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1913">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1914">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1914">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1915">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1915">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1916">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1916">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1917">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1917">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1918">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1918">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span></span> <span data-ttu-id="f845e-1919">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1919">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1920">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1920">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1921">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1921">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="f845e-1922">您可以根据自己的要求，在特殊处理之前或之后调用 base。</span><span class="sxs-lookup"><span data-stu-id="f845e-1922">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="f845e-1923">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1923">The purpose of this method is similar to common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1924">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1924">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1925">将事件标记为已处理仍然有助于防止典型的实例处理程序 (未指定调用) 的实例处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-1925">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1926">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1926">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1927">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1927">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1928">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1928">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1929">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1929">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1930">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1930">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1931">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1931">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1932">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1932">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1933">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1933">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1934">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1934">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1935">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1935">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1936">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1936">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1937">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1937">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1938">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1938">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1939">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1939">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1940">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1940">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1941">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1941">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1942">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1942">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1943">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1943">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1944">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1944">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1945">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1945">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1946">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1946">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1947">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1947">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1948">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1948">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1949">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1949">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1950">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1950">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1951">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1951">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1952">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1952">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1953">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1953">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1954">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1954">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1955">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1955">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1956">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1956">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1957">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1957">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1958">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1958">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1959">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1959">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1960">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1960">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1961">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1961">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1962">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1962">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1963">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1963">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1964">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1964">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1965">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1965">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1966">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1966">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1967">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1967">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1968">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1968">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1969">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1969">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1970">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1970">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1971">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1971">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1972">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1972">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1973">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1973">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1974">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1974">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1975">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span><span class="sxs-lookup"><span data-stu-id="f845e-1975">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="f845e-1976">实现此方法可为此事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1976">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1977">此方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1977">This method has no default implementation.</span></span> <span data-ttu-id="f845e-1978">因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1978">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="f845e-1979">此方法的用途类似于公共语言运行时 (CLR) 事件模式 \* ：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1979">The purpose of this method is similar to the common language runtime (CLR) event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="f845e-1980">在这种情况下，匹配事件是路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1980">In this case the matching event is a routed event.</span></span> <span data-ttu-id="f845e-1981">\*对于路由事件，On 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-1981">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="f845e-1982">因此，您的实现需要检查事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-1982">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="f845e-1983">大多数情况下，它不应尝试 reraise 该事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1983">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="f845e-1984">通过重写此方法或使用注册类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%2A> ， <xref:System.Windows.ContentElement> 可以在事件路由中收到事件时调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-1984">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="f845e-1985">适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。</span><span class="sxs-lookup"><span data-stu-id="f845e-1985">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1986">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1986">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1987">为在此元素内按下触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1987">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1988">此 <xref:System.Windows.ContentElement.OnTouchDown%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1988">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1989"><xref:System.Windows.ContentElement.OnTouchDown%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.TouchDown> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1989">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="f845e-1990">请确保调用基类的 <xref:System.Windows.ContentElement.OnTouchDown%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1990">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1991">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1991">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1992">为在触摸屏输入从此元素边界外部移动到其内部时发生的 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1992">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1993">此 <xref:System.Windows.ContentElement.OnTouchEnter%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1993">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1994"><xref:System.Windows.ContentElement.OnTouchEnter%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.TouchEnter> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1994">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="f845e-1995">请确保调用基类的 <xref:System.Windows.ContentElement.OnTouchEnter%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1995">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-1996">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-1996">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-1997">为在触摸屏输入从此元素边界内部移动到其外部时发生的 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-1997">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-1998">此 <xref:System.Windows.ContentElement.OnTouchLeave%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-1998">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-1999"><xref:System.Windows.ContentElement.OnTouchLeave%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.TouchLeave> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-1999">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="f845e-2000">请确保调用基类的 <xref:System.Windows.ContentElement.OnTouchLeave%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2000">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-2001">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2001">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-2002">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2002">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2003">此 <xref:System.Windows.ContentElement.OnTouchMove%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-2003">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-2004"><xref:System.Windows.ContentElement.OnTouchMove%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.TouchMove> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2004">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="f845e-2005">请确保调用基类的 <xref:System.Windows.ContentElement.OnTouchMove%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2005">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-2006">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2006">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="f845e-2007">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件提供类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2007">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2008">此 <xref:System.Windows.ContentElement.OnTouchUp%2A> 方法没有默认实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-2008">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="f845e-2009"><xref:System.Windows.ContentElement.OnTouchUp%2A>在派生类中重写以处理 <xref:System.Windows.ContentElement.TouchUp> 事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2009">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="f845e-2010">请确保调用基类的 <xref:System.Windows.ContentElement.OnTouchUp%2A> 方法，以便基类接收事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2010">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="f845e-2011">请求的焦点遍历的方向。</span><span class="sxs-lookup"><span data-stu-id="f845e-2011">The direction of the requested focus traversal.</span></span></param>
        <summary><span data-ttu-id="f845e-2012">当在派生类中重写时，返回将按指定焦点遍历方向接收焦点的元素，而不用实际将焦点移至该元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2012">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span></span></summary>
        <returns><span data-ttu-id="f845e-2013">如果实际调用了 <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，则为接收焦点的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2013">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2014">此方法在此类中的默认实现是不完整的，且始终返回 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2014">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2015">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2015">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2016">此事件将为 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewDragEnter> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2016">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2017">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewDragEnter> 附加到基础 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2017">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2018">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2018">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2019">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2019">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="f845e-2020">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2020">Routing strategy</span></span>|<span data-ttu-id="f845e-2021">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2021">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2022">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2022">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-2023">对应的冒泡事件为 <xref:System.Windows.ContentElement.DragEnter> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2023">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="f845e-2024">重写 <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2024">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2025">标识 <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2025">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2026">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2026">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2027">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2027">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2028">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2028">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2029">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2029">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2030">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2030">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2031">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2031">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2032">此事件将为 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewDragLeave> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2032">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2033">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewDragLeave> 附加到基础 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2033">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2034">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2034">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2035">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2035">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="f845e-2036">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2036">Routing strategy</span></span>|<span data-ttu-id="f845e-2037">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2037">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2038">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2038">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-2039">对应的冒泡事件为 <xref:System.Windows.ContentElement.DragLeave> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2039">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="f845e-2040">重写 <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2040">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2041">标识 <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2041">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2042">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2042">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2043">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2043">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2044">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2044">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2045">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2045">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2046">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2046">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2047">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2047">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2048">此事件将为 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewDragOver> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2048">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2049">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewDragOver> 附加到基础 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2049">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2050">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2050">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2051">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2051">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="f845e-2052">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2052">Routing strategy</span></span>|<span data-ttu-id="f845e-2053">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2053">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2054">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2054">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-2055">对应的冒泡事件为 <xref:System.Windows.ContentElement.DragOver> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2055">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="f845e-2056">重写 <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2056">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2057">标识 <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2057">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2058">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2058">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2059">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2059">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2060">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2060">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2061">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2061">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2062">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2062">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2063">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2063">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2064">此事件将为 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewDrop> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2064">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2065">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewDrop> 附加到基础 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2065">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2066">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2066">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2067">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2067">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="f845e-2068">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2068">Routing strategy</span></span>|<span data-ttu-id="f845e-2069">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2069">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2070">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2070">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="f845e-2071">对应的冒泡事件为 <xref:System.Windows.ContentElement.Drop> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2071">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="f845e-2072">重写 <xref:System.Windows.ContentElement.OnPreviewDrop%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2072">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2073">标识 <see cref="E:System.Windows.ContentElement.PreviewDrop" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2073">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2074">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2074">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2075">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2075">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2076">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2076">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2077">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2077">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2078">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2078">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2079">在开始拖放操作时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2079">Occurs when a drag-and-drop operation is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2080"><xref:System.Windows.ContentElement.PreviewGiveFeedback>事件使拖动事件的源可以修改鼠标指针的外观，以便在拖放操作过程中为用户提供视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="f845e-2080">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="f845e-2081">此事件将为 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewGiveFeedback> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2081">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2082">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewGiveFeedback> 附加到基础 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2082">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2083">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2083">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2084">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2084">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="f845e-2085">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2085">Routing strategy</span></span>|<span data-ttu-id="f845e-2086">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2086">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2087">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2087">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="f845e-2088">对应的冒泡事件为 <xref:System.Windows.ContentElement.GiveFeedback> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2088">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="f845e-2089">重写 <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2089">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2090">标识 <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2090">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2091">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2091">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2092">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2092">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2093">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2093">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2094">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2094">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2095">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2095">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2096">在此元素聚焦于键盘时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2096">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2097">由于此事件使用隧道路由，因此具有焦点的元素可以是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2097">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-2098">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定具有焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2098">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="f845e-2099">此事件将为 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2099">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2100">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> 附加到基础 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2100">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2101">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2101">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2102">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2102">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="f845e-2103">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2103">Routing strategy</span></span>|<span data-ttu-id="f845e-2104">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2104">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2105">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2105">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f845e-2106">对应的冒泡事件为 <xref:System.Windows.ContentElement.GotKeyboardFocus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2106">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f845e-2107">重写 <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2107">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2108">标识 <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2108">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2109">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2109">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2110">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2110">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2111">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2111">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2112">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2112">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2113">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2113">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2114">在此元素聚焦于键盘并且按下某个键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2114">Occurs when a key is pressed while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2115">键处理与其他平台功能（如命令和文本撰写）交互。</span><span class="sxs-lookup"><span data-stu-id="f845e-2115">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f845e-2116"><xref:System.Windows.ContentElement.KeyDown>事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="f845e-2116">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f845e-2117">这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2117">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="f845e-2118">此事件将为 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewKeyDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2118">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2119">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewKeyDown> 附加到基础 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2119">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2120">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2120">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2121">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2121">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="f845e-2122">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2122">Routing strategy</span></span>|<span data-ttu-id="f845e-2123">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2123">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2124">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2124">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f845e-2125">对应的冒泡事件为 <xref:System.Windows.ContentElement.KeyDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2125">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2126">重写 <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2126">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2127">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2127">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2128">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2128">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2129">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2129">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2130">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2130">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2131">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2131">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2132">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2132">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2133">在此元素聚焦于键盘并且松开某个键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2133">Occurs when a key is released while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2134">键处理与其他平台功能（如命令和文本撰写）交互。</span><span class="sxs-lookup"><span data-stu-id="f845e-2134">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="f845e-2135"><xref:System.Windows.ContentElement.KeyUp>事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="f845e-2135">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="f845e-2136">这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2136">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="f845e-2137">有关详细信息，请查看各个控件的文档。</span><span class="sxs-lookup"><span data-stu-id="f845e-2137">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="f845e-2138">此事件将为 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewKeyUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2138">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2139">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewKeyUp> 附加到基础 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2139">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2140">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2140">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2141">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2141">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="f845e-2142">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2142">Routing strategy</span></span>|<span data-ttu-id="f845e-2143">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2143">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2144">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2144">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="f845e-2145">对应的冒泡事件为 <xref:System.Windows.ContentElement.KeyUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2145">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2146">重写 <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2146">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2147">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2147">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2148">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2148">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2149">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2149">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2150">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2150">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2151">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2151">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2152">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2152">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2153">在此元素不再聚焦于键盘时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2153">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2154">由于此事件使用隧道路由，失去焦点的元素可能是子元素，而不是实际附加事件处理程序的元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2154">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="f845e-2155">检查 <xref:System.Windows.RoutedEventArgs.Source%2A> 事件数据中的，以确定失去焦点的实际元素。</span><span class="sxs-lookup"><span data-stu-id="f845e-2155">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="f845e-2156">此事件将为 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2156">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2157">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> 附加到基础 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2157">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2158">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2158">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2159">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2159">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="f845e-2160">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2160">Routing strategy</span></span>|<span data-ttu-id="f845e-2161">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2161">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2162">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2162">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="f845e-2163">对应的冒泡事件为 <xref:System.Windows.ContentElement.LostKeyboardFocus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2163">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="f845e-2164">重写 <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2164">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2165">标识 <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2165">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2166">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2166">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2167">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2167">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2168">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2168">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2169">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2169">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2170">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2170">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2171">在指针位于此元素上并且按下任意鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2171">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2172">此事件将为 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewMouseDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2172">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2173">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewMouseDown> 附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2173">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2174"><xref:System.Windows.ContentElement.PreviewMouseDown>事件通常与或一起引发 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> ，这对应于按下这两个标准鼠标按钮之一。</span><span class="sxs-lookup"><span data-stu-id="f845e-2174">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f845e-2175"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 和 <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2175"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f845e-2176">请参阅或的 "备注" <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2176">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2177">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2177">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2178">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2178">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="f845e-2179">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2179">Routing strategy</span></span>|<span data-ttu-id="f845e-2180">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2180">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2181">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2181">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2182">对应的冒泡事件为 <xref:System.Windows.ContentElement.MouseDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2182">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2183">重写 <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2183">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2184">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2184">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2185">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2185">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2186">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2186">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2187">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2187">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2188">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2188">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2189">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2189">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2190">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2190">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2191">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个事件都由元素树逐一引发和 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2191">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-2192">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2192">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-2193">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2193">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-2194">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2194">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-2195">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2195">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-2196">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-2196">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-2197">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2197">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2198">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2198">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2199">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2199">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="f845e-2200">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2200">Routing strategy</span></span>|<span data-ttu-id="f845e-2201">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2201">Direct</span></span>|  
|<span data-ttu-id="f845e-2202">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2202">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2203">重写 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2203">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2204">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2204">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2205">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2205">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2206">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2206">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2207">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2207">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2208">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2208">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2209">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2209">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2210">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2210">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2211">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个事件都由元素树逐一引发和 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2211">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-2212">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2212">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-2213">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2213">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-2214">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2214">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-2215">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2215">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-2216">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-2216">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-2217">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2217">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2218">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2218">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2219">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2219">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="f845e-2220">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2220">Routing strategy</span></span>|<span data-ttu-id="f845e-2221">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2221">Direct</span></span>|  
|<span data-ttu-id="f845e-2222">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2222">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2223">重写 <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2223">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2224">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2224">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2225">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2225">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2226">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2226">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2227">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2227">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2228">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2228">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2229">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2229">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2230">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2230">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2231">当鼠标指针第一次进入元素边界时，以及当鼠标指针移动到元素边界内时，将发生此事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2231">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="f845e-2232">此事件将为 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewMouseMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2232">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2233">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewMouseMove> 附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2233">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2234">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2234">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2235">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2235">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="f845e-2236">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2236">Routing strategy</span></span>|<span data-ttu-id="f845e-2237">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2237">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2238">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2238">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="f845e-2239">对应的冒泡事件为 <xref:System.Windows.ContentElement.MouseMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2239">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2240">重写 <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2240">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2241">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2241">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2242">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2242">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2243">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2243">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2244">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2244">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2245">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2245">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2246">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2246">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2247">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2247">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2248">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个事件都由元素树逐一引发和 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2248">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-2249">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2249">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-2250">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2250">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-2251">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2251">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-2252">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2252">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-2253">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-2253">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-2254">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2254">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2255">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2255">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2256">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2256">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="f845e-2257">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2257">Routing strategy</span></span>|<span data-ttu-id="f845e-2258">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2258">Direct</span></span>|  
|<span data-ttu-id="f845e-2259">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2259">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2260">重写 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2260">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2261">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2261">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2262">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2262">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2263">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2263">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2264">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2264">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2265">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2265">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2266">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2266">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2267">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2267">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2268">尽管此 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个事件都由元素树逐一引发和 reraised <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2268">Although this [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="f845e-2269">此事件是多个相关事件之一，用于报告基础事件的鼠标按钮细节 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> ，该事件是由事件路由中的每个元素处理的附加事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2269">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="f845e-2270">此事件的参数公开基础事件的参数 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2270">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f845e-2271">如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用来添加鼠标按钮特定事件的处理程序 <xref:System.Windows.ContentElement.AddHandler%2A> ，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2271">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="f845e-2272">从概念上讲，请将此事件的 (和) 上的其他鼠标按钮事件 <xref:System.Windows.ContentElement> 为鼠标 "service" (，并使用类) 提供的服务定义 <xref:System.Windows.Input.Mouse> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2272">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="f845e-2273">事件在事件数据中添加了不需要检查鼠标按钮状态 (的原始鼠标事件) 的便利。</span><span class="sxs-lookup"><span data-stu-id="f845e-2273">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="f845e-2274">对于更高级的方案，如检查非标准按钮的状态，可能需要在 <xref:System.Windows.Input.Mouse> 类而不是上使用 api <xref:System.Windows.ContentElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2274">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the APIs on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2275">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2275">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2276">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2276">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="f845e-2277">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2277">Routing strategy</span></span>|<span data-ttu-id="f845e-2278">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2278">Direct</span></span>|  
|<span data-ttu-id="f845e-2279">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2279">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2280">重写 <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2280">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2281">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2281">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2282">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2282">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2283">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2283">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2284">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2284">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2285">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2285">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2286">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2286">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2287">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2287">Occurs when any mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2288">此事件将为 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewMouseUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2288">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2289">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewMouseUp> 附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2289">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2290"><xref:System.Windows.ContentElement.PreviewMouseUp>事件通常与或一起引发 <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> ，这对应于按下这两个标准鼠标按钮之一。</span><span class="sxs-lookup"><span data-stu-id="f845e-2290">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="f845e-2291"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 和 <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2291"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="f845e-2292">请参阅或的 "备注" <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2292">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2293">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2293">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2294">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2294">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="f845e-2295">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2295">Routing strategy</span></span>|<span data-ttu-id="f845e-2296">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2296">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2297">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2297">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2298">对应的冒泡事件为 <xref:System.Windows.ContentElement.MouseUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2298">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2299">重写 <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2299">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2300">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2300">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2301">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2301">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2302">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2302">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2303">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2303">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2304">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2304">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2305">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2305">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2306">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2306">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2307">焦点或鼠标捕获优先于鼠标指针所在的位置;因此，如果从焦点或捕获的元素接收此事件，则鼠标指针实际上可能位于另一个元素上。</span><span class="sxs-lookup"><span data-stu-id="f845e-2307">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="f845e-2308">此事件将为 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewMouseMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2308">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2309">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewMouseMove> 附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2309">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2310">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2310">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2311">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2311">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="f845e-2312">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2312">Routing strategy</span></span>|<span data-ttu-id="f845e-2313">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2313">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2314">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2314">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="f845e-2315">对应的冒泡事件为 <xref:System.Windows.ContentElement.MouseWheel> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2315">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="f845e-2316">重写 <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2316">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2317">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2317">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2318">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2318">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2319">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2319">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2320">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2320">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2321">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2321">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2322">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2322">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2323">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2323">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2324">此 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> 事件允许拖动源声明是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-2324">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="f845e-2325">此事件将为 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2325">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2326">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> 附加到基础 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2326">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2327">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2327">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2328">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2328">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="f845e-2329">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2329">Routing strategy</span></span>|<span data-ttu-id="f845e-2330">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2330">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2331">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2331">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="f845e-2332">对应的冒泡事件为 <xref:System.Windows.ContentElement.QueryContinueDrag> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2332">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="f845e-2333">重写 <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2333">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2334">标识 <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2334">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2335">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2335">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2336">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2336">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2337">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2337">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2338">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2338">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2339">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2339">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2340">在指针位于此元素上并且按下触笔按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2340">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2341">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusButtonDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2341">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2342">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusButtonDown> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2342">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2343">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2343">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2344">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2344">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2345">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2345">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2346">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2346">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="f845e-2347">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2347">Routing strategy</span></span>|<span data-ttu-id="f845e-2348">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2348">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2349">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2349">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2350">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2350">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2351">重写 <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2351">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2352">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2352">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2353">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2353">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2354">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2354">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2355">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2355">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2356">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2356">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2357">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2357">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2358">在指针位于此元素上并且松开触笔按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2358">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2359">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusButtonUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2359">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2360">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusButtonUp> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2360">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2361">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2361">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2362">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2362">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2363">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2363">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2364">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2364">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="f845e-2365">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2365">Routing strategy</span></span>|<span data-ttu-id="f845e-2366">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2366">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2367">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2367">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2368">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2368">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2369">重写 <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2369">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2370">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2370">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2371">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2371">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2372">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2372">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2373">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2373">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2374">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2374">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2375">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2375">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2376">当触笔位于元素上且触及数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2376">Occurs when the stylus touches the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2377">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2377">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2378">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusDown> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2378">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2379">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2379">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2380">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2380">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2381">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2381">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2382">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2382">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="f845e-2383">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2383">Routing strategy</span></span>|<span data-ttu-id="f845e-2384">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2384">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2385">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2385">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="f845e-2386">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2386">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2387">重写 <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2387">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2388">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2388">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2389">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2389">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2390">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2390">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2391">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2391">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2392">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2392">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2393">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2393">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2394">在触笔掠过元素但并未实际接触数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2394">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2395">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusInAirMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2395">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2396">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusInAirMove> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2396">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2397">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2397">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2398">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2398">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2399">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2400">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2400">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="f845e-2401">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2401">Routing strategy</span></span>|<span data-ttu-id="f845e-2402">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2402">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2403">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2403">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2404">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusInAirMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2404">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2405">重写 <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2405">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2406">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2406">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2407">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2408">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2409">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2410">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2411">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2412">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2412">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2413">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusInRange> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2413">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2414">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusInRange> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2414">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2415">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2415">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2416">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2416">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2417">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2418">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2418">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="f845e-2419">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2419">Routing strategy</span></span>|<span data-ttu-id="f845e-2420">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2420">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2421">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2421">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2422">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusInRange> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2422">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="f845e-2423">重写 <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2423">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2424">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2424">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2425">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2425">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2426">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2426">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2427">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2427">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2428">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2428">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2429">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2429">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2430">在触笔位于元素上并且移动触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2430">Occurs when the stylus moves while over the element.</span></span> <span data-ttu-id="f845e-2431">数字化器在检测触笔时，触笔必须处于移动状态才会引发此事件，否则将改为引发 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2431">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2432">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2432">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2433">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusMove> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2433">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2434">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2434">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2435">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2435">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2436">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2437">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2437">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="f845e-2438">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2438">Routing strategy</span></span>|<span data-ttu-id="f845e-2439">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2439">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2440">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2440">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2441">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2441">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2442">重写 <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2442">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2443">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2443">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2444">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2445">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2446">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2447">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2448">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2449">在触笔与数字化仪之间的距离太远以致无法检测到触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2449">Occurs when the stylus is too far from the digitizer to be detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2450">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2450">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2451">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2451">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2452">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2452">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2453">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2453">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2454">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2454">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2455">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2455">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="f845e-2456">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2456">Routing strategy</span></span>|<span data-ttu-id="f845e-2457">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2457">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2458">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2458">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2459">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusOutOfRange> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2459">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="f845e-2460">重写 <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2460">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2461">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2461">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2462">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2462">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2463">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2463">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2464">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2464">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2465">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2465">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2466">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2466">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2467">在用户采用某一种触笔笔势时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2467">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2468">有关触笔势的信息，请参阅 <xref:System.Windows.Input.SystemGesture> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2468">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="f845e-2469">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2469">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2470">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2470">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2471">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2471">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2472">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2472">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2473">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2473">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2474">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2474">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="f845e-2475">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2475">Routing strategy</span></span>|<span data-ttu-id="f845e-2476">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2476">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2477">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2477">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="f845e-2478">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusSystemGesture> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2478">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="f845e-2479">重写 <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2479">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2480">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2480">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2481">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2481">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2482">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2482">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2483">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2483">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2484">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2484">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2485">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2485">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2486">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2486">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2487">此事件将为 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewStylusDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2487">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2488">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewStylusDown> 附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2488">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2489">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2489">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2490">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2490">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2491">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2491">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2492">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2492">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="f845e-2493">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2493">Routing strategy</span></span>|<span data-ttu-id="f845e-2494">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2494">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2495">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2495">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2496">对应的冒泡事件为 <xref:System.Windows.ContentElement.StylusUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2496">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2497">重写 <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2497">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2498">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2498">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2499">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2499">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2500">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2500">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2501">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2501">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2502">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2502">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2503">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2503">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2504">在此元素以设备无关模式获取文本时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2504">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2505"><xref:System.Windows.ContentElement.PreviewTextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="f845e-2505">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="f845e-2506">键盘是的主要方式 <xref:System.Windows.ContentElement.PreviewTextInput> ，但语音、手写和其他输入设备也可能会生成 <xref:System.Windows.ContentElement.PreviewTextInput> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2506">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="f845e-2507">由于键组合（在默认键盘或通过输入法编辑器）中，多个键事件可能只引发一个文本输入事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2507">Because of key combinations - either in default keyboards or through input method editors - multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="f845e-2508">此事件将为 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.PreviewTextInput> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2508">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2509">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.PreviewTextInput> 附加到基础 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2509">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2510">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2510">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2511">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2511">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="f845e-2512">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2512">Routing strategy</span></span>|<span data-ttu-id="f845e-2513">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2513">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2514">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2514">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="f845e-2515">对应的冒泡事件为 <xref:System.Windows.ContentElement.TextInput> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2515">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="f845e-2516">重写 <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2516">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2517">标识 <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2517">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2518">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2518">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2519">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2519">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2520">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2520">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2521">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2521">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2522">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2522">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2523">当悬停在此元素上方的手指触摸屏幕时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2523">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2524">默认情况下， <xref:System.Windows.ContentElement.PreviewTouchDown> 在 <xref:System.Windows.ContentElement.TouchDown> 手指触摸屏幕并移动之前，和事件不会发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2524">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="f845e-2525">在屏幕上按一根手指并在不移动它的情况下，将导致的按下和保持行为 <xref:System.Windows.Input.Stylus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2525">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="f845e-2526">按住行为等效于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="f845e-2526">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="f845e-2527">若要使 <xref:System.Windows.ContentElement.PreviewTouchDown> 和 <xref:System.Windows.ContentElement.TouchDown> 事件在手指触摸屏幕时立即发生，请将 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 此元素的附加属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2527">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2528">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2528">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2529">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2529">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="f845e-2530">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2530">Routing strategy</span></span>|<span data-ttu-id="f845e-2531">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2531">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2532">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2532">Delegate</span></span>|<span data-ttu-id="f845e-2533"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2533"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2534">对应的冒泡事件为 <xref:System.Windows.ContentElement.TouchDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2534">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2535">重写 <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2535">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2536">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2536">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2537">当悬停在此元素上方的手指在屏幕上移动时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2537">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2538">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2538">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2539">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2539">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="f845e-2540">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2540">Routing strategy</span></span>|<span data-ttu-id="f845e-2541">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2541">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2542">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2542">Delegate</span></span>|<span data-ttu-id="f845e-2543"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2543"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2544">对应的冒泡事件为 <xref:System.Windows.ContentElement.TouchMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2544">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2545">重写 <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2545">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2546">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2546">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2547">当悬停在此元素上方的手指从屏幕上移开时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2547">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2548">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2548">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2549">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2549">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="f845e-2550">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2550">Routing strategy</span></span>|<span data-ttu-id="f845e-2551">隧道</span><span class="sxs-lookup"><span data-stu-id="f845e-2551">Tunneling</span></span>|  
|<span data-ttu-id="f845e-2552">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2552">Delegate</span></span>|<span data-ttu-id="f845e-2553"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2553"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2554">对应的冒泡事件为 <xref:System.Windows.ContentElement.TouchUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2554">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2555">重写 <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2555">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2556">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2556">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2557">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2557">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2558">此 <xref:System.Windows.ContentElement.QueryContinueDrag> 事件允许拖动源确定是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="f845e-2558">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="f845e-2559">此事件将为 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.QueryContinueDrag> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2559">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2560">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.QueryContinueDrag> 附加到基础 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2560">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2561">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2561">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2562">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2562">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="f845e-2563">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2563">Routing strategy</span></span>|<span data-ttu-id="f845e-2564">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2564">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2565">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2565">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="f845e-2566">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2566">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="f845e-2567">重写 <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2567">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2568">标识 <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2568">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2569">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2569">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2570">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2570">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2571">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2571">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2572">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2572">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2573">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2573">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2574">当请求显示光标时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2574">Occurs when the cursor is requested to display.</span></span> <span data-ttu-id="f845e-2575">每次鼠标指针移至新位置时都会在一个元素上引发此事件，这意味着光标对象可能需要根据其新位置进行更改。</span><span class="sxs-lookup"><span data-stu-id="f845e-2575">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2576">此事件将为 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.QueryCursor> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2576">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2577">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.QueryCursor> 附加到基础 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2577">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2578">此事件名称所引用的游标不一定是文本光标 (有时称为插入点) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2578">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="f845e-2579">相反，此上下文中的光标是一个对象，该对象声明与 Windows 编程中几个可能的输入相关设备或概念相关的屏幕图形显示。</span><span class="sxs-lookup"><span data-stu-id="f845e-2579">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="f845e-2580">该对象由 <xref:System.Windows.Input.Cursor> WPF 中的类表示。</span><span class="sxs-lookup"><span data-stu-id="f845e-2580">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="f845e-2581">WPF 输入系统使你可以在其表示鼠标指针的屏幕位置时更改此光标。</span><span class="sxs-lookup"><span data-stu-id="f845e-2581">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="f845e-2582">可以从枚举中使用预定义的值 <xref:System.Windows.Input.Cursors> ，也可以将自定义游标声明为映像文件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2582">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="f845e-2583">侦听 <xref:System.Windows.ContentElement.QueryCursor> 事件不是游标管理的有效方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2583">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="f845e-2584">相反，每个元素应通过和定义其自己的游标行为 <xref:System.Windows.FrameworkContentElement.Cursor%2A> <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2584">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="f845e-2585">只应依赖于是否 <xref:System.Windows.ContentElement.QueryCursor> 未使用 WPF 框架级基元素，或者在基于每个元素定义游标行为的特殊情况下，不能满足您的需求。</span><span class="sxs-lookup"><span data-stu-id="f845e-2585">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="f845e-2586">有关实现游标行为以响应的详细信息 <xref:System.Windows.ContentElement.QueryCursor> ，请参阅 <xref:System.Windows.Input.QueryCursorEventHandler> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2586">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2587">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2587">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2588">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2588">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="f845e-2589">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2589">Routing strategy</span></span>|<span data-ttu-id="f845e-2590">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2590">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2591">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2591">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="f845e-2592">未定义相应的隧道事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2592">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="f845e-2593">重写 <xref:System.Windows.ContentElement.OnQueryCursor%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2593">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2594">标识 <see cref="E:System.Windows.ContentElement.QueryCursor" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2594">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2595">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2595">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2596">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2596">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2597">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2597">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2598">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2598">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2599">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2599">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f845e-2600">一个 <see cref="T:System.Windows.RoutedEventArgs" />，其中包含事件数据并标识要引发的事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2600">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span></span></param>
        <summary><span data-ttu-id="f845e-2601">引发特定路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2601">Raises a specific routed event.</span></span> <span data-ttu-id="f845e-2602">在提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 实例内标识将引发的 <see cref="T:System.Windows.RoutedEvent" />（作为该事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性）。</span><span class="sxs-lookup"><span data-stu-id="f845e-2602">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2603">`e`参数被类型化为所有路由事件数据的公共基类型; 但是，应将事件数据指定为可用于引发事件的最特定事件数据类型，因为 <xref:System.Windows.RoutedEventArgs> 派生类包含在引发特定事件时用于特定事件的实际特定数据属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-2603">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="f845e-2604"><xref:System.Windows.RoutedEventArgs> 不只是事件的状态属性;它还标识要引发的路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2604"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="f845e-2605">此事件引发模式和路由事件数据都不同于公共语言运行时 (CLR) 事件和数据类，通常只包含与事件相关的属性。</span><span class="sxs-lookup"><span data-stu-id="f845e-2605">This event-raising pattern and the routed event data both differ from common language runtime (CLR) events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f845e-2606">下面的示例创建事件数据、将事件标识符追加到数据，然后使用事件数据实例引发自定义路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2606">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-2607">从此元素中释放所有捕获的触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2607">Releases all captured touch devices from this element.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-2608">如果此元素具有鼠标捕获，则释放该捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-2608">Releases the mouse capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2609">如果此元素不包含捕获，则调用此方法将不起作用。</span><span class="sxs-lookup"><span data-stu-id="f845e-2609">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="f845e-2610">在调用此方法之前，请考虑检查的值 <xref:System.Windows.ContentElement.IsMouseCaptured%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2610">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f845e-2611">下面的处理程序根据鼠标按钮状态捕获或释放鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-2611">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="f845e-2612">该示例演示如何使用捕获的鼠标移动作为替代方法，而不是将鼠标指针移动到 UI 中。</span><span class="sxs-lookup"><span data-stu-id="f845e-2612">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the UI.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-2613">如果此元素具有触笔设备捕获，则释放该捕获。</span><span class="sxs-lookup"><span data-stu-id="f845e-2613">Releases the stylus device capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2614">如果此元素不包含捕获，则调用此方法将不起作用。</span><span class="sxs-lookup"><span data-stu-id="f845e-2614">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="f845e-2615">在调用此方法之前，请考虑检查的值 <xref:System.Windows.ContentElement.IsStylusCaptured%2A> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2615">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseTouchCapture (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="f845e-2616">要释放的设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2616">The device to release.</span></span></param>
        <summary><span data-ttu-id="f845e-2617">尝试从此元素释放指定触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2617">Attempts to release the specified touch device from this element.</span></span></summary>
        <returns><span data-ttu-id="f845e-2618">如果释放了触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2618"><see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f845e-2619"><paramref name="touchDevice" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2619"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="f845e-2620">附加处理程序的路由事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2620">The identifier of the.routed event for which the handler is attached.</span></span></param>
        <param name="handler"><span data-ttu-id="f845e-2621">要从此元素的事件处理程序集合中删除的特定处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="f845e-2621">The specific handler implementation to remove from the event handler collection on this element.</span></span></param>
        <summary><span data-ttu-id="f845e-2622">从此元素中删除指定的路由事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2622">Removes the specified routed event handler from this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2623">使用此 API 的最常见方案是实现公共语言运行时 (CLR) "包装器" 事件，该事件与自定义路由事件相关联，特别是在为 CLR 级别的处理程序实现 "remove" 逻辑时。</span><span class="sxs-lookup"><span data-stu-id="f845e-2623">The most common scenario for using this API is when you implement the common language runtime (CLR) "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the CLR level.</span></span> <span data-ttu-id="f845e-2624">此备注部分后面的示例演示了这种情况。</span><span class="sxs-lookup"><span data-stu-id="f845e-2624">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="f845e-2625">如果没有向与方法调用的输入参数匹配的条件注册处理程序，则调用此方法将不起作用。</span><span class="sxs-lookup"><span data-stu-id="f845e-2625">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="f845e-2626">如果附加了多个与条件相匹配的处理程序，则只会删除事件处理程序存储中的第一个处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2626">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="f845e-2627">此行为与运算符的 CLR 行为一致 `-=` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2627">This behavior is consistent with CLR behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="f845e-2628">既 `routedEvent` 不 `handler` 是也不是 `null` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2628">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="f845e-2629">尝试提供任何一个值时， `null` 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="f845e-2629">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="f845e-2630">此方法将忽略 `handledEventsToo` 参数信息，如果处理程序是首次通过签名添加的，而该 <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名启用了已处理的事件，则提供此方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2630">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="f845e-2631">已删除任一类型的处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2631">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-2632">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性的内容。</span><span class="sxs-lookup"><span data-stu-id="f845e-2632">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="f845e-2633">如果应当序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2633"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2634">`true`如果 <xref:System.Windows.ContentElement.CommandBindings%2A> 是本地设置的，则会返回。</span><span class="sxs-lookup"><span data-stu-id="f845e-2634">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="f845e-2635">`ShouldSerialize`提供此方法是因为 <xref:System.Windows.UIElement.CommandBindings%2A> 属性没有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="f845e-2635">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="f845e-2636">此方法指示属性是否已更改为其默认值。</span><span class="sxs-lookup"><span data-stu-id="f845e-2636">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="f845e-2637">如果要开发设计器或开发自己的包含的控件，通常需要调用此方法 <xref:System.Windows.UIElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2637">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="f845e-2638">有关详细信息，请参阅 [用 ShouldSerialize 和 Reset 方法定义默认值](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2638">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f845e-2639">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性的内容。</span><span class="sxs-lookup"><span data-stu-id="f845e-2639">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="f845e-2640">如果应当序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2640"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2641">`true`如果 <xref:System.Windows.ContentElement.InputBindings%2A> 是本地设置的，则会返回。</span><span class="sxs-lookup"><span data-stu-id="f845e-2641">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="f845e-2642">`ShouldSerialize`提供此方法是因为 <xref:System.Windows.UIElement.InputBindings%2A> 属性没有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="f845e-2642">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="f845e-2643">此方法指示属性是否已更改为其默认值。</span><span class="sxs-lookup"><span data-stu-id="f845e-2643">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="f845e-2644">如果要开发设计器或开发自己的包含的控件，通常需要调用此方法 <xref:System.Windows.UIElement> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2644">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="f845e-2645">有关详细信息，请参阅 [用 ShouldSerialize 和 Reset 方法定义默认值](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2645">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2646">在指针位于此元素上并且按下触笔按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2646">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2647">此事件将为 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusButtonDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2647">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2648">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusButtonDown> 附加到基础 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2648">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2649">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2649">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2650">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2650">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2651">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2651">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2652">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2652">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="f845e-2653">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2653">Routing strategy</span></span>|<span data-ttu-id="f845e-2654">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2654">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2655">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2655">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2656">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2656">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2657">重写 <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2657">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2658">标识 <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2658">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2659">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2659">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2660">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2660">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2661">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2661">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2662">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2662">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2663">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2663">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2664">在指针位于此元素上并且松开触笔按钮时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2664">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2665">此事件将为 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusButtonUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2665">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2666">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusButtonUp> 附加到基础 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2666">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2667">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2667">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2668">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2668">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2669">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2669">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2670">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2670">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="f845e-2671">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2671">Routing strategy</span></span>|<span data-ttu-id="f845e-2672">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2672">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2673">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2673">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="f845e-2674">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2674">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2675">重写 <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2675">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2676">标识 <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2676">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2677">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2677">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2678">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2678">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2679">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2679">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2680">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2680">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2681">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2681">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2682">在触笔位于此元素上且同时触及数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2682">Occurs when the stylus touches the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2683">此事件将为 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusDown> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2683">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2684">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusDown> 附加到基础 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2684">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2685">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2685">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2686">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2686">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2687">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2688">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2688">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="f845e-2689">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2689">Routing strategy</span></span>|<span data-ttu-id="f845e-2690">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2690">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2691">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2691">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="f845e-2692">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2692">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2693">重写 <xref:System.Windows.ContentElement.OnStylusDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2693">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2694">标识 <see cref="E:System.Windows.ContentElement.StylusDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2694">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2695">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2696">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2697">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2698">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2699">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2700">在触笔进入此元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2700">Occurs when the stylus enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2701"><xref:System.Windows.ContentElement.StylusEnter> 是使用直接事件处理路由策略的 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2701"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f845e-2702">直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。</span><span class="sxs-lookup"><span data-stu-id="f845e-2702">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f845e-2703">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2703">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f845e-2704">尽管在 <xref:System.Windows.ContentElement.StylusEnter> 触笔进入元素边界时进行跟踪，但此事件更确切地报告 <xref:System.Windows.ContentElement.IsStylusOver%2A> `false` `true` 此元素上的属性值已从更改为。</span><span class="sxs-lookup"><span data-stu-id="f845e-2704">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="f845e-2705">此事件将为 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusEnter> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2705">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2706">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusEnter> 附加到基础 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2706">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2707">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2707">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2708">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2708">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2709">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2710">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2710">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="f845e-2711">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2711">Routing strategy</span></span>|<span data-ttu-id="f845e-2712">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2712">Direct</span></span>|  
|<span data-ttu-id="f845e-2713">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2713">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2714">重写 <xref:System.Windows.ContentElement.OnStylusEnter%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2714">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2715">标识 <see cref="E:System.Windows.ContentElement.StylusEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2715">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2716">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2716">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2717">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2717">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2718">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2718">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2719">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2719">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2720">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2720">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2721">在触笔掠过元素但并未实际接触数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2721">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2722">此事件将为 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusInAirMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2722">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2723">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusInAirMove> 附加到基础 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2723">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2724">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2724">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2725">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2725">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2726">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2726">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2727">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2727">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="f845e-2728">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2728">Routing strategy</span></span>|<span data-ttu-id="f845e-2729">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2729">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2730">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2730">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2731">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusInAirMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2731">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2732">重写 <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2732">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2733">标识 <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2733">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2734">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2734">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2735">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2735">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2736">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2736">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2737">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2737">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2738">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2738">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2739">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2739">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2740">此事件将为 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusInRange> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2740">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2741">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusInRange> 附加到基础 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2741">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2742">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2742">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2743">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2743">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2744">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2744">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2745">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2745">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="f845e-2746">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2746">Routing strategy</span></span>|<span data-ttu-id="f845e-2747">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2747">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2748">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2748">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2749">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusInRange> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2749">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="f845e-2750">重写 <xref:System.Windows.ContentElement.OnStylusInRange%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2750">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2751">标识 <see cref="E:System.Windows.ContentElement.StylusInRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2751">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2752">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2752">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2753">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2753">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2754">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2754">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2755">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2755">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2756">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2756">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2757">在触笔离开元素的边界时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2757">Occurs when the stylus leaves the bounds of the element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2758"><xref:System.Windows.ContentElement.StylusLeave> 是使用直接事件处理路由策略的 [路由事件概述](/dotnet/framework/wpf/advanced/routed-events-overview) 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2758"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](/dotnet/framework/wpf/advanced/routed-events-overview) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="f845e-2759">直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。</span><span class="sxs-lookup"><span data-stu-id="f845e-2759">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="f845e-2760">但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。</span><span class="sxs-lookup"><span data-stu-id="f845e-2760">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="f845e-2761">尽管在 <xref:System.Windows.ContentElement.StylusLeave> 触笔离开元素边界时进行跟踪，但此事件更确切地报告 <xref:System.Windows.ContentElement.IsStylusOver%2A> `true` `false` 此元素上的属性值已从更改为。</span><span class="sxs-lookup"><span data-stu-id="f845e-2761">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="f845e-2762">此事件将为 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusLeave> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2762">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2763">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusLeave> 附加到基础 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2763">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2764">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2764">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2765">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2765">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2766">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2766">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2767">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2767">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="f845e-2768">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2768">Routing strategy</span></span>|<span data-ttu-id="f845e-2769">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2769">Direct</span></span>|  
|<span data-ttu-id="f845e-2770">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2770">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2771">重写 <xref:System.Windows.ContentElement.OnStylusLeave%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2771">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2772">标识 <see cref="E:System.Windows.ContentElement.StylusLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2772">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2773">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2773">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2774">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2774">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2775">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2775">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2776">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2776">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2777">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2777">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2778">在触笔移到此元素上时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2778">Occurs when the stylus moves over this element.</span></span> <span data-ttu-id="f845e-2779">触笔必须在位于数字化器上时移动，才会引发此事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2779">The stylus must move while on the digitizer to raise this event.</span></span> <span data-ttu-id="f845e-2780">否则将改为引发 <see cref="E:System.Windows.ContentElement.StylusInAirMove" />。</span><span class="sxs-lookup"><span data-stu-id="f845e-2780">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2781">此事件将为 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusMove> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2781">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2782">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusMove> 附加到基础 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2782">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2783">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2783">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2784">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2784">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2785">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2785">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2786">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2786">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="f845e-2787">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2787">Routing strategy</span></span>|<span data-ttu-id="f845e-2788">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2788">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2789">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2789">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2790">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2790">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2791">重写 <xref:System.Windows.ContentElement.OnStylusMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2791">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2792">标识 <see cref="E:System.Windows.ContentElement.StylusMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2792">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2793">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2793">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2794">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2794">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2795">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2795">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2796">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2796">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2797">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2797">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2798">在触笔位于此元素上并且触笔与数字化器之间的距离太远以致无法检测到触笔时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2798">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2799">此事件将为 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusOutOfRange> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2799">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2800">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusOutOfRange> 附加到基础 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2800">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2801">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2801">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2802">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2802">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2803">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2803">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2804">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2804">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="f845e-2805">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2805">Routing strategy</span></span>|<span data-ttu-id="f845e-2806">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2806">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2807">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2807">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2808">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2808">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="f845e-2809">重写 <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2809">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2810">标识 <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2810">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2811">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2811">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2812">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2812">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2813">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2813">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2814">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2814">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2815">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2815">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2816">在用户采用某一种触笔笔势时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2816">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2817">有关触笔手势的详细信息，请参阅 <xref:System.Windows.Input.SystemGesture> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2817">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="f845e-2818">此事件将为 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusSystemGesture> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2818">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2819">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusSystemGesture> 附加到基础 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2819">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2820">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2820">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2821">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2821">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2822">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2822">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2823">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2823">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="f845e-2824">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2824">Routing strategy</span></span>|<span data-ttu-id="f845e-2825">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2825">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2826">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2826">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="f845e-2827">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2827">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="f845e-2828">重写 <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2828">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2829">标识 <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2829">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2830">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2830">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2831">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2831">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2832">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2832">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2833">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2833">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2834">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2834">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2835">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2835">Occurs when the user raises the stylus off the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2836">此事件将为 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.StylusUp> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2836">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2837">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.StylusUp> 附加到基础 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2837">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="f845e-2838">触摸、鼠标和触笔输入在特定关系中存在。</span><span class="sxs-lookup"><span data-stu-id="f845e-2838">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="f845e-2839">有关详细信息，请参阅 [输入概述](/dotnet/framework/wpf/advanced/input-overview)。</span><span class="sxs-lookup"><span data-stu-id="f845e-2839">For more information, see [Input Overview](/dotnet/framework/wpf/advanced/input-overview).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2840">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2840">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2841">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2841">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="f845e-2842">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2842">Routing strategy</span></span>|<span data-ttu-id="f845e-2843">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2843">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2844">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2844">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="f845e-2845">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewStylusUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2845">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2846">重写 <xref:System.Windows.ContentElement.OnStylusUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2846">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2847">标识 <see cref="E:System.Windows.ContentElement.StylusUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2847">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2848">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2848">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2849">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2849">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2850">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2850">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2851">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2851">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2852">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2852">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2853">在此元素以设备无关模式获取文本时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2853">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f845e-2854">此事件可能已标记为由复合控件的内部实现进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2854">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="f845e-2855">请参阅下面的注释。</span><span class="sxs-lookup"><span data-stu-id="f845e-2855">See Remark below.</span></span>  
  
 <span data-ttu-id="f845e-2856"><xref:System.Windows.ContentElement.TextInput>事件可能已标记为由复合控件的内部实现进行处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2856">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="f845e-2857">例如，是一个 <xref:System.Windows.Controls.TextBox> 复合控件，其中的 <xref:System.Windows.ContentElement.TextInput> 事件已标记为已处理，在其组合中。</span><span class="sxs-lookup"><span data-stu-id="f845e-2857">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="f845e-2858">控件这样做的原因是，控件需要解释某些类型的输入（如箭头键），以便对该控件具有特殊意义。</span><span class="sxs-lookup"><span data-stu-id="f845e-2858">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="f845e-2859">如果将 <xref:System.Windows.ContentElement.PreviewTextInput> 用作文本输入处理程序的事件，可能会获得更好的结果。</span><span class="sxs-lookup"><span data-stu-id="f845e-2859">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="f845e-2860">此方法可避免控件组合已将此事件标记为已处理并防止处理程序通过事件路由接收事件的大多数情况。</span><span class="sxs-lookup"><span data-stu-id="f845e-2860">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="f845e-2861"><xref:System.Windows.ContentElement.TextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。</span><span class="sxs-lookup"><span data-stu-id="f845e-2861">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="f845e-2862">键盘是的主要方法 <xref:System.Windows.ContentElement.TextInput> ，但语音、手写和其他输入设备也可能会引发 <xref:System.Windows.ContentElement.TextInput> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2862">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="f845e-2863">由于键组合（在默认键盘或通过输入法编辑器）中，多个键事件可能只引发一个文本输入事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2863">Because of key combinations - either in default keyboards or through input method editors - multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="f845e-2864">此事件将为 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> 此类创建附加事件的别名，因此 <xref:System.Windows.ContentElement.TextInput> 当 <xref:System.Windows.ContentElement> 继承为基元素时，它是类成员列表的一部分。</span><span class="sxs-lookup"><span data-stu-id="f845e-2864">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="f845e-2865">附加到事件的事件处理程序 <xref:System.Windows.ContentElement.TextInput> 附加到基础 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="f845e-2865">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2866">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2866">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2867">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2867">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="f845e-2868">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2868">Routing strategy</span></span>|<span data-ttu-id="f845e-2869">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2869">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2870">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2870">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="f845e-2871">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewTextInput> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2871">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="f845e-2872">重写 <xref:System.Windows.ContentElement.OnTextInput%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2872">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2873">标识 <see cref="E:System.Windows.ContentElement.TextInput" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2873">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2874">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="f845e-2874">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="f845e-2875">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="f845e-2875">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="f845e-2876">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="f845e-2876">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="f845e-2877">有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2877">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="f845e-2878">有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2878">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2879">当悬停在此元素上方的手指触摸屏幕时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2879">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2880">默认情况下， <xref:System.Windows.ContentElement.PreviewTouchDown> 在 <xref:System.Windows.ContentElement.TouchDown> 手指触摸屏幕并移动之前，和事件不会发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2880">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="f845e-2881">在屏幕上按一根手指并在不移动它的情况下，将导致的按下和保持行为 <xref:System.Windows.Input.Stylus> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2881">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="f845e-2882">按住行为等效于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="f845e-2882">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="f845e-2883">若要使 <xref:System.Windows.ContentElement.PreviewTouchDown> 和 <xref:System.Windows.ContentElement.TouchDown> 事件在手指触摸屏幕时立即发生，请将 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 此元素的附加属性设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2883">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2884">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2884">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2885">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2885">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="f845e-2886">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2886">Routing strategy</span></span>|<span data-ttu-id="f845e-2887">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2887">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2888">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2888">Delegate</span></span>|<span data-ttu-id="f845e-2889"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2889"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2890">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewTouchDown> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="f845e-2891">重写 <xref:System.Windows.ContentElement.OnTouchDown%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2891">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2892">标识 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2892">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2893">在触摸屏输入从此元素边界外部移动到其内部时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2893">Occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f845e-2894">无论是否将触摸设备捕获到此 UI 元素，都将始终引发此事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2894">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2895">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2895">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2896">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2896">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="f845e-2897">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2897">Routing strategy</span></span>|<span data-ttu-id="f845e-2898">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2898">Direct</span></span>|  
|<span data-ttu-id="f845e-2899">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2899">Delegate</span></span>|<span data-ttu-id="f845e-2900"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2900"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2901">重写 <xref:System.Windows.ContentElement.OnTouchEnter%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2901">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2902">标识 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2902">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2903">获取在此元素上捕获的所有触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2903">Gets all touch devices that are captured to this element.</span></span></summary>
        <value><span data-ttu-id="f845e-2904">在此元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span><span class="sxs-lookup"><span data-stu-id="f845e-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2905">获取在此元素或其可视化树中的任何子元素上捕获的所有触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2905">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="f845e-2906">在此元素或其可视化树中的任何子元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span><span class="sxs-lookup"><span data-stu-id="f845e-2906">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2907">获取此元素上的所有触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2907">Gets all touch devices that are over this element.</span></span></summary>
        <value><span data-ttu-id="f845e-2908">位于此元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span><span class="sxs-lookup"><span data-stu-id="f845e-2908">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2909">获取在此元素或其可视化树中的任何子元素上的所有触摸设备。</span><span class="sxs-lookup"><span data-stu-id="f845e-2909">Gets all touch devices that are over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="f845e-2910">在此元素或其可视化树中的任何子元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span><span class="sxs-lookup"><span data-stu-id="f845e-2910">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2911">在触摸屏输入从此元素边界内部移动到其外部时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2911">Occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2912">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2912">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2913">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2913">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="f845e-2914">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2914">Routing strategy</span></span>|<span data-ttu-id="f845e-2915">直接</span><span class="sxs-lookup"><span data-stu-id="f845e-2915">Direct</span></span>|  
|<span data-ttu-id="f845e-2916">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2916">Delegate</span></span>|<span data-ttu-id="f845e-2917"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2917"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2918">重写 <xref:System.Windows.ContentElement.OnTouchLeave%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2918">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2919">标识 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2919">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2920">当悬停在此元素上方的手指在屏幕上移动时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2920">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2921">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2921">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2922">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2922">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="f845e-2923">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2923">Routing strategy</span></span>|<span data-ttu-id="f845e-2924">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2924">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2925">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2925">Delegate</span></span>|<span data-ttu-id="f845e-2926"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2926"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2927">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewTouchMove> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2927">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="f845e-2928">重写 <xref:System.Windows.ContentElement.OnTouchMove%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2928">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2929">标识 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2929">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2930">当悬停在此元素上方的手指从屏幕上移开时发生。</span><span class="sxs-lookup"><span data-stu-id="f845e-2930">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="f845e-2931">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="f845e-2931">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="f845e-2932">标识符字段</span><span class="sxs-lookup"><span data-stu-id="f845e-2932">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="f845e-2933">路由策略</span><span class="sxs-lookup"><span data-stu-id="f845e-2933">Routing strategy</span></span>|<span data-ttu-id="f845e-2934">冒泡</span><span class="sxs-lookup"><span data-stu-id="f845e-2934">Bubbling</span></span>|  
|<span data-ttu-id="f845e-2935">委托</span><span class="sxs-lookup"><span data-stu-id="f845e-2935">Delegate</span></span>|<span data-ttu-id="f845e-2936"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="f845e-2936"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="f845e-2937">对应的隧道事件为 <xref:System.Windows.ContentElement.PreviewTouchUp> 。</span><span class="sxs-lookup"><span data-stu-id="f845e-2937">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="f845e-2938">重写 <xref:System.Windows.ContentElement.OnTouchUp%2A> 以在派生类中实现此事件的类处理。</span><span class="sxs-lookup"><span data-stu-id="f845e-2938">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f845e-2939">标识 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件。</span><span class="sxs-lookup"><span data-stu-id="f845e-2939">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
