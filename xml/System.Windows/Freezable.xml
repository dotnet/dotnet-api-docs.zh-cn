<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="56fcd386d1225dc8c2e9dc9e8898a3d671c75245" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102092224" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定义具有可修改状态和只读（冻结）状态的对象。 从 <see cref="T:System.Windows.Freezable" /> 派生的类提供详细更改通知，可以设置为不可变，并且可以克隆自身。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>类提供了一些特殊功能，可帮助您在使用修改或复制成本很高的对象时提高应用程序性能。 对象的示例 <xref:System.Windows.Freezable> 包括：  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>派生自冻结  
 派生自的类具有 <xref:System.Windows.Freezable> 以下功能：  
  
-   特殊状态：只读 (冻结) 状态和可写状态。  
  
-   线程安全： <xref:System.Windows.Freezable> 可在线程之间共享冻结的对象。  
  
-   详细更改通知：与其他 <xref:System.Windows.DependencyObject> 对象不同， <xref:System.Windows.Freezable> 当子属性值更改时，对象会提供更改通知。  
  
-   轻松克隆：可冻结的类已经实现了几种生成深层克隆的方法。  
  
 有关使用和创建自己的对象的信息 <xref:System.Windows.Freezable> ，请参阅 " [冻结对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)"。  
  
 ]]></format>
    </remarks>
    <threadsafe><see langword="static" />此类型的任何公共成员都是线程安全的。 但不保证所有实例成员都是线程安全的。  
  
当 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为时 <see langword="false" /> ，只能 <see cref="T:System.Windows.Freezable" /> 从创建对象的线程访问对象。 尝试从另一个线程访问它将引发 <see cref="T:System.InvalidOperationException" /> 。 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和 <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> 方法为封送处理到正确的线程提供支持。  
  
当其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为时 <see langword="true" /> ， <see cref="T:System.Windows.Freezable" /> 对象是自由线程的。  有关详细信息，请参阅 [Freezable 对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是抽象类的受保护的可访问性构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否可将对象变为不可修改。</summary>
        <value>如果当前对象可以变为不可修改，或者已经不可修改，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>此方法实现使用 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> <paramref name="isChecking" /> 设置为的方法 <see langword="true" /> 来确定是否 <see cref="T:System.Windows.Freezable" /> 可将其变为不可修改。 若要修改此属性在派生类中的行为方式，请重写 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在修改 <see cref="T:System.Windows.Freezable" /> 或其包含的对象时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在) 属性时不能修改当前对象时尝试添加或删除事件处理程序 (<xref:System.Windows.Freezable.IsFrozen%2A> ，则 `true` 会引发异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Windows.Freezable" /> 的可修改克隆，以制作该对象值的深层副本。 在复制此对象的依赖属性时，此方法会复制表达式（可能不再解析），但不复制动画或其当前值。</summary>
        <returns>当前对象的可修改复本。 即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="false" />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 方法将生成冻结对象的可修改克隆 <xref:System.Windows.Freezable> (这些方法还 <xref:System.Windows.Freezable> 会克隆未冻结的对象) 。 克隆实际上是当前对象的深层副本。  
  
 下表总结了和方法之间的 <xref:System.Windows.Freezable.Clone%2A> 差异 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 。  
  
|操作|克隆方法行为|CloneCurrentValue 方法行为|  
|------------|---------------------------|---------------------------------------|  
|复制具有表达式的依赖项属性|表达式已复制，但可能不再解析。 有关详细信息，请参阅 [Freezable 对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。|复制表达式的当前值，而不是表达式本身。|  
|复制动画依赖属性|复制属性的基本 (非动画) 值。 不复制动画。|复制属性的当前动画值。 不复制动画。|  
  
 请注意，不会复制未设置的属性。 如果未设置属性的默认值为冻结 <xref:System.Windows.Freezable> ，则该属性的值在其他可修改复本中保持冻结状态。  
  
## <a name="move-a-freezable-between-threads"></a>在线程之间移动一个冻结  
 此方法可用于在 <xref:System.Windows.Freezable> 线程之间移动。 首先， <xref:System.Windows.Freezable> 通过调用方法来使其成为不可修改的 <xref:System.Windows.Freezable.Freeze%2A> 。 现在，另一个线程可以访问 <xref:System.Windows.Freezable> ，并使 <xref:System.Windows.Freezable.Clone%2A> 其可以访问。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法使用 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 生成克隆。 若要修改派生类中此方法的行为，请重写 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要克隆的对象。</param>
        <summary>使用基（未经过动画处理的）属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的克隆（深层复制）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由方法调用， <xref:System.Windows.Freezable.Clone%2A> 不应在代码中直接调用，除非在重写此方法时调用基实现。 若要创建当前对象的可修改副本，请调用， <xref:System.Windows.Freezable.Clone%2A> 而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果是从派生的 <see cref="T:System.Windows.Freezable" /> ，则可能需要重写此方法。 重写的原因包括： 
-派生类具有未通过依赖属性公开的数据。  
  
-派生类必须执行额外的初始化工作，而不能通过简单地重写来完成此操作 <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> 。 例如，如果您的派生类实现了，则这种情况适用 <see cref="T:System.ComponentModel.ISupportInitialize" /> 。  
  
将其所有数据存储在依赖属性中并且无需执行额外的初始化工作的类不需要重写 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 。  
  
所有实现都必须调用此方法的基实现，这一点非常重要。 实现仅应执行默认实现不执行的工作。 默认实现生成所有可写的本地设置的属性（包括内部表达式）的深层副本。  
  
如果对象具有数据绑定依赖项属性，则会复制表达式，但不能再解析表达式。 有关克隆数据绑定对象的详细信息，请参阅 [冻结对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。 如果对象具有动画依赖属性，则复制这些属性的基本 (非动画) 值。 不复制动画。  
  
请注意，不会复制未设置的属性，也不会为只读属性。 如果此类属性具有一个冻结的默认值 <see cref="T:System.Windows.Freezable" /> ，则该属性值在其他可修改复本中保持为冻结状态。  
  
下面的列表汇总了此方法的预期行为： 
-生成的副本包含所有 <see cref="T:System.Windows.Freezable" /> 子对象的副本。  
  
-不会复制-Unset 和只读属性。  
  
-复制表达式。  
  
-在创建时这些子对象均不会被冻结。  
  
-副本本身未冻结。  
  
-不复制动画。  
  
-仅复制属性基准值，而不复制当前动画值。</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用 <see cref="T:System.Windows.Freezable" /> 的当前值创建其可修改复本（深层副本）。</summary>
        <returns>当前对象的可修改复本。 即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="false" />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 方法将生成冻结对象的可修改克隆 <xref:System.Windows.Freezable> (这些方法还 <xref:System.Windows.Freezable> 会克隆未冻结的对象) 。 克隆实际上是当前对象的深层副本。  
  
 下表总结了和方法之间的 <xref:System.Windows.Freezable.Clone%2A> 差异 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 。  
  
|操作|克隆方法行为|CloneCurrentValue 方法行为|  
|------------|---------------------------|---------------------------------------|  
|复制具有表达式的依赖项属性|表达式已复制，但可能不再解析。 有关详细信息，请参阅 [Freezable 对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。|复制表达式的当前值，而不是表达式本身。|  
|复制动画依赖属性|复制属性的基本 (非动画) 值。 不复制动画。|复制属性的当前动画值。 不复制动画。|  
  
 请注意，不会复制未设置的属性。 如果未设置属性的默认值为冻结 <xref:System.Windows.Freezable> ，则该属性的值在其他可修改复本中保持冻结状态。  
  
## <a name="move-a-freezable-between-threads"></a>在线程之间移动一个冻结  
 此方法可用于在 <xref:System.Windows.Freezable> 线程之间移动。 首先， <xref:System.Windows.Freezable> 使用其方法使不可修改 <xref:System.Windows.Freezable.Freeze%2A> 。 现在，另一个线程可以访问 <xref:System.Windows.Freezable> 并创建它可以访问的本地克隆。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法使用 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 方法生成克隆; <see cref="T:System.Windows.Freezable" /> 重写的实施者 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 必须确保在创建时未冻结副本。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要克隆的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>使用当前属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的可修改克隆（深层复制）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由方法调用， <xref:System.Windows.Freezable.CloneCurrentValue%2A> 不应在代码中直接调用，除非在重写此方法时调用基实现。 若要创建当前对象的可修改副本，请调用， <xref:System.Windows.Freezable.CloneCurrentValue%2A> 而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果是从派生的 <see cref="T:System.Windows.Freezable" /> ，则可能需要重写此方法。 重写的原因包括： 
-派生类具有未通过依赖属性公开的数据。  
  
-派生类必须执行额外的初始化工作，而不能通过简单地重写来完成此操作 <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> 。 例如，如果您的派生类实现了，则这种情况适用 <see cref="T:System.ComponentModel.ISupportInitialize" /> 。  
  
将其所有数据存储在依赖属性中并且无需执行额外的初始化工作的类不需要重写 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 。  
  
所有实现都必须调用此方法的基实现，这一点非常重要。 实现仅应执行默认实现不执行的工作。 默认实现会生成所有可写的本地设置属性的深层副本。 如果对象包含的依赖项属性的表达式 (如数据绑定) ，则将复制该表达式的当前值，而不是表达式本身。  
  
如果对象具有动画依赖属性，则会复制这些属性的当前动画值，但不会复制动画。  
  
请注意，不会复制未设置的属性，也不会为只读属性。 如果此类属性具有一个冻结的默认值 <see cref="T:System.Windows.Freezable" /> ，则该属性值在其他可修改复本中保持为冻结状态。  
  
下面的列表汇总了此方法的预期行为。  
  
-生成的副本包含所有 <see cref="T:System.Windows.Freezable" /> 子对象的副本。  
  
-不会复制-Unset 和只读属性。  
  
-如果对属性进行动画处理，则会复制其当前值，但不会复制动画本身。  
  
-在创建时这些子对象均不会被冻结。  
  
-副本本身未冻结。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Freezable" /> 类的新实例。</summary>
        <returns>新实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个受保护的方法，并且该行为的实际特定于对象的实现依赖于方法的重写实现 <xref:System.Windows.Freezable.CreateInstanceCore%2A> ，此方法在内部调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，创建 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</summary>
        <returns>新实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿直接调用此方法， (在实现) 中调用基时除外。 <xref:System.Windows.Freezable.CreateInstance%2A>每当创建的新实例时，方法都会在内部调用此方法 <xref:System.Windows.Freezable> 。  
  
   
  
## Examples  
 下面的示例演示的典型实现 <xref:System.Windows.Freezable.CreateInstanceCore%2A> 。  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>每个 <see cref="T:System.Windows.Freezable" /> 派生类必须实现此方法。 典型的实现是只调用无参数的构造函数并返回结果。</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改并将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />，或测试是否可将 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使当前对象不可修改，并且将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免在 <xref:System.InvalidOperationException> 调用此方法时出现的可能性，请检查 <xref:System.Windows.Freezable.CanFreeze%2A> 属性以确定是否 <xref:System.Windows.Freezable> 可以在调用此方法之前将其变为不可修改。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">无法将 <see cref="T:System.Windows.Freezable" /> 设置为不可修改。</exception>
        <block subset="none" type="overrides"><para>此方法使用 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 方法使 <see cref="T:System.Windows.Freezable" /> 不可修改。 若要修改冻结行为，请重写 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function Freeze (freezable As Freezable, isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">要检查或要变为不可修改的对象。 如果 <paramref name="isChecking" /> 为 <see langword="true" />，则检查此对象，以确定是否可将其变为不可修改。 如果 <paramref name="isChecking" /> 为 <see langword="false" />，则在可能的情况下将此对象变为不可修改。</param>
        <param name="isChecking">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</param>
        <summary>如果 <paramref name="isChecking" /> 参数为 <see langword="true" />，则此方法指示是否可将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改。 如果 <paramref name="isChecking" /> 参数为 <see langword="false" />，则此方法尝试将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，并指示操作是否成功。</summary>
        <returns>当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。 当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除非您是从派生的 <xref:System.Windows.Freezable> ，并且重写方法，否则不要调用此方法 <xref:System.Windows.Freezable.FreezeCore%2A> 。  此方法可在方法中用于 <xref:System.Windows.Freezable.FreezeCore%2A> 冻结自身对象的类数据成员 <xref:System.Windows.Freezable> 。  
  
 在 <xref:System.Windows.Freezable> 已冻结 (不可修改) 的对象上，可以再次调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果 <paramref name="isChecking" /> 为 <see langword="false" />，则表明将 <paramref name="freezable" /> 变为不可修改的尝试已失败；对象目前处于未知状态（可能已将其部分冻结）。</exception>
        <block subset="none" type="overrides"><para>此方法使用 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 方法使 <see cref="T:System.Windows.Freezable" /> 不可修改。 若要修改冻结行为，请重写 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 方法。</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</param>
        <summary>使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改或测试是否可将其变为不可修改。</summary>
        <returns>当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。 当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />，如果无法将其变为不可修改，则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿直接调用此方法， (在实现) 中调用基时除外。 此方法由 <xref:System.Windows.Freezable.CanFreeze%2A> (`isChecking` 等于) 的属性 `true` 和 <xref:System.Windows.Freezable.Freeze%2A> (`isChecking` 等于) 的方法 `false` 在内部调用。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> 如果类包含未使用依赖项属性存储的数据，则实现程序必须重写此方法。  
  
典型的实现将调用 base，然后 <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> 对类所包含的所有 <see cref="T:System.Windows.Freezable" /> 类型属性调用静态方法， <see langword="true" /> 仅当所有属性都已冻结时才返回 (或如果在为) 指定的情况下，则返回 <see langword="true" /> <paramref name="isChecking" /> 。</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用基（未经过动画处理的）属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。 由于副本已冻结，因此将通过引用复制任何冻结的子对象。</summary>
        <returns><see cref="T:System.Windows.Freezable" /> 的冻结副本。 副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应在 <xref:System.Windows.Freezable.CanFreeze%2A> 调用此方法之前检查属性，以验证是否 <xref:System.Windows.Freezable> 可以冻结。 使用此方法类似于使用创建副本 <xref:System.Windows.Freezable.Clone%2A> ，然后使用方法将其冻结 <xref:System.Windows.Freezable.Freeze%2A> 。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 方法可以提高复制性能，因为它们不克隆 <xref:System.Windows.Freezable> 已经冻结的子对象; 它们只按引用复制它们。  
  
 下表总结了和方法之间的 <xref:System.Windows.Freezable.GetAsFrozen%2A> 差异 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 。  
  
|操作|GetAsFrozen 方法行为|GetCurrentValueAsFrozen 方法行为|  
|------------|---------------------------------|---------------------------------------------|  
|复制具有表达式的依赖项属性|方法引发， <xref:System.InvalidOperationException> 因为它不能 <xref:System.Windows.Freezable.Freeze%2A> 是属性。|复制表达式的当前值，而不是表达式本身。|  
|复制动画依赖属性|复制属性的基本 (非动画) 值。 不复制动画。|复制属性的当前动画值。 不复制动画。|  
  
 请注意，不会复制未设置的属性，也不会为只读属性。  
  
 若要创建 <xref:System.Windows.Freezable> 未冻结的副本，请使用 <xref:System.Windows.Freezable.Clone%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">无法冻结此 <see cref="T:System.Windows.Freezable" />，因为它包含表达式或经过动画处理的属性。</exception>
        <block subset="none" type="overrides"><para>此方法使用虚 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> 方法来生成克隆。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要复制的实例。</param>
        <summary>让该实例成为指定的 <see cref="T:System.Windows.Freezable" /> 的冻结克隆，前者使用基（非动画的）属性值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由方法调用， <xref:System.Windows.Freezable.GetAsFrozen%2A> 不应在代码中直接调用，除非在重写此方法时调用基实现。 若要创建当前对象的冻结副本，请调用， <xref:System.Windows.Freezable.GetAsFrozen%2A> 而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果是从派生的， <see cref="T:System.Windows.Freezable" /> 则可能需要重写此方法。 重写的原因包括： 
-派生类具有未通过依赖属性公开的数据。  
  
-派生类必须执行额外的初始化工作，而不能通过简单地重写来完成此操作 <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> 。 例如，如果您的派生类实现了，则这种情况适用 <see cref="T:System.ComponentModel.ISupportInitialize" /> 。  
  
将其所有数据存储在依赖属性中并且无需执行额外的初始化工作的类不需要重写 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> 。  
  
所有实现都必须调用此方法的基实现，这一点非常重要。 实现仅应执行默认实现不执行的工作。 默认实现为其包含的所有其他可写的本地设置属性生成任何未冻结的可冻结对象和浅层副本的深层副本。 如果对象具有数据绑定依赖项属性，则会复制表达式，但不能再解析它们;有关克隆数据绑定对象的详细信息，请参阅 [冻结对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。 如果对象具有动画依赖属性，则会复制这些属性的基本 (非动画) 值。 不复制动画。  
  
请注意，不会复制未设置的属性，也不会为只读属性。  
  
如果重写此方法，则必须调用基实现。  
  
不需要在 <see cref="M:System.Windows.Freezable.Freeze" /> 复制值时进行值。  在返回前，结果会被冻结 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用当前属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。 由于副本已冻结，因此将通过引用复制任何冻结的子对象。</summary>
        <returns><see cref="T:System.Windows.Freezable" /> 的冻结副本。 副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法类似于使用创建副本 <xref:System.Windows.Freezable.CloneCurrentValue%2A> ，然后使用方法将其冻结 <xref:System.Windows.Freezable.Freeze%2A> 。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 方法可以提高复制性能，因为它们不克隆 <xref:System.Windows.Freezable> 已经冻结的子对象; 它们只按引用复制它们。  
  
 下表总结了和方法之间的 <xref:System.Windows.Freezable.GetAsFrozen%2A> 差异 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 。  
  
|操作|GetAsFrozen 方法行为|GetCurrentValueAsFrozen 方法行为|  
|------------|---------------------------------|---------------------------------------------|  
|复制具有表达式的依赖项属性|方法引发， <xref:System.InvalidOperationException> 因为它不能 <xref:System.Windows.Freezable.Freeze%2A> 是属性。|复制表达式的当前值，而不是表达式本身。|  
|复制动画依赖属性|复制属性的基本 (非动画) 值。 不复制动画。|复制属性的当前动画值。 不复制动画。|  
  
 请注意，不会复制未设置的属性，也不会为只读属性。  
  
 若要创建 <xref:System.Windows.Freezable> 未冻结的副本，请使用 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法使用虚 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> 方法来生成克隆。</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">要复制和冻结的 <see cref="T:System.Windows.Freezable" />。</param>
        <summary>使当前实例成为指定 <see cref="T:System.Windows.Freezable" /> 的冻结克隆。 如果对象具有动画依赖属性，则复制其当前的动画值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由方法调用， <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 不应在代码中直接调用，除非在重写此方法时调用基实现。 若要创建当前对象的冻结副本，请调用， <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果是从派生的 <see cref="T:System.Windows.Freezable" /> ，则可能需要重写此方法。 重写的原因包括： 
-派生类具有未通过依赖属性公开的数据。  
  
-派生类必须执行额外的初始化工作，而不能通过简单地重写来完成此操作 <see cref="M:System.Windows.Freezable.CreateInstanceCore" /> 。 例如，如果您的派生类实现了，则这种情况适用 <see cref="T:System.ComponentModel.ISupportInitialize" /> 。  
  
将其所有数据存储在依赖属性中并且无需执行额外的初始化工作的类不需要重写 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> 。  
  
所有实现都必须调用此方法的基实现，这一点非常重要。 实现仅应执行默认实现不执行的工作。 默认实现使用方法创建一个新的， <see cref="T:System.Windows.Freezable" /> <see cref="M:System.Windows.Freezable.CreateInstance" /> 并为其包含的所有其他可写的本地设置的属性生成未冻结的可冻结对象和浅层副本的深层副本。 如果对象具有数据绑定依赖项属性，则会复制数据绑定，但这些绑定可能不再解析;有关克隆数据绑定对象的详细信息，请参阅 [冻结对象概述](/dotnet/framework/wpf/advanced/freezable-objects-overview)。 如果对象具有动画依赖属性，则会复制这些属性的当前动画值，但不会复制动画。  
  
<see cref="T:System.Windows.Freezable" />此默认实现不会复制中的只读依赖项属性。  
  
如果重写此方法，则必须调用基实现。  
  
不需要在 <see cref="M:System.Windows.Freezable.Freeze" /> 复制值时进行值。  在返回前，结果会被冻结 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 。</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示对象当前是否可修改。</summary>
        <value>如果该对象已被冻结且无法修改，则为 <see langword="true" />；如果可以修改该对象，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当对象的属性引发时，尝试修改该对象 <xref:System.Windows.Freezable.IsFrozen%2A> `true` <xref:System.InvalidOperationException> 。  
  
 从对象模型的角度来看，此属性是只读的。 当 <xref:System.Windows.Freezable> 讨论的其他方法的行为时，某些行为相关的文档可能会提到 "设置 <xref:System.Windows.Freezable.IsFrozen%2A> 为 `true` " 或类似的语言 <xref:System.Windows.Freezable> ，但当实例的方法操作抽象类中存在的私有变量时，该类实例内部会出现此行为。 若要设置此属性的值，应调用 <xref:System.Windows.Freezable.Freeze%2A> 。 这实际上只是一次操作，用于将 <xref:System.Windows.Freezable.IsFrozen%2A> 属性从初始默认状态更改 `false` 为 `true` 状态。 没有将值设置回的可用方法 `false` 。 相反，您可以更改从原始 (进行的任何深层复制，请参阅 <xref:System.Windows.Freezable.Clone%2A>) 的方法。 这是设计使然，并且是在应用于模式有用情况时，派生类的行为方式 <xref:System.Windows.Freezable> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>修改当前 <see cref="T:System.Windows.Freezable" /> 对象时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每当发生事件时，都会调用此方法 <xref:System.Windows.Freezable.Changed> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现派生自的类时，可以 <see cref="T:System.Windows.Freezable" /> 重写此方法以执行任务。</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确保为刚刚修改的类型 <see cref="T:System.Windows.DependencyObject" /> 的数据成员建立适当的上下文指针。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">数据成员以前的值。</param>
        <param name="newValue">数据成员当前的值。</param>
        <summary>确保为刚刚设置的 <see cref="T:System.Windows.DependencyObjectType" /> 数据成员建立适当的上下文指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>每次 <xref:System.Windows.DependencyObject> 不将存储为的数据成员设置为时，继承者都应调用此方法 <xref:System.Windows.DependencyProperty> 。  
  
 对于 <xref:System.Windows.DependencyObject> 使用存储的数据成员，不需要调用此方法 <xref:System.Windows.DependencyProperty> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">数据成员以前的值。</param>
        <param name="newValue">数据成员当前的值。</param>
        <param name="property">已更改的属性。</param>
        <summary>此成员支持 Windows Presentation Foundation (WPF) 基础结构，不应在代码中直接使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含有关已更改的属性的信息及其旧值和新值的事件数据。</param>
        <summary>重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 实现，以同时调用任何响应类型 <see cref="T:System.Windows.Freezable" /> 不断变化的依赖属性的 <see cref="E:System.Windows.Freezable.Changed" /> 处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件数据只包含其自身的相关信息 <xref:System.Windows.Freezable> 。 必须通过处理程序获取任何子属性信息 <xref:System.Windows.Freezable.Changed> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确保正在从有效的线程访问 <see cref="T:System.Windows.Freezable" />。 <see cref="T:System.Windows.Freezable" /> 的继承者必须在任何 API 一开始读取不属于依赖项对象的数据成员时调用此方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>派生自的类 <see cref="T:System.Windows.Freezable" /> 应在 <see cref="M:System.Windows.Freezable.ReadPreamble" /> 尝试访问任何非依赖属性成员之前调用方法。 在将 <see cref="M:System.Windows.Freezable.WritePreamble" /> 任何此类成员写入之前，应调用方法。  
  
此方法实际上不会调用任何操作 <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" /> 。</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see cref="T:System.Windows.Freezable" /> 的 <see cref="E:System.Windows.Freezable.Changed" /> 事件并调用其 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。 从 <see cref="T:System.Windows.Freezable" /> 派生的类应在修改的类成员不存储为依赖属性的任何 API 的末尾调用此方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>派生自的类 <see cref="T:System.Windows.Freezable" /> 应在任何修改未存储为的类成员的 API 的末尾调用此方法 <see cref="T:System.Windows.DependencyProperty" /> 。</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>验证 <see cref="T:System.Windows.Freezable" /> 是否未被冻结，并且是否正在从有效的线程上下文中访问它。 <see cref="T:System.Windows.Freezable" /> 的继承项应当在任何 API 一开始写入不属于依赖项属性的数据成员时调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 来验证线程上下文是否可访问，如果实例已冻结，则会引发异常 <xref:System.Windows.Freezable> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> 实例已冻结，并且无法写入其成员。</exception>
        <block subset="none" type="overrides"><para>派生自的类 <see cref="T:System.Windows.Freezable" /> 应 <see cref="M:System.Windows.Freezable.WritePreamble" /> 在尝试写入非依赖项属性的任何成员之前调用。 如果 <see cref="M:System.Windows.Freezable.WritePreamble" /> 在 API 中调用，则可忽略对的调用 <see cref="M:System.Windows.Freezable.ReadPreamble" /> 。</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>
