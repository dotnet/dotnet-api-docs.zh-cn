<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bb68fb04ebde74e761b9ede3333f4311befe68cf" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86640118" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Window extends System.Windows.Controls.ContentControl" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="fed4d-101">提供创建、配置、显示和管理窗口和对话框的生存期的能力。</span><span class="sxs-lookup"><span data-stu-id="fed4d-101">Provides the ability to create, configure, show, and manage the lifetime of windows and dialog boxes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-102">用户与独立应用程序之间的交互点是一个窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-102">The point of interaction between a user and a standalone application is a window.</span></span> <span data-ttu-id="fed4d-103">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]窗口包括两个不同的区域：</span><span class="sxs-lookup"><span data-stu-id="fed4d-103">A [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] window consists of two distinct areas:</span></span>  
  
-   <span data-ttu-id="fed4d-104">承载 windows 修饰的非工作区，包括图标、标题、系统菜单、最小化按钮、最大化按钮、还原按钮、关闭按钮和边框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-104">A non-client area, which hosts the windows adornments, including an icon, title, System menu, minimize button, maximize button, restore button, close button, and a border.</span></span>  
  
-   <span data-ttu-id="fed4d-105">承载特定于应用程序的内容的工作区。</span><span class="sxs-lookup"><span data-stu-id="fed4d-105">A client area, which hosts application-specific content.</span></span>  
  
 <span data-ttu-id="fed4d-106">标准窗口如下图所示：</span><span class="sxs-lookup"><span data-stu-id="fed4d-106">A standard window is shown in the following figure:</span></span>  
  
 <span data-ttu-id="fed4d-107">![窗口元素](~/add/media/windowoverviewfigure1.PNG "窗口元素")</span><span class="sxs-lookup"><span data-stu-id="fed4d-107">![Window elements](~/add/media/windowoverviewfigure1.PNG "Window elements")</span></span>  
  
 <span data-ttu-id="fed4d-108"><xref:System.Windows.Window> 封装了创建、配置、显示和管理窗口和对话框的生存期的功能，并提供了以下关键服务：</span><span class="sxs-lookup"><span data-stu-id="fed4d-108"><xref:System.Windows.Window> encapsulates the ability to create, configure, show, and manage the lifetime of both windows and dialog boxes, and provides the following key services:</span></span>  
  
 <span data-ttu-id="fed4d-109">**生存期管理**： <xref:System.Windows.Window.Activate%2A> 、 <xref:System.Windows.Window.Activated> 、、、、、 <xref:System.Windows.Window.Close%2A> 、、 <xref:System.Windows.Window.Closed> <xref:System.Windows.Window.Closing> <xref:System.Windows.Window.Deactivated> <xref:System.Windows.Window.Hide%2A> <xref:System.Windows.Window.IsActive%2A> <xref:System.Windows.Window.Show%2A> 、 <xref:System.Windows.Window.SourceInitialized> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-109">**Lifetime Management**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.</span></span>  
  
 <span data-ttu-id="fed4d-110">**窗口管理**： <xref:System.Windows.Window.GetWindow%2A> 、 <xref:System.Windows.Window.OwnedWindows%2A> 、 <xref:System.Windows.Window.Owner%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-110">**Window Management**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-111">**外观和行为**： <xref:System.Windows.Window.AllowsTransparency%2A> 、 <xref:System.Windows.Window.ContentRendered> 、 <xref:System.Windows.Window.DragMove%2A> 、 <xref:System.Windows.Window.Icon%2A> 、 <xref:System.Windows.Window.Left%2A> 、 <xref:System.Windows.Window.LocationChanged> <xref:System.Windows.Window.ResizeMode%2A> <xref:System.Windows.Window.RestoreBounds%2A> <xref:System.Windows.Window.ShowActivated%2A> <xref:System.Windows.Window.ShowInTaskbar%2A> <xref:System.Windows.Window.SizeToContent%2A> <xref:System.Windows.Window.StateChanged> <xref:System.Windows.Window.Title%2A> <xref:System.Windows.Window.Top%2A> <xref:System.Windows.Window.Topmost%2A> <xref:System.Windows.Window.WindowStartupLocation%2A> <xref:System.Windows.Window.WindowState%2A> 、、、、、、、、、、、、 <xref:System.Windows.Window.WindowStyle%2A></span><span class="sxs-lookup"><span data-stu-id="fed4d-111">**Appearance and Behavior**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A></span></span>  
  
 <span data-ttu-id="fed4d-112">**对话框**： <xref:System.Windows.Window.DialogResult%2A> 、 <xref:System.Windows.Window.ShowDialog%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-112">**Dialog Boxes**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-113">此外，还 <xref:System.Windows.Application> 公开了对管理应用程序中所有窗口的特殊支持：</span><span class="sxs-lookup"><span data-stu-id="fed4d-113">Additionally, <xref:System.Windows.Application> exposes special support for managing all of the windows in an application:</span></span>  
  
-   <span data-ttu-id="fed4d-114">应用程序维护当前在应用程序中实例化的所有窗口的列表。</span><span class="sxs-lookup"><span data-stu-id="fed4d-114">Application maintains a list of all the windows that are currently instantiated in the application.</span></span> <span data-ttu-id="fed4d-115">此列表由 <xref:System.Windows.Application.Windows%2A> 属性公开。</span><span class="sxs-lookup"><span data-stu-id="fed4d-115">This list is exposed by the <xref:System.Windows.Application.Windows%2A> property.</span></span>  
  
-   <span data-ttu-id="fed4d-116">默认情况下， <xref:System.Windows.Application.MainWindow%2A> 将使用对 <xref:System.Windows.Window> 应用程序中实例化的第一个的引用自动设置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-116">By default, <xref:System.Windows.Application.MainWindow%2A> is automatically set with a reference to the first <xref:System.Windows.Window> that is instantiated in an application.</span></span> <span data-ttu-id="fed4d-117">从而使窗口成为主应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-117">This thereby making the window the main application window.</span></span>  
  
 <span data-ttu-id="fed4d-118"><xref:System.Windows.Window>可以使用标记、标记和代码隐藏或代码来实现。</span><span class="sxs-lookup"><span data-stu-id="fed4d-118">A <xref:System.Windows.Window> can be implemented using markup, markup and code-behind, or code.</span></span>  
  
 <span data-ttu-id="fed4d-119"><xref:System.Windows.Window> 主要用于显示独立应用程序的窗口和对话框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-119"><xref:System.Windows.Window> is primarily used to display windows and dialog boxes for standalone applications.</span></span> <span data-ttu-id="fed4d-120">但是，对于需要在窗口级别导航的应用程序（如向导），可以改为使用 <xref:System.Windows.Navigation.NavigationWindow> ; <xref:System.Windows.Navigation.NavigationWindow> 从派生 <xref:System.Windows.Window> ，并使用浏览器样式的导航支持对其进行扩展。</span><span class="sxs-lookup"><span data-stu-id="fed4d-120">However, for applications that require navigation at the window level, such as wizards, you can use <xref:System.Windows.Navigation.NavigationWindow> instead; <xref:System.Windows.Navigation.NavigationWindow> derives from <xref:System.Windows.Window> and extends it with browser-style navigation support.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-121">可使用将可导航内容孤岛合并到其他内容和内容容器 <xref:System.Windows.Controls.Frame> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-121">Islands of navigable content can be incorporated into other content and content containers using <xref:System.Windows.Controls.Frame>.</span></span>  
  
 <span data-ttu-id="fed4d-122"><xref:System.Windows.Window> 需要 `UnmanagedCode` 实例化安全权限。</span><span class="sxs-lookup"><span data-stu-id="fed4d-122"><xref:System.Windows.Window> needs `UnmanagedCode` security permission to be instantiated.</span></span> <span data-ttu-id="fed4d-123">这会产生以下影响：</span><span class="sxs-lookup"><span data-stu-id="fed4d-123">This has the following consequences:</span></span>  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]<span data-ttu-id="fed4d-124">在从 Internet 或本地 Intranet 区域启动时，部署的独立应用程序将请求权限提升。</span><span class="sxs-lookup"><span data-stu-id="fed4d-124">-deployed standalone applications will request permission elevation when launched from either the Internet or Local Intranet zones.</span></span>  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] <span data-ttu-id="fed4d-125">这会请求任何小于完全权限的权限将无法实例化 windows 或对话框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-125">that request anything less than full permissions will not be able to instantiate windows or dialog boxes.</span></span>  
  
 <span data-ttu-id="fed4d-126">有关独立应用程序部署和安全注意事项的信息，请参阅 [WPF 安全策略-平台安全性](/dotnet/framework/wpf/wpf-security-strategy-platform-security)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-126">For information about standalone application deployment and security considerations, see [WPF Security Strategy - Platform Security](/dotnet/framework/wpf/wpf-security-strategy-platform-security).</span></span>  
  
 <span data-ttu-id="fed4d-127"><xref:System.Windows.Window>是 <xref:System.Windows.Controls.ContentControl> ，这意味着它可以包含任何类型的单个对象 (例如字符串、图像或面板) 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-127">A <xref:System.Windows.Window> is a <xref:System.Windows.Controls.ContentControl>, which means that it can contain a single object of any type (such as a string, an image, or a panel).</span></span> <span data-ttu-id="fed4d-128">有关更多信息，请参见 <xref:System.Windows.Controls.ContentControl> 类。</span><span class="sxs-lookup"><span data-stu-id="fed4d-128">For more information, see the <xref:System.Windows.Controls.ContentControl> class.</span></span> <span data-ttu-id="fed4d-129">另外， <xref:System.Windows.Window> 是根元素，因此，不能是另一个元素的内容的一部分。</span><span class="sxs-lookup"><span data-stu-id="fed4d-129">Also, <xref:System.Windows.Window> is a root element and, therefore, cannot be part of another element's content.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-130">在 <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.Width%2A> <xref:System.Windows.Window.Top%2A> <xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window> 运行时将不应用通过样式设置的、、和属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-130">The <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, and <xref:System.Windows.Window.Left%2A> properties set on a <xref:System.Windows.Window> through a style will not be applied at run time.</span></span>  
  
## <a name="customizing-the-window-control"></a><span data-ttu-id="fed4d-131">自定义窗口控件</span><span class="sxs-lookup"><span data-stu-id="fed4d-131">Customizing the Window Control</span></span>  
 <span data-ttu-id="fed4d-132">若要对多个控件应用相同的属性设置 <xref:System.Windows.Window> ，请使用 <xref:System.Windows.FrameworkElement.Style%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-132">To apply the same property settings to multiple <xref:System.Windows.Window> controls, use the <xref:System.Windows.FrameworkElement.Style%2A> property.</span></span> <span data-ttu-id="fed4d-133">您可以修改默认值 <xref:System.Windows.Controls.ControlTemplate> ，为控件指定独特的外观。</span><span class="sxs-lookup"><span data-stu-id="fed4d-133">You can modify the default <xref:System.Windows.Controls.ControlTemplate> to give the control a unique appearance.</span></span> <span data-ttu-id="fed4d-134">有关创建的详细信息 <xref:System.Windows.Controls.ControlTemplate> ，请参阅 [通过创建 System.windows.controls.controltemplate> 自定义现有控件的外观](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-134">For more information about creating a <xref:System.Windows.Controls.ControlTemplate>, see [Customizing the Appearance of an Existing Control by Creating a ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control).</span></span>  <span data-ttu-id="fed4d-135">若要查看特定于的部分和状态，请 <xref:System.Windows.Window> 参阅 [窗口样式和模板](/dotnet/framework/wpf/controls/window-styles-and-templates)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-135">To see the parts and states that are specific to the <xref:System.Windows.Window>, see [Window Styles and Templates](/dotnet/framework/wpf/controls/window-styles-and-templates).</span></span>  
  
 <span data-ttu-id="fed4d-136">此控件的依赖属性可能由控件的默认样式设置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-136">Dependency properties for this control might be set by the control's default style.</span></span>  <span data-ttu-id="fed4d-137">如果按默认样式设置属性，则当控件出现在应用程序中时，属性可能会更改为默认值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-137">If a property is set by a default style, the property might change from its default value when the control appears in the application.</span></span> <span data-ttu-id="fed4d-138">默认样式取决于应用程序运行时使用的桌面主题。</span><span class="sxs-lookup"><span data-stu-id="fed4d-138">The default style is determined by which desktop theme is used when the application is running.</span></span>  <span data-ttu-id="fed4d-139">有关详细信息，请参阅 [默认的 WPF 主题](https://go.microsoft.com/fwlink/?LinkID=158252)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-139">For more information, see [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).</span></span>  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 <span data-ttu-id="fed4d-140">下面的示例演示如何使用仅标记定义标准窗口：</span><span class="sxs-lookup"><span data-stu-id="fed4d-140">The following example shows how a standard window is defined using only markup:</span></span>  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 <span data-ttu-id="fed4d-141">下面的示例演示如何使用代码仅定义标准窗口：</span><span class="sxs-lookup"><span data-stu-id="fed4d-141">The following example shows how a standard window is defined using only code:</span></span>  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 <span data-ttu-id="fed4d-142">下面的示例演示如何使用标记和代码隐藏的组合定义标准窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-142">The following example shows how a standard window is defined using a combination of markup and code-behind.</span></span>  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-143">初始化 <see cref="T:System.Windows.Window" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="fed4d-143">Initializes a new instance of the <see cref="T:System.Windows.Window" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-144">构造函数将 <xref:System.Windows.FrameworkElement.Width%2A> 、 <xref:System.Windows.FrameworkElement.Height%2A> 、 <xref:System.Windows.Window.Top%2A> 和属性初始化 <xref:System.Windows.Window.Left%2A> 为其默认 <xref:System.Windows.Window> 值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-144">The constructor initializes the <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, and <xref:System.Windows.Window.Left%2A> properties to their default <xref:System.Windows.Window> values.</span></span>  
  
 <span data-ttu-id="fed4d-145">如果在具有对象的中创建窗口 <xref:System.AppDomain> <xref:System.Windows.Application> ，则构造函数 <xref:System.Windows.Window> 通过对象的属性将对象添加到 <xref:System.Windows.Application> 托管窗口集 <xref:System.Windows.Application.Windows%2A> <xref:System.Windows.Application> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-145">If a window is created within an <xref:System.AppDomain> that has an <xref:System.Windows.Application> object, the constructor adds the <xref:System.Windows.Window> object to the set of <xref:System.Windows.Application>-managed windows via the <xref:System.Windows.Application.Windows%2A> property of the <xref:System.Windows.Application> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-146">尝试将窗口置于前台并激活它。</span><span class="sxs-lookup"><span data-stu-id="fed4d-146">Attempts to bring the window to the foreground and activates it.</span></span></summary>
        <returns><span data-ttu-id="fed4d-147">如果成功激活了 <see cref="T:System.Windows.Window" />，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-147"><see langword="true" /> if the <see cref="T:System.Windows.Window" /> was successfully activated; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-148">确定窗口是否激活的规则与函数使用的规则 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` ( # A0) 相同。</span><span class="sxs-lookup"><span data-stu-id="fed4d-148">The rules that determine whether the window is activated are the same as those used by the [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` function (User32.dll).</span></span>  
  
 <span data-ttu-id="fed4d-149">如果在不是用户的前景应用程序的 Windows Presentation Foundation 应用程序中激活该窗口，则 <xref:System.Windows.Application.Activated> 会引发事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-149">If the window is activated in a Windows Presentation Foundation application that is not the user's foreground application, <xref:System.Windows.Application.Activated> event is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-150">当窗口承载于浏览器中时，不能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-150">This method cannot be called when a window is hosted in a browser.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-151">在窗口成为前台窗口时发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-151">Occurs when a window becomes the foreground window.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-152">激活窗口后 (成为前台窗口) 时间：</span><span class="sxs-lookup"><span data-stu-id="fed4d-152">A window is activated (becomes the foreground window) when:</span></span>  
  
-   <span data-ttu-id="fed4d-153">首先打开该窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-153">The window is first opened.</span></span>  
  
-   <span data-ttu-id="fed4d-154">用户通过使用鼠标、按 ALT + TAB 或从任务管理器中进行选择来切换到窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-154">A user switches to a window by selecting it with the mouse, pressing ALT+TAB, or from Task Manager.</span></span>  
  
-   <span data-ttu-id="fed4d-155">用户单击窗口的任务栏按钮。</span><span class="sxs-lookup"><span data-stu-id="fed4d-155">A user clicks the window's taskbar button.</span></span>  
  
 <span data-ttu-id="fed4d-156">需要检测激活时间的窗口可以处理 <xref:System.Windows.Window.Activated> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-156">Windows that need to detect when they become activate can handle the <xref:System.Windows.Window.Activated> event.</span></span>  
  
 <span data-ttu-id="fed4d-157">第一次激活窗口后，它可能会在其生存期内停用并多次重新激活。</span><span class="sxs-lookup"><span data-stu-id="fed4d-157">After a window is first activated, it may be deactivated and reactivated many times during its lifetime.</span></span> <span data-ttu-id="fed4d-158">如果应用程序的行为或状态取决于其激活状态，它可以 <xref:System.Windows.Window.IsActive%2A> 进行检查以确定它所在的激活状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-158">If an application's behavior or state depends on its activation state, it can inspect <xref:System.Windows.Window.IsActive%2A> to determine which activation state it's in.</span></span>  
  
 <span data-ttu-id="fed4d-159">应用程序也可以是 <xref:System.Windows.Application.Activated> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-159">An application can also be <xref:System.Windows.Application.Activated>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-160">获取或设置一个值，该值指示窗口的工作区是否支持透明。</span><span class="sxs-lookup"><span data-stu-id="fed4d-160">Gets or sets a value that indicates whether a window's client area supports transparency.</span></span></summary>
        <value><span data-ttu-id="fed4d-161">如果窗口支持透明，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-161"><see langword="true" /> if the window supports transparency; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-162">如果 <xref:System.Windows.Controls.Control.Background%2A> 将窗口的属性设置为透明色（ <xref:System.Windows.Media.Brushes.Transparent%2A> 例如，使用），窗口将保持不透明。</span><span class="sxs-lookup"><span data-stu-id="fed4d-162">When the <xref:System.Windows.Controls.Control.Background%2A> property of a window is set to a transparent color, using <xref:System.Windows.Media.Brushes.Transparent%2A> for example, the window remains opaque.</span></span> <span data-ttu-id="fed4d-163">这意味着桌面和任何正在运行的应用程序 "低于" 窗口都无法查看。</span><span class="sxs-lookup"><span data-stu-id="fed4d-163">This means that the desktop and any running applications "beneath" the window cannot be seen.</span></span> <span data-ttu-id="fed4d-164">若要启用此类型的透明度，则 <xref:System.Windows.Window.AllowsTransparency%2A> 必须设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-164">To enable this type of transparency, <xref:System.Windows.Window.AllowsTransparency%2A> must be set to `true`.</span></span>  
  
 <span data-ttu-id="fed4d-165"><xref:System.Windows.Window.AllowsTransparency%2A> 存在以帮助创建非矩形窗口，因此，当 <xref:System.Windows.Window.AllowsTransparency%2A> 设置为时， `true` 窗口的 <xref:System.Windows.Window.WindowStyle%2A> 属性必须设置为 <xref:System.Windows.WindowStyle.None> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-165"><xref:System.Windows.Window.AllowsTransparency%2A> exists to facilitate the creation of non-rectangular windows, and, consequently, when <xref:System.Windows.Window.AllowsTransparency%2A> is set to `true`, a window's <xref:System.Windows.Window.WindowStyle%2A> property must be set to <xref:System.Windows.WindowStyle.None>.</span></span>  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-166">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-166">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-167">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-167">Identifier field</span></span>|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|<span data-ttu-id="fed4d-168">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-168">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-169">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-169">None</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-170">一个具有除 <see cref="P:System.Windows.Window.WindowStyle" /> 以外的 <see cref="F:System.Windows.WindowStyle.None" /> 值的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-170">A window that has a <see cref="P:System.Windows.Window.WindowStyle" /> value of anything other than <see cref="F:System.Windows.WindowStyle.None" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-171">标识 <see cref="P:System.Windows.Window.AllowsTransparency" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-171">Identifies the <see cref="P:System.Windows.Window.AllowsTransparency" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds"><span data-ttu-id="fed4d-172">一个 <see cref="T:System.Windows.Size" />，反映窗口应该用来排列自身及其子元素的最终大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-172">A <see cref="T:System.Windows.Size" /> that reflects the final size that the window should use to arrange itself and its children.</span></span></param>
        <summary><span data-ttu-id="fed4d-173">重写此方法可对窗口及其子元素进行排列和大小调整。</span><span class="sxs-lookup"><span data-stu-id="fed4d-173">Override this method to arrange and size a window and its child elements.</span></span></summary>
        <returns><span data-ttu-id="fed4d-174">一个 <see cref="T:System.Windows.Size" />，反映所使用的实际大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-174">A <see cref="T:System.Windows.Size" /> that reflects the actual size that was used.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-175"><xref:System.Windows.Window.ArrangeOverride%2A> 当属性的值为时，不会调用 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Collapsed> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-175"><xref:System.Windows.Window.ArrangeOverride%2A> is not called when the <xref:System.Windows.UIElement.Visibility%2A> property has a value of <xref:System.Windows.Visibility.Collapsed>.</span></span> <span data-ttu-id="fed4d-176">如果属性的值 <xref:System.Windows.UIElement.Visibility%2A> 为 <xref:System.Windows.Visibility.Hidden> 或 <xref:System.Windows.Visibility.Visible> ， <xref:System.Windows.Window.ArrangeOverride%2A> 则调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-176">If the value of the <xref:System.Windows.UIElement.Visibility%2A> property is either <xref:System.Windows.Visibility.Hidden> or <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-177">当 <xref:System.Windows.Window.Show%2A> 调用或时 <xref:System.Windows.Window.ShowDialog%2A> ，的属性将 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> 设置为 <xref:System.Windows.Visibility.Visible> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-177">When either <xref:System.Windows.Window.Show%2A> or <xref:System.Windows.Window.ShowDialog%2A> are called, the <xref:System.Windows.UIElement.Visibility%2A> property of a <xref:System.Windows.Window> is set to <xref:System.Windows.Visibility.Visible>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-178">手动关闭 <see cref="T:System.Windows.Window" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-178">Manually closes a <see cref="T:System.Windows.Window" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-179"><xref:System.Windows.Window>可以使用位于其标题栏中的几个已知的、系统提供的机制之一来关闭。包括：</span><span class="sxs-lookup"><span data-stu-id="fed4d-179">A <xref:System.Windows.Window> can be closed using one of several, well-known, system-provided mechanisms located in its title bar, including:</span></span>  
  
-   <span data-ttu-id="fed4d-180">ALT + F4。</span><span class="sxs-lookup"><span data-stu-id="fed4d-180">ALT+F4.</span></span>  
  
-   <span data-ttu-id="fed4d-181">系统菜单 &#124; **关闭**。</span><span class="sxs-lookup"><span data-stu-id="fed4d-181">System menu &#124; **Close**.</span></span>  
  
-   <span data-ttu-id="fed4d-182">"**关闭**" 按钮。</span><span class="sxs-lookup"><span data-stu-id="fed4d-182">**Close** button.</span></span>  
  
 <span data-ttu-id="fed4d-183"><xref:System.Windows.Window>还可以使用开发人员提供的客户端区域中的几种已知机制之一将其关闭，其中包括：</span><span class="sxs-lookup"><span data-stu-id="fed4d-183">A <xref:System.Windows.Window> can also be closed using one of several well-known mechanisms within the client area that are provided by developers, including:</span></span>  
  
-   <span data-ttu-id="fed4d-184">**文件** &#124; 在主窗口上 **退出** 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-184">**File** &#124; **Exit** on a main window.</span></span>  
  
-   <span data-ttu-id="fed4d-185">**文件** &#124; **关闭** 或子窗口上的 " **关闭** " 按钮。</span><span class="sxs-lookup"><span data-stu-id="fed4d-185">**File** &#124; **Close** or a **Close** button on a child window.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-186">对话框中**Cancel**的 **"确定" 和 "取消"** 按钮也是开发人员提供的，尽管可能会设置 <xref:System.Windows.Window.DialogResult%2A> ，后者会自动关闭通过调用打开的窗口 <xref:System.Windows.Window.ShowDialog%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-186">**OK** and **Cancel** buttons on a dialog box are also developer-provided, although will likely set <xref:System.Windows.Window.DialogResult%2A>, which automatically closes a window that was opened by calling <xref:System.Windows.Window.ShowDialog%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-187">这些机制要求您显式调用 <xref:System.Windows.Window.Close%2A> 以关闭窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-187">These mechanisms require you to explicitly call <xref:System.Windows.Window.Close%2A> to close a window.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-188">如果通过调用打开的窗口， <xref:System.Windows.Window.ShowDialog%2A> 并将 <xref:System.Windows.Controls.Button> 其 <xref:System.Windows.Controls.Button.IsCancel%2A> 属性设置为 true，则在单击该按钮时将自动关闭，或按 ESC 键。</span><span class="sxs-lookup"><span data-stu-id="fed4d-188">If a window, opened by calling <xref:System.Windows.Window.ShowDialog%2A>, and with a <xref:System.Windows.Controls.Button> with its <xref:System.Windows.Controls.Button.IsCancel%2A> property set to true, will automatically close when the button is either clicked, or ESC is pressed.</span></span> <span data-ttu-id="fed4d-189">但是，如果使用打开窗口 <xref:System.Windows.Window.Show%2A> ， <xref:System.Windows.Window.Close%2A> 则必须显式调用，如从 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 的事件处理程序中 <xref:System.Windows.Controls.Button> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-189">If the window was opened using <xref:System.Windows.Window.Show%2A>, however, <xref:System.Windows.Window.Close%2A> must be explicitly called, such as from <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 <span data-ttu-id="fed4d-190">关闭窗口将导致 <xref:System.Windows.Window.Closing> 引发事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-190">Closing a window causes the <xref:System.Windows.Window.Closing> event to be raised.</span></span> <span data-ttu-id="fed4d-191">如果 <xref:System.Windows.Window.Closing> 事件未取消，则会发生以下情况：</span><span class="sxs-lookup"><span data-stu-id="fed4d-191">If the <xref:System.Windows.Window.Closing> event isn't canceled, the following occurs:</span></span>  
  
-   <span data-ttu-id="fed4d-192"><xref:System.Windows.Window> <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> 如果对象存在) ，则从 (中移除 <xref:System.Windows.Application> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-192">The <xref:System.Windows.Window> is removed from <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (if an <xref:System.Windows.Application> object exists).</span></span>  
  
-   <span data-ttu-id="fed4d-193"><xref:System.Windows.Window> <xref:System.Windows.Window> 如果在显示所有者/所属关系之前 <xref:System.Windows.Window> 以及在打开所有者后建立了所有者/拥有关系，则将从所有者中删除 <xref:System.Windows.Window> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-193">The <xref:System.Windows.Window> is removed from the owner <xref:System.Windows.Window> if the owner/owned relationship was established before the owned <xref:System.Windows.Window> was shown and after the owner <xref:System.Windows.Window> was opened.</span></span>  
  
-   <span data-ttu-id="fed4d-194">引发 <xref:System.Windows.Window.Closed> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-194">The <xref:System.Windows.Window.Closed> event is raised.</span></span>  
  
-   <span data-ttu-id="fed4d-195">将释放由创建的非托管资源 <xref:System.Windows.Window> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-195">Unmanaged resources created by the <xref:System.Windows.Window> are disposed.</span></span>  
  
-   <span data-ttu-id="fed4d-196">如果 <xref:System.Windows.Window.ShowDialog%2A> 调用以显示，则 <xref:System.Windows.Window> <xref:System.Windows.Window.ShowDialog%2A> 返回。</span><span class="sxs-lookup"><span data-stu-id="fed4d-196">If <xref:System.Windows.Window.ShowDialog%2A> was called to show the <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> returns.</span></span>  
  
 <span data-ttu-id="fed4d-197">关闭 <xref:System.Windows.Window> 会导致其拥有的所有窗口都处于关闭状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-197">Closing a <xref:System.Windows.Window> causes any windows that it owns to be closed.</span></span> <span data-ttu-id="fed4d-198">此外，关闭 <xref:System.Windows.Window> 可能会导致应用程序停止运行，具体取决于 <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> 属性的设置方式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-198">Furthermore, closing a <xref:System.Windows.Window> may cause an application to stop running depending on how the <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> property is set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-199">当窗口承载于浏览器中时，不能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-199">This method cannot be called when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-200">下面的示例演示要处理的 **文件** &#124; **退出** 菜单，以便进行显式调用 <xref:System.Windows.Window.Close%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-200">The following example shows a **File** &#124; **Exit** menu being handled to explicitly call <xref:System.Windows.Window.Close%2A>.</span></span>  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-201">在窗口即将关闭时发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-201">Occurs when the window is about to close.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-202">引发此事件后，将无法阻止窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-202">Once this event is raised, a window cannot be prevented from closing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-203">当窗口正在关闭时，将设置 <see cref="P:System.Windows.UIElement.Visibility" />，或者调用 <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" /> 或 <see cref="M:System.Windows.Window.Hide" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-203"><see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Hide" /> is called while a window is closing.</span></span></exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-204">在调用 <see cref="M:System.Windows.Window.Close" /> 之后立即发生，并且可进行处理以取消关闭窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-204">Occurs directly after <see cref="M:System.Windows.Window.Close" /> is called, and can be handled to cancel window closure.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-205"><xref:System.Windows.Window.Closing> 可以通过处理来检测窗口何时关闭 (例如，在 <xref:System.Windows.Window.Close%2A>) 调用时。</span><span class="sxs-lookup"><span data-stu-id="fed4d-205"><xref:System.Windows.Window.Closing> can be handled to detect when a window is being closed (for example, when <xref:System.Windows.Window.Close%2A> is called).</span></span> <span data-ttu-id="fed4d-206">此外， <xref:System.Windows.Window.Closing> 可用于阻止窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-206">Furthermore, <xref:System.Windows.Window.Closing> can be used to prevent a window from closing.</span></span> <span data-ttu-id="fed4d-207">若要阻止窗口关闭，可以将 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 参数的属性设置 <xref:System.ComponentModel.CancelEventArgs> 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-207">To prevent a window from closing, you can set the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> property of the <xref:System.ComponentModel.CancelEventArgs> argument to `true`.</span></span>  
  
 <span data-ttu-id="fed4d-208"><xref:System.Windows.Window.Closing> <xref:System.Windows.Window.Close%2A> 如果单击窗口的 "关闭" 按钮或用户按 ALT + F4，则在调用时引发事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-208">The <xref:System.Windows.Window.Closing> event is raised when <xref:System.Windows.Window.Close%2A> is called, if a window's Close button is clicked, or if the user presses ALT+F4.</span></span>  
  
 <span data-ttu-id="fed4d-209">如果拥有的窗口是由其所有者窗口使用打开的 <xref:System.Windows.Window.Show%2A> ，并且 "所有者" 窗口关闭，则不会引发所拥有的窗口的 <xref:System.Windows.Window.Closing> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-209">If an owned window was opened by its owner window using <xref:System.Windows.Window.Show%2A>, and the owner window is closed, the owned window's <xref:System.Windows.Window.Closing> event is not raised.</span></span> <span data-ttu-id="fed4d-210">如果关闭窗口的所有者 (请参阅 <xref:System.Windows.Window.Owner%2A>) ， <xref:System.Windows.Window.Closing> 不会在拥有的窗口上引发。</span><span class="sxs-lookup"><span data-stu-id="fed4d-210">If the owner of a window is closed (see <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> is not raised on the owned window.</span></span>  
  
 <span data-ttu-id="fed4d-211">如果 <xref:System.Windows.Application.Shutdown%2A> 调用了，则 <xref:System.Windows.Window.Closing> 会引发每个窗口的事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-211">If <xref:System.Windows.Application.Shutdown%2A> is called, the <xref:System.Windows.Window.Closing> event for each window is raised.</span></span> <span data-ttu-id="fed4d-212">但是，如果 <xref:System.Windows.Window.Closing> 取消，将忽略取消。</span><span class="sxs-lookup"><span data-stu-id="fed4d-212">However, if <xref:System.Windows.Window.Closing> is canceled, cancellation is ignored.</span></span>  
  
 <span data-ttu-id="fed4d-213">如果会话由于用户注销或关闭而结束， <xref:System.Windows.Window.Closing> 则不会引发; 处理 <xref:System.Windows.Application.SessionEnding> 以实现取消应用程序闭包的代码。</span><span class="sxs-lookup"><span data-stu-id="fed4d-213">If a session ends because a user logs off or shuts down, <xref:System.Windows.Window.Closing> is not raised; handle <xref:System.Windows.Application.SessionEnding> to implement code that cancels application closure.</span></span>  
  
 <span data-ttu-id="fed4d-214">如果要在应用程序的生存期内多次显示和隐藏窗口，并且不希望在每次显示窗口时化窗口，则可以处理该 <xref:System.Windows.Window.Closing> 事件，将其取消，然后调用 <xref:System.Windows.Window.Hide%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-214">If you want to show and hide a window multiple times during the lifetime of an application, and you don't want to reinstantiate the window each time you show it, you can handle the <xref:System.Windows.Window.Closing> event, cancel it, and call the <xref:System.Windows.Window.Hide%2A> method.</span></span> <span data-ttu-id="fed4d-215">然后，可以 <xref:System.Windows.Window.Show%2A> 在同一实例上调用以重新打开它。</span><span class="sxs-lookup"><span data-stu-id="fed4d-215">Then, you can call <xref:System.Windows.Window.Show%2A> on the same instance to reopen it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-216">下面的示例演示一个 <xref:System.Windows.Window> ，它确定是否需要用户干预才能关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-216">The following example demonstrates a <xref:System.Windows.Window> that determines whether it needs user intervention to close.</span></span>  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-217">当窗口正在关闭时，将设置 <see cref="P:System.Windows.UIElement.Visibility" />，或者调用 <see cref="M:System.Windows.Window.Show" />、<see cref="M:System.Windows.Window.ShowDialog" /> 或 <see cref="M:System.Windows.Window.Close" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-217"><see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Close" /> is called while a window is closing.</span></span></exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContentRendered;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-218">在窗口的内容呈现完毕之后发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-218">Occurs after a window's content has been rendered.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-219">如果该窗口不包含任何内容，则不会引发此事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-219">If the window has no content, this event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-220">在窗口成为后台窗口时发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-220">Occurs when a window becomes a background window.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-221">停用窗口后 (成为后台窗口) ：</span><span class="sxs-lookup"><span data-stu-id="fed4d-221">A window is deactivated (becomes a background window) when:</span></span>  
  
-   <span data-ttu-id="fed4d-222">用户切换到当前应用程序中的另一个窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-222">A user switches to another window in the current application.</span></span>  
  
-   <span data-ttu-id="fed4d-223">用户使用 ALT + TAB 或使用任务管理器切换到另一个应用程序中的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-223">A user switches to the window in another application by using ALT+TAB or by using Task Manager.</span></span>  
  
-   <span data-ttu-id="fed4d-224">用户单击另一应用程序中窗口的任务栏按钮。</span><span class="sxs-lookup"><span data-stu-id="fed4d-224">A user clicks the taskbar button for a window in another application.</span></span>  
  
 <span data-ttu-id="fed4d-225">Windows，需要通过处理事件来检测它们何时变为停用状态 <xref:System.Windows.Window.Deactivated> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-225">Windows that need to detect when they become deactivated by handling the <xref:System.Windows.Window.Deactivated> event.</span></span>  
  
 <span data-ttu-id="fed4d-226">第一次停用窗口后，它可能会在其生存期内重新激活和停用多次。</span><span class="sxs-lookup"><span data-stu-id="fed4d-226">After a window is first deactivated, it may be reactivated and deactivated many times during its lifetime.</span></span> <span data-ttu-id="fed4d-227">如果应用程序的行为或状态取决于其激活状态，它可以 <xref:System.Windows.Window.IsActive%2A> 进行检查以确定它所在的激活状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-227">If an application's behavior or state depends on its activation state, it can inspect <xref:System.Windows.Window.IsActive%2A> to determine which activation state it's in.</span></span>  
  
 <span data-ttu-id="fed4d-228">应用程序也可以是 <xref:System.Windows.Application.Deactivated> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-228">An application can also be <xref:System.Windows.Application.Deactivated>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public bool? DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-229">获取或设置对话框结果值，此值是从 <see cref="M:System.Windows.Window.ShowDialog" /> 方法返回的值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-229">Gets or sets the dialog result value, which is the value that is returned from the <see cref="M:System.Windows.Window.ShowDialog" /> method.</span></span></summary>
        <value><span data-ttu-id="fed4d-230">一个 <see cref="T:System.Nullable`1" /> 类型的 <see cref="T:System.Boolean" /> 值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-230">A <see cref="T:System.Nullable`1" /> value of type <see cref="T:System.Boolean" />.</span></span> <span data-ttu-id="fed4d-231">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-231">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-232"><xref:System.Windows.Window.DialogResult%2A> 可从显示对话框的代码中使用，以确定用户是否接受 (`true`) 或取消 (`false`) 对话框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-232"><xref:System.Windows.Window.DialogResult%2A> can be used from the code that showed a dialog box to determine whether a user accepted (`true`) or canceled (`false`) the dialog box.</span></span> <span data-ttu-id="fed4d-233">如果接受了某个对话框，这将表示打开此对话框的代码以检索用户收集的数据并对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="fed4d-233">If a dialog box was accepted, this signifies to the code that opened the dialog box to retrieve the data that was collected by the user and process it.</span></span> <span data-ttu-id="fed4d-234">不过，如果已取消对话框，这表示调用代码应停止任何进一步的处理。</span><span class="sxs-lookup"><span data-stu-id="fed4d-234">If a dialog box was canceled, however, this signifies that calling code should stop any further processing.</span></span>  
  
 <span data-ttu-id="fed4d-235">默认情况下，当用户执行以下操作之一时，将取消对话框：</span><span class="sxs-lookup"><span data-stu-id="fed4d-235">By default, a dialog box is canceled when a user does one of the following:</span></span>  
  
-   <span data-ttu-id="fed4d-236">PressesALT + F4。</span><span class="sxs-lookup"><span data-stu-id="fed4d-236">PressesALT+F4.</span></span>  
  
-   <span data-ttu-id="fed4d-237">单击 " **关闭** " 按钮。</span><span class="sxs-lookup"><span data-stu-id="fed4d-237">Clicks the **Close** button.</span></span>  
  
-   <span data-ttu-id="fed4d-238">从 "系统" 菜单中选择 " **关闭** "。</span><span class="sxs-lookup"><span data-stu-id="fed4d-238">Selects **Close** from the System menu.</span></span>  
  
 <span data-ttu-id="fed4d-239">在所有这些情况下， <xref:System.Windows.Window.DialogResult%2A> `false` 默认为。</span><span class="sxs-lookup"><span data-stu-id="fed4d-239">In all of these cases, <xref:System.Windows.Window.DialogResult%2A> is `false` by default.</span></span>  
  
 <span data-ttu-id="fed4d-240">对话框通常提供取消对话框（其属性设置为的按钮）的特殊按钮 <xref:System.Windows.Controls.Button.IsCancel%2A> `true` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-240">A dialog box typically provides a special button to cancel a dialog, which is the button whose <xref:System.Windows.Controls.Button.IsCancel%2A> property is set to `true`.</span></span> <span data-ttu-id="fed4d-241">按此方式配置的按钮会在按下或按 ESC 键时自动关闭窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-241">A button configured this way will automatically close a window when either it is pressed, or when the ESC key is pressed.</span></span> <span data-ttu-id="fed4d-242">在这两种情况下，都将 <xref:System.Windows.Window.DialogResult%2A> 保留 `false` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-242">In either of these cases, <xref:System.Windows.Window.DialogResult%2A> remains `false`.</span></span>  
  
 <span data-ttu-id="fed4d-243">对话框通常还会提供 "接受" 按钮，该按钮是其 <xref:System.Windows.Controls.Button.IsDefault%2A> 属性设置为的按钮 `true` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-243">A dialog box also typically provides an accept button, which is the button whose <xref:System.Windows.Controls.Button.IsDefault%2A> property is set to `true`.</span></span> <span data-ttu-id="fed4d-244">按此方式配置的按钮会 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 在按下或按下 ENTER 键时引发其事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-244">A button configured this way will raise its <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event when either it or the ENTER key is pressed.</span></span> <span data-ttu-id="fed4d-245">但是，它不会自动关闭对话框，也不会将其设置 <xref:System.Windows.Window.DialogResult%2A> 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-245">However, it won't automatically close the dialog box, nor will it set <xref:System.Windows.Window.DialogResult%2A> to `true`.</span></span> <span data-ttu-id="fed4d-246">你需要手动编写此代码，通常来自 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 默认按钮的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="fed4d-246">You need to manually write this code, usually from the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler for the default button.</span></span>  
  
 <span data-ttu-id="fed4d-247"><xref:System.Windows.Window.DialogResult%2A>`null`显示对话框时，但不接受也不取消。</span><span class="sxs-lookup"><span data-stu-id="fed4d-247"><xref:System.Windows.Window.DialogResult%2A> is `null` when the dialog box is shown but neither accepted nor canceled.</span></span>  
  
 <span data-ttu-id="fed4d-248">对话框关闭后，可以从方法返回的值 <xref:System.Windows.Window.ShowDialog%2A> 或通过检查属性来获取对话框结果 <xref:System.Windows.Window.DialogResult%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-248">After a dialog box closes, you can get the dialog result from the value returned by <xref:System.Windows.Window.ShowDialog%2A> method, or by inspecting the <xref:System.Windows.Window.DialogResult%2A> property.</span></span>  
  
 <span data-ttu-id="fed4d-249"><xref:System.Windows.Window.DialogResult%2A> 只能在 <xref:System.Windows.Window> 通过调用其方法打开时设置 <xref:System.Windows.Window.ShowDialog%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-249"><xref:System.Windows.Window.DialogResult%2A> can only be set when a <xref:System.Windows.Window> is opened by calling its <xref:System.Windows.Window.ShowDialog%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-250">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-250">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-251">下面的示例演示如何配置 "确定" 按钮和 "取消" 按钮以返回相应的 <xref:System.Windows.Window.DialogResult%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-251">The following example shows how to configure an OK button and a Cancel button to return the appropriate <xref:System.Windows.Window.DialogResult%2A>.</span></span>  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-252">设置<see cref="P:System.Windows.Window.DialogResult" /> 在通过调用 <see cref="M:System.Windows.Window.ShowDialog" /> 打开窗口之前。</span><span class="sxs-lookup"><span data-stu-id="fed4d-252"><see cref="P:System.Windows.Window.DialogResult" /> is set before a window is opened by calling <see cref="M:System.Windows.Window.ShowDialog" />.</span></span>  
  
<span data-ttu-id="fed4d-253">- 或 -</span><span class="sxs-lookup"><span data-stu-id="fed4d-253">-or-</span></span> 
 <span data-ttu-id="fed4d-254">通过调用 <see cref="P:System.Windows.Window.DialogResult" /> 设置 <see cref="M:System.Windows.Window.Show" /> 至打开的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-254"><see cref="P:System.Windows.Window.DialogResult" /> is set on a window that is opened by calling <see cref="M:System.Windows.Window.Show" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-255">显示窗口的屏幕的 DPI 发生更改后出现。</span><span class="sxs-lookup"><span data-stu-id="fed4d-255">Occurs after the DPI of the screen on which the Window is displayed changes.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-256">显示该窗口的屏幕的 DPI 发生更改时使用的 <see cref="T:System.Windows.RoutedEvent" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-256">A <see cref="T:System.Windows.RoutedEvent" /> for when the DPI of the screen the Window is on changes.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-257">允许使用在窗口工作区的暴露区域上方按下其鼠标左键的鼠标来拖动窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-257">Allows a window to be dragged by a mouse with its left button down over an exposed area of the window's client area.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-258">调用时，必须关闭鼠标左键 <xref:System.Windows.Window.DragMove%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-258">The left mouse button must be down when <xref:System.Windows.Window.DragMove%2A> is called.</span></span> <span data-ttu-id="fed4d-259">检测按下鼠标左键的时间的一种方法是处理 <xref:System.Windows.UIElement.MouseLeftButtonDown> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-259">One way to detect when the left mouse button is pressed is to handle the <xref:System.Windows.UIElement.MouseLeftButtonDown> event.</span></span>  
  
 <span data-ttu-id="fed4d-260"><xref:System.Windows.Window.DragMove%2A>调用时，必须在窗口工作区的公开区域上按下鼠标左键。</span><span class="sxs-lookup"><span data-stu-id="fed4d-260">When <xref:System.Windows.Window.DragMove%2A> is called, the left mouse button must be depressed over an exposed area of the window's client area.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-261">当窗口承载于浏览器中时，不能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-261">This method cannot be called when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-262">下面的示例演示如何重写 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 以调用 <xref:System.Windows.Window.DragMove%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-262">The following example shows how to override <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> to call <xref:System.Windows.Window.DragMove%2A>.</span></span>  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-263">鼠标左键未按下。</span><span class="sxs-lookup"><span data-stu-id="fed4d-263">The left mouse button is not down.</span></span></exception>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWindow (dependencyObject As DependencyObject) As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject"><span data-ttu-id="fed4d-264">依赖项对象。</span><span class="sxs-lookup"><span data-stu-id="fed4d-264">The dependency object.</span></span></param>
        <summary><span data-ttu-id="fed4d-265">返回对 <see cref="T:System.Windows.Window" /> 对象的引用，该对象承载依赖项对象所在的内容树。</span><span class="sxs-lookup"><span data-stu-id="fed4d-265">Returns a reference to the <see cref="T:System.Windows.Window" /> object that hosts the content tree within which the dependency object is located.</span></span></summary>
        <returns><span data-ttu-id="fed4d-266">对宿主窗口的 <see cref="T:System.Windows.Window" /> 引用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-266">A <see cref="T:System.Windows.Window" /> reference to the host window.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="fed4d-267"><paramref name="dependencyObject" /> 为 null。</span><span class="sxs-lookup"><span data-stu-id="fed4d-267"><paramref name="dependencyObject" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-268">使窗口不可见。</span><span class="sxs-lookup"><span data-stu-id="fed4d-268">Makes a window invisible.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-269">当窗口处于隐藏状态时，它不会关闭，同时 <xref:System.Windows.Window.Closing> 也不 <xref:System.Windows.Window.Closed> 会引发和事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-269">A window is not closed when it is hidden, and neither the <xref:System.Windows.Window.Closing> nor <xref:System.Windows.Window.Closed> event is raised.</span></span> <span data-ttu-id="fed4d-270">相反，窗口的 <xref:System.Windows.UIElement.Visibility%2A> 属性设置为 <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-270">Instead, the window's <xref:System.Windows.UIElement.Visibility%2A> property is set to <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="fed4d-271">如果某个窗口是应用程序， <xref:System.Windows.Application.MainWindow%2A> 并且应用程序的 <xref:System.Windows.Application.ShutdownMode%2A> 为 <xref:System.Windows.ShutdownMode.OnMainWindowClose> ，则应用程序不会关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-271">If a window is the application's <xref:System.Windows.Application.MainWindow%2A> and the application's <xref:System.Windows.Application.ShutdownMode%2A> is <xref:System.Windows.ShutdownMode.OnMainWindowClose>, the application does not shut down.</span></span> <span data-ttu-id="fed4d-272">同样，如果窗口是唯一窗口并且应用程序的关闭模式为，则应用程序不会关闭 <xref:System.Windows.ShutdownMode.OnLastWindowClose> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-272">Likewise, the application does not shut down if a window is the only window and the application's shutdown mode is <xref:System.Windows.ShutdownMode.OnLastWindowClose>.</span></span>  
  
 <span data-ttu-id="fed4d-273">如果要在应用程序的生存期内多次显示和隐藏窗口，并且不希望每次显示窗口时都重新实例化窗口，可以处理 <xref:System.Windows.Window.Closing> 事件，取消它，然后调用 <xref:System.Windows.Window.Hide%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-273">If you want to show and hide a window multiple times during the lifetime of an application, and you don't want to re-instantiate the window each time you show it, you can handle the <xref:System.Windows.Window.Closing> event, cancel it, and call the <xref:System.Windows.Window.Hide%2A> method.</span></span> <span data-ttu-id="fed4d-274">然后，可以 <xref:System.Windows.Window.Show%2A> 在同一实例上调用以重新打开它。</span><span class="sxs-lookup"><span data-stu-id="fed4d-274">Then, you can call <xref:System.Windows.Window.Show%2A> on the same instance to re-open it.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-275">对正在关闭 (<see cref="M:System.Windows.Window.Hide" />) 或已经关闭 (<see cref="E:System.Windows.Window.Closing" />) 的窗口调用 <see cref="E:System.Windows.Window.Closed" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-275"><see cref="M:System.Windows.Window.Hide" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</span></span></exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-276">获取或设置窗口的图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-276">Gets or sets a window's icon.</span></span></summary>
        <value><span data-ttu-id="fed4d-277">一个表示图标的 <see cref="T:System.Windows.Media.ImageSource" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fed4d-277">An <see cref="T:System.Windows.Media.ImageSource" /> object that represents the icon.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-278">Windows Presentation Foundation (WPF) 独立应用程序有两种类型的图标：</span><span class="sxs-lookup"><span data-stu-id="fed4d-278">Windows Presentation Foundation (WPF) standalone applications have two types of icons:</span></span>  
  
-   <span data-ttu-id="fed4d-279">一个程序集图标，它是使用 `<ApplicationIcon>` 应用程序的项目生成文件中的属性指定的。</span><span class="sxs-lookup"><span data-stu-id="fed4d-279">One assembly icon, which is specified by using the `<ApplicationIcon>` property in the application's project build file.</span></span> <span data-ttu-id="fed4d-280">此图标用作程序集的桌面图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-280">This icon is used as the desktop icon for an assembly.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="fed4d-281">在 Visual Studio 中进行调试时，你的图标可能不会由于承载进程而显示。</span><span class="sxs-lookup"><span data-stu-id="fed4d-281">When debugging in Visual Studio, your icon may not appear due to the hosting process.</span></span> <span data-ttu-id="fed4d-282">如果运行可执行文件，则会显示图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-282">If you run the executable, the icon will appear.</span></span> <span data-ttu-id="fed4d-283">有关详细信息，请参阅[托管进程 (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-283">For more information, see [Hosting Process (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).</span></span>  
  
-   <span data-ttu-id="fed4d-284">通过设置指定的每个窗口一个图标 <xref:System.Windows.Window.Icon%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-284">One icon per window that is specified by setting <xref:System.Windows.Window.Icon%2A>.</span></span> <span data-ttu-id="fed4d-285">对于每个窗口，此图标用于其标题栏、其任务栏按钮和其 ALT 选项卡应用程序选择列表项。</span><span class="sxs-lookup"><span data-stu-id="fed4d-285">For each window, this icon is used in its title bar, its task bar button, and in its ALT-TAB application selection list entry.</span></span>  
  
 <span data-ttu-id="fed4d-286">WPF 窗口始终显示一个图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-286">A WPF window always displays an icon.</span></span> <span data-ttu-id="fed4d-287">如果未通过设置提供一个，则 WPF 会根据 <xref:System.Windows.Window.Icon%2A> 以下规则选择要显示的图标：</span><span class="sxs-lookup"><span data-stu-id="fed4d-287">When one is not provided by setting <xref:System.Windows.Window.Icon%2A>, WPF chooses an icon to display based on the following rules:</span></span>  
  
1.  <span data-ttu-id="fed4d-288">如果已指定，则使用程序集图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-288">Use the assembly icon, if specified.</span></span>  
  
2.  <span data-ttu-id="fed4d-289">如果未指定程序集图标，则使用默认的 Microsoft Windows 图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-289">If the assembly icon is not specified, use the default Microsoft Windows icon.</span></span>  
  
 <span data-ttu-id="fed4d-290">如果使用 <xref:System.Windows.Window.Icon%2A> 指定自定义窗口图标，则可以通过将设置为来还原默认应用程序 <xref:System.Windows.Window.Icon%2A> 图标 `null` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-290">If you use <xref:System.Windows.Window.Icon%2A> to specify a custom window icon, you can restore the default application icon by setting <xref:System.Windows.Window.Icon%2A> to `null`.</span></span>  
  
 <span data-ttu-id="fed4d-291">在 Windows 中，可以通过多种方式使用单个图标，包括显示在窗口的标题栏、窗口的任务栏、"ALT + TAB 文件选择列表" 中。</span><span class="sxs-lookup"><span data-stu-id="fed4d-291">A single icon can be used in a variety of ways in Windows, including being shown in the title bar of a window, the task bar for a window, the ALT+TAB file selection list.</span></span> <span data-ttu-id="fed4d-292">其中每个显示使用不同大小的图标;16x16 像素图标将显示在窗口的标题栏和任务栏中，而32x32 像素图标则显示在 "ALT + TAB 文件选择列表" 中。</span><span class="sxs-lookup"><span data-stu-id="fed4d-292">Each of these shows the icon using a different size; a 16x16 pixel icon is displayed in the title bar of a window and in the task bar, while a 32x32 pixel icon is displayed in the ALT+TAB file selection list.</span></span> <span data-ttu-id="fed4d-293">某些应用程序（如 [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)] ）提供 " **视图** " 菜单，可用于选择要查看的图标的大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-293">Some applications, like [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], provide a **View** menu that allows you to choose the size of the icon you'd like to view.</span></span>  
  
 <span data-ttu-id="fed4d-294">为了满足各种显示大小的需要，图标文件由一个或多个实际的图标组成，其中每个图标都代表特定大小和颜色深度的图标版本。</span><span class="sxs-lookup"><span data-stu-id="fed4d-294">To cater to the various display sizes, an icon file is composed of one or more actual icons where each one represents a version of the icon that targets a specific size and color depth.</span></span> <span data-ttu-id="fed4d-295">例如，一个图标只能有一个16色的16x16 像素图标，而另一个图标可能包含16色和256色的16x16 像素和32x32 像素图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-295">For example, one icon may only have a single 16x16 pixel icon with 16 colors, while another may contain 16x16 pixel and 32x32 pixel icons with both 16 colors and 256 colors.</span></span>  
  
 <span data-ttu-id="fed4d-296">如果图标文件中存在所有可能大小和颜色深度的图标， <xref:System.Windows.Window> 将使用相应的图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-296">If icons for all possible sizes and color depths exist within an icon file, <xref:System.Windows.Window> will use the appropriate icon.</span></span> <span data-ttu-id="fed4d-297">如果图标文件仅包含所有可能的图标的子集，将 <xref:System.Windows.Window> 使用下一个最适合的图标，按减小大小和颜色深度顺序排列。</span><span class="sxs-lookup"><span data-stu-id="fed4d-297">If an icon file contains only a subset of all the possible icons, <xref:System.Windows.Window> uses the next most appropriate icon in order of decreasing sizes and color depth.</span></span>  
  
 <span data-ttu-id="fed4d-298">结果是，将始终使用图标 <xref:System.Windows.Window> ，尽管使用的图标可能不以所需的大小和颜色深度为目标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-298">The result is that an icon will always be used by <xref:System.Windows.Window>, although the icon used may not target the required size and color depth.</span></span> <span data-ttu-id="fed4d-299">例如，具有16种颜色的16x16 像素图标可用于显示为具有256颜色的32x32 像素图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-299">For example, a 16x16 pixel icon with 16 colors may be used for display as a 32x32 pixel icon with 256 colors.</span></span> <span data-ttu-id="fed4d-300">这可能会导致意外的视觉效果（如 pixilation），但可以通过为所有目标大小和颜色深度创建图标来避免出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="fed4d-300">This can cause undesirable visual effects, such as pixilation, but may be avoided by creating icons for all targeted sizes and color depths.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-301">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-301">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-302">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-302">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-303">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-303">Identifier field</span></span>|<xref:System.Windows.Window.IconProperty>|  
|<span data-ttu-id="fed4d-304">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-304">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-305">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-305">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-306">下面的示例演示如何设置窗口图标。</span><span class="sxs-lookup"><span data-stu-id="fed4d-306">The following example shows how to set a window icon.</span></span>  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-307">标识 <see cref="P:System.Windows.Window.Icon" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-307">Identifies the <see cref="P:System.Windows.Window.Icon" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-308">获取一个值，该值指示窗口是否为活动窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-308">Gets a value that indicates whether the window is active.</span></span></summary>
        <value><span data-ttu-id="fed4d-309">如果窗口是活动的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-309"><see langword="true" /> if the window is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="fed4d-310">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-310">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-311">活动窗口是用户的当前前景窗口，具有焦点，这由标题栏的活动外观表示。</span><span class="sxs-lookup"><span data-stu-id="fed4d-311">An active window is the user's current foreground window and has the focus, which is signified by the active appearance of the title bar.</span></span> <span data-ttu-id="fed4d-312">活动窗口还将是所有未显式设置属性的顶级窗口的顶层 <xref:System.Windows.Window.Topmost%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-312">An active window will also be the top-most of all top-level windows that don't explicitly set the <xref:System.Windows.Window.Topmost%2A> property.</span></span>  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-313">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-313">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-314">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-314">Identifier field</span></span>|<xref:System.Windows.Window.IsActiveProperty>|  
|<span data-ttu-id="fed4d-315">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-315">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-316">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-316">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-317">标识 <see cref="P:System.Windows.Window.IsActive" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-317">Identifies the <see cref="P:System.Windows.Window.IsActive" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-318">获取或设置窗口左边缘相对于桌面的位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-318">Gets or sets the position of the window's left edge, in relation to the desktop.</span></span></summary>
        <value><span data-ttu-id="fed4d-319">以逻辑单位（1/96 英寸）表示的窗口左边缘位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-319">The position of the window's left edge, in logical units (1/96th of an inch).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-320">当 <xref:System.Windows.Window> 最大化或最小化时，此值表示的还原点左边缘 <xref:System.Windows.Window> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-320">When the <xref:System.Windows.Window> is maximized or minimized, this value represents the left edge of the restore point for the <xref:System.Windows.Window>.</span></span>  
  
 <span data-ttu-id="fed4d-321">不能通过样式设置此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-321">This property cannot be set through a style.</span></span>  
  
 <span data-ttu-id="fed4d-322">如果未指定值， <xref:System.Windows.Window.Left%2A> 则将设置为系统默认值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-322">If you do not specify a value, <xref:System.Windows.Window.Left%2A> is set to the system default value.</span></span> <span data-ttu-id="fed4d-323">还可以通过将设置为来指定系统默认 <xref:System.Windows.Window.Left%2A> 值 <xref:System.Double.NaN> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-323">You can also specify the system default value by setting <xref:System.Windows.Window.Left%2A> to <xref:System.Double.NaN>.</span></span> <span data-ttu-id="fed4d-324">和都不是的 <xref:System.Double.NegativeInfinity> <xref:System.Double.PositiveInfinity> 有效值 <xref:System.Windows.Window.Left%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-324">Neither <xref:System.Double.NegativeInfinity> nor <xref:System.Double.PositiveInfinity> is a valid value for <xref:System.Windows.Window.Left%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-325">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-325">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-326">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-326">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-327">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-327">Identifier field</span></span>|<xref:System.Windows.Window.LeftProperty>|  
|<span data-ttu-id="fed4d-328">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-328">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-329">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-329">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-330">标识 <see cref="P:System.Windows.Window.Left" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-330">Identifies the <see cref="P:System.Windows.Window.Left" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-331">在窗口的位置改变时发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-331">Occurs when the window's location changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-332">当发生以下情况时，窗口的位置会发生更改：</span><span class="sxs-lookup"><span data-stu-id="fed4d-332">A window's location changes when:</span></span>  
  
-   <span data-ttu-id="fed4d-333">用户通过将窗口拖动到窗口的标题栏来移动窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-333">A user moves a window by dragging it with the window's title bar.</span></span>  
  
-   <span data-ttu-id="fed4d-334">调用后，将移动窗口 <xref:System.Windows.Window.DragMove%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-334">A window is moved after <xref:System.Windows.Window.DragMove%2A> is called.</span></span>  
  
-   <span data-ttu-id="fed4d-335"><xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window.Top%2A> 以编程方式设置或属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-335">Either the <xref:System.Windows.Window.Left%2A> or <xref:System.Windows.Window.Top%2A> property is set programmatically.</span></span>  
  
-   <span data-ttu-id="fed4d-336">将选择窗口系统菜单的 " **移动** " 菜单项。</span><span class="sxs-lookup"><span data-stu-id="fed4d-336">The **Move** menu item of a window's System menu is chosen.</span></span>  
  
-   <span data-ttu-id="fed4d-337"><xref:System.Windows.Window.WindowState%2A>属性已更改。</span><span class="sxs-lookup"><span data-stu-id="fed4d-337">The <xref:System.Windows.Window.WindowState%2A> property is changed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-338">获取窗口的逻辑子元素的一个枚举数。</span><span class="sxs-lookup"><span data-stu-id="fed4d-338">Gets an enumerator for a window's logical child elements.</span></span></summary>
        <value><span data-ttu-id="fed4d-339">窗口的逻辑子元素的一个 <see cref="T:System.Collections.IEnumerator" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-339">An <see cref="T:System.Collections.IEnumerator" /> a window's logical child elements.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize"><span data-ttu-id="fed4d-340">一个 <see cref="T:System.Windows.Size" />，反映此窗口可为子级提供的可用大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-340">A <see cref="T:System.Windows.Size" /> that reflects the available size that this window can give to the child.</span></span> <span data-ttu-id="fed4d-341">可以提供无穷大值，以指示窗口大小可根据任何可用的内容进行调整。</span><span class="sxs-lookup"><span data-stu-id="fed4d-341">Infinity can be given as a value to indicate that the window will size to whatever content is available.</span></span></param>
        <summary><span data-ttu-id="fed4d-342">重写此方法可测量窗口的大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-342">Override this method to measure the size of a window.</span></span></summary>
        <returns><span data-ttu-id="fed4d-343">一个 <see cref="T:System.Windows.Size" />，反映此窗口所确定的在布局期间需要的大小（根据其子级大小的计算结果来确定）。</span><span class="sxs-lookup"><span data-stu-id="fed4d-343">A <see cref="T:System.Windows.Size" /> that reflects the size that this window determines it needs during layout, based on its calculations of children's sizes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-344"><xref:System.Windows.Window.MeasureOverride%2A> 当属性的值为时，不会调用 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Visibility.Collapsed> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-344"><xref:System.Windows.Window.MeasureOverride%2A> is not called when the <xref:System.Windows.UIElement.Visibility%2A> property has a value of <xref:System.Windows.Visibility.Collapsed>.</span></span> <span data-ttu-id="fed4d-345">如果属性的值 <xref:System.Windows.UIElement.Visibility%2A> 为 <xref:System.Windows.Visibility.Hidden> 或 <xref:System.Windows.Visibility.Visible> ， <xref:System.Windows.Window.MeasureOverride%2A> 则调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-345">If the value of the <xref:System.Windows.UIElement.Visibility%2A> property is either <xref:System.Windows.Visibility.Hidden> or <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-346">当 <xref:System.Windows.Window.Show%2A> 调用或时 <xref:System.Windows.Window.ShowDialog%2A> ，的属性将 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> 设置为 <xref:System.Windows.Visibility.Visible> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-346">When either <xref:System.Windows.Window.Show%2A> or <xref:System.Windows.Window.ShowDialog%2A> are called, the <xref:System.Windows.UIElement.Visibility%2A> property of a <xref:System.Windows.Window> is set to <xref:System.Windows.Visibility.Visible>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-347">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-347">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-348">引发 <see cref="E:System.Windows.Window.Activated" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-348">Raises the <see cref="E:System.Windows.Window.Activated" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-349"><xref:System.Windows.Window.OnActivated%2A> 引发 <xref:System.Windows.Window.Activated> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-349"><xref:System.Windows.Window.OnActivated%2A> raises the <xref:System.Windows.Window.Activated> event.</span></span>  
  
 <span data-ttu-id="fed4d-350">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnActivated%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-350">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnActivated%2A>.</span></span> <span data-ttu-id="fed4d-351">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnActivated%2A> 在基类上调用 <xref:System.Windows.Window.Activated> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-351">The overridden method must call <xref:System.Windows.Window.OnActivated%2A> on the base class if <xref:System.Windows.Window.Activated> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-352">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-352">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-353">引发 <see cref="E:System.Windows.Window.Closed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-353">Raises the <see cref="E:System.Windows.Window.Closed" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-354"><xref:System.Windows.Window.OnClosed%2A> 引发 <xref:System.Windows.Window.Closed> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-354"><xref:System.Windows.Window.OnClosed%2A> raises the <xref:System.Windows.Window.Closed> event.</span></span>  
  
 <span data-ttu-id="fed4d-355">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnClosed%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-355">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnClosed%2A>.</span></span> <span data-ttu-id="fed4d-356">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnClosed%2A> 在基类上调用 <xref:System.Windows.Window.Closed> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-356">The overridden method must call <xref:System.Windows.Window.OnClosed%2A> on the base class if <xref:System.Windows.Window.Closed> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-357">包含事件数据的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-357">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-358">引发 <see cref="E:System.Windows.Window.Closing" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-358">Raises the <see cref="E:System.Windows.Window.Closing" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-359"><xref:System.Windows.Window.OnClosing%2A> 引发 <xref:System.Windows.Window.Closing> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-359"><xref:System.Windows.Window.OnClosing%2A> raises the <xref:System.Windows.Window.Closing> event.</span></span>  
  
 <span data-ttu-id="fed4d-360">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnClosing%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-360">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnClosing%2A>.</span></span> <span data-ttu-id="fed4d-361">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnClosing%2A> 在基类上调用 <xref:System.Windows.Window.Closing> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-361">The overridden method must call <xref:System.Windows.Window.OnClosing%2A> on the base class if <xref:System.Windows.Window.Closing> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent"><span data-ttu-id="fed4d-362">对旧内容树的根的引用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-362">A reference to the root of the old content tree.</span></span></param>
        <param name="newContent"><span data-ttu-id="fed4d-363">对新内容树的根的引用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-363">A reference to the root of the new content tree.</span></span></param>
        <summary><span data-ttu-id="fed4d-364">当 <see cref="P:System.Windows.Controls.ContentControl.Content" /> 属性更改时调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-364">Called when the <see cref="P:System.Windows.Controls.ContentControl.Content" /> property changes.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-365">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-365">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-366">引发 <see cref="E:System.Windows.Window.ContentRendered" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-366">Raises the <see cref="E:System.Windows.Window.ContentRendered" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-367"><xref:System.Windows.Window.OnContentRendered%2A> 引发 <xref:System.Windows.Window.ContentRendered> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-367"><xref:System.Windows.Window.OnContentRendered%2A> raises the <xref:System.Windows.Window.ContentRendered> event.</span></span>  
  
 <span data-ttu-id="fed4d-368">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnContentRendered%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-368">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnContentRendered%2A>.</span></span> <span data-ttu-id="fed4d-369">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnContentRendered%2A> 在基类上调用 <xref:System.Windows.Window.ContentRendered> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-369">The overridden method must call <xref:System.Windows.Window.OnContentRendered%2A> on the base class if <xref:System.Windows.Window.ContentRendered> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-370">为此 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> 创建并返回一个 <see cref="T:System.Windows.Window" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fed4d-370">Creates and returns a <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</span></span></summary>
        <returns><span data-ttu-id="fed4d-371">此 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> 的 <see cref="T:System.Windows.Window" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="fed4d-371">A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-372">此方法重写 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>。</span><span class="sxs-lookup"><span data-stu-id="fed4d-372">This method overrides <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-373">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-373">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-374">引发 <see cref="E:System.Windows.Window.Deactivated" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-374">Raises the <see cref="E:System.Windows.Window.Deactivated" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-375"><xref:System.Windows.Window.OnDeactivated%2A> 引发 <xref:System.Windows.Window.Deactivated> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-375"><xref:System.Windows.Window.OnDeactivated%2A> raises the <xref:System.Windows.Window.Deactivated> event.</span></span>  
  
 <span data-ttu-id="fed4d-376">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnDeactivated%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-376">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnDeactivated%2A>.</span></span> <span data-ttu-id="fed4d-377">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnDeactivated%2A> 在基类上调用 <xref:System.Windows.Window.Deactivated> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-377">The overridden method must call <xref:System.Windows.Window.OnDeactivated%2A> on the base class if <xref:System.Windows.Window.Deactivated> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi"><span data-ttu-id="fed4d-378">上一 DPI 比例设置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-378">The previous DPI scale setting.</span></span></param>
        <param name="newDpi"><span data-ttu-id="fed4d-379">新 DPI 比例设置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-379">The new DPI scale setting.</span></span></param>
        <summary><span data-ttu-id="fed4d-380">呈现此窗口所使用的 DPI 发生变化时进行调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-380">Called when the DPI at which this window is rendered changes.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-381">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-381">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-382">引发 <see cref="E:System.Windows.Window.LocationChanged" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-382">Raises the <see cref="E:System.Windows.Window.LocationChanged" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-383"><xref:System.Windows.Window.OnLocationChanged%2A> 引发 <xref:System.Windows.Window.LocationChanged> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-383"><xref:System.Windows.Window.OnLocationChanged%2A> raises the <xref:System.Windows.Window.LocationChanged> event.</span></span>  
  
 <span data-ttu-id="fed4d-384">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnLocationChanged%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-384">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnLocationChanged%2A>.</span></span> <span data-ttu-id="fed4d-385">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnLocationChanged%2A> 在基类上调用 <xref:System.Windows.Window.LocationChanged> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-385">The overridden method must call <xref:System.Windows.Window.OnLocationChanged%2A> on the base class if <xref:System.Windows.Window.LocationChanged> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-386">事件的数据。</span><span class="sxs-lookup"><span data-stu-id="fed4d-386">The data for the event.</span></span></param>
        <summary><span data-ttu-id="fed4d-387">在 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件发生时调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-387">Called when the <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> event occurs.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-388">此实现不会更改 <xref:System.Windows.RoutedEventArgs.Handled%2A> 事件数据的属性) 的已处理状态 (<xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-388">This implementation does not change the handled state (the <xref:System.Windows.RoutedEventArgs.Handled%2A> property) of the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event data.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="fed4d-389">如果重写 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> ，请始终在实现中调用基实现 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-389">If you override <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, always call the base implementation in your <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementation.</span></span> <span data-ttu-id="fed4d-390">未能调用基实现会阻止基类处理事件，这可能会更改最终类的运行时行为。</span><span class="sxs-lookup"><span data-stu-id="fed4d-390">Failure to call the base implementation prevents base classes from handling the event, which might change the run-time behavior of the final class.</span></span> <span data-ttu-id="fed4d-391">你可以在特殊处理之前或之后调用基本实现，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="fed4d-391">You can call the base implementation either before or after your special handling, depending on your requirements.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-392">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-392">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-393">引发 <see cref="E:System.Windows.Window.SourceInitialized" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-393">Raises the <see cref="E:System.Windows.Window.SourceInitialized" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-394"><xref:System.Windows.Window.OnSourceInitialized%2A> 引发 <xref:System.Windows.Window.SourceInitialized> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-394"><xref:System.Windows.Window.OnSourceInitialized%2A> raises the <xref:System.Windows.Window.SourceInitialized> event.</span></span>  
  
 <span data-ttu-id="fed4d-395">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnSourceInitialized%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-395">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnSourceInitialized%2A>.</span></span> <span data-ttu-id="fed4d-396">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnSourceInitialized%2A> 在基类上调用 <xref:System.Windows.Window.SourceInitialized> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-396">The overridden method must call <xref:System.Windows.Window.OnSourceInitialized%2A> on the base class if <xref:System.Windows.Window.SourceInitialized> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="fed4d-397">包含事件数据的 <see cref="T:System.EventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-397">An <see cref="T:System.EventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="fed4d-398">引发 <see cref="E:System.Windows.Window.StateChanged" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-398">Raises the <see cref="E:System.Windows.Window.StateChanged" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-399"><xref:System.Windows.Window.OnStateChanged%2A> 引发 <xref:System.Windows.Window.StateChanged> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-399"><xref:System.Windows.Window.OnStateChanged%2A> raises the <xref:System.Windows.Window.StateChanged> event.</span></span>  
  
 <span data-ttu-id="fed4d-400">派生自的类型 <xref:System.Windows.Window> 可以重写 <xref:System.Windows.Window.OnStateChanged%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-400">A type that derives from <xref:System.Windows.Window> may override <xref:System.Windows.Window.OnStateChanged%2A>.</span></span> <span data-ttu-id="fed4d-401">如果需要引发，则重写的方法必须 <xref:System.Windows.Window.OnStateChanged%2A> 在基类上调用 <xref:System.Windows.Window.StateChanged> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-401">The overridden method must call <xref:System.Windows.Window.OnStateChanged%2A> on the base class if <xref:System.Windows.Window.StateChanged> needs to be raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded"><span data-ttu-id="fed4d-402">已添加到集合的 <see cref="T:System.Windows.Media.Visual" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-402">The <see cref="T:System.Windows.Media.Visual" /> that was added to the collection.</span></span></param>
        <param name="visualRemoved"><span data-ttu-id="fed4d-403">从集合中移除的 <see cref="T:System.Windows.Media.Visual" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-403">The <see cref="T:System.Windows.Media.Visual" /> that was removed from the collection.</span></span></param>
        <summary><span data-ttu-id="fed4d-404">此 <see cref="T:System.Windows.Window" /> 对象的 <see cref="T:System.Windows.Media.VisualCollection" /> 被修改时调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-404">Called when the <see cref="T:System.Windows.Media.VisualCollection" /> of this <see cref="T:System.Windows.Window" /> object is modified.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent"><span data-ttu-id="fed4d-405">先前的父项。</span><span class="sxs-lookup"><span data-stu-id="fed4d-405">The previous parent.</span></span> <span data-ttu-id="fed4d-406">如果 <see cref="T:System.Windows.DependencyObject" /> 没有先前的父项，则设置为 null。</span><span class="sxs-lookup"><span data-stu-id="fed4d-406">Set to null if the <see cref="T:System.Windows.DependencyObject" /> did not have a previous parent.</span></span></param>
        <summary><span data-ttu-id="fed4d-407">在窗口的父项更改时调用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-407">Called when the parent of the window is changed.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-408">获取此窗口所拥有的窗口的集合。</span><span class="sxs-lookup"><span data-stu-id="fed4d-408">Gets a collection of windows for which this window is the owner.</span></span></summary>
        <value><span data-ttu-id="fed4d-409">一个 <see cref="T:System.Windows.WindowCollection" />，包含对此窗口所拥有的窗口的引用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-409">A <see cref="T:System.Windows.WindowCollection" /> that contains references to the windows for which this window is the owner.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-410">拥有的窗口是其 <xref:System.Windows.Window.Owner%2A> 属性设置为对其他窗口（称为所有者窗口）的引用的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-410">An owned window is one whose <xref:System.Windows.Window.Owner%2A> property is set with a reference to another window, which is known as the owner window.</span></span> <span data-ttu-id="fed4d-411">若要查找所有者窗口拥有的所有窗口，您可以枚举 <xref:System.Windows.WindowCollection> 由属性返回的 <xref:System.Windows.Window.OwnedWindows%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-411">To find all the windows that an owner window owns, you can enumerate <xref:System.Windows.WindowCollection> that is returned by the <xref:System.Windows.Window.OwnedWindows%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-412">下面的示例演示如何枚举 <xref:System.Windows.Window.OwnedWindows%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-412">The following example shows how to enumerate <xref:System.Windows.Window.OwnedWindows%2A>.</span></span>  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-413">获取或设置拥有此 <see cref="T:System.Windows.Window" /> 的 <see cref="T:System.Windows.Window" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-413">Gets or sets the <see cref="T:System.Windows.Window" /> that owns this <see cref="T:System.Windows.Window" />.</span></span></summary>
        <value><span data-ttu-id="fed4d-414">一个 <see cref="T:System.Windows.Window" /> 对象，表示此 <see cref="T:System.Windows.Window" /> 的所有者。</span><span class="sxs-lookup"><span data-stu-id="fed4d-414">A <see cref="T:System.Windows.Window" /> object that represents the owner of this <see cref="T:System.Windows.Window" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-415">当父窗口通过调用打开子窗口时 <xref:System.Windows.Window.ShowDialog%2A> ，将在父窗口和子窗口之间建立隐式关系。</span><span class="sxs-lookup"><span data-stu-id="fed4d-415">When a child window is opened by a parent window by calling <xref:System.Windows.Window.ShowDialog%2A>, an implicit relationship is established between both parent and child window.</span></span> <span data-ttu-id="fed4d-416">此关系强制实施某些行为，包括与最小化、最大化和还原有关的行为。</span><span class="sxs-lookup"><span data-stu-id="fed4d-416">This relationship enforces certain behaviors, including with respect to minimizing, maximizing, and restoring.</span></span>  
  
 <span data-ttu-id="fed4d-417">但当父窗口通过调用来创建子窗口时 <xref:System.Windows.Window.Show%2A> ，子窗口与父窗口之间没有关系。</span><span class="sxs-lookup"><span data-stu-id="fed4d-417">When a child window is created by a parent window by calling <xref:System.Windows.Window.Show%2A>, however, the child window does not have a relationship with the parent window.</span></span> <span data-ttu-id="fed4d-418">这意味着：</span><span class="sxs-lookup"><span data-stu-id="fed4d-418">This means that:</span></span>  
  
-   <span data-ttu-id="fed4d-419">子窗口没有对父窗口的引用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-419">The child window does not have a reference to the parent window.</span></span>  
  
-   <span data-ttu-id="fed4d-420">子窗口的行为不依赖于父窗口的行为;任何一个窗口都可以覆盖另一个窗口，或者将其最小化、最大化和还原。</span><span class="sxs-lookup"><span data-stu-id="fed4d-420">The behavior of the child window is not dependent on the behavior of the parent window; either window can cover the other, or be minimized, maximized, and restored independently of the other.</span></span>  
  
 <span data-ttu-id="fed4d-421">为了使你能够在子窗口和父窗口之间创建关系， <xref:System.Windows.Window> 支持所有权的概念。</span><span class="sxs-lookup"><span data-stu-id="fed4d-421">To allow you to create a relationship between a child window and a parent window, <xref:System.Windows.Window> supports the notion of ownership.</span></span> <span data-ttu-id="fed4d-422">当 <xref:System.Windows.Window.Owner%2A>)  (拥有的窗口的属性设置为拥有 (所有者窗口) 的另一个窗口的引用时，建立所有权。</span><span class="sxs-lookup"><span data-stu-id="fed4d-422">Ownership is established when the <xref:System.Windows.Window.Owner%2A> property of a window (the owned window) is set with a reference to another window (the owner window).</span></span>  
  
 <span data-ttu-id="fed4d-423">建立此关系后，将出现以下行为：</span><span class="sxs-lookup"><span data-stu-id="fed4d-423">Once this relationship is established, the following behaviors are exhibited:</span></span>  
  
-   <span data-ttu-id="fed4d-424">如果最小化所有者窗口，则其所有拥有的窗口也将最小化。</span><span class="sxs-lookup"><span data-stu-id="fed4d-424">If an owner window is minimized, all its owned windows are minimized as well.</span></span>  
  
-   <span data-ttu-id="fed4d-425">如果将拥有的窗口最小化，则其所有者不会最小化。</span><span class="sxs-lookup"><span data-stu-id="fed4d-425">If an owned window is minimized, its owner is not minimized.</span></span>  
  
-   <span data-ttu-id="fed4d-426">如果 "所有者" 窗口处于最大化状态，则会还原所有者窗口及其拥有的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-426">If an owner window is maximized, both the owner window and its owned windows are restored.</span></span>  
  
-   <span data-ttu-id="fed4d-427">所有者窗口永远不会涵盖拥有的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-427">An owner window can never cover an owned window.</span></span>  
  
-   <span data-ttu-id="fed4d-428">未使用打开的拥有的窗口 <xref:System.Windows.Window.ShowDialog%2A> 不是模式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-428">Owned windows that were not opened using <xref:System.Windows.Window.ShowDialog%2A> are not modal.</span></span> <span data-ttu-id="fed4d-429">用户仍可以与所有者窗口交互。</span><span class="sxs-lookup"><span data-stu-id="fed4d-429">The user can still interact with the owner window.</span></span>  
  
-   <span data-ttu-id="fed4d-430">如果关闭所有者窗口，则其拥有的窗口也会关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-430">If you close an owner window, its owned windows are also closed.</span></span>  
  
-   <span data-ttu-id="fed4d-431">如果拥有的窗口是由其所有者窗口使用打开的 <xref:System.Windows.Window.Show%2A> ，并且 "所有者" 窗口关闭，则不会引发所拥有的窗口的 <xref:System.Windows.Window.Closing> 事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-431">If an owned window was opened by its owner window using <xref:System.Windows.Window.Show%2A>, and the owner window is closed, the owned window's <xref:System.Windows.Window.Closing> event is not raised.</span></span>  
  
 <span data-ttu-id="fed4d-432">通过调用打开子窗口时 <xref:System.Windows.Window.ShowDialog%2A> ，还应设置 <xref:System.Windows.Window.Owner%2A> 子窗口的属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-432">When you open a child window by calling <xref:System.Windows.Window.ShowDialog%2A>, you should also set the <xref:System.Windows.Window.Owner%2A> property of the child window.</span></span> <span data-ttu-id="fed4d-433">否则，你的用户将无法通过按 "任务栏" 按钮来还原子窗口和父窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-433">If you don't, then your users won't be able to restore both child window and parent window by pressing the task bar button.</span></span> <span data-ttu-id="fed4d-434">相反，按 "任务栏" 按钮将生成一个窗口列表，其中包括子窗口和父窗口，以供选择;仅还原所选窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-434">Instead, pressing the task bar button will yield a list of windows, including both child and parent window, for them to select; only the selected window is restored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="fed4d-435">还应 <xref:System.Windows.Window.Owner%2A> 在通过调用打开的窗口上设置属性， <xref:System.Windows.Window.ShowDialog%2A> 以确保与的行为正确。</span><span class="sxs-lookup"><span data-stu-id="fed4d-435">You should also set the <xref:System.Windows.Window.Owner%2A> property on a window that is opened by calling <xref:System.Windows.Window.ShowDialog%2A> to ensure correct behavior with .</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-436">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-436">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-437">下面的示例演示如何建立所有者/拥有关系。</span><span class="sxs-lookup"><span data-stu-id="fed4d-437">The following example shows how to establish the owner/owned relationship.</span></span>  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="fed4d-438">窗口尝试拥有自身</span><span class="sxs-lookup"><span data-stu-id="fed4d-438">A window tries to own itself</span></span>  
  
 <span data-ttu-id="fed4d-439">- 或 -</span><span class="sxs-lookup"><span data-stu-id="fed4d-439">-or-</span></span>  
  
 <span data-ttu-id="fed4d-440">两个窗口尝试相互拥有。</span><span class="sxs-lookup"><span data-stu-id="fed4d-440">Two windows try to own each other.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-441">在使用 <see cref="P:System.Windows.Window.Owner" /> 显示的可见窗口上设置了 <see cref="M:System.Windows.Window.ShowDialog" /> 属性</span><span class="sxs-lookup"><span data-stu-id="fed4d-441">The <see cref="P:System.Windows.Window.Owner" /> property is set on a visible window shown using <see cref="M:System.Windows.Window.ShowDialog" /></span></span>  
  
<span data-ttu-id="fed4d-442">- 或 -</span><span class="sxs-lookup"><span data-stu-id="fed4d-442">-or-</span></span> 
<span data-ttu-id="fed4d-443">将 <see cref="P:System.Windows.Window.Owner" /> 属性设置为先前未曾显示的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-443">The <see cref="P:System.Windows.Window.Owner" /> property is set with a window that has not been previously shown.</span></span></exception>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-444">获取或设置调整大小模式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-444">Gets or sets the resize mode.</span></span></summary>
        <value><span data-ttu-id="fed4d-445">一个 <see cref="T:System.Windows.ResizeMode" /> 值，指定大小调整模式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-445">A <see cref="T:System.Windows.ResizeMode" /> value specifying the resize mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-446">下面有四个选择：</span><span class="sxs-lookup"><span data-stu-id="fed4d-446">There are four options:</span></span>  
  
-   <span data-ttu-id="fed4d-447">**NoResize**。</span><span class="sxs-lookup"><span data-stu-id="fed4d-447">**NoResize**.</span></span> <span data-ttu-id="fed4d-448">用户无法调整窗口的大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-448">The user cannot resize the window.</span></span> <span data-ttu-id="fed4d-449">不显示 "最大化" 和 "最小化" 框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-449">The Maximize and Minimize boxes are not shown.</span></span>  
  
-   <span data-ttu-id="fed4d-450">**CanMinimize**。</span><span class="sxs-lookup"><span data-stu-id="fed4d-450">**CanMinimize**.</span></span> <span data-ttu-id="fed4d-451">用户只能最小化窗口并从任务栏还原。</span><span class="sxs-lookup"><span data-stu-id="fed4d-451">The user can only minimize the window and restore it from the taskbar.</span></span> <span data-ttu-id="fed4d-452">同时显示 "最小化" 和 "最大化" 框，但只启用 "最小化" 框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-452">The Minimize and Maximize boxes are both shown, but only the Minimize box is enabled.</span></span>  
  
-   <span data-ttu-id="fed4d-453">**CanResize**。</span><span class="sxs-lookup"><span data-stu-id="fed4d-453">**CanResize**.</span></span> <span data-ttu-id="fed4d-454">用户可以通过使用 "最小化" 和 "最大化" 框以及围绕窗口的可拖动轮廓来完全调整窗口的大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-454">The user has the full ability to resize the window, using the Minimize and Maximize boxes, and a draggable outline around the window.</span></span> <span data-ttu-id="fed4d-455">显示和启用 "最小化" 和 "最大化" 框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-455">The Minimize and Maximize boxes are shown and enabled.</span></span> <span data-ttu-id="fed4d-456"> (默认) 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-456">(Default).</span></span>  
  
-   <span data-ttu-id="fed4d-457">**CanResizeWithGrip**。</span><span class="sxs-lookup"><span data-stu-id="fed4d-457">**CanResizeWithGrip**.</span></span> <span data-ttu-id="fed4d-458">此选项具有与相同的功能 <xref:System.Windows.ResizeMode.CanResize> ，但会将 "调整手柄" 添加到窗口的右下角。</span><span class="sxs-lookup"><span data-stu-id="fed4d-458">This option has the same functionality as <xref:System.Windows.ResizeMode.CanResize>, but adds a "resize grip" to the lower right corner of the window.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-459">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-459">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-460">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-460">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-461">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-461">Identifier field</span></span>|<xref:System.Windows.Window.ResizeModeProperty>|  
|<span data-ttu-id="fed4d-462">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-462">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-463">标识 <see cref="P:System.Windows.Window.ResizeMode" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-463">Identifies the <see cref="P:System.Windows.Window.ResizeMode" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-464">获取窗口在最小化或最大化之前的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-464">Gets the size and location of a window before being either minimized or maximized.</span></span></summary>
        <value><span data-ttu-id="fed4d-465">一个 <see cref="T:System.Windows.Rect" />，指定窗口在最小化或最大化之前的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-465">A <see cref="T:System.Windows.Rect" /> that specifies the size and location of a window before being either minimized or maximized.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-466">还原矩形是窗口在最小化或最大化之前占用的区域。</span><span class="sxs-lookup"><span data-stu-id="fed4d-466">The restore rectangle is the region occupied by the window before it was minimized or maximized.</span></span> <span data-ttu-id="fed4d-467">在 <xref:System.Windows.Window.RestoreBounds%2A> 应用程序关闭之前，可以使用保存窗口的最后大小和位置，并在下次应用程序开始时检索这些值，以将窗口还原到用户离开它的方式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-467">You can use <xref:System.Windows.Window.RestoreBounds%2A> to save the last size and location of a window before an application is closed, and retrieve those values the next time an application starts to restore a window to the way a user left it.</span></span>  
  
 <span data-ttu-id="fed4d-468">如果在 <xref:System.Windows.Window.RestoreBounds%2A> 显示窗口之前或在窗口关闭后进行查询， <xref:System.Windows.Rect.Empty%2A> 则返回。</span><span class="sxs-lookup"><span data-stu-id="fed4d-468">If you query <xref:System.Windows.Window.RestoreBounds%2A> before the window has been shown or after it has been closed, <xref:System.Windows.Rect.Empty%2A> is returned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-469">当窗口承载于浏览器中时，不能获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-469">You cannot get this property when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-470">下面的示例使用 <xref:System.Windows.Window.RestoreBounds%2A> 和独立存储，以确保窗口的大小和位置与上一次显示窗口时的大小和位置相同。</span><span class="sxs-lookup"><span data-stu-id="fed4d-470">The following example uses <xref:System.Windows.Window.RestoreBounds%2A> and isolated storage to ensure the size and location of a window are the same as they were the previous time the window was shown.</span></span>  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-471">打开窗口并返回，而不等待新打开的窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-471">Opens a window and returns without waiting for the newly opened window to close.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-472">当 <xref:System.Windows.Window> 类实例化时，默认情况下它不可见。</span><span class="sxs-lookup"><span data-stu-id="fed4d-472">When the <xref:System.Windows.Window> class is instantiated, it is not visible by default.</span></span> <span data-ttu-id="fed4d-473"><xref:System.Windows.Window.Show%2A> 显示一个窗口并立即返回，而不会等待窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="fed4d-473"><xref:System.Windows.Window.Show%2A> shows a window and returns immediately, without waiting for the window to be closed.</span></span> <span data-ttu-id="fed4d-474">因此，打开的窗口不会阻止用户与应用程序中的其他窗口交互。</span><span class="sxs-lookup"><span data-stu-id="fed4d-474">Consequently, the opened window does not prevent users from interacting with other windows in the application.</span></span> <span data-ttu-id="fed4d-475">这种类型的窗口称为 *无模式* 窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-475">This type of window is called a *modeless* window.</span></span> <span data-ttu-id="fed4d-476">无模式窗口的常见示例是属性窗口、工具箱和调色板。</span><span class="sxs-lookup"><span data-stu-id="fed4d-476">Common examples of modeless windows are properties windows, toolboxes, and palettes.</span></span> <span data-ttu-id="fed4d-477">若要限制用户与特定窗口交互，必须通过调用打开该窗口 <xref:System.Windows.Window.ShowDialog%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-477">To restrict a user to interacting with a specific window, the window must be opened by calling <xref:System.Windows.Window.ShowDialog%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-478">通过调用打开的窗口 <xref:System.Windows.Window.Show%2A> 不会自动与打开它的窗口建立关系; 具体而言，打开的窗口不知道哪个窗口打开了它。</span><span class="sxs-lookup"><span data-stu-id="fed4d-478">A window that is opened by calling <xref:System.Windows.Window.Show%2A> does not automatically have a relationship with the window that opened it; specifically, the opened window does not know which window opened it.</span></span> <span data-ttu-id="fed4d-479">此关系可以使用 <xref:System.Windows.Window.Owner%2A> 属性建立，并使用属性进行管理 <xref:System.Windows.Window.OwnedWindows%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-479">This relationship can be established using the <xref:System.Windows.Window.Owner%2A> property and managed using the <xref:System.Windows.Window.OwnedWindows%2A> property.</span></span>  
  
 <span data-ttu-id="fed4d-480">调用 <xref:System.Windows.Window.Show%2A> 可实现与将对象的属性设置为相同的最终结果 <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window> <xref:System.Windows.Visibility.Visible> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-480">Calling <xref:System.Windows.Window.Show%2A> achieves the same end result as setting <xref:System.Windows.UIElement.Visibility%2A> property of the <xref:System.Windows.Window> object to <xref:System.Windows.Visibility.Visible>.</span></span> <span data-ttu-id="fed4d-481">但是，这两种情况之间的区别在于计时透视。</span><span class="sxs-lookup"><span data-stu-id="fed4d-481">However, there is a difference between the two from a timing perspective.</span></span>  
  
 <span data-ttu-id="fed4d-482">调用 <xref:System.Windows.Window.Show%2A> 是一个同步操作，它仅在 <xref:System.Windows.FrameworkElement.Loaded> 引发子窗口上的事件后返回：</span><span class="sxs-lookup"><span data-stu-id="fed4d-482">Calling <xref:System.Windows.Window.Show%2A> is a synchronous operation that returns only after the <xref:System.Windows.FrameworkElement.Loaded> event on the child window has been raised:</span></span>  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 <span data-ttu-id="fed4d-483"><xref:System.Windows.UIElement.Visibility%2A>但是，设置是立即返回的异步操作：</span><span class="sxs-lookup"><span data-stu-id="fed4d-483">Setting <xref:System.Windows.UIElement.Visibility%2A>, however, is an asynchronous operation that returns immediately:</span></span>  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 <span data-ttu-id="fed4d-484">设置时 <xref:System.Windows.UIElement.Visibility%2A> ， <xref:System.Windows.UIElement.Visibility%2A> 只有在设置的方法完成执行后，才会引发在设置之前注册的任何窗口事件 <xref:System.Windows.UIElement.Visibility%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-484">When setting <xref:System.Windows.UIElement.Visibility%2A>, any window events you register before you set <xref:System.Windows.UIElement.Visibility%2A> may not be raised until after the method in which you set <xref:System.Windows.UIElement.Visibility%2A> has completed execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-485">下面的示例演示如何打开无模式窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-485">The following sample demonstrates how to open a modeless window.</span></span>  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-486">对正在关闭 (<see cref="M:System.Windows.Window.Show" />) 或已经关闭 (<see cref="E:System.Windows.Window.Closing" />) 的窗口调用 <see cref="E:System.Windows.Window.Closed" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-486"><see cref="M:System.Windows.Window.Show" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</span></span></exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-487">获取或设置一个值，该值指示在第一次显示窗口时，窗口是否处于激活状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-487">Gets or sets a value that indicates whether a window is activated when first shown.</span></span></summary>
        <value><span data-ttu-id="fed4d-488">如果窗口第一次显示时即激活，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-488"><see langword="true" /> if a window is activated when first shown; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="fed4d-489">默认为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-489">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-490">当 <xref:System.Windows.Window.ShowActivated%2A> 打开其属性设置为的窗口时，窗口不会激活，并且在 `false` <xref:System.Windows.Window.Activated> 用户通过选择窗口手动激活窗口之前，不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="fed4d-490">When a window with its <xref:System.Windows.Window.ShowActivated%2A> property set to `false` is opened, the window is not activated and its <xref:System.Windows.Window.Activated> event is not raised until a user manually activates the window by selecting it.</span></span> <span data-ttu-id="fed4d-491">选择该窗口后，它将正常激活和停用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-491">After the window is selected, it activates and deactivates normally.</span></span>  
  
 <span data-ttu-id="fed4d-492">若要防止窗口在窗口打开时被激活，则在 <xref:System.Windows.Window.ShowActivated%2A> 通过调用)  (显示窗口之前，必须将属性设置为，否则，将在显示窗口后将该属性设置为 `false` <xref:System.Windows.Window.Show%2A> ： <xref:System.Windows.Window.ShowActivated%2A> `false` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-492">To prevent a window from being activated when it opens, the <xref:System.Windows.Window.ShowActivated%2A> property must be set to `false` before the window is shown (by calling <xref:System.Windows.Window.Show%2A>); setting <xref:System.Windows.Window.ShowActivated%2A> to `false` after a window is shown has no effect.</span></span>  
  
 <span data-ttu-id="fed4d-493">如果将设置 <xref:System.Windows.Window.ShowActivated%2A> 为 `false` ，则通过调用以模式方式打开的窗口 <xref:System.Windows.Window.ShowDialog%2A> 没有真正的影响。</span><span class="sxs-lookup"><span data-stu-id="fed4d-493">Setting <xref:System.Windows.Window.ShowActivated%2A> to `false` on a window that is opened modally, by calling <xref:System.Windows.Window.ShowDialog%2A>, has no real impact.</span></span> <span data-ttu-id="fed4d-494">尽管不会激活模式窗口，但模式窗口会阻止用户激活任何其他打开的应用程序窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-494">Although the modal window will not be activated, the modal window will prevent the user from activating any other open application windows.</span></span>  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-495">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-495">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-496">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-496">Identifier field</span></span>|<xref:System.Windows.Window.ShowActivatedProperty>|  
|<span data-ttu-id="fed4d-497">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-497">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-498">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-498">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-499">下面的示例演示如何使用标记将窗口配置为在未激活的情况下打开。</span><span class="sxs-lookup"><span data-stu-id="fed4d-499">The following example shows how to use markup to configure a window to be opened without being activated.</span></span>  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 <span data-ttu-id="fed4d-500">下面的示例演示如何使用代码将窗口配置为在未激活的情况下打开。</span><span class="sxs-lookup"><span data-stu-id="fed4d-500">The following example shows how to use code to configure a window to be opened without it being activated.</span></span>  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-501">标识 <see cref="P:System.Windows.Window.ShowActivated" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-501">Identifies the <see cref="P:System.Windows.Window.ShowActivated" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public bool? ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="fed4d-502">打开一个窗口，并且仅在新打开的窗口关闭后才返回。</span><span class="sxs-lookup"><span data-stu-id="fed4d-502">Opens a window and returns only when the newly opened window is closed.</span></span></summary>
        <returns><span data-ttu-id="fed4d-503"><see cref="T:System.Nullable`1" /> 类型的 <see cref="T:System.Boolean" /> 值，该值指定活动被接受 (<see langword="true" />) 还是被取消 (<see langword="false" />)。</span><span class="sxs-lookup"><span data-stu-id="fed4d-503">A <see cref="T:System.Nullable`1" /> value of type <see cref="T:System.Boolean" /> that specifies whether the activity was accepted (<see langword="true" />) or canceled (<see langword="false" />).</span></span> <span data-ttu-id="fed4d-504">返回值是 <see cref="P:System.Windows.Window.DialogResult" /> 属性在窗口关闭前具有的值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-504">The return value is the value of the <see cref="P:System.Windows.Window.DialogResult" /> property before a window closes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-505"><xref:System.Windows.Window>类实例化时，默认情况下它不可见。</span><span class="sxs-lookup"><span data-stu-id="fed4d-505">When a <xref:System.Windows.Window> class is instantiated, it is not visible by default.</span></span> <span data-ttu-id="fed4d-506"><xref:System.Windows.Window.ShowDialog%2A> 显示窗口，禁用应用程序中的所有其他窗口，并仅在窗口关闭时返回。</span><span class="sxs-lookup"><span data-stu-id="fed4d-506"><xref:System.Windows.Window.ShowDialog%2A> shows the window, disables all other windows in the application, and returns only when the window is closed.</span></span> <span data-ttu-id="fed4d-507">这种类型的窗口称为 *模式* 窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-507">This type of window is known as a *modal* window.</span></span>  
  
 <span data-ttu-id="fed4d-508">模式窗口主要用作对话框。</span><span class="sxs-lookup"><span data-stu-id="fed4d-508">Modal windows are primarily used as dialog boxes.</span></span> <span data-ttu-id="fed4d-509">对话框是一种特殊类型的窗口，应用程序使用该窗口与用户交互以完成任务，如打开文件或打印文档。</span><span class="sxs-lookup"><span data-stu-id="fed4d-509">A dialog box is a special type of window that applications use to interact with users to complete tasks, such as opening files or printing documents.</span></span> <span data-ttu-id="fed4d-510">对话框通常允许用户接受或取消在对话框关闭前显示的任务。</span><span class="sxs-lookup"><span data-stu-id="fed4d-510">Dialog boxes commonly allow users to accept or cancel the task for which they were shown before the dialog box is closed.</span></span> <span data-ttu-id="fed4d-511"><xref:System.Windows.Window.ShowDialog%2A>返回一个 <xref:System.Nullable%601> <xref:System.Boolean> 值，该值指定是接受还是取消活动。</span><span class="sxs-lookup"><span data-stu-id="fed4d-511"><xref:System.Windows.Window.ShowDialog%2A> returns a <xref:System.Nullable%601><xref:System.Boolean> value that specifies whether the activity was accepted or canceled.</span></span> <span data-ttu-id="fed4d-512">返回值是 <xref:System.Windows.Window.DialogResult%2A> 属性在窗口关闭前具有的值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-512">The return value is the value of the <xref:System.Windows.Window.DialogResult%2A> property before a window closes.</span></span> <span data-ttu-id="fed4d-513">有关详细信息，请参阅 <xref:System.Windows.Window.DialogResult%2A>。</span><span class="sxs-lookup"><span data-stu-id="fed4d-513">For more information, see <xref:System.Windows.Window.DialogResult%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-514">通过调用方法打开的窗口 <xref:System.Windows.Window.ShowDialog%2A> 不会自动与打开它的窗口建立关系; 具体而言，打开的窗口不知道哪个窗口打开了它。</span><span class="sxs-lookup"><span data-stu-id="fed4d-514">A window that is opened by calling the <xref:System.Windows.Window.ShowDialog%2A> method does not automatically have a relationship with the window that opened it; specifically, the opened window does not know which window opened it.</span></span> <span data-ttu-id="fed4d-515">此关系可以使用 <xref:System.Windows.Window.Owner%2A> 属性建立，并使用属性进行管理 <xref:System.Windows.Window.OwnedWindows%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-515">This relationship can be established using the <xref:System.Windows.Window.Owner%2A> property and managed using the <xref:System.Windows.Window.OwnedWindows%2A> property.</span></span> <span data-ttu-id="fed4d-516">若要支持 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 自动化 (参阅 [UI automation 概述](/dotnet/framework/ui-automation/ui-automation-overview)) ， <xref:System.Windows.Window.Owner%2A> 必须为通过调用打开的窗口进行设置 <xref:System.Windows.Window.ShowDialog%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-516">To support [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automation (see [UI Automation Overview](/dotnet/framework/ui-automation/ui-automation-overview)), <xref:System.Windows.Window.Owner%2A> must be set for a window opened by calling <xref:System.Windows.Window.ShowDialog%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-517">如果模式 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 窗口 (通过调用) 打开的窗口 <xref:System.Windows.Window.ShowDialog%2A> 关闭，则会重新激活以前激活的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-517">When a modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] window (a window opened by calling <xref:System.Windows.Window.ShowDialog%2A>) is closed, the previously activated window is reactivated.</span></span> <span data-ttu-id="fed4d-518">如果模式 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 窗口有所有者窗口 (参阅 <xref:System.Windows.Window.Owner%2A>) ，则当模式 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 窗口关闭时，除非以前激活的窗口，否则不会重新激活所有者窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-518">If a modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] window has an owner window (see <xref:System.Windows.Window.Owner%2A>), the owner window is not reactivated when the modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] window is closed unless it was the previously activated window.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-519">当窗口承载于浏览器中时，不能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="fed4d-519">This method cannot be called when a window is hosted in a browser.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-520">下面的示例演示如何打开模式窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-520">The following sample demonstrates how to open a modal window.</span></span>  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="fed4d-521">对正在关闭 (<see cref="M:System.Windows.Window.ShowDialog" />) 或已经关闭 (<see cref="E:System.Windows.Window.Closing" />) 的窗口调用 <see cref="E:System.Windows.Window.Closed" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-521"><see cref="M:System.Windows.Window.ShowDialog" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</span></span></exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-522">获取或设置一个指示窗口是否具有任务栏按钮的值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-522">Gets or sets a value that indicates whether the window has a task bar button.</span></span></summary>
        <value><span data-ttu-id="fed4d-523">如果窗口具有任务栏按钮，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-523"><see langword="true" /> if the window has a task bar button; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="fed4d-524">当窗口承载在浏览器中时，此属性不适用。</span><span class="sxs-lookup"><span data-stu-id="fed4d-524">Does not apply when the window is hosted in a browser.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-525">如果 <xref:System.Windows.Window.ShowInTaskbar%2A> 设置为，则该 `true` 窗口还将出现在 "ALT + TAB 应用程序选择列表" 中。</span><span class="sxs-lookup"><span data-stu-id="fed4d-525">If <xref:System.Windows.Window.ShowInTaskbar%2A> is set to `true`, the window will also appear in the ALT+TAB application selection list.</span></span>  
  
 <span data-ttu-id="fed4d-526">用于 "任务栏" 按钮和 "ALT + TAB 应用程序选择" 列表的图标都是属性的值 <xref:System.Windows.Window.Icon%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-526">The icon that is used for both the task bar button and the ALT+TAB application selection list is the value of the <xref:System.Windows.Window.Icon%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-527">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-527">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-528">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-528">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-529">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-529">Identifier field</span></span>|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|<span data-ttu-id="fed4d-530">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-530">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-531">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-531">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-532">标识 <see cref="P:System.Windows.Window.ShowInTaskbar" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-532">Identifies the <see cref="P:System.Windows.Window.ShowInTaskbar" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-533">获取或设置一个值，该值指示窗口是否自动调整自身大小以适应其内容大小。</span><span class="sxs-lookup"><span data-stu-id="fed4d-533">Gets or sets a value that indicates whether a window will automatically size itself to fit the size of its content.</span></span></summary>
        <value><span data-ttu-id="fed4d-534">一个 <see cref="T:System.Windows.SizeToContent" /> 值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-534">A <see cref="T:System.Windows.SizeToContent" /> value.</span></span> <span data-ttu-id="fed4d-535">默认为 <see cref="F:System.Windows.SizeToContent.Manual" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-535">The default is <see cref="F:System.Windows.SizeToContent.Manual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-536">当 <xref:System.Windows.Window.SizeToContent%2A> 设置为时 <xref:System.Windows.SizeToContent.WidthAndHeight> ，设置 <xref:System.Windows.FrameworkElement.Height%2A> 或 <xref:System.Windows.FrameworkElement.Width%2A> 不起作用; 这两个属性都可以设置，但设置它们的值不会应用于窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-536">When <xref:System.Windows.Window.SizeToContent%2A> is set to <xref:System.Windows.SizeToContent.WidthAndHeight>, setting either <xref:System.Windows.FrameworkElement.Height%2A> or <xref:System.Windows.FrameworkElement.Width%2A> has no effect; both properties can be set, but the values they are set with are not applied to the window.</span></span>  
  
 <span data-ttu-id="fed4d-537">当 <xref:System.Windows.Window.SizeToContent%2A> 设置为时 <xref:System.Windows.SizeToContent.Height> ，设置不 <xref:System.Windows.FrameworkElement.Height%2A> 会更改窗口的高度。</span><span class="sxs-lookup"><span data-stu-id="fed4d-537">When <xref:System.Windows.Window.SizeToContent%2A> is set to <xref:System.Windows.SizeToContent.Height>, setting <xref:System.Windows.FrameworkElement.Height%2A> does not change the height of the window.</span></span>  
  
 <span data-ttu-id="fed4d-538">当 <xref:System.Windows.Window.SizeToContent%2A> 设置为时 <xref:System.Windows.SizeToContent.Width> ，设置不 <xref:System.Windows.FrameworkElement.Width%2A> 会更改窗口的宽度。</span><span class="sxs-lookup"><span data-stu-id="fed4d-538">When <xref:System.Windows.Window.SizeToContent%2A> is set to <xref:System.Windows.SizeToContent.Width>, setting <xref:System.Windows.FrameworkElement.Width%2A> does not change the width of the window.</span></span>  
  
 <span data-ttu-id="fed4d-539">如果的 <xref:System.Windows.Window.SizeToContent%2A> 值不是 <xref:System.Windows.SizeToContent.Manual> ：</span><span class="sxs-lookup"><span data-stu-id="fed4d-539">If <xref:System.Windows.Window.SizeToContent%2A> has a value other than <xref:System.Windows.SizeToContent.Manual>:</span></span>  
  
-   <span data-ttu-id="fed4d-540"><xref:System.Windows.Window.SizeToContent%2A><xref:System.Windows.SizeToContent.Manual>如果用户使用重设大小手柄或拖动边框来调整窗口的大小，则将自动设置为。</span><span class="sxs-lookup"><span data-stu-id="fed4d-540"><xref:System.Windows.Window.SizeToContent%2A> is automatically set to <xref:System.Windows.SizeToContent.Manual> if a user resizes the window by using the resize grip or dragging the border.</span></span>  
  
-   <span data-ttu-id="fed4d-541">如果内容大小以导致窗口大小调整的方式变化， <xref:System.Windows.FrameworkElement.SizeChanged> 则会引发。</span><span class="sxs-lookup"><span data-stu-id="fed4d-541">If the size of the content changes in a way that causes the window to resize itself, <xref:System.Windows.FrameworkElement.SizeChanged> is raised.</span></span>  
  
 <span data-ttu-id="fed4d-542">如果某个窗口是透明的 (参阅 <xref:System.Windows.Window.AllowsTransparency%2A>) ，应考虑将设置 <xref:System.Windows.Window.SizeToContent%2A> 为， <xref:System.Windows.SizeToContent.WidthAndHeight> 以确保该窗口不大于其可见内容。</span><span class="sxs-lookup"><span data-stu-id="fed4d-542">If a window is transparent (see <xref:System.Windows.Window.AllowsTransparency%2A>), you should consider setting <xref:System.Windows.Window.SizeToContent%2A> to <xref:System.Windows.SizeToContent.WidthAndHeight> to ensure the window is no larger than its visible content.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-543">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-543">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-544">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-544">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-545">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-545">Identifier field</span></span>|<xref:System.Windows.Window.SizeToContentProperty>|  
|<span data-ttu-id="fed4d-546">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-546">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-547">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-547">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="fed4d-548">下面的示例演示如何 <xref:System.Windows.Window.SizeToContent%2A> 在代码中设置属性，以指定如何调整窗口大小以适应其内容。</span><span class="sxs-lookup"><span data-stu-id="fed4d-548">The following example shows how to set the <xref:System.Windows.Window.SizeToContent%2A> property in code to specify how a window resizes to fit its content.</span></span>  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-549">标识 <see cref="P:System.Windows.Window.SizeToContent" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-549">Identifies the <see cref="P:System.Windows.Window.SizeToContent" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-550">引发此事件是为了支持与 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 的互操作。</span><span class="sxs-lookup"><span data-stu-id="fed4d-550">This event is raised to support interoperation with [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)].</span></span> <span data-ttu-id="fed4d-551">请参阅 <see cref="T:System.Windows.Interop.HwndSource" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-551">See <see cref="T:System.Windows.Interop.HwndSource" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-552">在窗口的 <see cref="P:System.Windows.Window.WindowState" /> 属性更改时发生。</span><span class="sxs-lookup"><span data-stu-id="fed4d-552">Occurs when the window's <see cref="P:System.Windows.Window.WindowState" /> property changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-553">获取或设置 <see cref="T:System.Windows.Window" /> 的 [!INCLUDE[win7](~/includes/win7-md.md)] 任务栏缩略图。</span><span class="sxs-lookup"><span data-stu-id="fed4d-553">Gets or sets the [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail for the <see cref="T:System.Windows.Window" />.</span></span></summary>
        <value><span data-ttu-id="fed4d-554"><see cref="T:System.Windows.Window" /> 的 [!INCLUDE[win7](~/includes/win7-md.md)] 任务栏缩略图。</span><span class="sxs-lookup"><span data-stu-id="fed4d-554">The [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail for the <see cref="T:System.Windows.Window" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-555">有关如何使用 [!INCLUDE[win7](~/includes/win7-md.md)] 任务栏缩略图的详细信息，请参阅 <xref:System.Windows.Shell.TaskbarItemInfo> 类。</span><span class="sxs-lookup"><span data-stu-id="fed4d-555">For more information about how to use the [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail, see the <xref:System.Windows.Shell.TaskbarItemInfo> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-556">标识 <see cref="P:System.Windows.Window.TaskbarItemInfo" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-556">Identifies the <see cref="P:System.Windows.Window.TaskbarItemInfo" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Windows.Localizability(System.Windows.LocalizationCategory.Title)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Windows.Localizability(System.Windows.LocalizationCategory.Title)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-557">获取或设置窗口的标题。</span><span class="sxs-lookup"><span data-stu-id="fed4d-557">Gets or sets a window's title.</span></span></summary>
        <value><span data-ttu-id="fed4d-558">一个 <see cref="T:System.String" />，包含窗口的标题。</span><span class="sxs-lookup"><span data-stu-id="fed4d-558">A <see cref="T:System.String" /> that contains the window's title.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-559"><xref:System.Windows.Window> <xref:System.Windows.Navigation.NavigationWindow> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] 还可以通过使用设置、或的标题 <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-559">The title of a <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, or [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], can also be set by using <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.</span></span>  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-560">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-560">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-561">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-561">Identifier field</span></span>|<xref:System.Windows.Window.TitleProperty>|  
|<span data-ttu-id="fed4d-562">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-562">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-563">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-563">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-564">标识 <see cref="P:System.Windows.Window.Title" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-564">Identifies the <see cref="P:System.Windows.Window.Title" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-565">获取或设置窗口上边缘相对于桌面的位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-565">Gets or sets the position of the window's top edge, in relation to the desktop.</span></span></summary>
        <value><span data-ttu-id="fed4d-566">以逻辑单位（1/96 英寸）表示的窗口上边缘位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-566">The position of the window's top, in logical units (1/96").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-567">当 <xref:System.Windows.Window> 最大化或最小化时，此值表示的还原点的上边缘 <xref:System.Windows.Window> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-567">When the <xref:System.Windows.Window> is maximized or minimized, this value represents the top edge of the restore point for the <xref:System.Windows.Window>.</span></span>  
  
 <span data-ttu-id="fed4d-568">不能通过样式设置此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-568">This property cannot be set through a style.</span></span>  
  
 <span data-ttu-id="fed4d-569">如果未指定值， <xref:System.Windows.Window.Top%2A> 则将设置为系统默认值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-569">If you do not specify a value, <xref:System.Windows.Window.Top%2A> is set to the system default value.</span></span> <span data-ttu-id="fed4d-570">还可以通过将设置为来指定系统默认 <xref:System.Windows.Window.Top%2A> 值 <xref:System.Double.NaN> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-570">You can also specify the system default value by setting <xref:System.Windows.Window.Top%2A> to <xref:System.Double.NaN>.</span></span> <span data-ttu-id="fed4d-571">和都不是的 <xref:System.Double.NegativeInfinity> <xref:System.Double.PositiveInfinity> 有效值 <xref:System.Windows.Window.Top%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-571">Neither <xref:System.Double.NegativeInfinity> nor <xref:System.Double.PositiveInfinity> is a valid value for <xref:System.Windows.Window.Top%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-572">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-572">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-573">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-573">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-574">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-574">Identifier field</span></span>|<xref:System.Windows.Window.TopProperty>|  
|<span data-ttu-id="fed4d-575">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-575">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-576">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-576">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-577">获取或设置一个值，该值指示窗口是否出现在 Z 顺序的最顶层。</span><span class="sxs-lookup"><span data-stu-id="fed4d-577">Gets or sets a value that indicates whether a window appears in the topmost z-order.</span></span></summary>
        <value><span data-ttu-id="fed4d-578">如果窗口是最顶层元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-578"><see langword="true" /> if the window is topmost; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-579">一个窗口，其 <xref:System.Windows.Window.Topmost%2A> 属性设置为 `true` 显示在所有其 <xref:System.Windows.Window.Topmost%2A> 属性设置为的窗口之上 `false` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-579">A window whose <xref:System.Windows.Window.Topmost%2A> property is set to `true` appears above all windows whose <xref:System.Windows.Window.Topmost%2A> properties are set to `false`.</span></span>  
  
 <span data-ttu-id="fed4d-580">在 <xref:System.Windows.Window.Topmost%2A> 将属性设置为的窗口组中 `true` ，当前激活的窗口是最顶部的窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-580">In the group of windows that have <xref:System.Windows.Window.Topmost%2A> property is set to `true`, the window that is currently activated is the topmost window.</span></span> <span data-ttu-id="fed4d-581">同样，将 <xref:System.Windows.Window.Topmost%2A> 属性设置为的窗口组也是如此 `false` 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-581">Likewise for the group of windows that have <xref:System.Windows.Window.Topmost%2A> property is set to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-582">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-582">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-583">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-583">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-584">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-584">Identifier field</span></span>|<xref:System.Windows.Window.TopmostProperty>|  
|<span data-ttu-id="fed4d-585">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-585">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-586">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-586">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-587">标识 <see cref="P:System.Windows.Window.Topmost" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-587">Identifies the <see cref="P:System.Windows.Window.Topmost" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-588">标识 <see cref="P:System.Windows.Window.Top" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-588">Identifies the <see cref="P:System.Windows.Window.Top" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-589">获取或设置窗口首次显示时的位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-589">Gets or sets the position of the window when first shown.</span></span></summary>
        <value><span data-ttu-id="fed4d-590">一个 <see cref="T:System.Windows.WindowStartupLocation" /> 值，指定窗口首次显示时的顶边/左边位置。</span><span class="sxs-lookup"><span data-stu-id="fed4d-590">A <see cref="T:System.Windows.WindowStartupLocation" /> value that specifies the top/left position of a window when first shown.</span></span> <span data-ttu-id="fed4d-591">默认为 <see cref="F:System.Windows.WindowStartupLocation.Manual" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-591">The default is <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-592">将 `WindowStartupLocation` 属性设置为将 <xref:System.Windows.WindowStartupLocation.Manual> 使窗口根据其 <xref:System.Windows.Window.Left%2A> 和 <xref:System.Windows.Window.Top%2A> 属性值定位。</span><span class="sxs-lookup"><span data-stu-id="fed4d-592">Setting the `WindowStartupLocation` property to <xref:System.Windows.WindowStartupLocation.Manual> causes a window to be positioned according to its <xref:System.Windows.Window.Left%2A> and <xref:System.Windows.Window.Top%2A> property values.</span></span> <span data-ttu-id="fed4d-593">如果 <xref:System.Windows.Window.Left%2A> <xref:System.Windows.Window.Top%2A> 未指定或属性，则其值由 Windows 决定。</span><span class="sxs-lookup"><span data-stu-id="fed4d-593">If either the <xref:System.Windows.Window.Left%2A> or <xref:System.Windows.Window.Top%2A> properties aren't specified, their values are determined by Windows.</span></span>  
  
 <span data-ttu-id="fed4d-594">如果将 `WindowStartupLocation` 属性设置为，则 <xref:System.Windows.WindowStartupLocation.CenterScreen> 会使窗口位于包含鼠标光标的屏幕的中央。</span><span class="sxs-lookup"><span data-stu-id="fed4d-594">Setting the `WindowStartupLocation` property to <xref:System.Windows.WindowStartupLocation.CenterScreen> causes a window to be positioned in the center of the screen that contains the mouse cursor.</span></span>  
  
 <span data-ttu-id="fed4d-595">如果将 `WindowStartupLocation` 属性设置为，则 <xref:System.Windows.WindowStartupLocation.CenterOwner> 会将窗口定位在其所有者窗口的中心 (参阅 <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>) （如果已指定）。</span><span class="sxs-lookup"><span data-stu-id="fed4d-595">Setting the `WindowStartupLocation` property to <xref:System.Windows.WindowStartupLocation.CenterOwner> causes a window to be positioned in the center of its owner window (see <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>), if specified.</span></span> <span data-ttu-id="fed4d-596">所有者窗口可以是另一个 WPF 窗口或非 WPF 窗口。</span><span class="sxs-lookup"><span data-stu-id="fed4d-596">The owner window can be either another WPF window or a non-WPF window.</span></span>

> [!NOTE]   
>  <span data-ttu-id="fed4d-597">有关具有非 WPF 窗口的 WPF 窗口的详细信息，请参阅 [wpf 和 Win32 互操作](/dotnet/framework/wpf/advanced/wpf-and-win32-interoperation) 性和 <xref:System.Windows.Interop.WindowInteropHelper> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-597">For more information about WPF windows with non-WPF windows, see [WPF and Win32 Interoperation](/dotnet/framework/wpf/advanced/wpf-and-win32-interoperation) and <xref:System.Windows.Interop.WindowInteropHelper>.</span></span> 

 <span data-ttu-id="fed4d-598">如果未指定所有者窗口，将按照与 `WindowStartupLocation` 将属性设置为相同的方式确定窗口的位置 <xref:System.Windows.WindowStartupLocation.Manual> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-598">If an owner window is not specified, the position of the window is determined in the same way as if the `WindowStartupLocation` property is set to <xref:System.Windows.WindowStartupLocation.Manual>.</span></span>

> [!NOTE]
>  <span data-ttu-id="fed4d-599">当窗口承载于浏览器中时，不能设置或获取此属性的值。</span><span class="sxs-lookup"><span data-stu-id="fed4d-599">You cannot set or get the value of this property when a window is hosted in a browser.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-600">获取或设置一个值，该值指示窗口是处于还原、最小化还是最大化状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-600">Gets or sets a value that indicates whether a window is restored, minimized, or maximized.</span></span></summary>
        <value><span data-ttu-id="fed4d-601">一个 <see cref="T:System.Windows.WindowState" />，确定窗口是处于还原、最小化还是最大化状态。</span><span class="sxs-lookup"><span data-stu-id="fed4d-601">A <see cref="T:System.Windows.WindowState" /> that determines whether a window is restored, minimized, or maximized.</span></span> <span data-ttu-id="fed4d-602">默认值为 <see cref="F:System.Windows.WindowState.Normal" />（还原）。</span><span class="sxs-lookup"><span data-stu-id="fed4d-602">The default is <see cref="F:System.Windows.WindowState.Normal" /> (restored).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-603">最小化或最大化窗口之前，窗口的大小和位置存储在中 <xref:System.Windows.Window.RestoreBounds%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-603">Before a window is minimized or maximized, its size and location are stored in <xref:System.Windows.Window.RestoreBounds%2A>.</span></span> <span data-ttu-id="fed4d-604">在随后还原窗口时，会使用中的值还原其大小和位置值 <xref:System.Windows.Window.RestoreBounds%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-604">When a window is subsequently restored, its size and location values are restored with the values from <xref:System.Windows.Window.RestoreBounds%2A>.</span></span>  
  
 <span data-ttu-id="fed4d-605">当 <xref:System.Windows.Window.WindowState%2A> 属性更改时， <xref:System.Windows.Window.StateChanged> 将引发。</span><span class="sxs-lookup"><span data-stu-id="fed4d-605">When the <xref:System.Windows.Window.WindowState%2A> property is changed, <xref:System.Windows.Window.StateChanged> is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-606">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-606">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-607">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-607">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-608">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-608">Identifier field</span></span>|<xref:System.Windows.Window.WindowStateProperty>|  
|<span data-ttu-id="fed4d-609">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-609">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-610">标识 <see cref="P:System.Windows.Window.WindowState" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-610">Identifies the <see cref="P:System.Windows.Window.WindowState" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-611">获取或设置窗口的边框样式。</span><span class="sxs-lookup"><span data-stu-id="fed4d-611">Gets or sets a window's border style.</span></span></summary>
        <value><span data-ttu-id="fed4d-612">一个指定窗口边框样式的 <see cref="T:System.Windows.WindowStyle" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-612">A <see cref="T:System.Windows.WindowStyle" /> that specifies a window's border style.</span></span> <span data-ttu-id="fed4d-613">默认为 <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />。</span><span class="sxs-lookup"><span data-stu-id="fed4d-613">The default is <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fed4d-614"><xref:System.Windows.Window.WindowStyle%2A> 可以是 <xref:System.Windows.WindowStyle> 枚举值之一，包括 <xref:System.Windows.WindowStyle.None> 、 <xref:System.Windows.WindowStyle.ToolWindow> 、 <xref:System.Windows.WindowStyle.SingleBorderWindow> (默认) 和 <xref:System.Windows.WindowStyle.ThreeDBorderWindow> 。</span><span class="sxs-lookup"><span data-stu-id="fed4d-614"><xref:System.Windows.Window.WindowStyle%2A> can be one of the <xref:System.Windows.WindowStyle> enumeration values, including <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (default), and <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.</span></span>  
  
 <span data-ttu-id="fed4d-615">下图显示了 [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero 主题上的窗口样式，并启用了透明玻璃) ：</span><span class="sxs-lookup"><span data-stu-id="fed4d-615">The following figure shows the window styles on [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero theme, with transparent glass enabled):</span></span>  
  
 <span data-ttu-id="fed4d-616">![窗口样式](~/add/media/windowoverviewfigure6.PNG "窗口样式")</span><span class="sxs-lookup"><span data-stu-id="fed4d-616">![Window styles](~/add/media/windowoverviewfigure6.PNG "Window styles")</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fed4d-617">当窗口承载于浏览器中时，不能设置或获取此属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-617">You cannot set or get this property when a window is hosted in a browser.</span></span>  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fed4d-618">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="fed4d-618">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fed4d-619">标识符字段</span><span class="sxs-lookup"><span data-stu-id="fed4d-619">Identifier field</span></span>|<xref:System.Windows.Window.WindowStyleProperty>|  
|<span data-ttu-id="fed4d-620">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="fed4d-620">Metadata properties set to `true`</span></span>|<span data-ttu-id="fed4d-621">无</span><span class="sxs-lookup"><span data-stu-id="fed4d-621">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="fed4d-622">标识 <see cref="P:System.Windows.Window.WindowStyle" /> 依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="fed4d-622">Identifies the <see cref="P:System.Windows.Window.WindowStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
