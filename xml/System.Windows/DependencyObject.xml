<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6341e55b3de6c47bf521f6ddaa3ec659af2622ed" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102066796" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示参与依赖属性系统的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject>类在其多个派生类上启用 (WPF) 属性系统服务 Windows Presentation Foundation。  
  
 属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的其他键类为 <xref:System.Windows.DependencyProperty> 。 <xref:System.Windows.DependencyProperty> 允许将依赖属性注册到属性系统，并提供有关每个依赖属性的标识和信息，而 <xref:System.Windows.DependencyObject> 作为基类使对象可以使用依赖项属性。  
  
 <xref:System.Windows.DependencyObject> 服务和特征包括：  
  
-   依赖属性承载支持。 通过调用 <xref:System.Windows.DependencyProperty.Register%2A> 方法，并将该方法的返回值存储为类中的公共静态字段，来注册依赖属性。  
  
-   附加属性托管支持。 可以通过调用方法来注册附加属性 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> ，并将该方法的返回值存储为类中的公共静态只读字段。  (还有其他成员要求;请注意，这表示附加属性的 WPF 特定实现。 有关详细信息，请参阅 [附加属性概述](/dotnet/framework/wpf/advanced/attached-properties-overview)。然后可以在派生自的任何类上设置附加属性 <xref:System.Windows.DependencyObject> ) 。  
  
-   获取、设置和清除中存在的任何依赖项属性值的实用工具方法 <xref:System.Windows.DependencyObject> 。  
  
-   元数据、强制值支持、属性更改通知和替代依赖属性或附加属性的回调。 此外， <xref:System.Windows.DependencyObject> 类还有助于依赖项属性的每个所有者的属性元数据。  
  
-   派生自、或的类的公共 <xref:System.Windows.ContentElement> 基类 <xref:System.Windows.Freezable> <xref:System.Windows.Media.Visual> 。  (<xref:System.Windows.UIElement> ，另一个基元素类具有包含的类层次结构 <xref:System.Windows.Media.Visual> 。 )   
  
   
  
## Examples  
 下面的示例从派生 <xref:System.Windows.DependencyObject> ，以创建一个新的抽象类。 然后，类将注册附加属性，并包含该附加属性的支持成员。  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.DependencyObject" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要清除的由 <see cref="T:System.Windows.DependencyProperty" /> 对象引用指定的依赖属性。</param>
        <summary>清除属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyProperty" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用来清除属性值 <xref:System.Windows.DependencyObject.ClearValue%2A> 并不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除属性仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 来清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">要清除的依赖属性的关键字。</param>
        <summary>清除只读属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyPropertyKey" /> 指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey>标识属性系统操作的只读依赖属性。 定义只读依赖项属性的类不应公开此密钥的公共访问权限。 公开密钥将提供一个非属性的只读字符的公共代码路径，前提 <xref:System.Windows.DependencyObject.ClearValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> 是可以在类或程序集的外部调用方法（如或），并引用密钥。  
  
 通过调用来清除属性值 <xref:System.Windows.DependencyObject.ClearValue%2A> 并不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除该值仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要强制转换的依赖项属性的标识符。</param>
        <summary>对指定依赖属性的值进行强制。 通过对调用方 <see cref="T:System.Windows.DependencyObject" /> 上存在的依赖属性的属性元数据中所指定的任何 <see cref="T:System.Windows.CoerceValueCallback" /> 函数进行调用来完成此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了通过调用显式调用以外 <xref:System.Windows.DependencyObject.CoerceValue%2A> ， <xref:System.Windows.CoerceValueCallback> 每当 WPF 属性系统重新计算依赖属性值时，也会在内部调用依赖属性的。  
  
 调用 <xref:System.Windows.DependencyObject.CoerceValue%2A> 方法时，最终将为指定的属性调用强制值回叫。 通常， <xref:System.Windows.DependencyObject.CoerceValue%2A> 仅当知道强制值回调存在并且知道回调的强制条件时，才会调用。  
  
 调用的最常见的情况 <xref:System.Windows.DependencyObject.CoerceValue%2A> 是在类处理或属性更改回调的相关属性中，这些属性会以从属方式影响彼此的值。 有关详细信息，请参阅[依赖属性回调和验证](/dotnet/framework/wpf/advanced/dependency-property-callbacks-and-validation)。  
  
   
  
## Examples  
 下面的示例在用作 <xref:System.Windows.DependencyObject.CoerceValue%2A> <xref:System.Windows.PropertyChangedCallback> <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 相同类的不同依赖属性的实现中调用。 这是在依赖属性之间引入 true 值依赖项的常见模式。  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效或不存在。</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.DependencyObjectType" /> 包装此实例的 CLR 类型的。</summary>
        <value><see cref="T:System.Windows.DependencyObjectType" />包装此实例的 CLR 类型的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从方法返回的对象的返回值类型为 <xref:System.Windows.DependencyObject> ，并且你希望根据其类型对其执行特定于属性系统的操作，则此属性很有用。 例如， <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> 使用 <xref:System.Windows.DependencyObjectType> 而不是 CLR 类型调用更有效。 <xref:System.Windows.DependencyObjectType> 有助于加快查找速度。  
  
   
  
## Examples  
 在下面的伪代码示例中， `MySubClass` 预计其他派生类可能会更改依赖属性的默认值 `MyCustom` 。 类实现一个无参数的构造函数，该构造函数可以通过在值上利用多态性 <xref:System.Windows.DependencyObjectType> ，只要该构造函数用作派生类 instantiator。  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前实例进行比较的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>确定提供的 <see cref="T:System.Windows.DependencyObject" /> 是否等效于当前 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>如果两个实例相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现只是引用相等性，不会尝试计算所包含属性的值相等性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> 重写然后密封两种基本 <see cref="T:System.Object" /> 方法： <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> 和 <see cref="M:System.Windows.DependencyObject.GetHashCode" /> 。 重写调用 <see cref="T:System.Object" /> 实现，从而导致对象相等行为。 这些有意的替代的目的是防止派生类尝试为指定值相等性 <see cref="T:System.Windows.DependencyObject" /> 。 的值 equalities <see cref="T:System.Windows.DependencyObject" /> 将永远不准确，这是因为原始属性值更改功能 <see cref="T:System.Windows.DependencyObject" /> 及其依赖属性。 这包括基本 WPF 功能，如数据绑定和 WPF 属性系统。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此 <see cref="T:System.Windows.DependencyObject" /> 的哈希代码。</summary>
        <returns>带符号 32 位整数哈希代码。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> 重写然后密封两种 <see cref="T:System.Object" /> 方法： <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> 和 <see cref="M:System.Windows.DependencyObject.GetHashCode" /> 。 重写调用 <see cref="T:System.Object" /> 实现，从而导致对象相等行为。 这些有意的替代的目的是防止派生类尝试为指定值相等性 <see cref="T:System.Windows.DependencyObject" /> 。 的值 equalities <see cref="T:System.Windows.DependencyObject" /> 将永远不准确，这是因为原始属性值更改功能 <see cref="T:System.Windows.DependencyObject" /> 及其依赖属性。 这包括基本 WPF 功能，如数据绑定和 WPF 属性系统。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个专用的枚举数，用于确定哪些依赖项属性在此 <see cref="T:System.Windows.DependencyObject" /> 上具有以本地方式设置的值。</summary>
        <returns>一个专用的本地值枚举数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *本地值* 是由设置的任何依赖属性值 <xref:System.Windows.DependencyObject.SetValue%2A> ，而不是属性系统的其他方面。  
  
 <xref:System.Windows.LocalValueEnumerator>通过调用获取的 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 可用于枚举在实例上具有本地设置的值的属性 <xref:System.Windows.DependencyObject> 。 每个这样的属性都由一个对象在枚举器中表示 <xref:System.Windows.LocalValueEntry> ，该对象的属性引用特定的 <xref:System.Windows.DependencyProperty> 及其值。 这种枚举本地集值的方法可用于优化或用于本地值的其他处理，例如，确定的哪些属性值 <xref:System.Windows.DependencyObject> 会更改（如果它们已被清除）。  
  
> [!IMPORTANT]
>  返回的 <xref:System.Windows.LocalValueEnumerator> 可能包含 <xref:System.Windows.LocalValueEntry> 只读依赖项属性的记录或属性系统计算值的依赖项属性。 例如，具有通过布局建立的宽度的视觉框架元素将报告的本地值 <xref:System.Windows.FrameworkElement.ActualWidth%2A> 。 如果你正在获取本地值来重置它们，请检查 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 每个的属性标识符上的值， <xref:System.Windows.LocalValueEntry> 以验证 <xref:System.Windows.DependencyProperty> 问题是否不是只读的。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 来清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要检索其值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>对 <see cref="T:System.Windows.DependencyObject" /> 的此实例返回依赖属性的当前有效值。</summary>
        <returns>返回当前有效值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *有效的值* 是属性系统返回给请求该值的任何调用方的属性的值。 有效的值是属性系统计算所有可能的输入，这些输入都参与属性系统值的优先级。 这包括强制和动画。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 此方法将永远不会返回 <xref:System.Windows.DependencyProperty.UnsetValue> 。 <xref:System.Windows.DependencyProperty.UnsetValue>是属性系统的一个 sentinel 值，可在内部使用并偶尔通过强制回调公开。  
  
 如果不确定属性的类型，则可以查询请求的依赖项属性的标识符，以确定是否有更具体的 <xref:System.Windows.DependencyProperty.PropertyType%2A> 返回值可以转换为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定 <paramref name="dp" /> 或其值无效，或者指定 <paramref name="dp" /> 不存在。</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要使其失效的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>重新评估指定依赖属性的有效值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用时 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> ， <xref:System.Windows.CoerceValueCallback> 可能会 <xref:System.Windows.PropertyChangedCallback> 调用为该依赖属性注册的任何关联的和适用的或函数。  
  
 <xref:System.Windows.DependencyObject.InvalidateProperty%2A>对设置了本地值的属性调用将不起作用，因为本地值优先于其他属性系统输入，动画除外。 但是，您可以调用 <xref:System.Windows.DependencyObject.ClearValue%2A> ，然后调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 不一定适用于许多依赖属性方案。 如果因任何组成部分中的值发生更改而导致依赖属性无效，则属性系统将使该依赖属性自动失效并重新计算该属性。 但仍有一些适合的方案 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 。 特别是，可以在 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 其他依赖属性的强制值或属性更改回调内使用。 你还可以使用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 来对无法实现建议的通知机制的数据源 <xref:System.ComponentModel.INotifyPropertyChanged> （如果使用不能从派生的数据类）或数据是静态成员) 的数据源强制重新计算绑定 (。  
  
   
  
## Examples  
 下面的示例 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 在自定义属性上调用，而在属性的计算中涉及的属性发生变化时。 这是一种调用方法的替代方法 <xref:System.Windows.DependencyObject.CoerceValue%2A> ，因为使属性失效还会调用任何已注册的 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 。  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此实例当前是否为密封的（只读）。</summary>
        <value>如果此实例是密封的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值在内部设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">将包含相关依赖属性标识符、类型的属性元数据以及旧值和新值的事件数据。</param>
        <summary>每当更新此 <see cref="T:System.Windows.DependencyObject" /> 的任何依赖属性的有效值时调用。 更改的特定依赖属性将在事件数据中报告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常不用于检测单个属性更改，也不会对每个案例执行属性失效。 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 用于修改常规失效模式，前提是了解有关属性的广泛分类的信息。 例如，中的更改 <xref:System.Windows.Freezable> 可能是的值类型发生更改 <xref:System.Windows.Freezable> ，也可能是子属性，其中的更改在其他 <xref:System.Windows.Freezable> 引用内。 <xref:System.Windows.Freezable>的重写实现 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 使用内部信息来确定属性是否为子属性，并为任意一种情况提供适当的基类逻辑。  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 在对象的整个生存期内，可能会多次调用。 因此，如果你重写特定属性的元数据，然后 <xref:System.Windows.CoerceValueCallback> 为单个属性附加或函数，则可以为整个属性系统获得更好的性能 <xref:System.Windows.PropertyChangedCallback> 。 但是，如果 <xref:System.Windows.DependencyObject> 包含大量与值相关的依赖项属性，则可以使用此方法，或者，如果包含的逻辑（如呈现行为）必须针对属性失效的几个相关事例重新运行，则应使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现。 如果不这样做，将明显禁用整个 WPF 属性系统，从而导致报告不正确的值。</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要检索其值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>如果存在，则返回依赖属性的本地值。</summary>
        <returns>返回本地值，或者如果未设置本地值，则返回 sentinel 值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于依赖属性，您应使用 <xref:System.Windows.DependencyObject.GetValue%2A> 最典型的 "get" 操作。 <xref:System.Windows.DependencyObject.ReadLocalValue%2A> 如果值不是本地设置的，则不会返回有效的值。  
  
 由 "样式"、"主题"、"模板"、"元数据" 或 "属性值继承" 的默认值设置的值不被视为本地值。 但是，在计算绑定和其他表达式后，它们被视为本地值。  
  
 如果未设置本地值，则此方法返回 <xref:System.Windows.DependencyProperty.UnsetValue> 。  
  
 如果返回的值不是 <xref:System.Windows.DependencyProperty.UnsetValue> ，则可以查询请求的依赖项属性的元数据，以确定是否有更具体的类型可以将返回值转换为。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的值而不更改其值源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由组件使用，该组件以编程方式设置其自己的属性之一的值，而无需禁用应用程序声明的属性用法。 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>方法可更改属性的有效值，但现有触发器、数据绑定和样式将继续工作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖属性或密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是为 <paramref name="dp" /> 属性注册的正确类型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置依赖属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的本地值，该值由其依赖属性标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 `value`应始终将参数提供为适当的类型。  
  
 在 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 所设置的依赖项属性的依赖项属性标识符上存在回调时，异常情况可能会受到影响。 否则，提供的值可能会失败， (例如，在本机类型为双) 精度类型时传递字符串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖属性或密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是为 <paramref name="dp" /> 属性注册的正确类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要设置的属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置一个只读依赖属性的本地值，该值由依赖属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你为自定义类定义的只读依赖项属性设置值时，通常使用此签名。 通常， <xref:System.Windows.DependencyObject.SetValue%2A> 仅从注册该依赖项属性的类型调用，后者实现为依赖属性提供确定值的内部逻辑。 有关详细信息，请参阅[只读依赖属性](/dotnet/framework/wpf/advanced/read-only-dependency-properties)。  
  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 `value`应始终将参数提供为适当的类型。 在 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 所设置的依赖项属性的依赖项属性标识符上存在回调时，异常情况可能会受到影响。  
  
   
  
## Examples  
 下面的示例定义了一个只读依赖项属性，以及一个 `public static readonly` <xref:System.Windows.DependencyProperty> 为属性使用者提供了必需的只读公开的，以及 CLR 包装的 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">应被序列化的依赖项属性的标识符。</param>
        <summary>返回一个值，该值指示序列化进程是否应序列化所提供的依赖属性的值。</summary>
        <returns>如果应对所提供的依赖属性的值进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `true` 依赖属性在上建立了一个本地值，则默认实现将返回 <xref:System.Windows.DependencyObject> 。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的替代可能以不同方式处理特定依赖属性。</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
