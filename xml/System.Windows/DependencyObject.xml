<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2c01cc2a18274c897823b5c44256769b3fd267f9" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83901588" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示参与依赖属性系统的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> 类在其多个派生类上启用 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 属性系统服务。  
  
 属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的另一个键类 <xref:System.Windows.DependencyProperty>。 <xref:System.Windows.DependencyProperty> 允许将依赖属性注册到属性系统，并提供有关每个依赖属性的标识和信息，而 <xref:System.Windows.DependencyObject> 为基类使对象能够使用依赖属性。  
  
 <xref:System.Windows.DependencyObject> 服务和特征包括：  
  
-   依赖属性承载支持。 通过调用 <xref:System.Windows.DependencyProperty.Register%2A> 方法，并将该方法的返回值存储为类中的公共静态字段，来注册依赖属性。  
  
-   附加属性托管支持。 通过调用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 方法，并将该方法的返回值存储为类中的公共静态只读字段，来注册附加属性。 （还有其他成员要求; 请注意，这表示附加属性的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 特定实现。 有关详细信息，请参阅[附加属性概述](/dotnet/framework/wpf/advanced/attached-properties-overview)。）然后，可以在从 <xref:System.Windows.DependencyObject>派生的任何类上设置附加属性。  
  
-   获取、设置和清除 <xref:System.Windows.DependencyObject>上存在的任何依赖项属性的值的实用工具方法。  
  
-   元数据、强制值支持、属性更改通知和替代依赖属性或附加属性的回调。 此外，<xref:System.Windows.DependencyObject> 类简化了依赖属性的每个所有者的属性元数据。  
  
-   从 <xref:System.Windows.ContentElement>、<xref:System.Windows.Freezable>或 <xref:System.Windows.Media.Visual>派生的类的公共基类。 （<xref:System.Windows.UIElement>，另一个基元素类具有包含 <xref:System.Windows.Media.Visual>的类层次结构。）  
  
   
  
## Examples  
 下面的示例从 <xref:System.Windows.DependencyObject> 派生，以创建一个新的抽象类。 然后，类将注册附加属性，并包含该附加属性的支持成员。  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.DependencyObject" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要清除的由 <see cref="T:System.Windows.DependencyProperty" /> 对象引用指定的依赖属性。</param>
        <summary>清除属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyProperty" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 清除属性值不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除属性仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 以清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">要清除的依赖属性的关键字。</param>
        <summary>清除只读属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyPropertyKey" /> 指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey> 标识属性系统操作的只读依赖属性。 定义只读依赖项属性的类不应公开此密钥的公共访问权限。 如果在引用密钥的类或程序集的外部调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 或 <xref:System.Windows.DependencyObject.SetValue%2A> 等方法，则公开的密钥将提供取反属性的只读字符的公共代码路径。  
  
 通过调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 清除属性值不一定为依赖属性指定在依赖项属性元数据中指定的默认值。 清除该值仅会专门清除可能应用的任何本地值。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要强制转换的依赖项属性的标识符。</param>
        <summary>对指定依赖属性的值进行强制。 通过对调用方 <see cref="T:System.Windows.DependencyObject" /> 上存在的依赖属性的属性元数据中所指定的任何 <see cref="T:System.Windows.CoerceValueCallback" /> 函数进行调用来完成此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了通过调用 <xref:System.Windows.DependencyObject.CoerceValue%2A>显式调用以外，每当 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统重新计算依赖属性值时，也会在内部调用依赖属性的 <xref:System.Windows.CoerceValueCallback>。  
  
 调用 <xref:System.Windows.DependencyObject.CoerceValue%2A> 方法时，最终将为指定的属性调用强制值回叫。 通常，仅当知道强制值回调存在并且知道回调的强制条件时，才会调用 <xref:System.Windows.DependencyObject.CoerceValue%2A>。  
  
 调用 <xref:System.Windows.DependencyObject.CoerceValue%2A> 的最常见方案是在类处理或属性更改回调的相关属性中，这些属性会以从属方式影响彼此的值。 有关详细信息，请参阅[依赖属性回调和验证](/dotnet/framework/wpf/advanced/dependency-property-callbacks-and-validation)。  
  
   
  
## Examples  
 下面的示例在 <xref:System.Windows.PropertyChangedCallback> 实现中调用 <xref:System.Windows.DependencyObject.CoerceValue%2A>，该实现用作相同类上不同依赖属性的 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>。 这是在依赖属性之间引入 true 值依赖项的常见模式。  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效或不存在。</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</summary>
        <value>对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从方法返回的对象的返回值类型为 <xref:System.Windows.DependencyObject> 并且想要根据其类型执行特定于属性系统的操作，则此属性很有用。 例如，使用 <xref:System.Windows.DependencyObjectType> 而不是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型调用 <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> 更为有效。 <xref:System.Windows.DependencyObjectType> 有助于加快查找速度。  
  
   
  
## Examples  
 在下面的伪代码示例中，`MySubClass` 预测其他派生类可能更改 `MyCustom` 依赖属性的默认值。 类实现一个无参数的构造函数，该构造函数可通过在 <xref:System.Windows.DependencyObjectType> 值上利用多态性，只要该构造函数用作 instantiator 派生类。  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前实例进行比较的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>确定提供的 <see cref="T:System.Windows.DependencyObject" /> 是否等效于当前 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>如果两个实例相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现只是引用相等性，不会尝试计算所包含属性的值相等性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> 重写，然后密封两个基本 <see cref="T:System.Object" /> 方法： <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> 和 <see cref="M:System.Windows.DependencyObject.GetHashCode" />。 重写调用 <see cref="T:System.Object" /> 实现，导致对象相等性行为。 这些有意的替代的目的是防止派生类尝试为 <see cref="T:System.Windows.DependencyObject" />定义值相等性。 由于 <see cref="T:System.Windows.DependencyObject" /> 及其依赖属性的原始属性值更改功能，<see cref="T:System.Windows.DependencyObject" /> 的值 equalities 将永远不准确。 这包括基本 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 功能，如数据绑定和 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此 <see cref="T:System.Windows.DependencyObject" /> 的哈希代码。</summary>
        <returns>带符号 32 位整数哈希代码。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> 重写，然后密封两个 <see cref="T:System.Object" /> 方法： <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> 和 <see cref="M:System.Windows.DependencyObject.GetHashCode" />。 重写调用 <see cref="T:System.Object" /> 实现，导致对象相等性行为。 这些有意的替代的目的是防止派生类尝试为 <see cref="T:System.Windows.DependencyObject" />定义值相等性。 由于 <see cref="T:System.Windows.DependencyObject" /> 及其依赖属性的原始属性值更改功能，<see cref="T:System.Windows.DependencyObject" /> 的值 equalities 将永远不准确。 这包括基本 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 功能，如数据绑定和 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个专用的枚举数，用于确定哪些依赖项属性在此 <see cref="T:System.Windows.DependencyObject" /> 上具有以本地方式设置的值。</summary>
        <returns>一个专用的本地值枚举数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *本地值*是 <xref:System.Windows.DependencyObject.SetValue%2A>所设置的任何依赖属性值，而不是属性系统的其他方面。  
  
 通过调用 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 获取的 <xref:System.Windows.LocalValueEnumerator> 可用于枚举 <xref:System.Windows.DependencyObject> 实例上具有本地设置值的属性。 每个这样的属性都在枚举器中表示 <xref:System.Windows.LocalValueEntry> 对象，该对象具有引用特定 <xref:System.Windows.DependencyProperty> 及其值的属性。 这种枚举本地集值的方法可用于优化或本地值的其他处理，例如，用于确定 <xref:System.Windows.DependencyObject> 在清除时将更改的属性值。  
  
> [!IMPORTANT]
>  返回的 <xref:System.Windows.LocalValueEnumerator> 可能包含只读的依赖项属性的 <xref:System.Windows.LocalValueEntry> 记录或属性系统计算值的依赖项属性。 例如，具有通过布局建立的宽度的视觉框架元素会报告 <xref:System.Windows.FrameworkElement.ActualWidth%2A>的本地值。 如果你正在获取本地值以重置它们，请检查每个 <xref:System.Windows.LocalValueEntry> 的属性标识符上的 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 值，以验证相关 <xref:System.Windows.DependencyProperty> 是否不是只读的。  
  
   
  
## Examples  
 下面的示例循环访问所有在对象上设置了本地值的属性，然后调用 <xref:System.Windows.DependencyObject.ClearValue%2A> 以清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要检索其值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>对 <see cref="T:System.Windows.DependencyObject" /> 的此实例返回依赖属性的当前有效值。</summary>
        <returns>返回当前有效值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *有效的值*是属性系统返回给请求该值的任何调用方的属性的值。 有效的值是属性系统计算所有可能的输入，这些输入都参与属性系统值的优先级。 这包括强制和动画。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 此方法从不返回 <xref:System.Windows.DependencyProperty.UnsetValue>。 <xref:System.Windows.DependencyProperty.UnsetValue> 是属性系统的一个 sentinel 值，用于内部使用的各种容量，偶尔也会通过强制回调公开。  
  
 如果不确定属性的类型，则可以查询请求的依赖属性的标识符，以确定是否有更具体的 <xref:System.Windows.DependencyProperty.PropertyType%2A> 可以将返回值转换为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定 <paramref name="dp" /> 或其值无效，或者指定 <paramref name="dp" /> 不存在。</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要使其失效的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>重新评估指定依赖属性的有效值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A>时，可能会调用为该依赖属性注册的任何关联的和适用的 <xref:System.Windows.CoerceValueCallback> 或 <xref:System.Windows.PropertyChangedCallback> 函数。  
  
 对设置了本地值的属性调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 将不起作用，因为本地值优先于其他属性系统输入，动画除外。 但是，你可以调用 <xref:System.Windows.DependencyObject.ClearValue%2A>，然后调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A>。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
 调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 不一定适用于许多依赖属性方案。 如果因任何组成部分中的值发生更改而导致依赖属性无效，则属性系统将使该依赖属性自动失效并重新计算该属性。 但在某些情况下，<xref:System.Windows.DependencyObject.InvalidateProperty%2A> 会很有用。 特别是，可以在其他依赖属性的强制值或属性更改回调内使用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A>。 你还可以使用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A> 来强制对不能实现建议 <xref:System.ComponentModel.INotifyPropertyChanged> 通知机制的数据源（可能是使用不能从派生的数据类，或数据为静态成员的数据源）进行重新计算。  
  
   
  
## Examples  
 下面的示例在自定义属性上调用 <xref:System.Windows.DependencyObject.InvalidateProperty%2A>，而在发生了无效属性的计算中所涉及的属性发生变化时。 这是调用 <xref:System.Windows.DependencyObject.CoerceValue%2A> 方法的另一种方法，因为使属性失效还会调用任何已注册的 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此实例当前是否为密封的（只读）。</summary>
        <value>如果此实例是密封的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值在内部设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">将包含相关依赖属性标识符、类型的属性元数据以及旧值和新值的事件数据。</param>
        <summary>每当更新此 <see cref="T:System.Windows.DependencyObject" /> 的任何依赖属性的有效值时调用。 更改的特定依赖属性将在事件数据中报告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常不用于检测单个属性更改，也不会对每个案例执行属性失效。 如果某些信息对属性的广泛分类有了解，<xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 将作为常规失效模式的修改。 例如，<xref:System.Windows.Freezable> 中的更改可能是 <xref:System.Windows.Freezable>的值类型发生更改，也可能是子属性，其中的更改在其他 <xref:System.Windows.Freezable> 引用内。 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 的 <xref:System.Windows.Freezable> 重写实现使用内部信息来确定属性是否为子属性，并为任何一种情况提供适当的基类逻辑。  
  
 在对象的整个生存期内，可能会多次调用 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>。 因此，如果你重写特定属性的元数据，然后为单个属性附加 <xref:System.Windows.CoerceValueCallback> 或 <xref:System.Windows.PropertyChangedCallback> 函数，则可以为整个属性系统获得更好的性能。 但是，如果 <xref:System.Windows.DependencyObject> 包含大量与值相关的依赖项属性，则可以使用此方法，或者，如果包含的是必须重新运行的逻辑（如属性失效的几个相关案例），则应使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现。 否则，将明显禁用整个 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统，从而导致报告错误的值。</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要检索其值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>如果存在，则返回依赖属性的本地值。</summary>
        <returns>返回本地值，或者如果未设置本地值，则返回 sentinel 值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于依赖属性，应使用 <xref:System.Windows.DependencyObject.GetValue%2A> 来执行最典型的 "get" 操作。 对于未本地设置值的各种情况，<xref:System.Windows.DependencyObject.ReadLocalValue%2A> 不返回有效值。  
  
 由 "样式"、"主题"、"模板"、"元数据" 或 "属性值继承" 的默认值设置的值不被视为本地值。 但是，在计算绑定和其他表达式后，它们被视为本地值。  
  
 如果未设置本地值，则此方法将返回 <xref:System.Windows.DependencyProperty.UnsetValue>。  
  
 如果返回的值不是 <xref:System.Windows.DependencyProperty.UnsetValue>，则可以查询请求的依赖项属性的元数据，以确定是否有更具体的类型可以将返回值转换为。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的值而不更改其值源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由组件使用，该组件以编程方式设置其自己的属性之一的值，而无需禁用应用程序声明的属性用法。 <xref:System.Windows.DependencyObject.SetCurrentValue%2A> 方法可更改属性的有效值，但现有触发器、数据绑定和样式将继续工作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖属性或密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是为 <paramref name="dp" /> 属性注册的正确类型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置依赖属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的本地值，该值由其依赖属性标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 应始终将 `value` 参数提供为适当的类型。  
  
 在所设置的依赖属性的依赖项属性标识符上存在的 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 回调可能会影响异常条件。 否则，提供的值可能会失败，一般类型检查条件（例如，在本机类型为 Double 时传递字符串）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖属性或密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是为 <paramref name="dp" /> 属性注册的正确类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要设置的属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置一个只读依赖属性的本地值，该值由依赖属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你为自定义类定义的只读依赖项属性设置值时，通常使用此签名。 通常，仅从注册了依赖属性的类型调用 <xref:System.Windows.DependencyObject.SetValue%2A>，该类型实现为依赖属性提供确定值的内部逻辑。 有关详细信息，请参阅[只读依赖属性](/dotnet/framework/wpf/advanced/read-only-dependency-properties)。  
  
 如果提供的类型与最初注册依赖属性时所声明的类型不匹配，则会引发异常。 应始终将 `value` 参数提供为适当的类型。 在所设置的依赖属性的依赖项属性标识符上存在的 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 回调可能会影响异常条件。  
  
   
  
## Examples  
 下面的示例定义了一个只读依赖项属性，以及一个向属性使用者提供必需的只读访问的 `public static readonly` <xref:System.Windows.DependencyProperty> 以及 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 包装的 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">应被序列化的依赖项属性的标识符。</param>
        <summary>返回一个值，该值指示序列化进程是否应序列化所提供的依赖属性的值。</summary>
        <returns>如果应对所提供的依赖属性的值进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果依赖属性在 <xref:System.Windows.DependencyObject>上建立了本地值，则默认实现将返回 `true`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的替代可能以不同方式处理特定依赖属性。</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
