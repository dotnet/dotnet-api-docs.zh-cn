<Type Name="UIElement" FullName="System.Windows.UIElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="387abbdb865962582a3a0ddf49d8addf8f31f899" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83901146" /></Metadata><TypeSignature Language="C#" Value="public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement" />
  <TypeSignature Language="VB.NET" Value="Public Class UIElement&#xA;Inherits Visual&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class UIElement : System::Windows::Media::Visual, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type UIElement = class&#xA;    inherit Visual&#xA;    interface IInputElement&#xA;    interface IAnimatable" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type UIElement = class&#xA;    inherit Visual&#xA;    interface IAnimatable&#xA;    interface IInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.UidProperty("Uid")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.UIElement" /> 是 WPF 核心级实现的基类，这些实现是在 Windows Presentation Foundation (WPF) 元素和基本表示特性上生成的。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement> 提供了元素布局特征的起点，还公开了派生类可以重写的虚拟方法，这可能会影响元素及其子元素的布局呈现行为。  
  
 通常，在 <xref:System.Windows.UIElement> 类中还定义了元素的大部分输入和焦点行为。 这包括键盘、鼠标和触笔输入的事件以及相关的状态属性。 其中的许多事件都是路由事件，许多输入相关事件都具有冒泡路由版本以及事件的隧道版本。 这些配对事件通常是控制作者最感兴趣的事件。  
  
 <xref:System.Windows.UIElement> 还包括与 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 事件模型相关的 Api，包括可以引发源自元素实例的指定路由事件的方法。  
  
 就体系结构而言，可以将 <xref:System.Windows.UIElement> 视为大致等效于 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 编程中的窗口句柄或 [!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)] 编程中的元素。 <xref:System.Windows.UIElement> 是 WPF 核心级别的基本元素。  
  
 <xref:System.Windows.UIElement> 具有 <xref:System.Windows.UIElement> 类具体定义的以下功能：  
  
-   可以作为子元素呈现（<xref:System.Windows.UIElement> 派生自 <xref:System.Windows.Media.Visual>，这是一个高级别的图形类）  
  
-   包含用于调整 <xref:System.Windows.UIElement> （由布局系统解释时）的可能的子元素进行大小和位置的逻辑  
  
-   可以响应用户输入（包括通过其事件路由处理或命令路由来控制输入的发送位置）  
  
-   可以引发通过逻辑元素树传送路由的路由事件  
  
-   支持动画系统的某些方面  
  
 <xref:System.Windows.FrameworkElement> 是在 <xref:System.Windows.UIElement>上构建的 WPF 框架级别实现类，并添加了与 WPF 框架级别的特定交互。 <xref:System.Windows.FrameworkElement> 添加并定义了以下功能：  
  
-   其他框架特定的布局特征  
  
-   支持更丰富的元数据报告属性  
  
-   某些输入基类的特定于类的实现及其附加属性或附加事件  
  
-   样式支持  
  
-   更多动画支持  
  
 其他相关类 <xref:System.Windows.ContentElement>。 <xref:System.Windows.ContentElement> 类实现了许多与 <xref:System.Windows.UIElement>相同的成员;这两个类之间的不同之处在于它们在整个内容模型中的预期位置。 <xref:System.Windows.UIElement> 派生类通常定义一个相对严格的内容模型，这意味着对标记中的子元素可以是哪些元素有限制。 在 <xref:System.Windows.UIElement>中使用限制较少的子内容可能存在容量，但该容量通常集中在指定的内容属性中。 <xref:System.Windows.ContentElement> 派生类通常不会对内容进行限制，以支持流格式文档等方案。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement.Visibility%2A> 状态会影响该元素的所有输入处理。 不可见的元素不参与命中测试，也不会接收到输入事件，即使鼠标位于元素显示的边界处。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.UIElement" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在应用程序代码中创建实际为类型 <xref:System.Windows.UIElement> 的新实例并不常见，因为 <xref:System.Windows.UIElement> 是基元素。 请参阅[基元素概述](/dotnet/framework/wpf/advanced/base-elements-overview)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要处理的路由事件的标识符。</param>
        <param name="handler">对处理程序实现的引用。</param>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以多次为同一事件添加同一处理程序，而不引发异常。 不过，处理事件时，处理程序实际上被多次调用。 因此，请考虑此行为在处理程序实现中应考虑的副作用。  
  
 通常使用此方法为自定义路由事件的 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 事件访问模式提供 "add" 访问器的实现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHandler (routedEvent As RoutedEvent, handler As Delegate, handledEventsToo As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要处理的路由事件的标识符。</param>
        <param name="handler">对处理程序实现的引用。</param>
        <param name="handledEventsToo">如果为 <see langword="true" />，则将按以下方式注册处理程序：即使路由事件在其事件数据中标记为已处理，也会调用处理程序；如果为 <see langword="false" />，则使用默认条件注册处理程序，即当路由事件被标记为已处理时，将不调用处理程序。  
  
默认值为 <see langword="false" />。  
  
请勿定期请求重新处理路由事件。</param>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。 将 <paramref name="handledEventsToo" /> 指定为 <see langword="true" />，可为已标记为由事件路由中的其他元素处理的路由事件调用所提供的处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以切实可行的方式处理低级别的输入事件是一项复杂的任务。 许多控件都实现了某个事件被标记为已处理的行为，并将其替换为另一个更直观的事件。 通常，如果有某些设计意图，控件只会将平台输入事件标记为已处理。 在某些情况下，这些设计意图可能并不是您特定的输入事件处理要求。 这适用于将 `handledEventsToo` 注册为 `true` 的处理程序的情况。 但不应定期执行此操作。 调用处理程序以响应所有事件（即使处理）会使你自己的应用程序事件处理逻辑变得复杂。 如果处理程序逻辑很大，则可能会出现性能下降的情况。 如果在开发过程中已发现某些控件处理仍要使用应用程序逻辑处理的事件，则应为已处理的事件保留使用附加处理程序。  
  
 避免某些事件控制组合的类处理行为的另一种方法是使用该事件的预览替代项。 例如，如果 <xref:System.Windows.UIElement.MouseLeftButtonDown> 通过类处理标记为已处理，则可以改为添加 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 的处理程序。  
  
 可以多次为同一事件添加同一处理程序，而不引发异常。 不过，处理事件时，处理程序实际上被多次调用。 因此，请考虑此行为在处理程序实现中应考虑的副作用。  
  
 通常使用此方法为自定义路由事件的 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 事件访问模式提供 "add" 访问器的实现。  
  
   
  
## Examples  
 下面的示例实现了一个使用 `handledEventsToo` `true`将已定义的处理程序附加到页面上某个命名元素的页面上的 <xref:System.Windows.FrameworkElement.Initialized> 事件上调用的处理程序。 即使路由中的另一个元素将共享事件数据标记为已处理，然后再到达路由中的处理元素，也会调用该处理程序。  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">要向其添加处理程序的事件路由。</param>
        <param name="e">用于添加处理程序的事件数据。 此方法使用事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性创建处理程序。</param>
        <summary>将处理程序添加到当前 <see cref="T:System.Windows.EventRoute" /> 事件处理程序集合的指定 <see cref="T:System.Windows.UIElement" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由内容宿主元素（实现 <xref:System.Windows.IContentHost> 的元素或不是的元素）用于向 <xref:System.Windows.EventRoute>中的子元素添加处理程序。 通常情况下，<xref:System.Windows.UIElement>不需要此项，因为对于在完成的逻辑树中找到的所有元素，将自动添加处理程序。 但是，在某些情况下，在模板树中混合使用 <xref:System.Windows.ContentElement> 和 <xref:System.Windows.UIElement> 时，需要将来自模板的干预元素添加到路由中。 <xref:System.Windows.ContentElement> 和 <xref:System.Windows.UIElement> 都支持此方法的版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.UIElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素能否用作拖放操作的目标。  这是依赖项属性。</summary>
        <value>如果此元素可用作拖放操作的目标，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下不启用拖放操作，并且必须通过将 <xref:System.Windows.UIElement.AllowDrop%2A> 设置为 `true`来特意启用。 除了此基本设置外，拖放行为完全是特定实现的，并且不是由 <xref:System.Windows.UIElement> 或任何其他基元素类定义的。 某些控件（例如 <xref:System.Windows.Controls.RichTextBox>）具有默认行为。 有关拖放的详细信息，请参阅[拖放概述](/dotnet/framework/wpf/advanced/drag-and-drop-overview)。  
  
 <xref:System.Windows.FrameworkElement> 在其实现中重写此依赖项属性的元数据。 具体而言，<xref:System.Windows.FrameworkElement> 指定此属性以允许属性值继承（<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 在元数据中 `true`）。 此上下文中的属性值继承表示，如果有子元素对于通过本地值或样式分配的 <xref:System.Windows.UIElement.AllowDrop%2A> 没有其他值，则为已分配此值的最近父元素的值（同样，在样式中、默认值或本地值），并将父元素的值分配给属性系统以前未分配的所有子元素。 在实际操作中，这意味着你可以指定是否允许在根元素处放置操作，并且该值将传播到尚未专门分配给 `false`的所有子元素。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.AllowDropProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 以下标记示例使用 <xref:System.Windows.Controls.TextBox>上的属性设置 `true` <xref:System.Windows.UIElement.AllowDrop%2A> 属性，并设置聚合中的某些其他相关属性，使该 <xref:System.Windows.Controls.TextBox> 在拖动时成为多行文本数据对象的目标。 有关完整示例，请参阅[加载已删除的文件示例](https://msdn.microsoft.com/library/be90d645-dd61-4f53-93bb-87902d086ef7)。  
  
 [!code-xaml[DragDrop_DropOpenTextFile#UIElementAllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/DragDrop_DropOpenTextFile/CS/window1.xaml#uielementallowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.AllowDrop" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将动画应用到此元素的指定依赖属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是密封的，不能对其进行重写。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">要进行动画处理的属性的标识符。</param>
        <param name="clock">控制和声明动画的动画时钟。</param>
        <summary>将动画应用到此元素的指定依赖属性。 任何现有动画均停止并替换为新动画。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要从属性中删除动画，请将该属性的标识符指定为 `dp`，并将 `clock` 指定为 `null`。 这将删除动画并将动画属性设置为其基值。 但是，不会停止最初关联的动画时钟。 分配给该时钟的任何其他动画都将继续运行。  
  
   
  
## Examples  
 在下面的示例中，<xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle` 通过调用 <xref:System.Windows.UIElement.ApplyAnimationClock%2A>，将特定计时动画应用于它。  
  
 [!code-csharp[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]
 [!code-vb[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">要进行动画处理的属性。</param>
        <param name="clock">控制和声明动画的动画时钟。</param>
        <param name="handoffBehavior">枚举的一个值。 默认值为 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，这会停止任何现有动画并将其替换为新动画。</param>
        <summary>向此元素的指定依赖属性应用动画，并且可以指定当该属性已有正在运行的动画时所要执行的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要从属性中删除动画，请将该属性的标识符指定为 `dp`，并将 `clock` 指定为 `null`。 这将删除动画并将动画属性设置为其基值。 但是，不会停止最初关联的动画时钟。 分配给该时钟的任何其他动画都将继续运行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素上是否至少捕获了一次触摸。</summary>
        <value>如果在此元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少捕获了一次触摸。</summary>
        <value>如果在此元素或其可视化树中的任何子元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素上是否至少按下了一次触摸设备。</summary>
        <value>如果在此元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少按下了一次触摸设备。</summary>
        <value>如果在此元素或其可视化树中的任何子元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arrange">
      <MemberSignature Language="C#" Value="public void Arrange (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Arrange(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Arrange (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Arrange(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="member this.Arrange : System.Windows.Rect -&gt; unit" Usage="uIElement.Arrange finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父元素为子元素计算的最终大小，表示为 <see cref="T:System.Windows.Rect" /> 实例。</param>
        <summary>定位子元素，并确定 <see cref="T:System.Windows.UIElement" /> 的大小。 父元素从它们的 <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> 实现（或者是 WPF 框架级别等效项）调用此方法，以便形成递归布局更新。 此方法产生第二次布局更新。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 WPF 框架级别的元素派生方案，<xref:System.Windows.UIElement.Arrange%2A> 的行为不应（并且不能，除非你进行了阴影）更改。 相反，应重写类中的 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 实现。 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 实现由 <xref:System.Windows.UIElement.Arrange%2A> 作为默认 WPF 框架级别布局操作的一部分在内部调用。 <xref:System.Windows.UIElement.ArrangeCore%2A> 实现还应在每个子元素上调用 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> （如果有子元素）。  
  
 对于 WPF 核心级别的元素派生方案，<xref:System.Windows.UIElement.Arrange%2A> 的行为不应（并且不能，除非你隐藏）发生更改。 相反，应重写类中的 <xref:System.Windows.UIElement.ArrangeCore%2A>。 <xref:System.Windows.UIElement.ArrangeCore%2A> 实现由 <xref:System.Windows.UIElement.Arrange%2A> 作为默认 WPF 框架级别布局操作的一部分在内部调用。 但是，这假定你使用的是 WPF 框架级别布局及其布局系统，但如果要从 <xref:System.Windows.UIElement> 基元素类专门派生 WPF core 级别的元素，这种情况通常并非如此。 <xref:System.Windows.UIElement.ArrangeCore%2A> 实现还应在每个子元素上调用 <xref:System.Windows.UIElement.Arrange%2A> （如果有子元素）。 请注意，WPF 核心级方案意味着不使用 <xref:System.Windows.FrameworkElement> 派生类，因为 <xref:System.Windows.FrameworkElement> 会密封 <xref:System.Windows.FrameworkElement.ArrangeCore%2A>。  
  
 在 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 中，WPF 框架级别布局定位的计算包括 <xref:System.Windows.UIElement.Measure%2A> 调用和 <xref:System.Windows.UIElement.Arrange%2A> 调用。 在 <xref:System.Windows.UIElement.Measure%2A> 调用期间，布局系统使用提供的 <xref:System.Windows.Size> （`availableSize`）参数确定元素的大小要求。 在 <xref:System.Windows.UIElement.Arrange%2A> 调用期间，布局系统将终结元素的边界框的大小和位置。  请参阅[布局](/dotnet/framework/wpf/advanced/layout)以了解详细信息。  
  
 `availableSize` 可以是从零到无限大的任何数字。 要布局的元素通过 `availableSize` 参数返回所需的最小 <xref:System.Windows.Size>。  
  
 第一次实例化布局时，将始终在 <xref:System.Windows.UIElement.Arrange%2A>之前接收 <xref:System.Windows.UIElement.Measure%2A> 调用。 但是，在第一次布局传递后，它可能会收到 <xref:System.Windows.UIElement.Arrange%2A> 调用，但没有 <xref:System.Windows.UIElement.Measure%2A>;如果更改仅影响 <xref:System.Windows.UIElement.Arrange%2A> 的属性（如对齐方式），或者当父对象收到没有 <xref:System.Windows.UIElement.Measure%2A>的 <xref:System.Windows.UIElement.Arrange%2A> 时，会发生这种情况。 <xref:System.Windows.UIElement.Measure%2A> 调用会自动使 <xref:System.Windows.UIElement.Arrange%2A> 调用无效。  
  
 布局更新通常是异步发生的（在布局系统确定的时间内）。 元素可能不会立即反映影响元素大小调整的属性（如 <xref:System.Windows.FrameworkElement.Width%2A>）的更改。  
  
> [!NOTE]
>  可以使用 <xref:System.Windows.UIElement.UpdateLayout%2A> 方法强制执行布局更新;但是，不建议调用此函数，因为通常不需要，因此可能会导致性能不佳。 在很多调用 <xref:System.Windows.UIElement.UpdateLayout%2A> 可能适用的情况下，布局系统可能已在处理更新。 布局系统可以以一种可以将所有必要更新作为包的一部分进行优化的方式来处理布局更改。  
  
 布局系统将两个不同的队列（一个用于 <xref:System.Windows.UIElement.Measure%2A>，一个用于 <xref:System.Windows.UIElement.Arrange%2A>。 布局队列根据可视化树中元素的顺序进行排序。 树中较高位置的元素位于队列的顶部，目的是为了避免父代中的重复更改导致冗余的布局。 重复项会自动从队列中删除，如果元素已经有效，则会自动从队列中删除它们。  
  
 更新布局时，首先清空 <xref:System.Windows.UIElement.Measure%2A> 队列，后跟 <xref:System.Windows.UIElement.Arrange%2A> 队列。 如果 <xref:System.Windows.UIElement.Measure%2A> 队列中有元素，则永远不会排列 <xref:System.Windows.UIElement.Arrange%2A> 队列中的元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected virtual void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeCore : System.Windows.Rect -&gt; unit&#xA;override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="uIElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父级中应使用元素排列自身及其子元素的最终区域。</param>
        <summary>定义 WPF 核心级别排列布局定义的模板。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  重写此方法仅适用于在 WPF 核心级别派生，并且未使用 WPF 框架级别布局系统和 <xref:System.Windows.FrameworkElement> 派生类，因为 <xref:System.Windows.FrameworkElement> 密封 <xref:System.Windows.FrameworkElement.ArrangeCore%2A>。 如果你使用的是 WPF 框架级别布局系统，则会 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>用于替代类特定布局排列行为的适当方法。  
  
   
  
## Examples  
 <xref:System.Windows.UIElement.ArrangeCore%2A> 实现应调用基实现以返回大小，然后调用每个可见子元素的 <xref:System.Windows.UIElement.Arrange%2A> 方法，并将这些 <xref:System.Windows.UIElement.Arrange%2A> 调用返回的大小与基实现的大小进行协调。 <xref:System.Windows.UIElement.ArrangeCore%2A> 实现的对帐方面的逻辑可能会有所不同，具体取决于元素的布局特征。 在下面的示例模板中，`VisualChildren` 是一个假设属性，元素可能会将其定义为帮助枚举其内容;<xref:System.Windows.UIElement> 未在此级别定义内容集合，则 WPF 框架级体系结构会将内容行为延迟为特定控件或控件基类等派生元素。  
  
 [!code-csharp[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementarrangeoverride)]
 [!code-vb[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementarrangeoverride)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果要在 WPF 核心级别开发元素，则应重写此方法，以便为 WPF 核心级别的元素提供唯一的排列布局行为，或对元素的子元素做出适当的布局决策。 如果无法从定义的模式（如 <see cref="T:System.Windows.Controls.ItemCollection" />）识别这些子元素，则可能需要重写。  
  
父元素必须在每个子元素上调用特定于类的 <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />，否则不会呈现这些子元素。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为此元素的指定要进行动画处理的属性启动动画。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">要进行动画处理的属性，它被指定为依赖项属性标识符。</param>
        <param name="animation">要启动的动画的时间线。</param>
        <summary>为此元素的指定要进行动画处理的属性启动动画。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检查属性是否已进行动画处理时，请注意，当呈现非动画起始点之外的第一个帧时，动画将开始，并被视为已进行动画处理。  
  
 如果 `animation` 的 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> 为 `null`，则将移除当前的任何动画，并保持该属性的当前值。  
  
 如果 `null`整个 `animation` 值，则从属性中移除所有动画，并且属性值将恢复为其基值。 但是，不会停止最初关联的动画时间线。 分配给该时间线的任何其他动画都将继续运行。  
  
   
  
## Examples  
 下面的示例创建一个动画并对其进行分配，然后调用 <xref:System.Windows.UIElement.BeginAnimation%2A> 以启动它。  
  
 [!code-csharp[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#beginanimation)]
 [!code-vb[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#beginanimation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">要进行动画处理的属性，它被指定为依赖项属性标识符。</param>
        <param name="animation">要应用的动画的时间线。</param>
        <param name="handoffBehavior">一个枚举值，用来指定新动画如何与已在影响属性值的任何当前（正在运行的）动画进行交互。</param>
        <summary>为此元素的指定要进行动画处理的属性启动特定的动画，并可以指定当该属性已有正在运行的动画时所要执行的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检查属性是否已进行动画处理时，请注意，当呈现非动画起始点之外的第一个帧时，动画将开始，并被视为已进行动画处理。  
  
 如果 `animation` 的 <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> 为 `null`，则将移除当前的任何动画，并保持该属性的当前值。  
  
 如果 `null`整个 `animation` 值，则从属性中移除所有动画，并且属性值将恢复为其基值。 但是，不会停止最初关联的动画时间线。 分配给该时间线的任何其他动画都将继续运行。  
  
   
  
## Examples  
 下面的示例实现了一个处理程序，该处理程序从资源获取现有动画，然后使用指定的移交行为调用 <xref:System.Windows.UIElement.BeginAnimation%2A>。  
  
 [!code-csharp[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/csharp/VS_Snippets_Wpf/BrushesIntroduction/CSharp/SampleViewer.xaml.cs#beginanimationhandoff)]
 [!code-vb[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BrushesIntroduction/visualbasic/sampleviewer.xaml.vb#beginanimationhandoff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.UIElement.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个位图效果，该效果将直接应用到此元素所呈现的内容。  这是依赖项属性。</summary>
        <value>要应用的位图效果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Effects.BitmapEffect> 是抽象类型，因此 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 使用需要 <xref:System.Windows.Media.Effects.BitmapEffect>实现的派生类，例如 <xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>。 请注意，一个实现的派生类是一种集合类型，它允许你使用嵌套标记语法指定多个顺序 <xref:System.Windows.Media.Effects.BitmapEffect>。  
  
 <xref:System.Windows.Media.Effects.BitmapEffect> 的现有派生类都不支持类型转换器，因此，用于此属性的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法通常是属性元素语法。  
  
<a name="dependencyPropertyInfo_BitmapEffect"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.BitmapEffectProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Windows.Media.Effects.BlurBitmapEffect>设置位图效果。  
  
 [!code-csharp[EffectsGallery_snip#CodeBehindBlurCodeBehindExampleInline](~/samples/snippets/csharp/VS_Snippets_Wpf/EffectsGallery_snip/CSharp/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.UIElement.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置位图效果的输入源，该效果将直接应用到此元素所呈现的内容。  这是依赖项属性。</summary>
        <value>位图效果的源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BitmapEffectInput"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInputProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectInputProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectInputProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectInputProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectInputProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.BitmapEffectInput" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.BitmapEffect" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.UIElement.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.UIElement" /> 的缓存表示形式。</summary>
        <value><see cref="T:System.Windows.Media.CacheMode" />，用于容纳 <see cref="T:System.Windows.UIElement" /> 的缓存表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要提高呈现所需的内容的性能，请设置 <xref:System.Windows.UIElement.CacheMode%2A> 属性。 有关详细信息，请参阅 <xref:System.Windows.Media.BitmapCache>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Media3D.Viewport2DVisual3D.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="CacheModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.CacheModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.CacheModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.CacheMode" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="uIElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将鼠标强制捕获到此元素。</summary>
        <returns>如果成功捕获了鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要捕获，必须启用一个元素。 在调用 <xref:System.Windows.UIElement.CaptureMouse%2A>之前，请检查是否 `true` <xref:System.Windows.UIElement.IsEnabled%2A>。  
  
 如果调用 <xref:System.Windows.UIElement.CaptureMouse%2A> 将返回 `true`，则 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 也 `true`。  
  
 如果调用 <xref:System.Windows.UIElement.CaptureMouse%2A> 返回 `true`，则将引发 <xref:System.Windows.UIElement.GotMouseCapture> 和 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 事件，并在事件数据中将 <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> 报告为调用 <xref:System.Windows.UIElement.CaptureMouse%2A> 方法的元素。 如果强制捕获，则可能会干扰现有捕获，尤其是与用鼠标拖放相关的捕获。  
  
 若要从所有元素中清除鼠标捕获，请用 `null`提供的 `element` 参数调用 <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例实现了一对鼠标和键输入组合的处理程序，这些处理程序用于捕获（和 uncapture）鼠标，并为查看3D 模型启用了特殊的鼠标模式。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="uIElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将触笔强制捕获到此元素。</summary>
        <returns>如果成功捕获了触笔，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基于基础默认触笔设备的默认实现始终返回 `true`。 但是，如果你要扩展为输入系统提供设备实现的输入设备，则可以使用可能返回不同结果的备用触笔设备实现创建系统。  
  
 当某个元素捕获触笔时，它将接收触笔输入，即使触笔位于其边界之外。 通常仅在拖放操作期间捕获触笔。  
  
 调用此方法将调用基础静态 <xref:System.Windows.Input.Stylus> 方法 <xref:System.Windows.Input.Stylus.Capture%2A>。 实际捕获行为是由活动的触笔设备实现实现的。  
  
 若要捕获，必须启用一个元素。 在调用 <xref:System.Windows.UIElement.CaptureStylus%2A>之前，请检查是否 `true` 返回 <xref:System.Windows.UIElement.IsEnabled%2A>。  
  
 如果调用 <xref:System.Windows.UIElement.CaptureStylus%2A> 返回 `true`，则 <xref:System.Windows.UIElement.IsStylusCaptured%2A> 也 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureTouch (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要捕获的设备。</param>
        <summary>尝试将触摸屏输入强制捕获到此元素。</summary>
        <returns>如果将指定触摸屏输入捕获到此元素，则为 <see langword="true" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前已将 <xref:System.Windows.Input.TouchDevice> 捕获到另一个元素，<xref:System.Windows.UIElement.CaptureTouch%2A> 将返回 `false`。  
  
 如果 <xref:System.Windows.UIElement.CaptureTouch%2A> 返回 `true`，则会引发 <xref:System.Windows.UIElement.GotTouchCapture> 事件。  
  
 若要从此元素中释放单个触摸的捕获，请使用 <xref:System.Windows.UIElement.ReleaseTouchCapture%2A> 方法，并指定要释放的触摸设备。 若要释放此元素的所有接触，请使用 <xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.UIElement.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于定义元素内容轮廓的几何图形。  这是依赖项属性。</summary>
        <value>用于剪裁区域大小的几何图形。 默认值为 null <see cref="T:System.Windows.Media.Geometry" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在呈现的布局中，将以可视方式裁剪几何图形外的元素。 几何图形不必是矩形。  
  
<a name="dependencyPropertyInfo_Clip"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ClipProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 此示例演示如何定义框架元素的 <xref:System.Windows.UIElement.Clip%2A> 区域。 若要定义剪辑，请使用 <xref:System.Windows.Media.Geometry> （例如，将 <xref:System.Windows.Media.EllipseGeometry> 设置为元素的 <xref:System.Windows.UIElement.Clip%2A> 属性。 只有位于几何区域内的区域才可见。  
  
 下面的示例演示没有定义的剪辑区域的 <xref:System.Windows.Controls.Image> 元素。 由于未定义剪辑区域，因此将显示整个图像。  
  
 [!code-xaml[ClipPathExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#2)]  
  
 ![应用剪辑区域之前的对象](~/add/media/mil-task-clip-region-noclip.png "应用剪裁区域之前的对象")  
不包含剪辑区域的图像  
  
 在下一个示例中，将创建一个相同的映像，只不过它具有定义的剪辑区域。 仅显示 <xref:System.Windows.Media.EllipseGeometry> 区域内的图像部分。  
  
 [!code-xaml[ClipPathExample#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#4)]  
  
 ![剪切的对象](~/add/media/mil-task-clip-region-ellispe.PNG "已剪裁的对象")  
带有椭圆形剪辑区域的图像  
  
 下面的示例演示如何对框架元素的 <xref:System.Windows.UIElement.Clip%2A> 区域进行动画处理。 在此示例中，<xref:System.Windows.Media.EllipseGeometry> 用于定义 <xref:System.Windows.Controls.Image> 元素的椭圆形剪辑区域。 一个 <xref:System.Windows.Media.Animation.PointAnimation> 将椭圆几何图形的 <xref:System.Windows.Media.EllipseGeometry.Center%2A> 属性从（0，0）动画处理为（200，150）。 动画加载并无限重复后，动画就会开始播放。  
  
 [!code-xaml[ClipPathExample#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#5)]  
  
 有关完整示例，请参阅[剪辑区域示例](https://msdn.microsoft.com/library/83043a0b-f824-445f-9675-103280c5ca67)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="ClipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Clip" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBounds">
      <MemberSignature Language="C#" Value="public bool ClipToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipToBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.ClipToBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property ClipToBounds As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ClipToBounds { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ClipToBounds : bool with get, set" Usage="System.Windows.UIElement.ClipToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否剪切此元素的内容(或来自此元素的子元素的内容)使其适合包含元素的大小。   这是依赖项属性。</summary>
        <value>如果应剪切内容，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于子元素，对于布局行为 <xref:System.Windows.UIElement.ClipToBounds%2A> 具有不同的效果，具体取决于父元素的高度和宽度是否由 <xref:System.Windows.FrameworkElement.Height%2A> / <xref:System.Windows.FrameworkElement.Width%2A> 或 <xref:System.Windows.FrameworkElement.MaxHeight%2A> / <xref:System.Windows.FrameworkElement.MaxWidth%2A>确定。 无论 <xref:System.Windows.UIElement.ClipToBounds%2A> 的值是什么，都将始终考虑父元素 <xref:System.Windows.FrameworkElement.MaxHeight%2A> / <xref:System.Windows.FrameworkElement.MaxWidth%2A>，并且有效的剪辑将始终根据这些最大值来剪裁内容。 <xref:System.Windows.UIElement.ClipToBounds%2A> `false`时，父级的 <xref:System.Windows.FrameworkElement.Height%2A> / <xref:System.Windows.FrameworkElement.Width%2A> 设置不会剪裁内容，但如果 <xref:System.Windows.UIElement.ClipToBounds%2A> `true`，则会剪裁内容。  
  
 请注意，默认为 `false` 是在 <xref:System.Windows.UIElement> 类中实现的常规行为。 派生自 <xref:System.Windows.UIElement> 的任何给定元素都可以重写该实例中此属性的依赖项属性元数据，以默认改为 `true`。 多个现有的派生类将重写此元数据和/或调整依赖属性的默认值。  
  
 <xref:System.Windows.Controls.InkCanvas>、<xref:System.Windows.Controls.InkPresenter>和 <xref:System.Windows.Controls.Primitives.Popup> 都将重写要 `true`的默认值。  
  
 <xref:System.Windows.FrameworkElement> 重写此依赖项属性的元数据。 具体而言，<xref:System.Windows.FrameworkElement> 指定此属性以允许属性值继承（<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 在元数据中 `true`）。 此上下文中的属性值继承表示，如果有子元素对于通过本地值或样式分配的 <xref:System.Windows.UIElement.ClipToBounds%2A> 没有其他值，则为已分配此值的最近父元素的值（同样，无论是样式、默认值或本地值），该父元素的值将由属性系统分配给所有未分配的子元素。 在实践中，这意味着您可以指定是否允许在根元素处使用剪辑到边界，并将该值传播到未专门分配给 `false`的所有子元素。  
  
<a name="dependencyPropertyInfo_ClipToBounds"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ClipToBoundsProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ClipToBoundsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipToBoundsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipToBoundsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipToBoundsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipToBoundsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.ClipToBounds" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.UIElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此元素关联的 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。 <see cref="T:System.Windows.Input.CommandBinding" /> 为此元素启用命令处理，并声明命令、命令的事件和由此元素附加的处理程序之间的链接。</summary>
        <value>所有 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 填充 <xref:System.Windows.UIElement.CommandBindings%2A> 集合的另一种典型方法是以编程方式使用 <xref:System.Windows.Input.CommandManager> 方法。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  
  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreCommandBindings*  
 一个或多个 <xref:System.Windows.Input.CommandBinding> 元素。 其中每个都应将 <xref:System.Windows.Input.CommandBinding.Command%2A> 特性设置为已知命令，并为 <xref:System.Windows.Input.CommandBinding.CanExecute> 和 <xref:System.Windows.Input.CommandBinding.Executed> 处理程序实现设置特性。 有关更多信息，请参见<xref:System.Windows.Input.CommandBinding>。  
  
   
  
## Examples  
 下面的示例使用标记将 <xref:System.Windows.Input.CommandBinding> 添加到窗口中。 请注意，在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中，不会在标记中将 <xref:System.Windows.Input.CommandBindingCollection> 声明为元素;集合对象由属性所采用的类型推断，并使用一个或多个 <xref:System.Windows.Input.CommandBinding> 元素填充 property 元素：  
  
 [!code-xaml[commandWithHandler#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 有关集合的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法的详细信息，请参阅[XAML 语法的详细](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail)信息。  
  
 下面的示例在代码中本质上是相同的：  
  
 [!code-csharp[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DesiredSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size DesiredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size DesiredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.DesiredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DesiredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size DesiredSize { System::Windows::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DesiredSize : System.Windows.Size" Usage="System.Windows.UIElement.DesiredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在布局流程的度量传递过程中此元素计算所得的大小。</summary>
        <value>计算所得大小，它将成为排列过程所需的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `true`<xref:System.Windows.UIElement.IsMeasureValid%2A> 属性的值，则此属性返回的值将只是有效的度量值。  
  
 当你实现布局行为重写（如 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>、<xref:System.Windows.FrameworkElement.MeasureOverride%2A>或 <xref:System.Windows.UIElement.OnRender%2A>）时，通常会将 <xref:System.Windows.UIElement.DesiredSize%2A> 作为度量因素之一进行检查（在 <xref:System.Windows.UIElement.OnRender%2A> 情况下，你可以改为检查 <xref:System.Windows.UIElement.RenderSize%2A>，但这取决于实现）。 根据方案的不同，<xref:System.Windows.UIElement.DesiredSize%2A> 可能会完全遵守实现逻辑，对 <xref:System.Windows.UIElement.DesiredSize%2A> 的约束可能会被应用，并且此类约束也可能更改父元素或子元素的其他特征。 例如，支持可滚动区域（但选择不从已启用可滚动区域的 WPF 框架级控件派生）的控件可以将可用大小与 <xref:System.Windows.UIElement.DesiredSize%2A>进行比较。 然后，控件可以设置在该控件的 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 中启用滚动条的内部状态。 或者，在某些情况下，<xref:System.Windows.UIElement.DesiredSize%2A> 可能也会被忽略。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Windows.UIElement.DesiredSize%2A> 作为 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> 实现的一部分。 请注意，在获取 <xref:System.Windows.UIElement.DesiredSize%2A>之前，如何立即调用 <xref:System.Windows.UIElement.Measure%2A>。 这可确保 <xref:System.Windows.UIElement.DesiredSize%2A> 持有合法值。  
  
 [!code-cpp[PlotPanel#2](~/samples/snippets/cpp/VS_Snippets_Wpf/PlotPanel/CPP/PlotPanel.cpp#2)]
 [!code-csharp[PlotPanel#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PlotPanel/CSharp/PlotPanel.cs#2)]
 [!code-vb[PlotPanel#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PlotPanel/VisualBasic/PlotPanel.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.DragEnter> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.DragEnterEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewDragEnter>。  
  
-   重写 <xref:System.Windows.UIElement.OnDragEnter%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.DragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将为此类创建 <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.DragLeave> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.DragLeaveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.DragDrop.PreviewDragLeave>。  
  
-   重写 <xref:System.Windows.UIElement.OnDragLeave%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.DragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使拖动源自元素边界，也会发生此事件。 如果拖动从边界外开始，并在内部移动，则还会引发此事件，以及 <xref:System.Windows.UIElement.DragEnter> 和相关的预览事件。  
  
 此事件将为此类创建 <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.DragOver> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.DragOverEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.DragDrop.PreviewDragOver>。  
  
-   重写 <xref:System.Windows.UIElement.OnDragOver%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.DragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将为此类创建 <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.Drop?displayProperty=nameWithType> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.Drop> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.DropEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewDrop>。  
  
-   重写 <xref:System.Windows.UIElement.OnDrop%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.Drop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.UIElement.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于 <see cref="T:System.Windows.UIElement" /> 的位图效果。 这是依赖项属性。</summary>
        <value>一个表示位图效果的 <see cref="T:System.Windows.Media.Effects.Effect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Windows.UIElement.Effect%2A> 属性将位图效果应用于 <xref:System.Windows.UIElement>。  
  
<a name="dependencyPropertyInfo_Effect"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.EffectProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的 XAML 演示如何向 <xref:System.Windows.UIElement.Effect%2A> 属性分配自定义 <xref:System.Windows.Media.Effects.ShaderEffect>。  
  
 [!code-xaml[System.Windows.Media.Effects.ShaderEffect#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="EffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.EffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.EffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Effect" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="uIElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将焦点设定到此元素上。</summary>
        <returns>如果键盘焦点和逻辑焦点同时设定到此元素上，则为 <see langword="true" />；如果只有逻辑焦点设定到此元素上或此方法调用未强制更改焦点，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获得可设定焦点，必须同时 `true`<xref:System.Windows.UIElement.Focusable%2A> 和 <xref:System.Windows.UIElement.IsEnabled%2A>。  
  
 即使元素可设定焦点并且有效，`Focus` 预览事件也可以在特定树中进行处理，并且可能不允许焦点在该元素上（例如，在复合控件中）。
在这种情况下，此方法将返回 `false`。
 
 通常，焦点由两个不同的概念控制：键盘焦点和逻辑焦点。 这两个概念并非始终相同。 有关详细信息，请参阅[重点摘要](/dotnet/framework/wpf/advanced/focus-overview)和[输入概述](/dotnet/framework/wpf/advanced/input-overview)。
 
 如果调用 <xref:System.Windows.UIElement.Focus%2A> 返回 `true`，则 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 和 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 也 `true`。  
  
 如果尚未 `true`相关属性，则在调用 <xref:System.Windows.UIElement.Focus%2A>时，会按以下顺序引发以下一个或多个事件： "<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>"、"<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>" （源为新的焦点目标）、<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>、<xref:System.Windows.UIElement.LostKeyboardFocus>、<xref:System.Windows.UIElement.GotKeyboardFocus> （源为新的焦点目标）。  
  
 为了成功进行此调用，应用程序中的其他某个元素需要事先具有焦点。  
  
   
  
## Examples  
 下面的示例将焦点设置到 <xref:System.Windows.FrameworkElement.Name%2A>引用的 <xref:System.Windows.Controls.TextBox>，然后在 <xref:System.Windows.Controls.TextBox>内调整光标的位置。  
  
 [!code-csharp[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBox_CursorToEnd/CSharp/Window1.xaml.cs#uielementfocus)]
 [!code-vb[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBox_CursorToEnd/VisualBasic/Window1.xaml.vb#uielementfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.UIElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示元素能否得到焦点。  这是依赖项属性。</summary>
        <value>如果元素能得到焦点，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有聚焦元素接收键盘输入。  
  
 <xref:System.Windows.UIElement.Focusable%2A> 是 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 属性访问器，对于实际上是依赖属性。 在派生元素类中，特别是在控件中，此特定依赖项属性的默认值在外观上以不同的方式进行设置。 这种情况通常采用以下两种方式之一：  
  
-   依赖属性由特定派生类继承，但该派生类将重写依赖属性的元数据，并更改属性的默认值。  
  
-   样式或模板应用于元素，这会以不同的方式设置该依赖属性值。  
  
 例如，<xref:System.Windows.Controls.Button> 控件的 <xref:System.Windows.UIElement.Focusable%2A> 的外观 "默认" 将 `true`，即使 <xref:System.Windows.Controls.Button> 直接从 <xref:System.Windows.UIElement.Focusable%2A> 继承 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 属性。<xref:System.Windows.UIElement> 这是因为 <xref:System.Windows.UIElement.Focusable%2A> 依赖属性的已应用元数据值已在 <xref:System.Windows.Controls.Control> 基类的静态构造函数中重写，该构造函数位于类层次结构中的 <xref:System.Windows.Controls.Button> 和 <xref:System.Windows.UIElement> 之间。  
  
 当由 <xref:System.Windows.Controls.Control> 或其派生类继承时，<xref:System.Windows.Controls.Control> 将此属性的默认值重定义为 "`true`"。  
  
 当由 <xref:System.Windows.Controls.Label> 继承（这是一个 <xref:System.Windows.Controls.Control> 派生类）时，再次将默认值重新定义为 `false`。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.FocusableProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例代码演示了特定自定义控件的控件模板，该控件模板用于设置模板内某个元素 <xref:System.Windows.UIElement.Focusable%2A> `false`。  
  
 [!code-xaml[RichTextBox_NoScrollViewer#_ControlTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/CS/window1.xaml#_controltemplate)]
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当直接从 <see cref="T:System.Windows.UIElement" /> 派生（而不是从 <see cref="T:System.Windows.Controls.Control" />）时，请考虑你是否希望元素可获得焦点，因为默认情况下，元素将无法获得焦点。 如果希望元素可设定焦点，请在类型的静态构造函数中重写此属性的元数据，如下所示： 
[！ code-csharp[CorePseudocode # UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)][！ code-vb[CorePseudocode # UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)] 
其中 <paramref name="myElement" /> 应为要重写元数据值的类型的类名。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.UIElement.Focusable" /> 属性的值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Focusable" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="uIElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要检查的依赖项属性。</param>
        <summary>为此元素上的指定属性返回基属性值，忽略任何可能来自正在运行或已停止的动画的动画值。</summary>
        <returns>就像没有动画被附加到指定的依赖属性一样的属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有任何动画附加到属性，则 <xref:System.Windows.UIElement.GetAnimationBaseValue%2A> 返回值始终与 <xref:System.Windows.DependencyObject.GetValue%2A> 返回值相同。 如果附加了动画，则将忽略所有可能的动画派生值（包括开始值和结束值），并根据所有其他可能的输入来确定属性值。 有关详细信息，请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)。  
  
   
  
## Examples  
 下面的示例实现了一个处理程序，该处理程序报告 <xref:System.Windows.Controls.Button>上动画 <xref:System.Windows.FrameworkElement.Width%2A> 属性的基值以及转换的基值。  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalue)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="abstract member GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry&#xA;override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="uIElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">元素提供的可用大小。</param>
        <summary>返回一个替代剪辑几何图形，它表示将 <see cref="P:System.Windows.UIElement.ClipToBounds" /> 设置为 <see langword="true" /> 时要剪辑的区域。</summary>
        <returns>可能的剪辑几何图形。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现将返回合法值，但不会在其计算中使用 `layoutSlotSize` 参数。 相反，它使用 <xref:System.Windows.UIElement.RenderSize%2A>的值。  
  
 此方法由直接派生的 <xref:System.Windows.FrameworkElement> 类大幅重写，并且 <xref:System.Windows.FrameworkElement> 重写为常规 WPF 框架级别元素生成更复杂的行为。 有关详细信息，请参阅 <xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="uIElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，如果不存在可视父级，则返回其他[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父级。</summary>
        <returns>如果派生类的实现具有要报告的替代父级连接，则为一个对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认虚拟实现将返回 `null`。 <xref:System.Windows.FrameworkElement> 提供了一个实际实现。  
  
 备用父级用于事件路由，在这种情况下，元素创建备用父结构，使其事件以与其分离从可视化树向上路由到标准父级的标准模式，或在预览路由策略中向下传递。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现涉及此元素的基础拖放操作时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.GiveFeedback> 事件允许拖动事件的源修改鼠标指针的外观，以便在拖放操作过程中为用户提供视觉反馈。 视觉对象反馈强调正在处理拖放操作。  
  
 此事件将为此类创建 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.GiveFeedback> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.GiveFeedback> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GiveFeedbackEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewGiveFeedback>。  
  
-   重写 <xref:System.Windows.UIElement.OnGiveFeedback%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素获得逻辑焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通过使用方法调用有意强制焦点，但上一个键盘焦点存在于不同的范围内，则逻辑焦点不同于键盘焦点。 在这种情况下，键盘焦点将保留在该位置，并且调用 <xref:System.Windows.UIElement.Focus%2A> 方法的元素仍会获得逻辑焦点。  
  
 此事件的更精确解释是：当路由中某个元素的 <xref:System.Windows.UIElement.IsFocused%2A> 属性的值从 "`false`" 更改为 "`true`时，将引发此事件。  
  
 因为此事件使用冒泡路由，所以接收焦点的元素可能是一个子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定获得焦点的实际元素。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GotFocusEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
-   没有相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnGotFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 是一种类似的事件，用于跟踪维护元素的焦点状态的属性中的状态更改;在许多相同的情况下都会引发 <xref:System.Windows.UIElement.GotKeyboardFocus> 事件。  
  
 由于此事件使用冒泡路由，因此具有焦点的元素可以是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定具有焦点的实际元素。  
  
 此事件将为此类创建 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.GotKeyboardFocus> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.GotKeyboardFocus> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus>。  
  
-   重写 <xref:System.Windows.UIElement.OnGotKeyboardFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素捕获鼠标时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时，它将接收鼠标输入，即使鼠标指针在其边界之外也是如此。 通常仅在拖放操作期间捕获鼠标，并在拖放操作的删除操作发生之前捕获该鼠标。  
  
 由于此事件使用冒泡路由，因此具有捕获的元素可以是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定具有鼠标捕获的实际元素。  
  
 此事件将为此类创建 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.GotMouseCapture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.GotMouseCapture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   未定义相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnGotMouseCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GotMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素捕获触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获触笔时，它将接收触笔输入，即使指针在其边界之外也是如此。 通常仅在拖放操作期间捕获触笔，并保留捕获，直到拖放操作的删除操作发生。  
  
 由于此事件使用冒泡路由，因此具有捕获的元素可以是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定具有捕获的实际元素。  
  
 此事件将为此类创建附加事件的别名，以便当 <xref:System.Windows.UIElement> 继承为基元素时，<xref:System.Windows.UIElement.GotStylusCapture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.GotStylusCapture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   未定义相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnGotStylusCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GotStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素上捕获触摸屏输入时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写 <xref:System.Windows.UIElement.OnGotTouchCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.GotTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.UIElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素是否具有任何进行动画处理的属性。</summary>
        <value>如果此元素具有附加到其任何属性的动画，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性为持久性（unclocked、always-正在运行）动画或具有特定时间线的动画返回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property HasEffectiveKeyboardFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HasEffectiveKeyboardFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEffectiveKeyboardFocus : bool" Usage="System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Windows.UIElement" /> 是否具有焦点。</summary>
        <value>如果 <see cref="T:System.Windows.UIElement" /> 具有焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子类可以重写此属性，以指定元素具有键盘焦点的时间。  当你的 <xref:System.Windows.UIElement> 包含可具有键盘焦点的元素，并且你希望你的元素报告它具有焦点时，这非常有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>实现 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> 以提供基元素命中测试行为。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">描述要执行的命中测试，包括初始命中点。</param>
        <summary>实现 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> 以提供基元素命中测试行为（返回 <see cref="T:System.Windows.Media.GeometryHitTestResult" />）。</summary>
        <returns>测试结果，包括计算的几何图形。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关在进一步派生的类中重写此方法的信息，请参阅原始虚拟方法 <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>。 请注意，有几个特定的控件（例如<xref:System.Windows.Controls.TextBlock>）具有不同的实现，这将重写此实现。  
  
 此方法不应从应用程序代码中调用。 此方法支持由输入系统的各个方面公开的内部命中测试行为（例如，鼠标指针是否位于元素上）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">描述要执行的命中测试，包括初始命中点。</param>
        <summary>实现 <see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" /> 以提供基元素命中测试行为（返回 <see cref="T:System.Windows.Media.HitTestResult" />）。</summary>
        <returns>包括计算的点的测试结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关在进一步派生的类中重写此方法的信息，请参阅原始虚拟方法 <xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>。 请注意，有几个特定的控件（例如<xref:System.Windows.Controls.TextBlock>）具有不同的实现，它们会重写 <xref:System.Windows.UIElement>定义的 <xref:System.Windows.UIElement.HitTestCore%2A>。  
  
 此方法不应从应用程序代码中调用。 此方法支持由输入系统的各个方面公开的内部命中测试行为（例如，鼠标指针是否位于元素上）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.UIElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此元素关联的输入绑定的集合。</summary>
        <value>输入绑定的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 输入绑定支持将命令绑定到输入设备。 例如，<xref:System.Windows.Input.MouseBinding> 实现包含特定于鼠标设备的属性的输入绑定。  
  
 输入绑定的集合将包含与该类型相关的输入绑定，以及在该实例上声明的输入绑定。  
  
 相关属性 <xref:System.Windows.UIElement.CommandBindings%2A>维护一组命令绑定。 它们与输入绑定的不同之处在于，它们表示命令处理下一级别的操作，这些操作与已知命令相关联。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  
  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreInputBindings*  
 一个或多个 <xref:System.Windows.Input.InputBinding> 元素（通常为 <xref:System.Windows.Input.KeyBinding> 或 <xref:System.Windows.Input.MouseBinding> 派生类）。 其中每个都应具有 <xref:System.Windows.Input.InputBinding.Command%2A> 和 <xref:System.Windows.Input.InputBinding.Gesture%2A> 属性集。  
  
   
  
## Examples  
 下面的示例使用单个 <xref:System.Windows.Input.KeyBinding>在 <xref:System.Windows.Window>上填充此属性。  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 有关集合的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法的详细信息，请参阅[XAML 语法的详细](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail)信息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InputHitTest">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.IInputElement InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputHitTest (point As Point) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::IInputElement ^ InputHitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.InputHitTest : System.Windows.Point -&gt; System.Windows.IInputElement" Usage="uIElement.InputHitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">此元素中的偏移坐标。</param>
        <summary>返回指定坐标上的当前元素中的输入元素（相对于当前元素的源）。</summary>
        <returns>位于指定位置的子元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作为返回类型返回 <xref:System.Windows.IInputElement>，因为该类型是 <xref:System.Windows.UIElement> 和 <xref:System.Windows.ContentElement>的公共接口。 然后，你可以相应地强制转换返回类型，或使用由 <xref:System.Windows.IInputElement> 接口定义的某些成员的接口实例。  
  
 通常不会从应用程序代码中调用此方法。 仅当打算重新实现大量低级别输入功能（如重新创建鼠标设备逻辑）时，才可以调用此方法。  
  
 <xref:System.Windows.IContentHost> 使用同一签名来约定 <xref:System.Windows.IContentHost.InputHitTest%2A> 方法，某些元素选择显式实现此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateArrange">
      <MemberSignature Language="C#" Value="public void InvalidateArrange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateArrange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateArrange" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateArrange ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateArrange();" />
      <MemberSignature Language="F#" Value="member this.InvalidateArrange : unit -&gt; unit" Usage="uIElement.InvalidateArrange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使元素排列状态（布局）无效。 排列状态失效后，该元素将更新其布局，更新将以异步方式发生，除非随后由 <see cref="M:System.Windows.UIElement.UpdateLayout" /> 强制执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 频繁调用 <xref:System.Windows.UIElement.InvalidateArrange%2A> 或特别是 <xref:System.Windows.UIElement.UpdateLayout%2A> 会对性能产生重大影响。 因此，请避免调用此方法，除非你在对代码中的其他 Api 进行后续调用时绝对需要精确布局状态。 如果要为不在 <xref:System.Windows.Freezable> 或 <xref:System.Windows.FrameworkElement> 派生类上的依赖属性创建 <xref:System.Windows.PropertyChangedCallback>，而该属性在更改时仍会影响布局的排列处理过程，则可以调用 <xref:System.Windows.UIElement.InvalidateArrange%2A> 的高级方案。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateMeasure">
      <MemberSignature Language="C#" Value="public void InvalidateMeasure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateMeasure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateMeasure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateMeasure();" />
      <MemberSignature Language="F#" Value="member this.InvalidateMeasure : unit -&gt; unit" Usage="uIElement.InvalidateMeasure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使元素度量状态（布局）无效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法还会在内部调用 <xref:System.Windows.UIElement.InvalidateArrange%2A>，无需连续调用 <xref:System.Windows.UIElement.InvalidateMeasure%2A> 和 <xref:System.Windows.UIElement.InvalidateArrange%2A>。 失效后，该元素将更新其布局，这将以异步方式发生，除非调用 <xref:System.Windows.UIElement.UpdateLayout%2A> 来强制进行同步布局更改。  
  
 WPF 框架级别布局系统自行处理元素的可视化树中的更改，并且在大多数常见的布局失效情况下，布局系统在必要时将调用与此方法等效的。 仅当生成可直接操作元素树或类似高级方案的完整布局实现时，才应调用此方法。 一种高级方案是，如果您要为不在 <xref:System.Windows.Freezable> 或 <xref:System.Windows.FrameworkElement> 派生类上的依赖属性创建 <xref:System.Windows.PropertyChangedCallback>，而该属性在更改时仍会影响布局的测量处理过程。  
  
 频繁调用 <xref:System.Windows.UIElement.InvalidateMeasure%2A> 或特别是 <xref:System.Windows.UIElement.UpdateLayout%2A> 会对性能产生重大影响。 因此，请避免调用此方法，除非你在对代码中的其他 Api 进行后续调用时绝对需要精确布局状态。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateVisual">
      <MemberSignature Language="C#" Value="public void InvalidateVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateVisual() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateVisual" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateVisual ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateVisual();" />
      <MemberSignature Language="F#" Value="member this.InvalidateVisual : unit -&gt; unit" Usage="uIElement.InvalidateVisual " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使元素的呈现失效，并强制执行完整的新布局处理过程。 完成布局循环后调用 <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在内部调用 <xref:System.Windows.UIElement.InvalidateArrange%2A>。  
  
 通常不会从应用程序代码中调用此方法。 WPF 框架级别布局系统自行处理元素的可视化树中的更改，并在必要时调用此方法的等效项。 只有高级方案才需要调用此方法。 一个这样的高级方案是，如果您要为不在 <xref:System.Windows.Freezable> 或 <xref:System.Windows.FrameworkElement> 派生类上的依赖属性创建 <xref:System.Windows.PropertyChangedCallback>，而该属性在更改时仍会影响布局。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
      </Docs>
    </Member>
    <Member MemberName="IsArrangeValid">
      <MemberSignature Language="C#" Value="public bool IsArrangeValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArrangeValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsArrangeValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArrangeValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArrangeValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArrangeValid : bool" Usage="System.Windows.UIElement.IsArrangeValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素布局中的子元素的计算大小和位置是否有效。</summary>
        <value>如果布局的大小和位置都有效，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以通过对此元素（或其父元素）调用 <xref:System.Windows.UIElement.InvalidateArrange%2A> 来强制使排列无效。 这会标志布局系统确定时，重新进行重新组合的布局。 或者，可以对 <xref:System.Windows.UIElement.UpdateLayout%2A> 进行直接调用，但仅当确信没有更进一步的失效处于挂起状态时，才应执行此操作（大量不必要的强制更新会导致性能后果）。  
  
 除非还 `true` <xref:System.Windows.UIElement.IsMeasureValid%2A>，否则不能 `true` <xref:System.Windows.UIElement.IsArrangeValid%2A> （在布局过程中，无需先进行度量，就无法有效排列）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
        <altmember cref="P:System.Windows.UIElement.IsMeasureValid" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.UIElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中启用此元素。  这是依赖项属性。</summary>
        <value>如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性受特定元素上的特定于类的 <xref:System.Windows.UIElement.IsEnabledCore%2A> 实现（通常在运行时）的影响。 因此，此处列出的默认值有时不有效。 例如，每当确定不需要支持滚动条时，<xref:System.Windows.Controls.Primitives.ScrollBar> <xref:System.Windows.UIElement.IsEnabled%2A> `false`。 尝试设置此值时，可能会被 <xref:System.Windows.UIElement.IsEnabledCore%2A>返回的值覆盖。  
  
 未启用的元素不参与命中测试或焦点，因此不会成为输入事件的源。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsEnabledProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例演示一个按钮的处理程序，该处理程序在执行时将设置其他命名按钮 `b1`<xref:System.Windows.UIElement.IsEnabled%2A> `false`。  
  
 [!code-csharp[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/CSharp/default.xaml.cs#handler)]
 [!code-vb[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/VisualBasic/default.xaml.vb#handler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsEnabled" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.UIElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值成为派生类中 <see cref="P:System.Windows.UIElement.IsEnabled" /> 的返回值。</summary>
        <value>如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>此属性的默认实现会缓存值，还会计算是否已启用此元素的父元素。 （如果未启用父元素，则不能在实际 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]中有效地启用子元素。）如果选择重写此实现，请确保调用基实现以保留此行为。  
  
<see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> 类提供此属性的现有重写实现。 此重写确定内容显示区域内的内容是否超出可用区域。 如果内容超出了区域，则会启用滚动条部分。 否则，不会启用滚动条。</para></block>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsEnabled" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.UIElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定此元素是否具有逻辑焦点。  这是依赖项属性。</summary>
        <value>如果此元素具有逻辑焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序有多个焦点区域（例如菜单内容和应用程序的其余部分之间），则逻辑焦点可能与键盘焦点不同。 在此方案中，键盘焦点只能在应用程序 UI 的一个元素上，但是，其他焦点部门中的某些元素可能仍会保留逻辑焦点。 有关逻辑焦点的详细信息，请参阅[焦点概述](/dotnet/framework/wpf/advanced/focus-overview)。  
  
 不通过设置此属性（它是只读的）来设置焦点。 此属性的典型用途是将其用作 <xref:System.Windows.Setter> 或 <xref:System.Windows.EventTrigger>的依赖属性。 若要以编程方式设置焦点，请调用 <xref:System.Windows.UIElement.Focus%2A>。 还可以通过用户操作或控件实现（可能包括鼠标捕获行为）来设置焦点。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsFocusedProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例是一个代码处理程序，它在焦点为焦点时更改控件的背景。  
  
 [!code-csharp[PopupSimple#IsFocused](~/samples/snippets/csharp/VS_Snippets_Wpf/PopupSimple/CSharp/Window1.xaml.cs#isfocused)]  
  
 实现相同效果的另一种常见方法是将 <xref:System.Windows.Trigger> 放置在控件的 <xref:System.Windows.Style> 中;此方法不需要使用代码隐藏来处理特定的事件，并允许设计人员更好地访问 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]的交互式和图形特性。 有关示例，请参阅[如何：创建外部发光效果](https://msdn.microsoft.com/library/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsFocused" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsHitTestVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHitTestVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHitTestVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisible : bool with get, set" Usage="System.Windows.UIElement.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值声明是否可以返回此元素作为其呈现内容的某些部分的点击测试结果。 这是依赖项属性。</summary>
        <value>如果此元素可以从至少一个点作为命中测试结果返回，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的有效值受到逻辑树中命中可测试元素的相对位置的影响。 例如，如果元素是未命中测试的元素的子元素，则子级上属性的有效值将保留 `false`，即使尝试在本地设置该值也是如此。 出于此原因，不要将 <xref:System.Windows.UIElement.IsHitTestVisible%2A> 设置为对复合控件 `false`，除非您不希望对该控件执行任何输入或命中测试。 有关命中测试的详细信息，请参阅[可视化层中的命中测试](/dotnet/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer)。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsHitTestVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsHitTestVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 依赖项属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHitTestVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHitTestVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHitTestVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否启用输入法系统（如 [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]）来处理此元素的输入。</summary>
        <value>如果输入法处于活动状态，则为<see langword="true" /> ；否则为 <see langword="false" />。 基础附加属性的默认值为 <see langword="true;" />；但在运行时该值会受到输入法实际状态的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回由当前启用的输入方法（键盘、语音和其他输入设备） <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> 的附加属性返回的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.UIElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值表示该元素是否具有键盘焦点。  这是依赖项属性。</summary>
        <value>如果此元素具有键盘焦点，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此属性的确定值所做的更改可能伴随着与焦点相关的事件。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 和 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 通常用于其他与输入相关的事件的类事件处理程序中，例如，用于确定元素是否已具有键盘焦点，或在鼠标事件和键盘事件一起发生时做出决定。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
        <altmember cref="E:System.Windows.UIElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示键盘焦点是否位于元素或其可视化树子元素内的任意位置。  这是依赖项属性。</summary>
        <value>如果键盘焦点在元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此属性的值所做的更改通常引发 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> 事件，除非派生类已重写 <xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A> 以禁止显示该事件。  
  
 不会直接设置此属性，但可以通过调用 <xref:System.Windows.UIElement.Focus%2A>或发出 <xref:System.Windows.UIElement.MoveFocus%2A> 请求将焦点设置到元素。 这两种方法调用可能会更改此属性值。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 和 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 通常用于其他与输入相关的事件的类事件处理程序中，例如，用于确定元素是否已具有键盘焦点，或在鼠标事件和键盘事件一起发生时做出决定。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabled">
      <MemberSignature Language="C#" Value="public bool IsManipulationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsManipulationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsManipulationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsManipulationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsManipulationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsManipulationEnabled : bool with get, set" Usage="System.Windows.UIElement.IsManipulationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否对此 <see cref="T:System.Windows.UIElement" /> 启用操作事件。</summary>
        <value>如果对此 <see cref="T:System.Windows.UIElement" /> 启用操作事件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果希望 <xref:System.Windows.UIElement> 接收 <xref:System.Windows.UIElement.ManipulationStarting>、<xref:System.Windows.UIElement.ManipulationStarted>、<xref:System.Windows.UIElement.ManipulationDelta>、<xref:System.Windows.UIElement.ManipulationInertiaStarting>、<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>和 <xref:System.Windows.UIElement.ManipulationCompleted> 事件，请将此属性设置为 true。 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
   
  
## Examples  
 下面的示例创建一个具有红色矩形的应用程序。  矩形的 <xref:System.Windows.UIElement.IsManipulationEnabled%2A> 属性设置为 true，应用程序的窗口将订阅 <xref:System.Windows.UIElement.ManipulationStarting>、<xref:System.Windows.UIElement.ManipulationDelta>和 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件。 本示例摘自[演练：创建您的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)中的一个更大的示例。  
  
 [!code-xaml[BasicManipulation#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsManipulationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsManipulationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsManipulationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsManipulationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsManipulationEnabled" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMeasureValid">
      <MemberSignature Language="C#" Value="public bool IsMeasureValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMeasureValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMeasureValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMeasureValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMeasureValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMeasureValid : bool" Usage="System.Windows.UIElement.IsMeasureValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示布局测量返回的当前大小是否有效。</summary>
        <value>如果布局的测量处理过程返回一个有效的当前值，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以通过对此元素（或在可视化树中向上的任何父元素）调用 <xref:System.Windows.UIElement.InvalidateMeasure%2A> 来强制使测量和排列无效。 这会指定布局进行异步重新组合，在布局系统确定的时间发生。 或者，你可以立即调用 <xref:System.Windows.UIElement.UpdateLayout%2A>。 但是，如果有可能不会等待进一步的失效，则只应调用 <xref:System.Windows.UIElement.UpdateLayout%2A> （大量不必要的强制更新将会导致性能后果）。  
  
 如果 `false`<xref:System.Windows.UIElement.IsMeasureValid%2A>，<xref:System.Windows.UIElement.IsArrangeValid%2A> 还必须 `false` （通过布局过程的强制逻辑），则在没有度量值首次有效的情况下，排列将是无效的。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.UIElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素是否捕获了鼠标。  这是依赖项属性。</summary>
        <value>如果元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标捕获状态与进程内拖放操作相关。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例根据是否已为元素捕获鼠标，打开或关闭鼠标捕获状态。  
  
 如果鼠标捕获在其他位置，则将鼠标捕获设置为该元素。 如果该元素具有鼠标捕获，则通过调用具有 null 输入的 <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> 清除它。  
  
 [!code-csharp[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseSnippetSample/CSharp/Window1.xaml.cs#ismousecaptured)]
 [!code-vb[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseSnippetSample/visualbasic/window1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定鼠标捕获是由此元素还是其可视化树中的子元素持有。 这是依赖项属性。</summary>
        <value>如果此元素或包含的元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /> 值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在考虑元素组合的情况下，鼠标指针的位置是否与命中测试结果相对应。  这是依赖项属性。</summary>
        <value>如果鼠标指针位于与命中测试相同的元素结果上，则为<see langword="true" /> ；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Windows.UIElement.IsMouseOver%2A>不同，仅当鼠标指针位于文本元素上时才 `true` 此属性，因为它适用于命中测试。 如果鼠标指针在子元素上，而不是作为元素的更深层模板和组合的一部分的元素，则此属性将 `false`。 除非您知道控件的组合方式（例如，在自定义控件模板中对您定义的控件使用此属性），否则此属性可能会返回意外的结果。 对于不是创作控件的大多数情况，请改用 <xref:System.Windows.UIElement.IsMouseOver%2A>。  
  
 如果此元素捕获鼠标并且此属性在捕获时 `true`，则此属性将继续返回 `true`，直至鼠标捕获丢失并且指针不在其边界上。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.UIElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示鼠标指针是否位于此元素（包括可视化树中的子元素）的上方。  这是依赖项属性。</summary>
        <value>如果鼠标指针位于该元素或其子元素上方，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，控件是复合的，因此控件内的各种元素（可视化树）都将报告包含控件的鼠标状态。 例如，如果鼠标位于其几何图形上的任意位置（包括任何 <xref:System.Windows.Controls.ListBoxItem>），则 <xref:System.Windows.Controls.ListBox> 样式控件将报告 <xref:System.Windows.UIElement.IsMouseOver%2A> 为 `true`。  
  
 尽管不存在类似的 "IsMouseOverChanged" 事件，但有几个类似的事件。 例如，可以处理 <xref:System.Windows.UIElement.MouseEnter>、<xref:System.Windows.UIElement.MouseMove>和 <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>。  
  
 如果此元素捕获鼠标，此属性将保持 `true`，直到鼠标捕获丢失，并且鼠标指针离开元素边界。  
  
 某些控件有意捕获鼠标上某些不直接涉及鼠标的操作。 即使鼠标没有明显移动，这也会导致 <xref:System.Windows.UIElement.IsMouseOver%2A> `true`。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsMouseOverProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例将此属性作为 \<样式 <xref:System.Windows.Trigger>的一部分的属性类型引用。触发器 > block。 如果鼠标位于控件上方，控件文本将变为蓝色，光标将变为手形。  
  
 [!code-xaml[ListViewChkBox#Trigger](~/samples/snippets/csharp/VS_Snippets_Wpf/ListViewChkBox/CS/window1.xaml#trigger)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsMouseOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.UIElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值表示此元素是否捕获了触笔。  这是依赖项属性。</summary>
        <value>如果元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定触笔捕获是由此元素还是由元素边界内的元素及其可视化树持有。 这是依赖项属性。</summary>
        <value>如果此元素或包含的元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[Windows Vista 中的触摸输入支持](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)和[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在考虑元素组合的情况下，触笔的位置是否与命中测试结果相对应。  这是依赖项属性。</summary>
        <value>如果触笔指针位于与命中测试相同的元素结果上，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Windows.UIElement.IsStylusOver%2A>不同，此属性仅在触笔位于元素上时 `true`。 如果触笔位于某个子元素上或作为元素的更深层组合（可视化树）一部分的元素，则将 `false`此属性。  
  
 除非您知道控件的组合方式（例如，在自定义控件模板中对您定义的控件使用此属性），否则此属性可能会返回意外的结果。 对于不是创作控件的大多数情况，请改用 <xref:System.Windows.UIElement.IsStylusOver%2A>。  
  
 如果此元素具有触笔捕获，而此属性在捕获时 `true`，则此属性将保持 `true`，直到触笔捕获丢失并且触笔不在其边界上。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.UIElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示触笔指针是否位于此元素（包括可视化子元素）的上方。  这是依赖项属性。</summary>
        <value>如果触笔光标位于元素或其子元素上方，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素具有触笔捕获，此属性将继续返回 `true`，直到触笔捕获丢失且指针超出其边界。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsStylusOverProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsStylusOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Windows.UIElement.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中是否可见。  这是依赖项属性。</summary>
        <value>如果该元素可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 确定 <xref:System.Windows.UIElement.IsVisible%2A> 值将考虑布局的所有因素。 相反，<xref:System.Windows.UIElement.Visibility%2A>，这是一个可设置的属性，只指示以编程方式使元素可见或不可见的意图。  
  
 如果 <xref:System.Windows.UIElement.IsVisible%2A> `false` 的元素不参与输入事件（或命令），则不会影响布局的度量值或排列处理过程、不可获得焦点、不在 tab 序列中，并且不会在命中测试中报告。 相反，<xref:System.Windows.UIElement.IsEnabled%2A> `false` 的元素仍将参与事件和命令，并进行命中测试，但也不能获得焦点。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.IsVisibleProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement.IsVisible" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果布局系统未呈现元素，则不会引发此事件，原因不是 <xref:System.Windows.UIElement.IsVisible%2A> 属性的值。 例如，元素可能没有关联的视觉对象。  
  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.IsVisible" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当焦点在该元素上时按下某个键后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键处理与其他平台功能（如命令和文本撰写）交互。 <xref:System.Windows.UIElement.KeyDown> 事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。 这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。  
  
 此事件将为此类创建 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.KeyDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.KeyDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.KeyDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewKeyDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnKeyDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.KeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当焦点在该元素上时松开某个键后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将为此类创建 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.KeyUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.KeyUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.KeyUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewKeyUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnKeyUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.KeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler LayoutUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LayoutUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LayoutUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LayoutUpdated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LayoutUpdated;" />
      <MemberSignature Language="F#" Value="member this.LayoutUpdated : EventHandler " Usage="member this.LayoutUpdated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在与当前 <see cref="T:System.Windows.Threading.Dispatcher" /> 关联的各种可视元素的布局更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于属性更改、窗口大小调整或显式用户请求，可能会发生布局更新。  
  
 此成员是 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 事件，而不是路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失逻辑焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有意通过某个方法调用强制失去了焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。 在此方案中，键盘焦点仍保留在何处，而调用 <xref:System.Windows.UIElement.Focus%2A> 方法的元素仍获得逻辑焦点。  
  
 此事件的更精确解释是：当路由中某个元素的 <xref:System.Windows.UIElement.IsFocused%2A> 属性的值从 `true` 改为 `false`时，将引发此事件。  
  
 由于此事件使用冒泡路由，失去焦点的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定获得焦点的实际元素。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.LostFocusEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
-   没有相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnLostFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在键盘焦点不再位于此元素上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用冒泡路由，失去焦点的元素可能是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定失去焦点的实际元素。  
  
 此事件创建此类的 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.LostKeyboardFocus> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.LostKeyboardFocus> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>。  
  
-   重写 <xref:System.Windows.UIElement.OnLostKeyboardFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.LostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失鼠标捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时，它将接收鼠标输入，即使指针在其边界之外也是如此。 通常仅在拖放操作期间捕获鼠标。  
  
 由于此事件使用冒泡路由，失去捕获的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定丢失捕获的实际元素。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.LostMouseCapture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.LostMouseCapture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   未定义相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnLostMouseCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.LostMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失触笔捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获触笔时，它将接收触笔输入，即使指针在其边界之外也是如此。 通常仅在拖放操作期间捕获触笔。  
  
 由于此事件使用冒泡路由，失去焦点的元素可能是一个子元素，而不是实际附加了事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定失去焦点的实际元素。  
  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.LostStylusCapture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.LostStylusCapture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   未定义相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnLostStylusCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.LostStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素失去触摸屏输入捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写 <xref:System.Windows.UIElement.OnLostTouchCapture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.LostTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationBoundaryFeedback As EventHandler(Of ManipulationBoundaryFeedbackEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^&gt; ^ ManipulationBoundaryFeedback;" />
      <MemberSignature Language="F#" Value="member this.ManipulationBoundaryFeedback : EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " Usage="member this.ManipulationBoundaryFeedback : System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当操作遇到边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ManipulationBoundaryFeedback"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationBoundaryFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationBoundaryFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationCompleted As EventHandler(Of ManipulationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationCompletedEventArgs ^&gt; ^ ManipulationCompleted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationCompleted : EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " Usage="member this.ManipulationCompleted : System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对于 <see cref="T:System.Windows.UIElement" /> 对象的操作和延时完毕时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此事件来获取有关操作完成时的操作的信息。  例如，可以使用 <xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType> 属性来确定操作位置更改的总量。  
  
 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
<a name="routedEventInfo_ManipulationCompleted"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationCompletedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompletedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationCompletedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationCompletedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationCompletedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationCompletedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDelta">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationDelta" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationDelta As EventHandler(Of ManipulationDeltaEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationDeltaEventArgs ^&gt; ^ ManipulationDelta;" />
      <MemberSignature Language="F#" Value="member this.ManipulationDelta : EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " Usage="member this.ManipulationDelta : System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当输入设备在操作期间更改位置时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户在操作过程中将手指拖动到屏幕上，并且发生惯性时，<xref:System.Windows.UIElement.ManipulationDelta> 事件发生多次。  您可以使用 <xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A> 属性检查是否在惯性期间发生事件。  
  
 事件发生时，发生 <xref:System.Windows.UIElement.ManipulationDelta> 事件的元素不会以任何方式受到影响。  必须为要操作的元素提供逻辑。  <xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A> 和 <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> 属性（类型为 <xref:System.Windows.Input.ManipulationDelta>）包含有关操作位置如何变化并解释为移动、调整大小或旋转对象的数据。  将该信息应用于要操作的元素。  
  
 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
<a name="routedEventInfo_ManipulationDelta"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationDeltaEventArgs>。|  
  
   
  
## Examples  
 下面的示例演示了 <xref:System.Windows.UIElement.ManipulationDelta> 事件的事件处理程序。 该示例使用 <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> 属性移动、调整大小和旋转 <xref:System.Windows.Shapes.Rectangle>。  该示例还检查是否在惯性期间发生了 <xref:System.Windows.UIElement.ManipulationDelta> 事件，以及矩形是否正在触及窗口的边缘。  如果这些事例为 true，则应用程序将停止操作以防止矩形离开应用程序的可见区域。 本示例摘自[演练：创建您的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)中的一个更大的示例。  
  
 [!code-csharp[BasicManipulation#ManipulationDelta](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationdelta)]
 [!code-vb[BasicManipulation#ManipulationDelta](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationdelta)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDeltaEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationDeltaEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationDeltaEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationDeltaEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationDeltaEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationDelta" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationInertiaStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationInertiaStarting As EventHandler(Of ManipulationInertiaStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationInertiaStartingEventArgs ^&gt; ^ ManipulationInertiaStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationInertiaStarting : EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " Usage="member this.ManipulationInertiaStarting : System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当输入设备在操作期间与 <see cref="T:System.Windows.UIElement" /> 对象失去联系且延时开始时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户在操作过程中将所有手指从屏幕上提起时，将发生 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件。 例如，如果用户在表面上 "抛出" <xref:System.Windows.UIElement>，则用户将触摸 <xref:System.Windows.UIElement> 以开始操作，在屏幕上将手指移动一小段，然后释放 <xref:System.Windows.UIElement>。 当用户释放元素时，惯性将开始，并且 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件发生。  <xref:System.Windows.UIElement> 继续接收 <xref:System.Windows.UIElement.ManipulationDelta> 事件，以指示元素上出现惯性。  
  
 您可以使用此事件来指定惯性的行为。  例如，可以设置惯性开始时使用的初始速度。  还可以通过设置所需的减速度或设置所需的位置来指定惯性量。  您可以单独为每种类型的操作（转换、扩展或旋转）设置这些值。  有关详细信息，请参阅 <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。  
  
 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
<a name="routedEventInfo_ManipulationInertiaStarting"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。|  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件处理程序，并为惯性期间使用的转换、扩展和旋转设置所需的减速度。 本示例摘自[演练：创建您的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)中的一个更大的示例。  
  
 [!code-csharp[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationinertiastarting)]
 [!code-vb[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationinertiastarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationInertiaStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationInertiaStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationInertiaStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarted As EventHandler(Of ManipulationStartedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartedEventArgs ^&gt; ^ ManipulationStarted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarted : EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " Usage="member this.ManipulationStarted : System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当输入设备对 <see cref="T:System.Windows.UIElement" /> 对象开始操作时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationStarted> 事件发生在 <xref:System.Windows.UIElement.ManipulationStarting> 事件之后。  您可以对 <xref:System.Windows.Input.ManipulationStartedEventArgs>执行以下操作：  
  
-   使用 <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A> 属性获取该操作的位置相对于的元素。  
  
-   使用 <xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A> 属性获取操作的原点。  
  
-   通过调用 <xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A> 方法来取消操作。  
  
 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
<a name="routedEventInfo_ManipulationStarted"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationStartedEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationStartedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationStarted" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarting As EventHandler(Of ManipulationStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartingEventArgs ^&gt; ^ ManipulationStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarting : EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " Usage="member this.ManipulationStarting : System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在首次创建操作处理器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户将手指放在 <xref:System.Windows.UIElement.IsManipulationEnabled%2A> 属性设置为 `true` 时，将在该元素上发生 <xref:System.Windows.UIElement.ManipulationStarting> 事件。 默认情况下，后续操作事件会报告与 <xref:System.Windows.UIElement.IsManipulationEnabled%2A> 设置为 `true`的元素相关的操作位置。  您可以通过设置 "<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>" 属性来指定该位置应与另一个元素相关。 例如，可以相对于元素的父级进行操作。  
  
 你还可以在 <xref:System.Windows.UIElement.ManipulationStarting>的事件处理程序中执行以下操作：  
  
-   通过设置 <xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType> 属性，指定用户是否需要多个手指来执行操作。  
  
-   通过将 <xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType> 属性设置为 <xref:System.Windows.Input.ManipulationModes> 枚举来指定启用哪种类型的操作。  
  
-   通过设置 "<xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType>" 属性指定单指旋转的中心。  
  
-   通过调用 <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType> 方法来取消操作。  
  
 有关操作的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  有关响应操作的应用程序的示例，请参阅[演练：创建你的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)。  
  
<a name="routedEventInfo_ManipulationStarting"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.ManipulationStartingEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.ManipulationStartingEventArgs>。|  
  
   
  
## Examples  
 下面的示例演示了 <xref:System.Windows.UIElement.ManipulationStarting> 事件的事件处理程序，并将 <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> 设置为父元素，该元素接收操作事件，以便操作的坐标相对于父元素。  本示例摘自[演练：创建您的第一个 Touch 应用程序](/dotnet/framework/wpf/advanced/walkthrough-creating-your-first-touch-application)中的一个更大的示例。  
  
 [!code-csharp[BasicManipulation#ManipulationStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationstarting)]
 [!code-vb[BasicManipulation#ManipulationStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationstarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.ManipulationStarting" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Measure">
      <MemberSignature Language="C#" Value="public void Measure (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Measure(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Measure (availableSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Measure(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="member this.Measure : System.Windows.Size -&gt; unit" Usage="uIElement.Measure availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父元素可以为子元素分配的可用空间。 子元素可以请求大于可用空间的空间；如果可在当前元素的内容模型中进行滚动，则提供的大小可以适应此空间。</param>
        <summary>更新 <see cref="T:System.Windows.UIElement" /> 的 <see cref="P:System.Windows.UIElement.DesiredSize" />。 父元素从其自身的 <see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /> 实现调用此方法以形成递归布局更新。 调用此方法构成布局更新的第一个处理过程（“测量”处理过程）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 中的布局定位的计算由 <xref:System.Windows.UIElement.Measure%2A> 调用和 <xref:System.Windows.UIElement.Arrange%2A> 调用组成。 在 <xref:System.Windows.UIElement.Measure%2A> 调用期间，元素通过使用 `availableSize` 输入来确定其大小要求。 在 <xref:System.Windows.UIElement.Arrange%2A> 调用期间，元素大小已完成。  
  
 `availableSize` 可以是从零到无限大的任何数字。 参与布局的元素应返回给定 `availableSize`所需的最小 <xref:System.Windows.Size>。  
  
 第一次实例化布局时，将始终在 <xref:System.Windows.UIElement.Arrange%2A>之前接收 <xref:System.Windows.UIElement.Measure%2A> 调用。 但是，在第一次布局传递后，它可能会收到 <xref:System.Windows.UIElement.Arrange%2A> 调用，但没有 <xref:System.Windows.UIElement.Measure%2A>;如果更改仅影响 <xref:System.Windows.UIElement.Arrange%2A> 的属性（如对齐方式），或者当父对象收到没有 <xref:System.Windows.UIElement.Measure%2A>的 <xref:System.Windows.UIElement.Arrange%2A> 时，会发生这种情况。 <xref:System.Windows.UIElement.Measure%2A> 调用会自动使 <xref:System.Windows.UIElement.Arrange%2A> 调用无效。  
  
 布局更新以异步方式进行，因此主线程不会等待每个可能的布局更改。 通过对属性值进行代码隐藏检查来查询元素，可能不会立即反映对与大小调整或布局特征（例如 <xref:System.Windows.FrameworkElement.Width%2A> 属性）交互的属性所做的更改。  
  
> [!NOTE]
>  可以使用 <xref:System.Windows.UIElement.UpdateLayout%2A> 方法强制执行布局更新。 但是，通常不需要调用此方法，这可能会导致性能不佳。  
  
 布局系统将两个不同的队列（一个用于 <xref:System.Windows.UIElement.Measure%2A>，一个用于 <xref:System.Windows.UIElement.Arrange%2A>。 布局队列是根据执行布局的元素的可视化树中的元素顺序进行排序的。树中较高位置的元素位于队列的顶部，以避免父代中的重复更改导致冗余的布局。 重复项会自动从队列中删除，如果元素已经进行了布局验证，则会自动从队列中删除它们。  
  
 更新布局时，首先清空 <xref:System.Windows.UIElement.Measure%2A> 队列，后跟 <xref:System.Windows.UIElement.Arrange%2A> 队列。 如果 <xref:System.Windows.UIElement.Measure%2A> 队列中有元素，则永远不会排列 <xref:System.Windows.UIElement.Arrange%2A> 队列中的元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureCore : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="uIElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父元素可以为子元素分配的可用大小。</param>
        <summary>在派生类中重写时，提供测量逻辑来适当地调整此元素的大小，兼顾任何子元素内容的大小。</summary>
        <returns>此元素在布局中的所需大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从 <xref:System.Windows.FrameworkElement> 而不是 <xref:System.Windows.UIElement>派生元素更常见。 如果从 <xref:System.Windows.FrameworkElement>派生，请注意，<xref:System.Windows.FrameworkElement> 上的 <xref:System.Windows.UIElement.MeasureCore%2A> 的重写会密封 <xref:System.Windows.UIElement.MeasureCore%2A> 方法。 因此，如果通过不包含 <xref:System.Windows.FrameworkElement>的继承从 <xref:System.Windows.UIElement> 派生，则只会重写 <xref:System.Windows.UIElement.MeasureCore%2A> 作为更改布局度量值特性的方法。 如果你尝试在 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 核心级别上构建自己的实现，则可能会出现这种情况。 否则，如果从 <xref:System.Windows.FrameworkElement>派生，则度量值行为的实现模板为的 <xref:System.Windows.FrameworkElement> 实现。<xref:System.Windows.FrameworkElement.MeasureOverride%2A>。  
  
 具有子元素的父元素必须对每个子元素调用 <xref:System.Windows.UIElement.Measure%2A>; 否则，这些子元素将不会调整大小或排列，并且将从布局中有效地消失。  
  
   
  
## Examples  
 <xref:System.Windows.UIElement.MeasureCore%2A> 的典型重写遵循此大致模式（不存在名为 `VisualChildren`的内置集合; `VisualChildren` 是表示元素所维护的任何子集合的占位符）。  
  
 [!code-csharp[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementmeasureoverride)]
 [!code-vb[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementmeasureoverride)]  
  
-   必须对每个子元素调用 <xref:System.Windows.UIElement.Measure%2A>。  
  
-   通常，实现应在同一元素中的 <xref:System.Windows.UIElement.MeasureCore%2A> 和 <xref:System.Windows.UIElement.ArrangeCore%2A> 方法调用之间缓存度量信息。  
  
-   不需要调用 <xref:System.Windows.UIElement.MeasureCore%2A> 的基实现，但如果基本实现提供所需的布局功能，则可能适用。  
  
-   对子元素 <xref:System.Windows.UIElement.Measure%2A> 的调用应传递与父元素相同的 `availableSize` 或区域子集，具体取决于父元素支持的布局的类型。 例如，删除特定于元素的边框或填充、滚动条或自定义控件的区域是有效的。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现必须能够处理为无限 <paramref name="availableSize" /> 提供的值。 无限值指示没有请求的约束，并通过递归度量值将度量选择有效地推迟到父元素。  
  
实现可以考虑为 <paramref name="availableSize" /> 提供的值是软约束。 即使应用程序代码的其他方面能够确定父元素的当前实际大小，子元素也可能会指定更大的大小。 大大小请求是一种约定，指示子元素正在查询父元素是否可以支持内容显示区域内的内容滚动。</para></block>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement.MouseDown> 事件通常与 <xref:System.Windows.UIElement.MouseLeftButtonDown> 或 <xref:System.Windows.UIElement.MouseRightButtonDown>一起引发，这对应于按下这两个标准鼠标按钮之一。 <xref:System.Windows.UIElement.MouseLeftButtonDown> 和 <xref:System.Windows.UIElement.MouseRightButtonDown> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。 有关 <xref:System.Windows.UIElement.MouseLeftButtonDown> 或 <xref:System.Windows.UIElement.MouseRightButtonDown>，请参阅 "备注"。  
  
> [!IMPORTANT]
>  某些控件可能具有鼠标按钮事件的固有类处理。 鼠标左键按下事件是在控件中具有类处理的最可能的事件。 类处理通常将基础 <xref:System.Windows.Input.Mouse> 类事件标记为已处理。 将该事件标记为已处理后，通常不会引发附加到该元素的其他实例处理程序。 通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。  
  
 你可以通过使用以下任一解决方案解决在具有类处理的派生类上的 "前面重要" 和 "仍然接收鼠标悬停事件 <xref:System.Windows.UIElement.MouseDown> 事件" 中所述的问题：  
  
-   为 <xref:System.Windows.UIElement.PreviewMouseDown> 事件附加处理程序，这些处理程序未标记为由控件处理。 请注意，因为这是预览事件，所以路由从根节点开始，向下隧道到控件。  
  
-   通过调用 <xref:System.Windows.UIElement.AddHandler%2A> 并选择允许处理程序侦听事件的签名选项（即使它们已在路由事件数据中标记为已处理），在控件过程上注册处理程序。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewMouseDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnMouseDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针进入此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseEnter> 是使用直接事件处理路由策略的[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)。 直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。 但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。  
  
 尽管 <xref:System.Windows.UIElement.MouseEnter> 跟踪鼠标指针进入元素边界的时间，但此事件更确切地报告 <xref:System.Windows.UIElement.IsMouseOver%2A> 属性值已从 `false` 更改为此元素上的 `true`。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseEnter> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseEnter> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 当按钮有焦点且按下的键是空格栏时，<xref:System.Windows.Controls.Button> （或任何 <xref:System.Windows.Controls.Primitives.ButtonBase> 派生类）具有 <xref:System.Windows.UIElement.KeyDown> 事件的本机处理。 本机处理会引发 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件，并将按钮作为源，同时捕获鼠标，即使鼠标指针看上去没有移动也是如此。 作为鼠标捕获的结果，也会随按钮作为源来引发 <xref:System.Windows.UIElement.MouseEnter> 事件。 通常，如果元素捕获鼠标，则会引发 <xref:System.Windows.UIElement.MouseEnter>，以及 <xref:System.Windows.UIElement.GotMouseCapture> 和其他特定于控件的事件。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseEnter%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针离开此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeave> 是使用直接事件处理路由策略的[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)。 直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。 但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。  
  
 尽管 <xref:System.Windows.UIElement.MouseLeave> 跟踪鼠标离开元素的时间，但此事件更确切地报告 <xref:System.Windows.UIElement.IsMouseOver%2A> 属性值已从 `true` 更改为此元素上的 `false`。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseLeave> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseLeave> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseLeave%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)似乎会在元素树中跟随冒泡路由，但它实际上是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.MouseLeftButtonDown> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 处理。 这可能包括类处理程序生成的事件，例如 <xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
> [!IMPORTANT]
>  某些控制类可能具有鼠标按钮事件的固有类处理。 鼠标左键按下事件是在控件中具有类处理的最可能的事件。 类处理通常将基础 <xref:System.Windows.Input.Mouse> 类事件标记为已处理。 将该事件标记为已处理后，通常不会引发附加到该元素的其他实例处理程序。 通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。  
  
 你可以通过使用以下任一解决方案解决在具有类处理的派生类上的 "前面重要" 和 "仍然接收鼠标悬停事件 <xref:System.Windows.UIElement.MouseLeftButtonDown> 事件" 中所述的问题：  
  
-   为 <xref:System.Windows.UIElement.PreviewMouseDown> 事件附加处理程序，这些处理程序未标记为由控件处理。 请注意，因为这是预览事件，所以路由从根节点开始，向下隧道到控件。  
  
-   通过调用 <xref:System.Windows.UIElement.AddHandler%2A> 并选择允许处理程序侦听事件的签名选项（即使它们已在路由事件数据中标记为已处理），在控件过程上注册处理程序。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)似乎会在元素树中跟随冒泡路由，但它实际上是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.MouseLeftButtonUp> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 处理。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且移动鼠标指针时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseMoveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewMouseMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnMouseMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)似乎会在元素树中跟随冒泡路由，但它实际上是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.MouseRightButtonDown> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 处理。 这可能包括类处理程序生成的事件，例如 <xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
 鼠标右键事件通常在应用程序方案中具有本机处理。 例如，按下鼠标右键可能会显示上下文菜单。 请参阅[ContextMenu 概述](/dotnet/framework/wpf/controls/contextmenu-overview)。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)似乎会在元素树中跟随冒泡路由，但它实际上是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.MouseRightButtonUp> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 处理。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement.MouseUp> 事件通常与 <xref:System.Windows.UIElement.MouseLeftButtonUp> 或 <xref:System.Windows.UIElement.MouseRightButtonUp>一起引发，这对应于两个标准鼠标按钮之一的版本。 <xref:System.Windows.UIElement.MouseLeftButtonUp> 和 <xref:System.Windows.UIElement.MouseRightButtonUp> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。 有关 <xref:System.Windows.UIElement.MouseLeftButtonUp> 或 <xref:System.Windows.UIElement.MouseRightButtonUp>，请参阅 "备注"。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewMouseUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnMouseUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于鼠标指针所在的位置;因此，如果从焦点或捕获的元素接收到 <xref:System.Windows.UIElement.MouseWheel> 事件，则鼠标指针实际上可能位于另一个元素上。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.MouseWheel> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.MouseWheel> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.MouseWheelEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewMouseWheel>。  
  
-   重写 <xref:System.Windows.UIElement.OnMouseWheel%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.MouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="uIElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">一个遍历请求，其中包含一个属性，该属性指示以现有 Tab 键顺序遍历的模式或视觉移动的方向。</param>
        <summary>尝试将焦点从此元素移到其他元素。 移动焦点的方向由指导方向指定，该方向在此元素的可视父级的组织结构中解释。</summary>
        <returns>如果执行了请求的遍历，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请确保选中此方法的返回值。 如果遍历运行到由控件的组合定义的制表位，并且遍历请求未请求换行，则可能会返回 `false` 的返回值。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit&#xA;override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="uIElement.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">访问键事件的事件数据。 事件数据报告哪个键被调用，并指示控制发送这些事件的 <see cref="T:System.Windows.Input.AccessKeyManager" /> 对象是否也将此访问键调用发送到其他元素。</param>
        <summary>在调用对于此元素有意义的访问键时提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement> 类或其他位置没有实际的 AccessKey 事件，您可以引发或附加的处理程序。 相反，事件是通过一个专用的管理器类（<xref:System.Windows.Input.AccessKeyManager>）发出的，它会对所有输入进行后处理，以搜索适用于整个输入模型的访问密钥。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的默认实现 <see cref="T:System.Windows.UIElement" /> 将键盘焦点设置到此元素（通过调用 <see cref="M:System.Windows.UIElement.Focus" />）。 如果实现可获得焦点，则实现应保持此行为，因为它是辅助功能方案的预期行为。 请注意，基实现对传递的事件数据不执行任何操作，并且不会引发进一步的事件;它只是设置焦点。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChanged (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChanged(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit&#xA;override this.OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit" Usage="uIElement.OnChildDesiredSizeChanged child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">重新调整其大小的子元素。</param>
        <summary>重新调整子元素的大小时支持布局行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常不由应用程序代码调用。 它是公开的，因此派生元素类可以对其自身可能无效的布局状态进行进一步检查。 类还可以尝试进行优化，以根据对子元素的大小更改，最大程度地减少布局传递的处理时间。 实现 <xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A> 是 <xref:System.Windows.Controls.Grid> 控件的一个示例派生元素类。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> 方法具有对其自身调用 <see cref="M:System.Windows.UIElement.InvalidateMeasure" /> 的默认实现。 典型的实现方式为：执行你自己的元素支持的任何优化，然后通常从至少一个代码分支调用基 <see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" /> （这是根据你自己的度量值缓存逻辑指示 "已更新" 状态的）。  
  
如果此方法是产生大小更改的子本身，则仅在布局处理中调用此方法。 否则，如果父元素按布局系统规则启动 <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> 传递，则父元素已经重新计算布局。 布局系统将按子对象到父级的顺序处理布局，因此不需要从子元素布局调用返回到父元素大小调整。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="uIElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构返回特定于类的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</summary>
        <returns>特定于类型的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>此方法的实现通常用于调用特定 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现的构造函数，并将其作为返回值返回。  
  
所有 <see cref="T:System.Windows.UIElement" /> 派生类都应该实现此方法以便向 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构提供自己的特定 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。 有关实现此模式的详细信息，请参阅 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件数据必须包含 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件的标识符。</param>
        <summary>使用所提供的事件数据引发 <see cref="E:System.Windows.UIElement.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然虚拟，但这种方法具有引发事件的默认实现。  
  
 此 On * 方法实现旨在引发事件，并在内部调用此相同的方法实现，以便在 <xref:System.Windows.UIElement.IsFocused%2A> 属性值更改时引发事件。 <xref:System.Windows.UIElement.OnGotFocus%2A> 实现不同于一些其他 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On * 实现，后者仅提供一种简便的方法来为该事件添加类处理。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非您有意且异常地需要不引发焦点事件，否则请确保您的实现调用基实现。 否则，在通常将焦点设置到此元素的典型用户操作期间，不会引发 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件。 如果你不想让你的元素成为可设定焦点的元素，则可以通过将 <see cref="P:System.Windows.UIElement.Focusable" /> 设置为 <see langword="false" />来防止元素获得焦点。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素上捕获触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.GotTouchCapture" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnGotTouchCapture%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnGotTouchCapture%2A> 以处理 <xref:System.Windows.UIElement.GotTouchCapture> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnGotTouchCapture%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 依赖属性的值发生更改时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 事件。 请注意，<xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>在此元素即将引发 <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> 事件前调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 依赖属性的值发生更改时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> 事件。 请注意，<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged> 事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 事件。 请注意，<xref:System.Windows.UIElement.IsMouseCapturedChanged> 事件不是路由事件;因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>当 <see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> 事件。 请注意，该事件不是路由事件;因此，不能在类处理程序中将其标记为已处理。  
  
此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsMouseDirectlyOver%2A> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> 事件。 请注意，<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged> 事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsStylusCaptured%2A> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsStylusCapturedChanged> 事件。 请注意，该事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsStylusCaptureWithin%2A> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsStylusCaptureWithinChanged> 事件。 请注意，该事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Windows.UIElement.IsStylusDirectlyOver%2A> 依赖项属性的值更改其值时，将引发此虚方法。 首先引发虚方法，并在必要时对事件数据进行操作。 然后，将用相同的事件数据实例引发 <xref:System.Windows.UIElement.IsStylusDirectlyOverChanged> 事件。 请注意，该事件不是路由事件。 因此，不能在类处理程序中将其标记为已处理。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 击键由专用的输入管理器处理。 依赖于击键的其他编程功能（例如，输入和命令绑定）可能会处理击键，然后将其作为一般击键公开。 如果这些输入系统功能将事件标记为已处理，则不会调用 <xref:System.Windows.UIElement.OnKeyDown%2A>。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 击键由专用的输入管理器处理。 依赖于击键的其他编程功能（例如，输入和命令绑定）可能会处理击键，然后将其作为一般击键公开。 如果这些输入系统功能将事件标记为已处理，则不会调用 <xref:System.Windows.UIElement.OnKeyUp%2A>。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件数据必须包含 <see cref="E:System.Windows.UIElement.LostFocus" /> 事件的标识符。</param>
        <summary>使用提供的事件数据引发 <see cref="E:System.Windows.UIElement.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然虚拟，但这种方法具有引发事件的默认实现。  
  
 此 On * 方法实现旨在引发事件，并在内部调用此相同的方法实现，以便在 <xref:System.Windows.UIElement.IsFocused%2A> 属性值更改时引发事件。 此实现不同于 * 实现中的某些其他 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]，后者仅提供一种简便的方法来为该事件添加类处理。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非您有意且异常地需要不引发焦点事件，否则请确保您的实现调用基实现。 否则，在通常将焦点设置到此元素的典型用户操作期间，不会引发 <see cref="E:System.Windows.UIElement.LostFocus" /> 事件。 如果你不想让你的元素成为可设定焦点的元素，则可以通过将 <see cref="P:System.Windows.UIElement.Focusable" /> 设置为 <see langword="false" />来防止元素获得焦点。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素失去触摸屏输入捕获时发生的 <see cref="E:System.Windows.UIElement.LostTouchCapture" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnLostTouchCapture%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnLostTouchCapture%2A> 以处理 <xref:System.Windows.UIElement.LostTouchCapture> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnLostTouchCapture%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit&#xA;override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="uIElement.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">事件的数据。</param>
        <summary>在 <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 事件发生时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> 以处理 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationCompleted (e As ManipulationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationCompleted(System::Windows::Input::ManipulationCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit&#xA;override this.OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit" Usage="uIElement.OnManipulationCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">事件的数据。</param>
        <summary>在 <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> 事件发生时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationCompleted%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationCompleted%2A> 以处理 <xref:System.Windows.UIElement.ManipulationCompleted> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationCompleted%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationDelta (e As ManipulationDeltaEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationDelta(System::Windows::Input::ManipulationDeltaEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit&#xA;override this.OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit" Usage="uIElement.OnManipulationDelta e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">事件的数据。</param>
        <summary>在 <see cref="E:System.Windows.UIElement.ManipulationDelta" /> 事件发生时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationDelta%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationDelta%2A> 以处理 <xref:System.Windows.UIElement.ManipulationDelta> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationDelta%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationInertiaStarting (e As ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationInertiaStarting(System::Windows::Input::ManipulationInertiaStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit&#xA;override this.OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationInertiaStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">事件的数据。</param>
        <summary>在 <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> 事件发生时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> 以处理 <xref:System.Windows.UIElement.ManipulationInertiaStarting> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarted(class System.Windows.Input.ManipulationStartedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarted (e As ManipulationStartedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarted(System::Windows::Input::ManipulationStartedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit&#xA;override this.OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartedEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">事件的数据。</param>
        <summary>在 <see cref="E:System.Windows.UIElement.ManipulationStarted" /> 事件发生时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarted%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationStarted%2A> 以处理 <xref:System.Windows.UIElement.ManipulationStarted> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationStarted%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarting (e As ManipulationStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarting(System::Windows::Input::ManipulationStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit&#xA;override this.OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.ManipulationStartingEventArgs" />。</param>
        <summary>为在首次创建操作处理器时发生的 <see cref="E:System.Windows.UIElement.ManipulationStarting" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarting%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnManipulationStarting%2A> 以处理 <xref:System.Windows.UIElement.ManipulationStarting> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnManipulationStarting%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 此事件数据报告有关按下鼠标按钮和已处理状态的详细信息。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标按钮操作也由专用的输入管理器进行处理。 依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。 如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 事件标记为 "已处理"，则不会调用 <xref:System.Windows.UIElement.OnMouseDown%2A>。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.UIElement.MouseLeftButtonDown> 和 <xref:System.Windows.UIElement.MouseRightButtonDown>。 接收到 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 时，可能会在接收元素上引发这些事件中的任何一个。  
  
 如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。 如果事件是在类处理中处理的，则不会调用 subevents 的实例处理程序，除非你显式将 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 与 `handledEventsToo` `true` 结合使用才能附加处理程序。 类处理程序也不会被调用，除非这些类处理程序已注册到具有 `handledEventsToo` `true`的 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名。 通过处理 <xref:System.Windows.UIElement.OnMouseDown%2A>，你的类处理会考虑到所有可能的鼠标按钮按下操作。 此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。  
  
 每个特定于按钮的直接事件还具有一个虚拟 On * 方法;考虑是否可以更适当地重写这些按钮特定的类处理程序。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件，其中包含直接路由策略。 将事件标记为已处理仍然有助于防止调用典型的实例处理程序（未指定 `handledEventsToo`）。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件，其中包含直接路由策略。 将事件标记为已处理仍然有助于防止调用典型的实例处理程序（未指定 `handledEventsToo`）。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标左键。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> 路由事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonDown> 事件显示为以冒泡路线旅行，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是冒泡路由的基础事件，事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.MouseLeftButtonDown>。 虽然您可以将 <xref:System.Windows.UIElement.MouseLeftButtonDown> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。 是否选择调用基实现取决于方案。 如果无法调用 base，则会禁用上级类上对该鼠标事件的默认输入处理，这也会要求调用 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>。 例如，你可以在派生类中派生 <xref:System.Windows.Controls.Button> 和重写 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>，而无需调用基实现;但是，此替代禁用 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已松开鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonUp> 事件显示为以冒泡路线旅行，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是冒泡路由的基础事件，事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.MouseLeftButtonUp>。 虽然您可以将 <xref:System.Windows.UIElement.MouseLeftButtonUp> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonDown> 事件显示为以冒泡路线旅行，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是冒泡路由的基础事件，事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.MouseRightButtonDown>。 虽然您可以将 <xref:System.Windows.UIElement.MouseRightButtonDown> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。 是否选择调用基实现取决于方案。 如果无法调用 base，则会禁用上级类上对该鼠标事件的默认输入处理，这也会要求调用 <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>。 例如，你可以在派生类中派生 <xref:System.Windows.Controls.Control> 和重写 <xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>，而无需调用 base;但是，此替代禁用控件上的上下文菜单服务，这是 <xref:System.Windows.Controls.Control> 默认行为的组成部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已释放鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonUp> 事件显示为以冒泡路线旅行，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是冒泡路由的基础事件，事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.MouseRightButtonUp>。 虽然您可以将 <xref:System.Windows.UIElement.MouseRightButtonUp> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据将报告已松开了鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标按钮操作也由专用的输入管理器进行处理。 依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。 如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 事件标记为 "已处理"，则不会调用 <xref:System.Windows.UIElement.OnMouseUp%2A>。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.UIElement.MouseLeftButtonUp> 和 <xref:System.Windows.UIElement.MouseRightButtonUp>。 接收到 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 时，可能会在接收元素上引发这些事件中的任何一个。  
  
 如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。 如果事件是在类处理中处理的，则不会调用 subevents 的实例处理程序，除非你显式将 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 与 `handledEventsToo` `true` 结合使用才能附加处理程序。 类处理程序也不会被调用，除非这些类处理程序已注册到具有 `handledEventsToo` `true`的 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名。 通过处理 <xref:System.Windows.UIElement.OnMouseUp%2A>，你的类处理会考虑到所有可能的鼠标按钮向上操作。 此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。  
  
 每个特定于按钮的直接事件还具有一个虚拟 On * 方法;考虑是否可以更适当地重写这些按钮特定的类处理程序。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下一个或多个鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标按钮操作也由专用的输入管理器进行处理。 依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。 如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件标记为 "已处理"，则不会调用 <xref:System.Windows.UIElement.OnPreviewMouseDown%2A>。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>。 接收到 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 时，可能会在接收元素上引发这些事件中的任何一个。  
  
 如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。 如果事件是在类处理中处理的，则不会调用 subevents 的实例处理程序，除非你显式将 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 与 `handledEventsToo` `true` 结合使用才能附加处理程序。 类处理程序也不会被调用，除非这些类处理程序已注册到具有 `handledEventsToo` `true`的 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名。 通过处理 <xref:System.Windows.UIElement.OnPreviewMouseDown%2A>，你的类处理会考虑到所有可能的鼠标按钮按下操作。 此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。  
  
 每个特定于按钮的直接事件还具有一个虚拟 On * 方法;考虑是否可以更适当地重写这些按钮特定的类处理程序。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>" 事件显示为传送隧道路由，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是作为隧道路由的基础事件，并且事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>。 虽然您可以将 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。 是否选择调用基实现取决于方案。 如果无法调用 base，则会禁用上级类上对该鼠标事件的默认输入处理，这也会要求调用 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>。 例如，你可以在派生类中派生 <xref:System.Windows.Controls.Button> 和重写 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>，而无需调用基实现;但是，此替代禁用 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已松开鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>" 事件显示为传送隧道路由，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是作为隧道路由的基础事件，并且事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>。 虽然您可以将 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>" 事件显示为传送隧道路由，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是作为隧道路由的基础事件，并且事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.MouseRightButtonDown>。 虽然您可以将 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 或者，您可以重写此方法，以便为特定的鼠标状态更改事件处理。 是否选择调用基实现取决于方案。 如果无法调用 base，则会禁用上级类上对该鼠标事件的默认输入处理，这也会要求调用 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>。 例如，你可以在派生类中派生 <xref:System.Windows.Controls.Control> 和重写 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>，而无需调用 base;但是，此替代禁用控件上的上下文菜单服务，这是 <xref:System.Windows.Controls.Control> 默认行为的组成部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已释放鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>" 事件显示为传送隧道路由，但实际以间接方式传播。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是作为隧道路由的基础事件，并且事件路由中的每个 <xref:System.Windows.UIElement> 使用相同的处理来引发直接路由事件 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 虽然您可以将 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> 事件标记为为此元素的目的进行处理，但已处理状态并不会与事件路由中的其他元素保持。 但是，你可能需要将事件标记为已处理，以防止调用常规实例处理程序（未指定 `handledEventsToo`）。  
  
 <xref:System.Windows.UIElement> 中的常规鼠标事件处理的默认实现侦听 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 并将其转换为适当的本地事件。 如果要重写此逻辑，必须创建派生类。 在派生类的静态构造函数中，为 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>注册替代类处理程序。 不能通过重写 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>更改 <xref:System.Windows.UIElement> 的鼠标处理行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据将报告已释放了一个或多个鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标按钮操作也由专用的输入管理器进行处理。 依赖于鼠标按钮操作的其他编程功能（如输入和命令绑定）可能会调用操作的处理程序，然后才能将其作为常规鼠标按钮操作公开。 如果这些输入系统功能将 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件标记为 "已处理"，则不会调用 <xref:System.Windows.UIElement.OnPreviewMouseUp%2A>。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件： <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>。 接收到 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 时，可能会在接收元素上引发这些事件中的任何一个。  
  
 如果将此事件标记为 "在类处理中处理"，则仍会引发 subevents;但是，它们将在事件数据中传递已处理状态。 如果事件是在类处理中处理的，则不会调用 subevents 的实例处理程序，除非你显式将 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 与 `handledEventsToo` `true` 结合使用才能附加处理程序。 类处理程序也不会被调用，除非这些类处理程序已注册到具有 `handledEventsToo` `true`的 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名。 通过处理 <xref:System.Windows.UIElement.OnPreviewMouseUp%2A>，你的类处理会考虑到所有可能的鼠标按钮向上操作。 此行为可能不是必需的;因此，使用此虚方法将事件标记为已处理时，请谨慎使用。  
  
 每个特定于按钮的直接事件还具有一个虚拟 On * 方法;考虑是否可以更适当地重写这些按钮特定的类处理程序。  
  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。 专门用于预览事件的另一种方案是将其标记为已处理，以便不会调用匹配的冒泡类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入按下此元素时发生的 <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> 以处理 <xref:System.Windows.UIElement.PreviewTouchDown> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> 以处理 <xref:System.Windows.UIElement.PreviewTouchMove> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> 以处理 <xref:System.Windows.UIElement.PreviewTouchUp> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="uIElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRender(class System.Windows.Media.DrawingContext drawingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRender (drawingContext As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRender(System::Windows::Media::DrawingContext ^ drawingContext);" />
      <MemberSignature Language="F#" Value="abstract member OnRender : System.Windows.Media.DrawingContext -&gt; unit&#xA;override this.OnRender : System.Windows.Media.DrawingContext -&gt; unit" Usage="uIElement.OnRender drawingContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="drawingContext">特定元素的绘制指令。 此上下文是为布局系统提供的。</param>
        <summary>在派生类中重写时，会参与由布局系统控制的呈现操作。 调用此方法时，不直接使用此元素的呈现指令，而是将其保留供布局和绘制在以后异步使用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在 <xref:System.Windows.UIElement> 类中没有默认实现。  
  
   
  
## Examples  
 下面的代码示例演示面板派生类的可能实现。  
  
 [!code-csharp[LightWeightCustomPanel#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LightWeightCustomPanel/CSharp/OffsetPanel.cs#1)]
 [!code-vb[LightWeightCustomPanel#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LightWeightCustomPanel/visualbasic/offsetpanel.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>可以重写 <see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /> 方法，以将更多图形元素（之前未在逻辑树中定义）添加到呈现的元素（如效果或装饰器）。 将 <see cref="T:System.Windows.Media.DrawingContext" /> 对象作为参数传递，该参数提供用于绘制形状、文本、图像或视频的方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRenderSizeChanged (info As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ info);" />
      <MemberSignature Language="F#" Value="abstract member OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit&#xA;override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="uIElement.OnRenderSizeChanged info" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="info">打包的参数 (<see cref="T:System.Windows.SizeChangedInfo" />)，其中包括新旧大小，其尺寸实际上发生了改变。</param>
        <summary>在派生类中重写时，会参与由布局系统控制的呈现操作。 如果元素的 <see cref="P:System.Windows.UIElement.RenderSize" /> 已因布局更新而更改，则在布局更新之后以及呈现之前调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 典型的 WPF 框架级别元素使用 <xref:System.Windows.FrameworkElement>中的重写实现。 <xref:System.Windows.FrameworkElement> 实现将使 <xref:System.Windows.FrameworkElement.Width%2A> 和 <xref:System.Windows.FrameworkElement.Height%2A> 属性，并处理重塑布局的基本知识。 在 <xref:System.Windows.UIElement> 级别重写 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> 意味着元素实现有意不要使用 WPF 框架级别的实现，因此，你的元素必须更直接处理布局逻辑，通常通过编写替换布局系统进行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 此方法的目的类似于 * 方法 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 将事件标记为已处理仍然有助于防止调用典型的实例处理程序（未指定 `handledEventsToo`）。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。 您可以根据自己的要求，在特殊处理之前或之后调用 base。  
  
 此方法的目的类似于 * 方法 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 将事件标记为已处理仍然有助于防止调用典型的实例处理程序（未指定 `handledEventsToo`）。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件到达派生自此类的其路由中的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 因为继承中的中间类可能实现此方法，所以建议您在实现中调用基实现。  
  
 此方法的目的类似于 * 方法上的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：此方法提供了通过建立类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可以由子元素引发，这不一定是将调用处理程序的元素。 因此，您的实现需要检查事件数据的源属性。 大多数情况下，它不应尝试 reraise 该事件。  
  
 通过重写此方法或使用 <xref:System.Windows.EventManager.RegisterClassHandler%2A>注册类处理程序，<xref:System.Windows.UIElement> 的派生类可以在事件路由收到事件时调用私有类处理程序方法。 适用于类处理的一种情况是操作事件数据，并将路由事件标记为 "已处理"。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内按下触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.TouchDown" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchDown%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnTouchDown%2A> 以处理 <xref:System.Windows.UIElement.TouchDown> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnTouchDown%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入从此元素边界外部移动到其内部时发生的 <see cref="E:System.Windows.UIElement.TouchEnter" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchEnter%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnTouchEnter%2A> 以处理 <xref:System.Windows.UIElement.TouchEnter> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnTouchEnter%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入从此 <see cref="E:System.Windows.UIElement.TouchLeave" /> 边界内部移动到其外部时发生的 <see cref="T:System.Windows.UIElement" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchLeave%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnTouchLeave%2A> 以处理 <xref:System.Windows.UIElement.TouchLeave> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnTouchLeave%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.TouchMove" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchMove%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnTouchMove%2A> 以处理 <xref:System.Windows.UIElement.TouchMove> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnTouchMove%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.UIElement.TouchUp" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchUp%2A> 方法没有默认实现。 重写派生类中的 <xref:System.Windows.UIElement.OnTouchUp%2A> 以处理 <xref:System.Windows.UIElement.TouchUp> 事件。 请确保调用基类的 <xref:System.Windows.UIElement.OnTouchUp%2A> 方法，以便基类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="uIElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父项。 如果 <see cref="T:System.Windows.DependencyObject" /> 先前不具有父元素，则此项可以提供为 <see langword="null" />。</param>
        <summary>在此 <see cref="T:System.Windows.UIElement" /> 的父元素报告其基础可视父元素发生更改时，调用此方法。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>如果重写此方法，请始终调用基实现。 默认基实现对反向继承属性状态执行一些内部维护。 未能调用基实现将使此状态失效。  
  
此方法重写 <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />。 <see cref="T:System.Windows.FrameworkElement" /> 和 <see cref="T:System.Windows.Window" /> 也会重写 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />的 <see cref="T:System.Windows.UIElement" /> 实现，并 <see cref="T:System.Windows.Window" /> 密封它。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.UIElement.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当 <see cref="T:System.Windows.UIElement" /> 在 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中呈现时为其整体应用的不透明度因子。  这是依赖项属性。</summary>
        <value>不透明度因子。 默认不透明度为 1.0。 值应介于 0.0 和 1.0 之间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1.0 默认值是 <xref:System.Windows.UIElement> 类上此依赖项属性的初始元数据提供的默认值。 其他派生类可能会通过在其类构造函数中重写元数据来更改此默认值。  
  
 <xref:System.Windows.UIElement.Opacity%2A> 的值将不会应用于实际布局，除非该元素也可见（<xref:System.Windows.UIElement.IsVisible%2A> `true`）。  
  
 <xref:System.Windows.UIElement.Opacity%2A> 将从元素树的下方父元素应用于子元素，但嵌套的 opacity 设置的可见效果不会在各个子元素的属性值中指定。 例如，如果列表的不透明度为50% （0.5），其中一个列表项的不透明度设置为20% （0.2），则该列表项的净可见不透明度将呈现为10% （0.1），但在查询时，列表项 <xref:System.Windows.UIElement.Opacity%2A> 属性的属性值仍然为0.2。  
  
 即使声明或计算的不透明度为0，元素仍参与输入事件和命令，而且可能可获得焦点。 这种情况可能很有用，例如，可以将不透明度零的对象（如形状）用于使用透明元素的掩码基础对象。 然后，不透明度零对象可以处理基础区域的所有输入事件处理。 但是，对象或形状的 `Background` 或 `Fill` 应设置为一个值，即使它是 <xref:System.Windows.Media.Brushes.Transparent%2A>，也不会启用命中测试，也不会接收任何事件。  
  
<a name="dependencyPropertyInfo_Opacity"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.OpacityProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.OpacityMask" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.UIElement.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个作为 <see cref="T:System.Windows.Media.Brush" /> 实现的不透明蒙板，该蒙板可应用到此元素所呈现内容的任何 Alpha 通道蒙板。  这是依赖项属性。</summary>
        <value>要用于不透明蒙板的画笔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于提供的 <xref:System.Windows.Media.Brush>，此属性只使用 alpha 通道值。 将忽略 <xref:System.Windows.Media.Brush>呈现内容的其他通道（红色、绿色或蓝色）。  
  
 用于此目的的最典型 <xref:System.Windows.Media.Brush> 是 <xref:System.Windows.Media.ImageBrush>，可用于各种照片屏蔽技术，如 vignette。 但可以使用任何定义的 <xref:System.Windows.Media.Brush> （如 <xref:System.Windows.Media.LinearGradientBrush>）。  
  
 在 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]中，此属性值可以使用特定于 <xref:System.Windows.Media.Brush> 抽象类的每个实现的内联语法。 有关详细信息，请参阅[采用纯色和渐变进行绘制概述](/dotnet/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview)。  
  
<a name="dependencyPropertyInfo_OpacityMask"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.OpacityMaskProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 以下标记示例演示了一个应用于其他 <xref:System.Windows.Controls.Image><xref:System.Windows.Media.ImageBrush> 不透明蒙板。  
  
 [!code-xaml[OpacityMasksSnippet#UIElementOpacityMask](~/samples/snippets/csharp/VS_Snippets_Wpf/OpacityMasksSnippet/CS/ImageBrushExample.xaml#uielementopacitymask)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMaskProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityMaskProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityMaskProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityMaskProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityMaskProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityMaskProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityMaskProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityMaskProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.OpacityMask" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Opacity" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistId">
      <MemberSignature Language="C#" Value="public int PersistId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PersistId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.PersistId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PersistId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PersistId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PersistId : int" Usage="System.Windows.UIElement.PersistId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个唯一标识此元素的值。</summary>
        <value>此元素的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PersistId%2A> 唯一标识每个元素。 每次加载同一 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] （包括二进制表示形式）时，元素都保持相同的 <xref:System.Windows.UIElement.PersistId%2A>。 此标识符用于内部加载、分析和序列化要求。 不应由应用程序代码使用。  
  
 此属性与任何给定实例的 <xref:System.Object.GetHashCode%2A> 结果无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="uIElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">请求的焦点遍历的方向。</param>
        <summary>当在派生类中重写时，返回将按指定焦点遍历方向接收焦点的元素，而不用实际将焦点移至该元素。</summary>
        <returns>如果实际调用了 <see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，则为接收焦点的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在此类中的默认实现不完整，并且始终返回 `null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewDragEnter> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewDragEnter> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.DragEnter>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewDragEnter%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewDragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewDragLeave> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewDragLeave> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.DragLeave>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewDragLeave%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewDragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewDragOver> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewDragOver> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewDragOverEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.DragOver>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewDragOver%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewDragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewDrop> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewDrop> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewDropEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.Drop>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewDrop%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewDrop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在开始拖放操作时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Windows.UIElement.PreviewGiveFeedback> 事件，拖动事件源可以修改鼠标指针的外观，以便在拖放操作过程中为用户提供视觉反馈。  
  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewGiveFeedback> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewGiveFeedback> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.GiveFeedback>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用隧道路由，因此具有焦点的元素可以是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定具有焦点的实际元素。  
  
 此事件创建此类的 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewGotKeyboardFocus> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.GotKeyboardFocus>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当焦点在该元素上时按下某个键后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键处理与其他平台功能（如命令和文本撰写）交互。 <xref:System.Windows.UIElement.KeyDown> 事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。 这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。  
  
 此事件创建此类的 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewKeyDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewKeyDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.KeyDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewKeyDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewKeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当焦点在该元素上时松开某个键后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键处理与其他平台功能（如命令和文本撰写）交互。 <xref:System.Windows.UIElement.KeyUp> 事件是较低级别的文本输入事件，可能不会在某些控件上按预期方式工作。 这是因为某些控件具有控件组合或类处理，可提供较高级别的文本输入处理和相关事件。 有关详细信息，请查看各个控件的文档。  
  
 此事件创建此类的 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewKeyUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewKeyUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.KeyUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewKeyUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewKeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素不再聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用隧道路由，失去焦点的元素可能是子元素，而不是实际附加事件处理程序的元素。 检查事件数据中的 <xref:System.Windows.RoutedEventArgs.Source%2A>，以确定失去焦点的实际元素。  
  
 此事件创建此类的 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewLostKeyboardFocus> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewLostKeyboardFocus> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.LostKeyboardFocus>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewMouseDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewMouseDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement.PreviewMouseDown> 事件通常与 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 或 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>一起引发，这对应于按下这两个标准鼠标按钮之一。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。 有关 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 或 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>，请参阅 "备注"。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.MouseDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 处理。 这可能包括类处理程序生成的事件，例如 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 处理。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且移动鼠标指针时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当鼠标指针第一次进入元素边界时，以及当鼠标指针移动到元素边界内时，将发生此事件。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewMouseMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewMouseMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.MouseMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 处理。 这可能包括类处理程序生成的事件，例如 <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管此[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)看起来是通过元素树跟踪隧道路由，但实际上它是一个直接路由事件，每个 <xref:System.Windows.UIElement>都会沿着元素树引发并 reraised 该事件。  
  
 此事件是多个相关事件之一，用于报告基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件的鼠标按钮细节，该事件是由事件路由中的每个元素处理的附加事件。  
  
 此事件的事件数据公开基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件的事件数据。 如果该事件在事件路由中标记为 "已处理"，则仍会引发鼠标按钮特定的事件;但是，必须通过显式调用 <xref:System.Windows.UIElement.AddHandler%2A>来添加鼠标按钮特定事件的处理程序，并且可以选择处理已标记为已处理的事件，以便作为事件的侦听器。 如果将 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> 标记为 "已处理"，则实质上是将为沿着路由的所有其他侦听器和所有相关事件标记 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 处理。  
  
 从概念上讲，将此事件（以及 <xref:System.Windows.UIElement>上的其他鼠标按钮事件）视为鼠标 "服务" （使用 <xref:System.Windows.Input.Mouse> 类提供的服务定义）。 事件增加了不需要在事件数据中检查鼠标按钮状态（从左到右、向下）的原始鼠标事件的便利。 对于更高级的方案，如检查非标准按钮的状态，可能需要使用 <xref:System.Windows.Input.Mouse> 类上的 Api，而不是 <xref:System.Windows.UIElement>上的 Api。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewMouseUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewMouseUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement.PreviewMouseUp> 事件通常与 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 或 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>一起引发，这对应于按下这两个标准鼠标按钮之一。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 和 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> 也是路由事件，但它们是直接路由事件，当 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 事件沿事件路由到达此元素时，将引发相应的按钮特定的事件。 有关 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> 或 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>，请参阅 "备注"。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.MouseUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于鼠标指针所在的位置;因此，如果从焦点或捕获的元素接收此事件，则鼠标指针实际上可能位于另一个元素上。  
  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewMouseMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewMouseMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.MouseWheel>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewMouseWheel%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewMouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在拖放操作期间键盘或鼠标按钮的状态改变时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewQueryContinueDrag> 事件允许拖动源声明是否应取消拖放操作。  
  
 此事件创建此类的 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewQueryContinueDrag> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewQueryContinueDrag> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.QueryContinueDrag>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusButtonDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusButtonDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[Windows Vista 中的触摸输入支持](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)和[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusButtonDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且松开触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusButtonUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusButtonUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusButtonUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于元素上且触及数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔掠过元素但并未实际接触数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusInAirMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusInAirMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusInAirMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusInRange> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusInRange> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusInRange>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusInRange%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于元素上并且移动触笔时发生。 数字化器在检测触笔时，触笔必须处于移动状态才会引发此事件，否则将改为引发 <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔与数字化仪之间的距离太远以致无法检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusOutOfRange> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusOutOfRange> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusOutOfRange>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户采用某一种触笔笔势时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关触笔势的信息，请参阅 <xref:System.Windows.Input.SystemGesture>。  
  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusSystemGesture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusSystemGesture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusSystemGesture>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewStylusDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewStylusDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.StylusUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewStylusUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewStylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素以设备无关模式获取文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewTextInput> 事件允许组件或应用程序以与设备无关的方式侦听文本输入。 键盘是 <xref:System.Windows.UIElement.PreviewTextInput>的主要方法;但语音、手写和其他输入设备还可以生成 <xref:System.Windows.UIElement.PreviewTextInput>。  
  
 由于键组合（在默认键盘或通过输入法编辑器）中，多个键事件可能只引发一个文本输入事件。  
  
 此事件创建此类的 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.PreviewTextInput> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.PreviewTextInput> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewTextInputEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.TextInput>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewTextInput%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewTextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指触摸屏幕时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在手指触摸屏幕并移动之前，不会发生 <xref:System.Windows.UIElement.PreviewTouchDown> 和 <xref:System.Windows.UIElement.TouchDown> 事件。 在屏幕上按一根手指而不移动它会导致 <xref:System.Windows.Input.Stylus>的按压行为。 按住行为等效于鼠标右键单击。  
  
 若要使 <xref:System.Windows.UIElement.PreviewTouchDown> 和 <xref:System.Windows.UIElement.TouchDown> 事件在手指触摸屏幕时立即发生，请将 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 附加属性设置为此元素的 `false`。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.TouchDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指在屏幕上移动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.TouchMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指从屏幕上移开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的冒泡事件 <xref:System.Windows.UIElement.TouchUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在拖放操作期间键盘或鼠标按钮的状态改变时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.QueryContinueDrag> 事件允许拖动源确定是否应取消拖放操作。  
  
 此事件创建此类的 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.QueryContinueDrag> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.QueryContinueDrag> 事件的事件处理程序附加到基础 <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.QueryContinueDragEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewQueryContinueDrag>。  
  
-   重写 <xref:System.Windows.UIElement.OnQueryContinueDrag%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.QueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当请求显示光标时发生。 每次鼠标指针移至新位置时都会在一个元素上引发此事件，这意味着光标对象可能需要根据其新位置进行更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.QueryCursor> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.QueryCursor> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 此事件名称所引用的游标不一定是文本光标（有时也称为插入点）。 相反，此上下文中的光标是一个对象，该对象声明与 Windows 编程中几个可能的输入相关设备或概念相关的屏幕图形显示。 该对象由 WPF 中的 <xref:System.Windows.Input.Cursor> 类表示。 WPF 输入系统使你可以在其表示鼠标指针的屏幕位置时更改此光标。 可以从 <xref:System.Windows.Input.Cursors> 枚举使用预定义的值，也可以将自定义游标声明为映像文件。  
  
 侦听 <xref:System.Windows.UIElement.QueryCursor> 事件不是游标管理的有效方法。 相反，每个元素都应该定义自己的具有 <xref:System.Windows.FrameworkContentElement.Cursor%2A> 和 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>的游标行为。 仅当未使用 WPF 框架级别的基元素时，或在基于每个元素定义游标行为的特殊情况下，你应依赖于 <xref:System.Windows.UIElement.QueryCursor>，这不能满足你的需求。 有关实现游标行为以响应 <xref:System.Windows.UIElement.QueryCursor>的详细信息，请参阅 <xref:System.Windows.Input.QueryCursorEventHandler>。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.QueryCursorEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   未定义相应的隧道事件。  
  
-   重写 <xref:System.Windows.UIElement.OnQueryCursor%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.QueryCursor" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Windows.RoutedEventArgs" />，其中包含事件数据并标识要引发的事件。</param>
        <summary>引发特定路由事件。 在提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 实例内标识将引发的 <see cref="T:System.Windows.RoutedEvent" />（作为该事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` 参数类型化为所有路由事件数据的通用基类型;但是，应将事件数据指定为可用于引发事件的最特定事件数据类型，因为 <xref:System.Windows.RoutedEventArgs> 派生类包含用于引发特定事件的实际特定数据属性。  
  
 <xref:System.Windows.RoutedEventArgs> 不只是事件的状态属性;它还标识要引发的路由事件。 此事件引发模式和路由事件数据都不同于 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件和数据类，它们通常只包含与事件相关的属性。  
  
   
  
## Examples  
 下面的示例创建事件数据、将事件标识符追加到数据，然后使用事件数据实例引发自定义路由事件。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="uIElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从此元素中释放所有捕获的触摸设备。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="uIElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果此元素具有鼠标捕获，则释放该捕获。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素不包含捕获，则调用此方法将不起作用。 在调用此方法之前，请考虑检查 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 的值。  
  
   
  
## Examples  
 下面的示例与为 <xref:System.Windows.UIElement.CaptureMouse%2A>提供的示例并行：它处理鼠标按钮，释放鼠标捕获并重新启用移动鼠标。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="uIElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果此元素具有触笔设备捕获，则释放该捕获。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素不包含捕获，则调用此方法将不起作用。 在调用此方法之前，请考虑检查 <xref:System.Windows.UIElement.IsStylusCaptured%2A> 的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseTouchCapture (touchDevice As TouchDevice) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要释放的设备。</param>
        <summary>尝试从此元素释放指定触摸设备。</summary>
        <returns>如果释放了触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveHandler (routedEvent As RoutedEvent, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">附加了处理程序的路由事件的标识符。</param>
        <param name="handler">要从此元素的事件处理程序集合中删除的特定处理程序实现。</param>
        <summary>从此元素中删除指定的路由事件处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此 API 的最常见方案是实现与自定义路由事件相关联的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "包装" 事件，特别是在 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 级别实现处理程序的 "删除" 逻辑时。 此备注部分后面的示例演示了这种情况。  
  
 如果没有向与方法调用的输入参数匹配的条件注册处理程序，则调用此方法将不起作用。  
  
 如果附加了多个与条件相匹配的处理程序，则只会删除事件处理程序存储中的第一个处理程序。 此行为与 `-=` 运算符 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 行为一致。  
  
 `routedEvent` 和 `handler` 均无法 `null`。 尝试将任一值作为 `null` 提供会引发异常。  
  
 此方法将忽略 `handledEventsToo` 参数信息，如果处理程序是第一次用允许处理已处理事件的 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名添加的，则提供此方法。 已删除任一类型的处理程序。  
  
   
  
## Examples  
 下面的示例使用 <xref:System.Windows.UIElement.RemoveHandler%2A> 作为事件包装器定义的一部分。  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="RenderSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size RenderSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size RenderSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderSize" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size RenderSize { System::Windows::Size get(); void set(System::Windows::Size value); };" />
      <MemberSignature Language="F#" Value="member this.RenderSize : System.Windows.Size with get, set" Usage="System.Windows.UIElement.RenderSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取（或设置）此元素的最终呈现大小。</summary>
        <value>此元素的呈现大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果使用的是 WPF 框架级别布局系统，请不要尝试在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 中或在代码中设置此属性。 几乎所有典型的应用程序方案都将使用此布局系统。 布局系统将不会直接遵循 <xref:System.Windows.UIElement.RenderSize%2A> 属性中设置的大小。 仅将 <xref:System.Windows.UIElement.RenderSize%2A> 属性声明为可写，以启用特意避开典型布局协议的某些 WPF 核心级桥接方案，如对 <xref:System.Windows.Documents.Adorner> 类的支持。  
  
 此属性可用于在布局系统替代（如 <xref:System.Windows.UIElement.OnRender%2A> 或 <xref:System.Windows.UIElement.GetLayoutClip%2A>）内检查适用的呈现大小。  
  
 更常见的情况是处理具有类处理程序重写或 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A> 事件的 <xref:System.Windows.FrameworkElement.SizeChanged> 事件。  
  
## Examples  
 下面的示例演示自定义装饰器如何使用 <xref:System.Windows.UIElement.RenderSize%2A> 值，以便在其 <xref:System.Windows.UIElement.OnRender%2A> 实现中创建定义装饰器的矩形图形并调整其大小。  
  
 [!code-csharp[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/csharp/VS_Snippets_Wpf/AdornersMiscCode/CSharp/Window1.xaml.cs#uielementdesiredsize)]
 [!code-vb[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AdornersMiscCode/visualbasic/window1.xaml.vb#uielementdesiredsize)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform RenderTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform RenderTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ RenderTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.UIElement.RenderTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置影响此元素的呈现位置的转换信息。  这是依赖项属性。</summary>
        <value>描述所需呈现转换的细节。 默认值为 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呈现转换不会重新生成布局大小或呈现大小信息。 呈现转换通常用于对元素进行动画处理或应用临时效果。 例如，元素可能会在聚焦或鼠标指针置于时进行缩放，或可能在负载上抖动，以吸引 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]的那部分。  
  
<a name="dependencyPropertyInfo_RenderTransform"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.RenderTransformProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOrigin">
      <MemberSignature Language="C#" Value="public System.Windows.Point RenderTransformOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point RenderTransformOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransformOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransformOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point RenderTransformOrigin { System::Windows::Point get(); void set(System::Windows::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransformOrigin : System.Windows.Point with get, set" Usage="System.Windows.UIElement.RenderTransformOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置由 <see cref="P:System.Windows.UIElement.RenderTransform" /> 声明的任何可能呈现转换的中心点，相对于元素的边界。  这是依赖项属性。</summary>
        <value>声明呈现转换的值。 默认值是一个坐标为 (0,0) 的 <see cref="T:System.Windows.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> 对 <xref:System.Windows.Point> 结构值的使用有点非标准，因为 <xref:System.Windows.Point> 不表示坐标系统中的绝对位置。 相反，介于0和1之间的值被解释为每个 x，y 轴中当前元素的范围的因子。 例如，（0.5，0.5）将导致在元素上居中呈现转换，或者（1，1）将呈现转换放置在元素的右下角。 <xref:System.Double.NaN> 不是接受的值。  
  
 还将接受0和1之外的值，并将导致更非常规的转换效果。 例如，如果将 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> 设置为（5，5），然后应用 <xref:System.Windows.Media.RotateTransform>，则旋转点将在元素本身的边界之外。 该转换将使元素围绕在右下方的大圆中旋转。 原点可能位于其父元素内的某个位置，可能可能会超出框架或视图。 负点值类似，它们将超出左上边界。  
  
 呈现转换不影响布局，通常用于对元素进行动画或应用临时效果。  
  
<a name="xamlAttributeUsage_RenderTransformOrigin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object RenderTransformOrigin="xOrigin, yOrigin"/>  
```  
  
<a name="xamlPropertyElementUsage_RenderTransformOrigin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.RenderTransformOrigin>  
    <Point X=" xOrigin " Y=" yOrigin "/>  
  </object.RenderTransformOrigin>  
</object>  
```  
  
<a name="xamlValues_RenderTransformOrigin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *xOrigin*  
 水平原点系数。 通常将此值指定为0和1之间的值。 请参阅“备注”。  
  
 *yOrigin*  
 垂直原点系数。 通常将此值指定为0和1之间的值。 请参阅“备注”。  
  
<a name="dependencyPropertyInfo_RenderTransformOrigin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例在代码中生成元素，应用 <xref:System.Windows.UIElement.RenderTransformOrigin%2A>，然后应用 <xref:System.Windows.UIElement.RenderTransform%2A>。  
  
 [!code-csharp[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/csharp/VS_Snippets_Wpf/transformanimations_snip/CSharp/RotateAboutCenterExample.cs#uielementrendertransformorigin)]
 [!code-vb[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/visualbasic/VS_Snippets_Wpf/transformanimations_snip/visualbasic/rotateaboutcenterexample.vb#uielementrendertransformorigin)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.RenderTransform" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOriginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformOriginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformOriginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformOriginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformOriginProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.RenderTransformOrigin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.RenderTransform" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.UIElement.CommandBindings" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.UIElement.CommandBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果本地设置 <xref:System.Windows.UIElement.CommandBindings%2A>，这将返回 `true`。  
  
 提供此 `ShouldSerialize` 方法的原因是 <xref:System.Windows.UIElement.CommandBindings%2A> 属性没有简单的默认值。 此方法指示属性是否已更改为其默认值。 如果要开发设计器或开发自己的包含 <xref:System.Windows.UIElement>的控件，通常会调用此方法。  
  
 有关详细信息，请参阅[用 ShouldSerialize 和 Reset 方法定义默认值](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.UIElement.InputBindings" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.UIElement.InputBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果本地设置 <xref:System.Windows.UIElement.InputBindings%2A>，这将返回 `true`。  
  
 提供此 `ShouldSerialize` 方法的原因是 <xref:System.Windows.UIElement.InputBindings%2A> 属性没有简单的默认值。 此方法指示属性是否已更改为其默认值。 如果要开发设计器或开发自己的包含 <xref:System.Windows.UIElement>的控件，通常会调用此方法。  
  
 有关详细信息，请参阅[用 ShouldSerialize 和 Reset 方法定义默认值](/dotnet/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberSignature Language="VB.NET" Value="Public Property SnapsToDevicePixels As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SnapsToDevicePixels { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SnapsToDevicePixels : bool with get, set" Usage="System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定在呈现过程中，此元素的呈现是否应使用特定于设备的像素设置。  这是依赖项属性。</summary>
        <value>如果元素应按照设备像素呈现，则为<see langword="true" /> ；否则为 <see langword="false" />。 在 <see cref="T:System.Windows.UIElement" /> 上声明的默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可将此属性设置为在根元素上 `true`，以在 UI 中启用像素对齐呈现。 对于在 96 [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]以上运行的设备，像素对齐呈现可以最大程度地减少单单元实线附近的抗锯齿视觉对象。  
  
 当由 <xref:System.Windows.FrameworkElement> 或任何可能的派生类继承时，<xref:System.Windows.FrameworkElement> 将重写此依赖项属性的元数据，以将 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 元数据属性设置为 `true`。 这样做的结果是，子树中的最外面的元素只需指定 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> 作为 `true`，该子树的所有子元素将报告 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> 为 `true`，并将具有 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> 视觉效果。  
  
<a name="dependencyPropertyInfo_SnapsToDevicePixels"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/aa970908(v=vs.90)">WPF 应用程序中的像素对齐</related>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SnapsToDevicePixelsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SnapsToDevicePixelsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusButtonDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusButtonDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusButtonDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusButtonDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusButtonDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且松开触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusButtonUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusButtonUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusButtonUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusButtonUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusButtonUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上且同时触及数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusDown> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusDown> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔进入此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusEnter> 是使用直接事件处理路由策略的[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)。 直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。 但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。  
  
 尽管 <xref:System.Windows.UIElement.StylusEnter> 在触笔进入元素边界时进行跟踪，但此事件更确切地报告 <xref:System.Windows.UIElement.IsStylusOver%2A> 属性值已从 `false` 更改为此元素上的 `true`。  
  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusEnter> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusEnter> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnStylusEnter%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔掠过元素但并未实际接触数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusInAirMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusInAirMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusInAirMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusInAirMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusInRange> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusInRange> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusInRangeEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusInRange>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusInRange%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔离开元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusLeave> 是使用直接事件处理路由策略的[路由事件](/dotnet/framework/wpf/advanced/routed-events-overview)。 直接路由事件不沿路由引发;相反，它们是在引发它们的同一元素中进行处理的。 但是，它们会启用路由事件行为的其他方面，如样式中的事件触发器。  
  
 尽管 <xref:System.Windows.UIElement.StylusLeave> 在触笔离开元素边界时进行跟踪，但此事件更准确地报告 <xref:System.Windows.UIElement.IsStylusOver%2A> 属性值已从 `true` 更改为此元素上的 `false`。  
  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusLeave> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusLeave> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   重写 <xref:System.Windows.UIElement.OnStylusLeave%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔移到此元素上时发生。 触笔必须在位于数字化器上时移动，才会引发此事件。 否则将改为引发 <see cref="E:System.Windows.UIElement.StylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusMove> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusMove> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusMoveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离太远以致无法检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusOutOfRange> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusOutOfRange> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusOutOfRange>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusOutOfRange%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPlugIns">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.StylusPlugIns" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property StylusPlugIns As StylusPlugInCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ StylusPlugIns { System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StylusPlugIns : System.Windows.Input.StylusPlugIns.StylusPlugInCollection" Usage="System.Windows.UIElement.StylusPlugIns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.StylusPlugInCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此元素关联的所有触笔插件（自定义）对象的集合。</summary>
        <value>触笔插件的集合，作为专用集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas>填充此集合的控件的一个示例。 <xref:System.Windows.Controls.InkCanvas> 将 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 添加为收集项，这使 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 能够与触笔输入进行交互，并在响应触笔驱动事件时生成唯一渲染。  
  
 有关创建可接收和解释触笔输入的自定义插件的信息，请参阅[截获触笔输入](/dotnet/framework/wpf/advanced/intercepting-input-from-the-stylus)。  
  
   
  
## Examples  
 下面的示例创建一个 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 实例，并将其添加到自定义墨迹处理控件的 <xref:System.Windows.UIElement.StylusPlugIns%2A> 集合。  
  
 [!code-csharp[StylusPluginSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StylusPluginSamples/CSharp/StylusControl.cs#3)]
 [!code-vb[StylusPluginSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StylusPluginSamples/VisualBasic/StylusControl.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPlugIns.DynamicRenderer" />
        <altmember cref="T:System.Windows.Controls.InkCanvas" />
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户采用某一种触笔笔势时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关触笔手势的详细信息，请参阅 <xref:System.Windows.Input.SystemGesture>。  
  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusSystemGesture> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusSystemGesture> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusSystemGesture>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusSystemGesture%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建此类的 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.StylusUp> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.StylusUp> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
 触摸、鼠标和触笔输入在特定关系中存在。 有关详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.StylusUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewStylusUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnStylusUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.StylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素以设备无关模式获取文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此事件可能已标记为由复合控件的内部实现进行处理。 请参阅下面的注释。  
  
 <xref:System.Windows.UIElement.TextInput> 事件可能已标记为由复合控件的内部实现进行处理。 例如，<xref:System.Windows.Controls.TextBox> 是一个复合控件，其中 <xref:System.Windows.UIElement.TextInput> 事件已标记为已处理;的组合。 控件这样做的原因是，控件需要解释某些类型的输入（如箭头键），以便对该控件具有特殊意义。 如果使用 <xref:System.Windows.UIElement.PreviewTextInput> 作为文本输入的处理程序的事件，可能会获得更好的结果。 此方法可避免控件组合已将此事件标记为已处理并防止处理程序通过事件路由接收事件的大多数情况。  
  
 <xref:System.Windows.UIElement.TextInput> 事件允许组件或应用程序以与设备无关的方式侦听文本输入。 键盘是 <xref:System.Windows.UIElement.TextInput>的主要方式，但语音、手写和其他输入设备也会引发 <xref:System.Windows.UIElement.TextInput>。  
  
 由于键组合（在默认键盘或通过输入法编辑器）中，多个键事件可能只引发一个文本输入事件。  
  
 此事件创建此类的 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> 附加事件的别名，以便在将 <xref:System.Windows.UIElement> 作为基元素继承时，<xref:System.Windows.UIElement.TextInput> 是类成员列表的一部分。 附加到 <xref:System.Windows.UIElement.TextInput> 事件的事件处理程序附加到基础 <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> 附加事件，并接收相同的事件数据实例。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TextInputEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewTextInput>。  
  
-   重写 <xref:System.Windows.UIElement.OnTextInput%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指触摸屏幕时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在手指触摸屏幕并移动之前，不会发生 <xref:System.Windows.UIElement.PreviewTouchDown> 和 <xref:System.Windows.UIElement.TouchDown> 事件。 在屏幕上按一根手指而不移动它会导致 <xref:System.Windows.Input.Stylus>的按压行为。 按住行为等效于鼠标右键单击。  
  
 若要使 <xref:System.Windows.UIElement.PreviewTouchDown> 和 <xref:System.Windows.UIElement.TouchDown> 事件在手指触摸屏幕时立即发生，请将 <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> 附加属性设置为此元素的 `false`。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TouchDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewTouchDown>。  
  
-   重写 <xref:System.Windows.UIElement.OnTouchDown%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触摸屏输入从此元素边界外部移动到其内部时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件始终引发，无论触摸设备是否捕获到此元素。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TouchEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写 <xref:System.Windows.UIElement.OnTouchEnter%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TouchEnter" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素上捕获的所有触摸设备。</summary>
        <value>在此元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素或其可视化树中的任何子元素上捕获的所有触摸设备。</summary>
        <value>在此元素或其可视化树中的任何子元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素上的所有触摸设备。</summary>
        <value>位于此元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素或其可视化树中的任何子元素上的所有触摸设备。</summary>
        <value>在此元素或其可视化树中的任何子元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触摸屏输入从此元素边界内部移动到其外部时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件始终引发，无论触摸设备是否捕获到此元素。  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TouchLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写 <xref:System.Windows.UIElement.OnTouchLeave%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TouchLeave" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指在屏幕上移动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TouchMoveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewTouchMove>。  
  
-   重写 <xref:System.Windows.UIElement.OnTouchMove%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指从屏幕上移开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.TouchUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   对应的隧道事件 <xref:System.Windows.UIElement.PreviewTouchUp>。  
  
-   重写 <xref:System.Windows.UIElement.OnTouchUp%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement.TouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatePoint">
      <MemberSignature Language="C#" Value="public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point TranslatePoint(valuetype System.Windows.Point point, class System.Windows.UIElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function TranslatePoint (point As Point, relativeTo As UIElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point TranslatePoint(System::Windows::Point point, System::Windows::UIElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="member this.TranslatePoint : System.Windows.Point * System.Windows.UIElement -&gt; System.Windows.Point" Usage="uIElement.TranslatePoint (point, relativeTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="relativeTo" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="point">相对于此元素的点值。</param>
        <param name="relativeTo">给定点转换后的元素。</param>
        <summary>将相对于此元素的点转换为相对于指定元素的坐标。</summary>
        <returns>相对于目标元素而不是此源元素的点值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 允许传递 `relativeTo` 的 `null`，并指示坐标应相对于此元素所属的逻辑树中的根元素。  
  
 此方法用于转换命中测试点值。 如果正在创作控件并且需要在较低级别处理输入，则调用此方法主要是相关的。 如果使用的是现有控件，通常可以假定已完成的控件将报告正确转换的命中测试结果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Uid">
      <MemberSignature Language="C#" Value="public string Uid { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Uid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Uid" />
      <MemberSignature Language="VB.NET" Value="Public Property Uid As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Uid { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Uid : string with get, set" Usage="System.Windows.UIElement.Uid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素的唯一标识符（用于本地化）。 这是依赖项属性。</summary>
        <value>一个字符串，该字符串是此元素的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由设计器用来获取 `x:Uid` 值（有关详细信息，请参阅[WPF 全球化和本地化概述](/dotnet/framework/wpf/advanced/wpf-globalization-and-localization-overview)）。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.UidProperty>|  
|元数据属性设置为 `true`|None|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/81defade-483b-4a89-b76d-9b25bba34010">X：Uid 特性</related>
      </Docs>
    </Member>
    <Member MemberName="UidProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UidProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UidProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.UidProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UidProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UidProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UidProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.UidProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Uid" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLayout">
      <MemberSignature Language="C#" Value="public void UpdateLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.UpdateLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateLayout();" />
      <MemberSignature Language="F#" Value="member this.UpdateLayout : unit -&gt; unit" Usage="uIElement.UpdateLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>请确保此元素的所有可视子元素都正确地进行了布局更新。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法时，`false` 或 <xref:System.Windows.UIElement.IsArrangeValid%2A>`false` <xref:System.Windows.UIElement.IsMeasureValid%2A>元素将调用强制执行布局更新的元素特定的 <xref:System.Windows.UIElement.MeasureCore%2A> 和 <xref:System.Windows.UIElement.ArrangeCore%2A> 方法，并验证所有计算的大小。  
  
 如果布局没有变化，或者布局的排列和度量状态均无效，则调用此方法将不起作用。 但是，如果布局在任何一个方面无效，则 <xref:System.Windows.UIElement.UpdateLayout%2A> 调用将重做整个布局。 因此，应避免在元素树中的每次增量更改和次要更改之后调用 <xref:System.Windows.UIElement.UpdateLayout%2A>。 布局系统将使用一种算法来以延迟方式执行元素布局，并使用一种算法来平衡性能和货币，并使用加权策略来将更改延迟到所有子元素有效。 仅当你确实需要更新的大小和位置，并且仅在你确定控制的所有属性更改和可能影响布局的情况下，才调用 <xref:System.Windows.UIElement.UpdateLayout%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Visibility" />
      <MemberSignature Language="VB.NET" Value="Public Property Visibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility Visibility { System::Windows::Visibility get(); void set(System::Windows::Visibility value); };" />
      <MemberSignature Language="F#" Value="member this.Visibility : System.Windows.Visibility with get, set" Usage="System.Windows.UIElement.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素的 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 可见性。  这是依赖项属性。</summary>
        <value>枚举的一个值。 默认值为 <see cref="F:System.Windows.Visibility.Visible" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性会影响 <xref:System.Windows.UIElement.IsVisible%2A>的值，而这又可能引发 <xref:System.Windows.UIElement.IsVisibleChanged> 事件。 但 <xref:System.Windows.UIElement.IsVisible%2A> 具有影响它的其他因素，例如，包含它的父级的可见性设置。  
  
 不 <xref:System.Windows.Visibility.Visible> <xref:System.Windows.UIElement.Visibility%2A> 的元素不参与输入事件（或命令），不影响布局的度量值或排列处理方式，不在选项卡序列中，也不会在命中测试中报告。  
  
 当由 <xref:System.Windows.Window> 或其派生类继承时，<xref:System.Windows.Window> 将此属性的默认值重定义为 "<xref:System.Windows.Visibility.Collapsed>"。 这会影响未对最初创建的 <xref:System.Windows.Window>运行布局测量处理过程，并且 <xref:System.Windows.UIElement.RenderSize%2A> 返回（0，0）。 有关详细信息，请参阅 <xref:System.Windows.Window>。 <xref:System.Windows.Controls.Primitives.Popup> 还会重新定义要 <xref:System.Windows.Visibility.Collapsed>的默认值，<xref:System.Windows.Controls.Primitives.Popup> 及其派生类产生类似的结果行为。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement.VisibilityProperty>|  
|元数据属性设置为 `true`|None|  
  
   
  
## Examples  
 下面的示例实现了一个处理程序，该处理程序引用了两个不同的命名按钮，它们分别是用户界面中的互斥对。 在运行与按钮关联的实际程序逻辑之前，按钮本身设置为 "<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>"，并将该对中的另一个按钮设置为 <xref:System.Windows.Visibility.Visible?displayProperty=nameWithType>。  
  
 [!code-csharp[MediaElement_snip#UIElementVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/MediaElement_snip/CSharp/PlaybackExample.cs#uielementvisibility)]
 [!code-vb[MediaElement_snip#UIElementVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MediaElement_snip/VB/PlaybackExample.vb#uielementvisibility)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.VisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement.Visibility" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
