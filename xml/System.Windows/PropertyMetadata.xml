<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="031d42f8259f0e05948ded4bfe196a4253a11d14" /><Meta Name="ms.sourcegitcommit" Value="9f423345753728e8cad38d4a22663a109e69ea91" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/04/2021" /><Meta Name="ms.locfileid" Value="102057074" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="94ab8-101">定义依赖属性在应用于特定类型（包括该属性向其注册的条件）时行为的某些方面。</span><span class="sxs-lookup"><span data-stu-id="94ab8-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-102">调用方法时，可以在依赖项属性注册过程中定义和使用属性元数据 <xref:System.Windows.DependencyProperty.Register%2A> (或) 的附加属性或只读依赖属性的变体，或在调用该方法时，在原始所有者注册后使用 <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="94ab8-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> 还使用属性元数据。</span><span class="sxs-lookup"><span data-stu-id="94ab8-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="94ab8-104">此类是一个具体的基类，可在每个调用中使用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="94ab8-105">但是，使用派生类之一（如）指定元数据是很常见的 <xref:System.Windows.FrameworkPropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="94ab8-106">这些派生类支持将更详细的元数据作为布尔属性值传递，这对于检测或启用仅在 WPF 框架级别实现的某些属性系统和布局行为很有用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the WPF framework level.</span></span>  
  
 <span data-ttu-id="94ab8-107">此类的多个属性是对对象模型的读写属性，但只能在与属性系统操作（如或）中使用的实例之前写入 <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="94ab8-108">这些属性中的每一个都可能是由构造函数设置的，但会公开，以便 <xref:System.Windows.PropertyMetadata.Merge%2A> 方法实现可以对其进行设置。</span><span class="sxs-lookup"><span data-stu-id="94ab8-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="94ab8-109">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="94ab8-109">XAML Text Usage</span></span>  
 <span data-ttu-id="94ab8-110">此类型和此类型的成员通常不在 XAML 中使用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-110">This type, and members of this type, are not typically used in XAML.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="94ab8-111">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="94ab8-112">初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="94ab8-113">要为依赖项对象指定的默认值，通常作为某种特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="94ab8-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="94ab8-114">使用此元数据将应用于的依赖项对象的指定默认值，初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-115">为提供的值的类型 `defaultValue` 必须是匹配的，或者与此元数据将应用到的依赖属性的初始注册中指定的类型相关。</span><span class="sxs-lookup"><span data-stu-id="94ab8-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="94ab8-116">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配 (会引发运行时异常) 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="94ab8-117">尽管它是每个无参数构造函数的默认设置，但 `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> 不能指定的。</span><span class="sxs-lookup"><span data-stu-id="94ab8-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="94ab8-118">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="94ab8-119"><paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="94ab8-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="94ab8-120">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="94ab8-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="94ab8-121">用指定的 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="94ab8-122">依赖项对象的默认值，通常作为某种特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="94ab8-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="94ab8-123">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="94ab8-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="94ab8-124">用指定的默认值和 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-125">提供的值的类型 `defaultValue` 必须是匹配的，或者与此元数据将应用到的依赖属性的原始注册中指定的类型相关。</span><span class="sxs-lookup"><span data-stu-id="94ab8-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="94ab8-126">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配 (会引发运行时异常) 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="94ab8-127">尽管它是每个无参数构造函数的默认设置，但 `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> 不能指定的。</span><span class="sxs-lookup"><span data-stu-id="94ab8-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="94ab8-128">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="94ab8-129"><paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="94ab8-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="94ab8-130">依赖项对象的默认值，通常作为某种特定类型的值提供。</span><span class="sxs-lookup"><span data-stu-id="94ab8-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="94ab8-131">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="94ab8-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="94ab8-132">对处理程序实现的引用，每当属性系统对该属性调用 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时都将调用此处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="94ab8-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="94ab8-133">用指定的默认值和回调初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="94ab8-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-134">如果要指定 <xref:System.Windows.CoerceValueCallback> 而不是 <xref:System.Windows.PropertyChangedCallback> ，可以 `null` 为 `propertyChangedCallback` 参数传递。</span><span class="sxs-lookup"><span data-stu-id="94ab8-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="94ab8-135">为提供的值的类型 `defaultValue` 必须是匹配的，或者与此元数据将应用到的依赖属性的初始注册中指定的类型相关。</span><span class="sxs-lookup"><span data-stu-id="94ab8-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="94ab8-136">如果元数据默认值类型与其应用于依赖属性的类型不匹配，则很难进行调试，因为在编译期间不能检测到不匹配 (会引发运行时异常) 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="94ab8-137">尽管它是每个无参数构造函数的默认设置，但 `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> 不能指定的。</span><span class="sxs-lookup"><span data-stu-id="94ab8-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="94ab8-138">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="94ab8-139"><paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="94ab8-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="94ab8-140">获取或设置对此元数据中所指定 <see cref="T:System.Windows.CoerceValueCallback" /> 实现的引用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="94ab8-141">一个 <see cref="T:System.Windows.CoerceValueCallback" /> 实现引用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-142">属性元数据中的回调通常不是包含类型上的公共成员，因此，此属性的值对于只使用现有依赖属性的元数据的大多数方案而言并不重要。</span><span class="sxs-lookup"><span data-stu-id="94ab8-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="94ab8-143">此属性被公开的一个原因是，如果基本元数据和重写/添加元数据都指定，则元数据子类可以执行其所需的合并逻辑 <xref:System.Windows.CoerceValueCallback> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="94ab8-144">但是，的默认合并逻辑 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 是替换前一个逻辑。</span><span class="sxs-lookup"><span data-stu-id="94ab8-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="94ab8-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="94ab8-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="94ab8-146">这样就 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 可以在对象本身初始化后进行调整 <xref:System.Windows.PropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="94ab8-147">但是，在调用、或的过程中使用元数据后 <xref:System.Windows.DependencyProperty.Register%2A> ， <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 属性系统将密封该元数据实例，并且属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="94ab8-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="94ab8-148">如果尝试设置 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 一次 <xref:System.Windows.PropertyMetadata.IsSealed%2A> ， `true` 此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="94ab8-149">将元数据属性应用于依赖属性操作后，无法设置该属性。</span><span class="sxs-lookup"><span data-stu-id="94ab8-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="94ab8-150">获取或设置依赖属性的默认值。</span><span class="sxs-lookup"><span data-stu-id="94ab8-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="94ab8-151">属性的默认值。</span><span class="sxs-lookup"><span data-stu-id="94ab8-151">The default value of the property.</span></span> <span data-ttu-id="94ab8-152"><see cref="T:System.Windows.PropertyMetadata" />使用无参数构造函数创建的实例上的默认值将为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="94ab8-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="94ab8-154">这样就 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 可以在对象本身初始化后进行调整 <xref:System.Windows.PropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="94ab8-155">但是，在调用、或的过程中使用元数据后 <xref:System.Windows.DependencyProperty.Register%2A> ， <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 属性系统将密封该元数据实例，并且属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="94ab8-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="94ab8-156">如果尝试设置 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 一次 <xref:System.Windows.PropertyMetadata.IsSealed%2A> ， `true` 此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="94ab8-157">尽管它是每个无参数构造函数的默认 `defaultValue` 设置，但 <xref:System.Windows.DependencyProperty.UnsetValue> 不能使用 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 或构造函数来设置的。</span><span class="sxs-lookup"><span data-stu-id="94ab8-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="94ab8-158">尝试这样做将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="94ab8-159">XAML 文本用法</span><span class="sxs-lookup"><span data-stu-id="94ab8-159">XAML Text Usage</span></span>  
 <span data-ttu-id="94ab8-160">此类型的成员通常不在 XAML 中使用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-160">Members of this type are not typically used in XAML.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="94ab8-161">创建之后不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</span><span class="sxs-lookup"><span data-stu-id="94ab8-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="94ab8-162">将元数据属性应用于依赖属性操作后，无法设置该属性。</span><span class="sxs-lookup"><span data-stu-id="94ab8-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="94ab8-163">获取一个值，该值确定是否已通过某种方式将元数据应用于属性，从而导致该元数据实例变为不可变状态。</span><span class="sxs-lookup"><span data-stu-id="94ab8-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="94ab8-164">如果元数据实例不可变，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="94ab8-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-165">的各种属性（ <xref:System.Windows.PropertyMetadata> 例如 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ）在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="94ab8-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="94ab8-166">这就是在初始化对象本身后可以调整这些属性 <xref:System.Windows.PropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="94ab8-167">但是，在对、或的调用中，将元数据应用于依赖属性后， <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 属性系统将密封该元数据实例，并且属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="94ab8-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="94ab8-168">在其中一个调用时， <xref:System.Windows.PropertyMetadata.OnApply%2A> 将调用，并将此属性的值设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94ab8-169">下面的示例在 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 自定义元数据属性的 set 操作之前进行检查。</span><span class="sxs-lookup"><span data-stu-id="94ab8-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="94ab8-170">要与此实例的值合并的基元数据。</span><span class="sxs-lookup"><span data-stu-id="94ab8-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="94ab8-171">要应用此元数据的依赖项对象。</span><span class="sxs-lookup"><span data-stu-id="94ab8-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="94ab8-172">将此元数据与基元数据合并。</span><span class="sxs-lookup"><span data-stu-id="94ab8-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-173">当)  (方法重写元数据时，将在内部使用此方法 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="94ab8-174">下面的示例为自定义元数据类型实现合并，该类型将附加属性添加到属性元数据。</span><span class="sxs-lookup"><span data-stu-id="94ab8-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="94ab8-175">派生自的类实现 <see cref="T:System.Windows.PropertyMetadata" /> 应重写此方法，以考虑它们在实现中添加的任何元数据属性。</span><span class="sxs-lookup"><span data-stu-id="94ab8-175">Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="94ab8-176">例如，你的实现可能已添加了一个新的 flagwise 枚举值， <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 然后实现应能够正确组合这些标志。</span><span class="sxs-lookup"><span data-stu-id="94ab8-176">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="94ab8-177">在实现代码之前始终调用基实现，因为基实现负责合并已在该类型上定义的所有属性 <see cref="T:System.Windows.PropertyMetadata" /> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-177">Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.</span></span>  
  
<span data-ttu-id="94ab8-178">合并的确切行为取决于你。</span><span class="sxs-lookup"><span data-stu-id="94ab8-178">The exact behavior of the merge is up to you.</span></span> <span data-ttu-id="94ab8-179">您可以选择将值组合在一起，如果派生的元数据保留为默认值，则恢复为基值，或者根据添加到特定元数据类的属性类型及其含义，恢复为其他许多行为。</span><span class="sxs-lookup"><span data-stu-id="94ab8-179">You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="94ab8-180">已应用了元数据的依赖项对象。</span><span class="sxs-lookup"><span data-stu-id="94ab8-180">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="94ab8-181">与此元数据关联的类型（如果这是特定于类型的元数据）。</span><span class="sxs-lookup"><span data-stu-id="94ab8-181">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="94ab8-182">如果这是默认元数据，则此值为 null 引用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-182">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="94ab8-183">当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-183">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-184">子类应该确保调用后，子类的数据结构的任何可变性都 <xref:System.Windows.PropertyMetadata> 应该标记为不可变 <xref:System.Windows.PropertyMetadata.OnApply%2A> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-184">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="94ab8-185">一旦将元数据应用于属性系统操作 (注册、添加所有者、重写元数据) ，就会调用此操作。</span><span class="sxs-lookup"><span data-stu-id="94ab8-185">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="94ab8-186">获取或设置对此元数据中所指定 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现的引用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-186">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="94ab8-187">一个 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现引用。</span><span class="sxs-lookup"><span data-stu-id="94ab8-187">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="94ab8-188">属性元数据中的回调通常不是定义类型上的公共成员，因此，此属性的值对于只使用现有依赖属性的元数据的大多数方案并不重要。</span><span class="sxs-lookup"><span data-stu-id="94ab8-188">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="94ab8-189">此属性被公开的一个原因是，如果基本元数据和重写/添加元数据都指定，则元数据类可以执行其所需的合并逻辑 <xref:System.Windows.PropertyChangedCallback> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-189">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="94ab8-190">的默认合并逻辑是维护 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 表中的所有实现，并通过在层次结构中第一个运行的最深层类建立回调来调用每个实现。</span><span class="sxs-lookup"><span data-stu-id="94ab8-190">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="94ab8-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 在对象模型中定义为读写。</span><span class="sxs-lookup"><span data-stu-id="94ab8-191"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="94ab8-192">这样就 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 可以在对象本身初始化后进行调整 <xref:System.Windows.PropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="94ab8-192">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="94ab8-193">但是，在调用、或的过程中使用元数据后 <xref:System.Windows.DependencyProperty.Register%2A> ， <xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 属性系统将密封该元数据实例，并且属性现在被视为不可变。</span><span class="sxs-lookup"><span data-stu-id="94ab8-193">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="94ab8-194">如果尝试设置 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 一次 <xref:System.Windows.PropertyMetadata.IsSealed%2A> ， `true` 此元数据实例将引发异常。</span><span class="sxs-lookup"><span data-stu-id="94ab8-194">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="94ab8-195">将元数据属性应用于依赖属性操作后，无法设置该属性。</span><span class="sxs-lookup"><span data-stu-id="94ab8-195">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
