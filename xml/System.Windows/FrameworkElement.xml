<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9f75bfa5cde108be6ef82b0ffc2cffaf3006ba10" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83901300" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface ISupportInitialize&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface IQueryAmbient" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize" FrameworkAlternate="netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 Windows Presentation Foundation (WPF) 元素的属性、事件和方法的 WPF 框架级别集。 此类表示所提供的 WPF 框架级别实现基于 <see cref="T:System.Windows.UIElement" /> 定义的 WPF 核心级别 API。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 是 WPF 框架级别的元素类与 WPF core 级别的 <xref:System.Windows.UIElement> 表示服务之间的连接点。 有关这些概念的详细信息，请参阅[WPF 体系结构](/dotnet/framework/wpf/advanced/wpf-architecture)。  
  
 <xref:System.Windows.FrameworkElement> 扩展 <xref:System.Windows.UIElement> 并添加以下功能：  
  
-   **布局系统定义**： <xref:System.Windows.FrameworkElement> 为在 <xref:System.Windows.UIElement>中定义为虚拟成员的某些方法提供特定的 WPF 框架级实现。 最值得注意的是，<xref:System.Windows.FrameworkElement> 密封了某些 WPF 核心级别的布局重写，而是提供了一个 WPF 框架级别等效项，派生类应改为重写。 例如，<xref:System.Windows.FrameworkElement> 密封 <xref:System.Windows.UIElement.ArrangeCore%2A> 但提供 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。 这些更改反映了这样一个事实：在 WPF 框架级别，有一个完全布局系统可呈现任何 <xref:System.Windows.FrameworkElement> 派生类。 在 WPF 核心级别，将构造基于常规 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 的布局解决方案的某些成员是就地的，但布局系统的实际引擎并未定义。 请参阅[布局](/dotnet/framework/wpf/advanced/layout)以了解详细信息。  
  
-   **逻辑树：** 一般的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 编程模型通常以元素树的形式表示。 支持将元素树表示为逻辑树，并支持在标记中定义该树在 <xref:System.Windows.FrameworkElement> 级别实现。 但请注意，<xref:System.Windows.FrameworkElement> 特意不定义内容模型，而是将此责任留给派生类。 有关详细信息，请参见 [WPF 中的树](/dotnet/framework/wpf/advanced/trees-in-wpf)。  
  
-   **对象生存期事件：** 通常，知道何时初始化元素（调用构造函数）或将元素首次加载到逻辑树中。 <xref:System.Windows.FrameworkElement> 定义了一些与对象生存期相关的事件，这些事件为涉及元素的代码隐藏操作提供有用的挂钩，如添加更多的子元素。 有关详细信息，请参阅[对象生存期事件](/dotnet/framework/wpf/advanced/object-lifetime-events)。  
  
-   **数据绑定和动态资源引用支持：** 数据绑定和资源的属性级别支持由 <xref:System.Windows.DependencyProperty> 类实现并在属性系统中使用，但是，解析存储为 <xref:System.Windows.Expression> 的成员值（编程构造是数据绑定和动态资源）的能力由 <xref:System.Windows.FrameworkElement>实现。 有关详细信息，请参阅[数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)和[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
-   **样式：** <xref:System.Windows.FrameworkElement> 定义 <xref:System.Windows.FrameworkElement.Style%2A> 属性。 但是，<xref:System.Windows.FrameworkElement> 尚未定义对模板的支持，或不支持修饰器。 这些功能由控件类（如 <xref:System.Windows.Controls.Control> 和 <xref:System.Windows.Controls.ContentControl>）引入。  
  
-   **更多动画支持：** 某些动画支持已在 WPF 核心级别进行了定义，但 <xref:System.Windows.FrameworkElement> 通过实现 <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> 和相关成员对此进行了扩展。  
  
 从类层次结构中可以看出，许多 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 类直接或通过中间基类（如 <xref:System.Windows.Controls.Panel> 或 <xref:System.Windows.Controls.Control>）派生自 <xref:System.Windows.FrameworkElement>。  
  
 如果要使用 <xref:System.Windows.FrameworkElement> 作为基类，则可能需要首先检查现有的派生类。 <xref:System.Windows.FrameworkElement> 提供了对许多基本方案的支持，但对于在 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]中创建 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 的构建基块而言，还缺少一些需要用于 "元素" 的功能。 例如，<xref:System.Windows.FrameworkElement> 不定义任何真正的内容模型;作为基类 <xref:System.Windows.FrameworkElement> 不定义可创建 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 子元素的属性。 特别是，您可能需要查看 <xref:System.Windows.Controls.Control> 和 <xref:System.Windows.Controls.ContentControl>。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkElement" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的呈现高度。</summary>
        <value>元素的高度，这是一个采用[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]的值。 默认值为 0（零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是基于其他高度输入和布局系统的计算值。 该值是由布局系统本身基于实际呈现处理方式设置的，因此可能会略微滞后于属性的设置值，例如 <xref:System.Windows.FrameworkElement.Height%2A> 作为输入更改的基础。  
  
 由于 <xref:System.Windows.FrameworkElement.ActualHeight%2A> 是一个计算值，因此你应该注意到，它可能会对其进行多个或增量报告的更改，作为布局系统的各种操作的结果。 布局系统可能会计算子元素所需的测量空间、父元素的约束等。  
  
 尽管不能从 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]设置此属性，但可以根据样式中的值来设置 <xref:System.Windows.Trigger>。  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例显示了各种高度属性。  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的呈现宽度。</summary>
        <value>元素的宽度，这是一个采用[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]的值。 默认值为 0（零）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是基于其他宽度输入和布局系统的计算值。 该值是由布局系统本身基于实际呈现处理方式设置的，因此可能会略微滞后于属性的设置值，例如 <xref:System.Windows.FrameworkElement.Width%2A> 作为输入更改的基础。  
  
 由于 <xref:System.Windows.FrameworkElement.ActualWidth%2A> 是一个计算值，因此你应该注意到，它可能会对其进行多个或增量报告的更改，作为布局系统的各种操作的结果。 布局系统可能会计算子元素所需的测量空间、父元素的约束等。  
  
 尽管不能从 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]设置此属性，但可以根据样式中的值来设置 <xref:System.Windows.Trigger>。  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例显示了各种宽度属性。  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要添加的子元素。</param>
        <summary>将提供的对象添加到此元素的逻辑树。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可实现对象的集合，这些对象表示元素的逻辑子元素。 子元素集合的集合维护可以在属性 getter 或 setter 中完成，也可以在更改事件、构造函数或集合类型本身的类处理中完成。  
  
 对于控件作者，不建议在此级别操作逻辑树，除非可用基控件类的任何内容模型都适用于控件方案。 请考虑在 <xref:System.Windows.Controls.ContentControl>、<xref:System.Windows.Controls.ItemsControl>和 <xref:System.Windows.Controls.HeaderedItemsControl>级别进行子类化。 这些类提供了一个内容模型，其中包含通过专用 Api 特定的逻辑树子元素强制，并支持在 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 控件（例如通过模板设置样式）中通常需要的其他功能。 有关如何使用 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 和 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>的详细信息，请参阅[WPF 中的树](/dotnet/framework/wpf/advanced/trees-in-wpf)。  
  
 如果在另一个进程循环访问逻辑树时调用，则 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> 可能会引发异常。  
  
   
  
## Examples  
 下面的示例实现自定义 <xref:System.Windows.FrameworkElement> 上的 `Child` 属性，该属性执行其自己的可视化层实现。 属性 setter 设计为这样，如果值发生更改，则会从逻辑树中删除旧值，并从特定于类的视觉对象集合中删除旧值。 将缓存属性值，然后将新值添加到逻辑树和自定义视觉对象集合中。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在必要时生成当前模板的可视化树，然后返回一个值，该值指示可视化树是否由此调用重新生成。</summary>
        <returns>如果在树中添加了视觉对象，则返回 <see langword="true" />；否则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以调用此方法以确保元素的可视化树已完成。 如果代码要检查树中的子元素，则此保证步骤可能是必需的。 对于应用程序中的典型元素逻辑，不需要调用 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A>，因为模板会自动应用到其生存期中相应点的元素。  
  
 WPF 框架级别布局系统对每个度量值调用 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A>。  
  
 <xref:System.Windows.FrameworkElement> 派生类可以使用 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> 类处理程序，以便在显式调用此方法或布局系统的情况下获得通知。 在完整生成模板并将其附加到逻辑树后，调用 <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">父级中应使用此元素排列自身及其子元素的最终区域。</param>
        <summary>实现 <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />（在 <see cref="T:System.Windows.UIElement" /> 中定义为虚拟对象）并密封实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是密封的。 为了在自定义元素中替代元素布局的排列处理过程的逻辑，您的 <xref:System.Windows.FrameworkElement> 派生类必须重写 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">父级中应使用此元素排列自身及其子元素的最终区域。</param>
        <summary>在派生类中重写时，为 <see cref="T:System.Windows.FrameworkElement" /> 派生类定位子元素并确定大小。</summary>
        <returns>使用的实际大小。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>要自定义布局处理过程的控件作者应重写此方法。 实现模式应在每个可见的子元素上调用 <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />，并为每个子元素传递最终所需大小作为 <paramref name="finalRect" /> 参数。 父元素应该对每个子元素调用 <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />，否则不会呈现子元素。  
  
许多派生类提供此方法的实现。 主要包括： <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />、<see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> 和 <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />。</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动此元素的初始化过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要以不公开或将元素连接到任何元素树的方式对其进行调整，则可以对单个元素调用此方法。 例如，你可能已经创建了一个新的 <xref:System.Windows.FrameworkElement>，但尚未将其附加到任何逻辑树。 或者，逻辑树（其中元素是其中的子元素）可能未连接到应用程序的窗口或页面。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>实现此方法可提供在元素加载过程中初始化元素之前应发生的特殊处理。  
  
你的实现应调用基实现，因为基（默认）实现设置了一些内部标志来跟踪初始化。 一种可能的实现方法是使用此方法作为挂钩到你自己的私有类初始化例程，这些例程尚未由构造函数启用。  
  
如果在调用 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 之前对同一元素多次调用 <see cref="M:System.Windows.FrameworkElement.BeginInit" />，则基实现将引发异常。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最典型的动画方案不使用此方法。 通常，您将在标记中创建 <xref:System.Windows.Media.Animation.Storyboard> 或 <xref:System.Windows.Media.Animation.BeginStoryboard> 元素，然后将它们放置为元素上的 <xref:System.Windows.EventTrigger> 内容。 当事件触发时，动画将运行。 <xref:System.Windows.Media.Animation.Storyboard> 的大部分控制方面都可以通过在标记中公开的属性进行寻址。  
  
 对于不使用 `isControllable`、参数或指定该参数的签名 `false`，一旦动画达到 "填充" 时间段，就会删除与动画关联的时间线时钟。 因此，不能在运行后重新启动动画。 控制动画还要求情节提要具有[X：Name 指令](/dotnet/framework/xaml-services/x-name-directive)或可通过代码中的引用进行访问。  
  
   
  
## Examples  
 下面的示例从资源中检索 <xref:System.Windows.Media.Animation.Storyboard>，然后在对内部事件进行类处理时运行 <xref:System.Windows.Media.Animation.Storyboard>。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <summary>开始所提供的演示图板中包含的操作序列，并指定选项来指明当已对属性进行动画处理时应发生的行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最典型的动画方案不使用此方法。 通常，您将在标记中创建 <xref:System.Windows.Media.Animation.Storyboard> 或 <xref:System.Windows.Media.Animation.BeginStoryboard> 元素，然后将它们放置为元素上的 <xref:System.Windows.EventTrigger> 内容。 当事件触发时，动画将运行。 <xref:System.Windows.Media.Animation.Storyboard> 的大部分控制方面都可以通过在标记中公开的属性进行寻址。  
  
 对于不使用 `isControllable`、参数或指定该参数的签名 `false`，一旦动画达到 "填充" 时间段，就会删除与动画关联的时间线时钟。 因此，不能在运行后重新启动动画。 控制动画还要求情节提要具有[X：Name 指令](/dotnet/framework/xaml-services/x-name-directive)或可通过代码中的引用进行访问。  
  
 可以将移交行为指定为 <xref:System.Windows.Media.Animation.BeginStoryboard>的属性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰写 HandoffBehavior  
 使用 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>将 <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>或 <xref:System.Windows.Media.Animation.AnimationClock> 应用于属性时，以前与该属性关联的任何 <xref:System.Windows.Media.Animation.Clock> 对象将继续使用系统资源;计时系统不会自动删除时钟。  
  
 为了避免在使用 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>应用大量时钟时出现性能问题，应在完成后从动画属性中删除组合时钟。 有几种方法可以删除时钟：  
  
-   若要从属性中删除所有时钟，请使用动画对象的 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 或 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 方法。 指定正在进行动画处理的属性作为第一个参数，并 `null` 为第二个参数。 这将从属性中移除所有动画时钟。  
  
-   若要从时钟列表中删除特定 <xref:System.Windows.Media.Animation.AnimationClock>，请使用 <xref:System.Windows.Media.Animation.AnimationClock> 的 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 属性检索 <xref:System.Windows.Media.Animation.ClockController>，然后调用 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 的 <xref:System.Windows.Media.Animation.ClockController>方法。 通常在时钟的 <xref:System.Windows.Media.Animation.Clock.Completed> 事件处理程序中完成此操作。 请注意，只能通过 <xref:System.Windows.Media.Animation.ClockController>来控制根时钟;子时钟的 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 属性返回 `null`。 另请注意，如果时钟的有效持续时间是永久性的，则不会引发 <xref:System.Windows.Media.Animation.Clock.Completed> 事件。  在这种情况下，用户必须确定何时调用 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  当对对象进行垃圾回收时，还会断开其时钟的连接并对其进行垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview)。  
  
   
  
## Examples  
 下面的示例从资源中检索 <xref:System.Windows.Media.Animation.Storyboard>，然后在对内部事件进行类处理时运行 <xref:System.Windows.Media.Animation.Storyboard>。  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginStoryboard (storyboard As Storyboard, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <param name="isControllable">声明在动画开始后是否仍可以对它进行控制（可以暂停）。</param>
        <summary>开始所提供的演示图板中包含的操作序列，并使动画控件在动画开始后具有指定的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最典型的动画方案不使用此方法。 通常，您将在标记中创建 <xref:System.Windows.Media.Animation.Storyboard> 或 <xref:System.Windows.Media.Animation.BeginStoryboard> 元素，然后将它们放置为元素上的 <xref:System.Windows.EventTrigger> 内容。 当事件触发时，动画将运行。 <xref:System.Windows.Media.Animation.Storyboard> 的大部分控制方面都可以通过在标记中公开的属性进行寻址。  
  
 对于不使用 `isControllable`、参数或指定该参数的签名 `false`，一旦动画达到 "填充" 时间段，就会删除与动画关联的时间线时钟。 因此，不能在运行后重新启动动画。 控制动画还要求情节提要具有[X：Name 指令](/dotnet/framework/xaml-services/x-name-directive)或可通过代码中的引用进行访问。  
  
 可以将移交行为指定为 <xref:System.Windows.Media.Animation.BeginStoryboard>的属性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰写 HandoffBehavior  
 使用 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>将 <xref:System.Windows.Media.Animation.Storyboard>、<xref:System.Windows.Media.Animation.AnimationTimeline>或 <xref:System.Windows.Media.Animation.AnimationClock> 应用于属性时，以前与该属性关联的任何 <xref:System.Windows.Media.Animation.Clock> 对象将继续使用系统资源;计时系统不会自动删除时钟。  
  
 为了避免在使用 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>应用大量时钟时出现性能问题，应在完成后从动画属性中删除组合时钟。 有几种方法可以删除时钟：  
  
-   若要从属性中删除所有时钟，请使用动画对象的 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 或 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 方法。 指定正在进行动画处理的属性作为第一个参数，并 `null` 为第二个参数。 这将从属性中移除所有动画时钟。  
  
-   若要从时钟列表中删除特定 <xref:System.Windows.Media.Animation.AnimationClock>，请使用 <xref:System.Windows.Media.Animation.AnimationClock> 的 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 属性检索 <xref:System.Windows.Media.Animation.ClockController>，然后调用 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 的 <xref:System.Windows.Media.Animation.ClockController>方法。 通常在时钟的 <xref:System.Windows.Media.Animation.Clock.Completed> 事件处理程序中完成此操作。 请注意，只能通过 <xref:System.Windows.Media.Animation.ClockController>来控制根时钟;子时钟的 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 属性返回 `null`。 另请注意，如果时钟的有效持续时间是永久性的，则不会引发 <xref:System.Windows.Media.Animation.Clock.Completed> 事件。  在这种情况下，用户必须确定何时调用 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  当对对象进行垃圾回收时，还会断开其时钟的连接并对其进行垃圾回收。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> 可用于验证对象的多个属性的值。 例如，假设应用程序提示用户输入地址，然后使用用户提供的值填充 `Address`类型的对象，该对象的属性 `Street`、`City`、`ZipCode`和 `Country`。 应用程序具有一个包含四个 <xref:System.Windows.Controls.TextBox> 控件的面板，其中每个控件都绑定到对象的一个属性。 可以在 <xref:System.Windows.Data.BindingGroup> 中使用 <xref:System.Windows.Controls.ValidationRule> 来验证 `Address` 对象。 例如，<xref:System.Windows.Controls.ValidationRule> 可以确保邮政编码对地址的国家/地区有效。  
  
 子元素从其父元素继承 <xref:System.Windows.Data.BindingGroup>，就像任何其他可继承的属性一样。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 以下示例是应用程序的一部分，用于检查用户是否已将两个对象的属性设置为相等值。 第一个示例创建两个 <xref:System.Windows.Controls.TextBox> 控件，其中每个控件都绑定到不同的数据源。 <xref:System.Windows.Controls.StackPanel> 具有一个 <xref:System.Windows.Data.BindingGroup>，其中包含的 <xref:System.Windows.Controls.ValidationRule> 检查两个字符串是否相等。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 下面的示例演示上一示例使用的 <xref:System.Windows.Controls.ValidationRule>。  在 <xref:System.Windows.Controls.ValidationRule.Validate%2A> 方法重写中，该示例从 <xref:System.Windows.Data.BindingGroup> 中获取每个源对象，并检查对象的属性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 若要调用 <xref:System.Windows.Controls.ValidationRule>，请调用 <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> 方法。  下面的示例在按钮的 click 事件发生时调用 <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.BindingGroup" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，可以引发源自当前元素的 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件。 引发此事件的目的是 <xref:System.Windows.Controls.ScrollViewer>或派生类或类似类处理此事件。 预期的行为是由父元素处理事件（在事件数据中标记为已处理），事件源通过嵌入在 <xref:System.Windows.Controls.ScrollViewer> 控件中的逻辑进入视图。 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件和 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 方法均不传输任何有关成功或失败的信息，而不是该事件通常标记为成功处理。 失败的原因可能包括元素设置，如 <xref:System.Windows.UIElement.Visibility%2A> 是 <xref:System.Windows.Visibility.Visible>以外的其他值。  
  
 如果使用未指定 `targetRectangle`的签名，则整个元素大小（其 <xref:System.Windows.UIElement.RenderSize%2A>）将变得可见。  
  
 通过调用此方法，您可能会对包含该元素的任何父可滚动区域调用 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>。 如果此元素不包含在可滚动区域中，则仍会引发 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件，但由于没有事件侦听器，因此将不起作用。  
  
   
  
## Examples  
 下面的示例为应用程序导航事件实现了一个处理程序，该事件在导航到的统一资源标识符（URI）包含片段时做出响应。 片段在哈希符号（#）后面的 URI 中命名，实现的行为使元素滚动到帧内的视图中。 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 和 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 请求该示例中的滚动行为。  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">也应放入视图中的元素的指定大小。</param>
        <summary>尝试将此元素的提供区域大小放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，可以引发源自当前元素的 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件。 引发此事件的目的是 <xref:System.Windows.Controls.ScrollViewer>或派生类或类似类处理此事件。 预期的行为是由父元素处理事件（在事件数据中标记为已处理），事件源通过嵌入在 <xref:System.Windows.Controls.ScrollViewer> 控件中的逻辑进入视图。 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件和 <xref:System.Windows.FrameworkElement.BringIntoView%2A> 方法均不传输任何有关成功或失败的信息，而不是该事件通常标记为成功处理。 失败的原因可能包括元素设置，如 <xref:System.Windows.UIElement.Visibility%2A> 是 <xref:System.Windows.Visibility.Visible>以外的其他值。  
  
 如果使用未指定 `targetRectangle`的签名，则整个元素大小（其 <xref:System.Windows.UIElement.RenderSize%2A>）将变得可见。  
  
 通过调用此方法，您可能会对包含该元素的任何父可滚动区域调用 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>。 如果此元素不包含在可滚动区域中，则仍会引发 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件，但由于没有事件侦听器，因此将不起作用。  
  
   
  
## Examples  
 下面的示例在受约束的滚动区域中有一个大型图形。 页面上的按钮具有处理程序，可将视图滚动到大型图形的特定区域。  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置通过 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 从此元素内部请求上下文菜单时应该显示的上下文菜单元素。</summary>
        <value>分配给此元素的上下文菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> 本身是一个 <xref:System.Windows.FrameworkElement> 派生类，在技术上也可以 <xref:System.Windows.Controls.ContextMenu> 自身具有 <xref:System.Windows.FrameworkElement.ContextMenu%2A> 属性。 但是，这会为用户带来混乱的上下文菜单体验，不建议使用这种做法。  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭上下文菜单，该事件的处理程序应将其标记为已处理。  
  
 若要使用此事件作为样式中的 <xref:System.Windows.EventTrigger>，必须引用事件的基础服务定义：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 （这种用法是必需的，因为公开基础服务事件 <xref:System.Windows.FrameworkElement> 上的事件实现不会映射 <xref:System.Windows.FrameworkElement.ContextMenuClosing> 标识符，因此你可以将其用作触发器）。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是一个 <xref:System.Windows.FrameworkElement> 派生类，但 <xref:System.Windows.FrameworkElement.ContextMenuClosing> 事件不会直接由上下文菜单引发。 相反，事件是从 "拥有" 上下文菜单作为属性的元素引发的，仅当用户尝试关闭用户界面菜单时才会引发。 但 <xref:System.Windows.Controls.ContextMenu> 本身有可能具有 <xref:System.Windows.FrameworkElement.ContextMenu%2A> 属性（一个嵌套上下文菜单）。 在这种情况下，<xref:System.Windows.Controls.ContextMenu> 确实拥有嵌套 <xref:System.Windows.Controls.ContextMenu>，可能引发事件，并将事件的源作为嵌套上下文菜单。  
  
 <xref:System.Windows.Controls.ContextMenu> 类本身也具有类似的事件（<xref:System.Windows.Controls.ContextMenu.Closed>），但 <xref:System.Windows.Controls.ContextMenu.Closed> 事件不会为你提供取消用户操作的机会。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   重写 <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开上下文菜单，事件的处理程序应将相关事件标记为 "已处理"。 否则，将使用 <xref:System.Windows.FrameworkElement.ContextMenu%2A> 属性的现有值自动打开上下文菜单。 将事件标记为已处理会有效地取消默认操作，并且可能有机会重置 <xref:System.Windows.FrameworkElement.ContextMenu%2A> 属性的值，然后打开新的 <xref:System.Windows.Controls.ContextMenu>。 但是，有一个应该注意的计时问题。 为了通过 <xref:System.Windows.FrameworkElement.ContextMenuOpening> 处理程序完全替换上下文菜单，初始上下文菜单不得为 null/空。 或者，您可能需要处理事件，然后手动打开新的上下文菜单。 有关详细信息，请参阅[如何：处理 ContextMenuOpening 事件](/dotnet/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event)。  
  
 若要使用此事件作为样式中的 <xref:System.Windows.EventTrigger>，必须引用底层附加事件：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 （这种用法是必需的，因为公开基础服务事件 <xref:System.Windows.FrameworkElement> 上的事件实现不会映射 <xref:System.Windows.FrameworkElement.ContextMenuOpening> 标识符，以便在触发器中使用它）。  
  
 <xref:System.Windows.Controls.ContextMenu> 本身是一个 <xref:System.Windows.FrameworkElement> 派生类，但不会从作为源打开的上下文菜单引发此事件。 事件是从 "拥有" 上下文菜单作为属性的元素引发的，仅当用户尝试在用户界面中打开上下文菜单时才会引发该事件。 <xref:System.Windows.Controls.ContextMenu> 本身具有 <xref:System.Windows.FrameworkElement.ContextMenu%2A> 属性，但应避免此情况（有关详细信息，请参阅 <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>）。  
  
 <xref:System.Windows.Controls.ContextMenu> 类本身也具有类似的事件（<xref:System.Windows.Controls.ContextMenu.Opened>），但 <xref:System.Windows.Controls.ContextMenu.Opened> 不提供取消用户操作的机会。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   重写 <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ContextMenu" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在鼠标指针位于此元素上时显示的光标。</summary>
        <value>要显示的光标。 按此依赖属性，默认值定义为 <see langword="null" />。 但是，运行时的实际默认值将受到多种因素的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]中设置此属性时，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器依赖于 <xref:System.Windows.Input.Cursor> 类的类型转换来计算字符串。 提供的字符串的计算结果应为 <xref:System.Windows.Input.CursorType> 值。 有关详细信息，请参阅<xref:System.Windows.Input.Cursor>。  
  
 当鼠标指针位于此元素上时，是否显示此属性所建立的光标也依赖于 <xref:System.Windows.FrameworkElement.ForceCursor%2A> 属性的值。 此外，与事件相关的注意事项，如活动拖动、鼠标捕获、控件内的文本编辑模式等，也会影响其优先级高于在此属性中指定的值的光标。  
  
 若要将此属性的设置方式恢复为最终的默认值，请将其设置为 "`null`"。  
  
 默认情况下，`null` 是指在此处推迟确定实际的游标值，应从其他位置获取该值。 如果未从任何源以编程方式提供值，则会在 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 应用程序上直观地显示默认光标。 但是，在传递时，不会将暂时性游标更改设置为元素的 <xref:System.Windows.FrameworkElement.Cursor%2A> 值。 只有在实际设置了代码或样式的情况下，<xref:System.Windows.FrameworkElement.Cursor%2A> 属性才会报告非 null 值。 鼠标在 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 应用程序上的每个移动都将引发 <xref:System.Windows.UIElement.QueryCursor> 事件。 事件冒泡，而路由中的任何元素都有机会处理事件，并通过此事件的参数设置游标的值。 这是在大多数情况下生成视觉上明显的光标的机制。 如果 <xref:System.Windows.UIElement.QueryCursor> 处理程序返回游标结果，则处理事件并在参数中具有更改的值将优先于任何级别的 <xref:System.Windows.FrameworkElement.Cursor%2A> 属性的值，除非设置 <xref:System.Windows.FrameworkElement.ForceCursor%2A>。  
  
 如果未创建自定义游标，通常会将此属性设置为 <xref:System.Windows.Input.Cursors> 类的静态属性值。 在代码中设置 <xref:System.Windows.FrameworkElement.Cursor%2A> 需要执行下列操作之一：  
  
-   调用 <xref:System.Windows.Input.Cursor> 构造函数以获取 <xref:System.Windows.Input.Cursor> 实例。 <xref:System.Windows.Input.Cursor> 构造函数的两个签名都使用流或文件，这是为了为自定义游标创建 <xref:System.Windows.Input.Cursor> 对象。  
  
-   使用 <xref:System.Windows.Input.CursorConverter> 类及其 <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> 方法，通过 <xref:System.Windows.Input.CursorType>或可计算为 <xref:System.Windows.Input.CursorType>的字符串指定游标，并将返回值强制转换为 <xref:System.Windows.Input.Cursor>。  
  
 在部分信任环境中未启用将 <xref:System.Windows.Input.Cursor> 设置为自定义值。 有关自定义游标的详细信息，请参阅[输入概述](/dotnet/framework/wpf/advanced/input-overview)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例演示如何特意设置光标图形。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素参与数据绑定时的数据上下文。</summary>
        <value>要用作数据上下文的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *数据上下文*是一种概念，允许元素从父元素继承有关用于绑定的数据源以及绑定的其他特征（如路径）的信息。  
  
 可以将数据上下文直接设置为 .NET 对象，并将绑定计算为该对象的属性。 或者，您可以将数据上下文设置为 <xref:System.Windows.Data.DataSourceProvider> 对象。  
  
 此依赖属性继承属性值。 如果有子元素没有通过本地值或样式建立的 <xref:System.Windows.FrameworkElement.DataContext%2A> 的其他值，则属性系统会将该值设置为已分配此值的最近父元素的 <xref:System.Windows.FrameworkElement.DataContext%2A> 值。  
  
 或者，您可以使用 <xref:System.Windows.Data.Binding> 类的以下属性之一来显式指定绑定源：
  
    - <xref:System.Windows.Data.Binding.ElementName%2A> 列中的一个值匹配。
    - <xref:System.Windows.Data.Binding.Source%2A> 列中的一个值匹配。
    - <xref:System.Windows.Data.Binding.RelativeSource%2A> 列中的一个值匹配。 
  
  有关详细信息，请参阅[如何：指定绑定源](/dotnet/framework/wpf/data/how-to-specify-the-binding-source)。  
  
 在 XAML 中，<xref:System.Windows.FrameworkElement.DataContext%2A> 通常设置为 <xref:System.Windows.Data.Binding> 声明。 您可以使用属性元素语法或特性语法。 此页上的示例显示了特性语法。 你还可以使用代码设置 <xref:System.Windows.FrameworkElement.DataContext%2A>。  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> 是一种可绑定的属性，可用于在一个上下文可能绑定到另一个上下文的情况下实现。 但是，如果绑定到 <xref:System.Windows.FrameworkElement.DataContext%2A>，请注意不要创建循环绑定引用（不将 <xref:System.Windows.FrameworkElement.DataContext%2A> 绑定到其自身，因为 <xref:System.Windows.FrameworkElement.DataContext%2A> 属性的属性值继承特性）。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml  
<object DataContext="bindingUsage"/>  
```

-或-

```xaml
<object DataContext="{resourceExtension contextResourceKey}"/>  
```
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 作为父元素中任何绑定的数据上下文的直接嵌入对象。 通常，此对象是 <xref:System.Windows.Data.Binding> 或另一个 <xref:System.Windows.Data.BindingBase> 派生类。 或者，可将用于绑定的任何对象类型的原始数据放置在此处，并在以后定义实际绑定。  
  
 *bindingUsage*  
 计算结果为适当数据上下文的绑定使用情况。 有关详细信息，请参阅 [Binding 标记扩展](/dotnet/framework/wpf/advanced/binding-markup-extension)。  
  
 *resourceExtension*  
 以下项之一： [`StaticResource`](/dotnet/framework/wpf/advanced/staticresource-markup-extension)或[`DynamicResource`](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension)。 当引用定义为资源中的对象的原始数据时，将使用此用法。 请参阅[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
 *contextResourceKey*  
 要从 <xref:System.Windows.ResourceDictionary>中请求的对象的密钥标识符。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例说明了数据上下文如何对绑定进行操作，并提供了定义绑定属性的特定值的信息。  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的数据上下文更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关数据上下文和数据绑定的说明，请参阅[数据绑定概述](/dotnet/framework/wpf/data/data-binding-overview)。  
  
> [!IMPORTANT]
>  当元素的 <xref:System.Windows.FrameworkElement.DataContext%2A> 更改时，此元素上的所有数据绑定属性都可能会受到影响。 这适用于作为逻辑树中当前元素的子元素的所有元素，这些元素继承数据上下文以及当前元素本身。 所有此类现有绑定都必须重新解释新 <xref:System.Windows.FrameworkElement.DataContext%2A>，并将重新计算绑定结果。 数据绑定引擎并不确定这些 reevaluations 的顺序，这与引发 <xref:System.Windows.FrameworkElement.DataContextChanged> 事件相关。 Reevaluations 可以在事件之前、事件之后或任何组合中发生。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.DataContext" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在使用或定义主题样式时要用于引用此控件样式的键。</summary>
        <value>样式键。 要作为主题样式查找的一部分正常工作，此值应是带样式的控件的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常不通过其任何直接属性访问器设置此属性。 相反，每次创建新的 <xref:System.Windows.FrameworkElement> 派生类时，都要重写此依赖项属性的特定于类型的元数据。 派生控件时，在控件派生类（或等效类初始化）的静态构造函数中，对 <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> 标识符调用 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 方法。  
  
 控件通常会将此属性的默认值覆盖为其自己的类型，但在某些情况下，可能还会使用主题字典中的样式所在的基类型。 这仅适用于基本控件的控件模板完全定义该派生控件的可视化表示形式，并且如果派生类型公开的任何其他成员不需要作为控件模板的一部分的其他元素，这是可行的。  
  
 如果你希望你的元素或控件特意不使用主题样式，请将 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 属性设置为 `true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例演示了备注中讨论的依赖属性元数据覆盖用法。 此代码定义了一个自定义控件类 `NumericUpDown` 应从专用的控件库程序集使用。 阐释的静态构造函数引用了某些专用初始化函数、注册类处理程序（另一常见控件子类方案; 请参阅将[路由事件标记为已处理，以及类处理](/dotnet/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling)）并最终覆盖 `NumericUpDown` 类的 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 依赖项属性元数据。 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 始终将其自己的类型作为预期键返回，这是主题样式系统用于查找某些任意非样式控件的样式的约定。 完整示例还定义了该键引用的实际控件主题样式;请参阅[NumericUpDown 自定义控件以及主题和 UI 自动化支持示例](https://go.microsoft.com/fwlink/?LinkID=160025)。  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  GitHub 上提供了此示例的完整源代码[C#](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) ，适用于和[Visual Basic](https://github.com/dotnet/dotnet-api-docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary)。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">带有主题和 UI 自动化支持示例的 NumericUpDown 自定义控件</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示元素的初始化过程已完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果之前调用了 <xref:System.Windows.FrameworkElement.BeginInit%2A>，则基实现将引发 <xref:System.Windows.FrameworkElement.Initialized> 事件。 否则，如果未调用 <xref:System.Windows.FrameworkElement.BeginInit%2A> 或无法确定是否调用了 <xref:System.Windows.FrameworkElement.BeginInit%2A>，则不会引发 <xref:System.Windows.FrameworkElement.Initialized>，而是会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 之前尚未在元素上调用 <see cref="M:System.Windows.FrameworkElement.BeginInit" />。</exception>
        <block subset="none" type="overrides"><para>实现此方法可提供在元素加载过程中初始化元素时应发生的特殊处理。  
  
 你的实现应调用基实现，因为基（默认）实现设置了一些内部标志来跟踪初始化。</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所请求元素的名称。</param>
        <summary>查找具有提供的标识符名的元素。</summary>
        <returns>请求的元素。 如果找不到匹配的元素，该值将为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果元素包含子元素，则会以递归方式搜索所请求的命名元素的子元素。  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> 在当前元素的名称范围内运行。 有关详细信息，请参阅[WPF XAML 名称范围](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">X：Name 特性</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">所请求资源的键标识符。</param>
        <summary>搜索具有指定密钥的资源，如果未找到请求的资源，则会引发异常。</summary>
        <returns>所请求的资源。 如果未找到具有所提供键的资源，将引发异常。 在发生异常的情况下，可能还会返回一个 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果对找不到的键调用此方法，则会引发异常。 如果不想处理通过调用 <xref:System.Windows.FrameworkElement.FindResource%2A>而产生的异常，请改为调用 <xref:System.Windows.FrameworkElement.TryFindResource%2A>。 当找不到请求的资源时，<xref:System.Windows.FrameworkElement.TryFindResource%2A> 返回 `null`，并且不会引发异常。  
  
 如果在调用元素上找不到该资源，将在下一步搜索逻辑树中的父元素，然后搜索应用程序，然后是主题，最后是系统资源。 此查找方法与在标记中动态资源引用请求资源时搜索树的方式相同。 有关资源查找的详细信息，请参阅[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
 通常，您会立即将 <xref:System.Windows.FrameworkElement.FindResource%2A> 返回值强制转换为使用返回的资源值设置的属性的类型。  
  
 资源键不一定是字符串。 例如，主题级别的控件样式被有意地键控到控件的 <xref:System.Type> 中，控件的应用程序或页面样式通常使用此相同的键约定。 有关详细信息，请参阅[样式设置和模板化](/dotnet/framework/wpf/controls/styling-and-templating)或[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
   
  
## Examples  
 下面的示例获取命名资源，并将其转换为适当的类型以填充属性。  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到 <paramref name="resourceKey" />，且事件管理器对于 <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件不存在。  
  
-或- 
 找不到 <paramref name="resourceKey" />，且 <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> 属性在 <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> 事件中为 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置方向，文本和其他 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 元素在任何控制其布局的父元素中都按此方向流动。</summary>
        <value>文本和其他 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 元素在它们的父元素中的流动方向，是一个枚举值。 默认值是 <see cref="F:System.Windows.FlowDirection.LeftToRight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖属性用法设置此元素上的 <xref:System.Windows.FrameworkElement.FlowDirection%2A>。 由于属性值继承，因此在元素上设置 <xref:System.Windows.FrameworkElement.FlowDirection%2A> 可能会在未 <xref:System.Windows.FrameworkElement.FlowDirection%2A> 本地或其他方式（如样式）上设置 <xref:System.Windows.FrameworkElement.FlowDirection%2A>。  
  
 此属性不会自动设置为任何应用程序区域性信息的一部分，因为元素可能包含不一定要遵循区域性信息隐含的一般流方向的内容。 有关全球化注意事项的详细信息，请参阅[WPF 的全球化](/dotnet/framework/wpf/advanced/globalization-for-wpf)。  
  
 此属性具有定义的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 属性访问器，因此它将作为依赖属性。 不过，它也注册为附加属性，因此它也可以作为附加属性。 附加的注册主要是为了支持属性值继承，但属性也可用作真正的附加属性。 仅当要设置流方向的对象具有执行布局的 <xref:System.Windows.FrameworkElement> 父元素时，附加属性用法才适用，它本身不是 <xref:System.Windows.FrameworkElement>，并且还没有更直接定义 `FlowDirection` 属性。 （某些流文档类（如 <xref:System.Windows.Documents.Block> 和 <xref:System.Windows.Documents.Inline> 定义它们自己的 `FlowDirection`，并且此属性还可以设置流方向。 然后，最终内容主机会读取属性值，而无需附加的属性用法。）  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
 \<*对象* **system.windows.flowdirection>**= "<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 还可以通过以下 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 附加属性用法，在不 <xref:System.Windows.FrameworkElement> 派生类的类上设置此属性：  
  
 `<`*对象*`FrameworkElement.`**system.windows.flowdirection>**= "<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 此属性既是依赖属性，也是附加属性;请参阅 "备注"。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个属性，该属性允许自定义此元素在捕获到键盘焦点时要应用于此元素的外观、效果或其他样式特征。</summary>
        <value>要应用于焦点的所需样式。 该依赖属性中声明的默认值是一个空的静态 <see cref="T:System.Windows.Style" />。 但是，运行时的有效值通常是（但并非总是）控件的主题支持所提供的样式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性会影响视觉外观，但不会在元数据中报告 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>。 这是因为视觉外观更改是事件驱动的，可能不会在任何时候都适用，因此通常不会在元数据中报告任何视觉对象或布局信息。  
  
 从概念上讲，应用于控件的焦点的视觉行为应与控件一致。 强制一致性的最明智方式是仅在编写整个主题时更改焦点视觉样式。 对单个控件样式设置此属性，而不是主题的一部分，这并不是此属性的预期用法，因为这可能会导致与键盘焦点有关的用户体验混乱。 如果要在主题中特意不连贯特定于控件的行为，一种更好的方法是在样式中使用各个输入状态属性（例如 <xref:System.Windows.UIElement.IsFocused%2A> 或 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>）的触发器，并以不会直观干扰任何现有焦点视觉样式的方式执行此操作。 有关 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> 和替代焦点属性的设计意图的详细信息，请参阅[为控件中的焦点设置样式和 FocusVisualStyle](/dotnet/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一：、或。 请参阅[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 该键引用 <xref:System.Windows.ResourceDictionary>中的现有资源。  
  
> [!NOTE]
>  属性元素语法在技术上是可行的，但不建议这样做。 请参阅[内联样式和模板](/dotnet/framework/wpf/advanced/inline-styles-and-templates)。 也可以使用[TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension)或 <xref:System.Windows.Data.Binding> 的绑定引用，但情况并不常见。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Windows.FrameworkElement" /> 是否应该强制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 按照 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 属性所声明的方式呈现光标。</summary>
        <value>如果强制光标在位于此元素（包括所有子元素）上时的呈现使用光标的当前 <see cref="P:System.Windows.FrameworkElement.Cursor" /> 设置，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为 `true` 将覆盖由子元素建立的游标首选项。 在一般的应用程序 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 中执行此操作可能会使用户感到困惑，特别是当子元素尝试指定游标时。 设置 <xref:System.Windows.FrameworkElement.ForceCursor%2A> 更适用于控件子类或复合方案。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例强制游标值。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ForceCursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要从中获取绑定的目标 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>返回表示指定属性的绑定的 <see cref="T:System.Windows.Data.BindingExpression" />。</summary>
        <returns>如果目标属性具有活动的绑定，则返回 <see cref="T:System.Windows.Data.BindingExpression" />；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检查 `null` 的返回值是一种技术，可用于确定属性是否具有活动绑定。  
  
 此方法实际上只是围绕 <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> 方法的便利包装。 <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> 将当前实例和 `dp` 参数传递给 <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">要为其返回 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 的元素。</param>
        <summary>获取指定的 <see cref="T:System.Windows.DependencyObject" /> 的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加属性值。</summary>
        <returns>所请求的流方向（作为一个枚举值）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的主要用途是支持 <xref:System.Windows.FrameworkElement.FlowDirection%2A> 属性的附加属性语法，因此，提供的 <xref:System.Windows.FrameworkElement> 的子元素可指定其父元素中的排列方向。 若要获取当前 <xref:System.Windows.FrameworkElement>上的值，请使用 "直接 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 访问器 <xref:System.Windows.FrameworkElement.FlowDirection%2A>"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">执行可视化演示的元素的部分大小。</param>
        <summary>返回剪切蒙版的形状。 如果布局系统尝试排列的元素大小超过可用显示空间，将会应用蒙版。</summary>
        <returns>剪切形状。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作为布局系统行为的一部分，将从 `layoutSlotSize` 中减去边距。  
  
 返回的空引用指示将不会进行剪辑。 当 <xref:System.Windows.UIElement.ClipToBounds%2A> `false`时，默认实现始终返回 `null`。 此方法重写 <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>。 <xref:System.Windows.FrameworkElement> 实现在其计算中使用 <xref:System.Windows.FrameworkElement.MaxHeight%2A> 和 <xref:System.Windows.FrameworkElement.MaxWidth%2A>。 <xref:System.Windows.FrameworkElement> 的多个子类将再次重写此方法。 <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>，重写始终返回 `null`，因为装饰器通常特意在普通边界之外。 如果 <xref:System.Windows.UIElement.ClipToBounds%2A> 为 `false`，则 <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> 和 <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> 返回 `null`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>当 <see cref="P:System.Windows.UIElement.ClipToBounds" /> <see langword="false" />时，默认实现始终返回 <see langword="null" />。 重写通常会保留此行为，尽管存在异常，具体取决于派生类及其布局逻辑相对于基类的关系和目的。</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">要查找的子级的名称。</param>
        <summary>返回实例化的 <see cref="T:System.Windows.Controls.ControlTemplate" /> 可视化树中的命名元素。</summary>
        <returns>请求的元素。 如果具有所请求名称的元素不存在，则可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 中的模板具有独立的名称范围。 这是因为模板是重复使用的，当控件的多个实例实例化其模板时，模板中定义的任何名称都不能保持唯一。 调用 <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> 方法，以返回对实例化后来自模板的对象的引用。 不能使用 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> 方法来查找模板中的项，因为 <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> 在更通用的作用域中操作，并且在应用了 <xref:System.Windows.Controls.ControlTemplate> 类本身与实例化模板之间没有任何连接。  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 提供与此方法相同的函数。 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> 是公共的，而不是受保护的，它将使用正确的名称范围注意事项，使其能够访问元素中的模板，并查找其中的已命名项。 如果需要在其父控件之外获取元素，请使用 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果没有视觉父级，则返回此元素的备用逻辑父级。</summary>
        <returns>当此方法的 WPF 框架级别实现具有非视觉父级连接时，即返回 <see langword="null" /> 之外的内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>。 默认 <xref:System.Windows.FrameworkElement> 实现返回预期的单个可视父级，这与获取 <xref:System.Windows.FrameworkElement.Parent%2A> 值的结果相同。 派生类实现可能返回备用的父关系。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">集合中请求的子元素的从零开始的索引。</param>
        <summary>重写 <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />，并从子元素集合中返回指定索引处的子元素。</summary>
        <returns>请求的子元素。 这不应返回 <see langword="null" />；如果提供的索引超出范围，则引发异常。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Windows.FrameworkElement> 实现中，唯一有效的索引为零。 <xref:System.Windows.FrameworkElement.GetVisualChild%2A> 的内容模型支持零个或一个子元素，而不是一个集合。  
  
   
  
## Examples  
 下面的示例演示自定义装饰器如何使用它为其多个视觉对象维护的 <xref:System.Windows.Media.VisualCollection> 所声明的值。 这些值通过 <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> 和 <xref:System.Windows.FrameworkElement.GetVisualChild%2A>的替代进行报告。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此实现仅对没有维护更具描述性的可视化子元素集合的元素有效。 确实具有此集合的任何元素都必须重写此方法，并将索引映射到该元素支持的子元素集合中的等效索引。 从零到 <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> （减1）的范围内的索引应返回有效的元素;任何其他索引应引发超出范围的异常。 支持子集合并覆盖 <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> 以返回多个可能的子级的元素类型的示例 <see cref="T:System.Windows.Controls.Panel" />。  
  
<see cref="T:System.Windows.FrameworkElement" /> 中的默认实现仅假定一个视觉对象。 为 <paramref name="index" /> 以外的任何值传递的任何值都将导致引发异常。 几个常见元素（如修饰器、装饰器或具有专用呈现的元素）会重写 <see cref="T:System.Windows.FrameworkElement" /> 实现（在中间基类中实现）。 某些实现仍强制实施一个视觉对象，而其他实现则允许集合。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的建议高度。</summary>
        <value>元素的高度（以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 为单位）。 默认值是 <see cref="F:System.Double.NaN" />。 此值必须等于或大于 0.0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> 是指定高度信息 <xref:System.Windows.FrameworkElement> 上三个可写的属性之一。 另外两个 <xref:System.Windows.FrameworkElement.MinHeight%2A> 和 <xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果这两个值之间存在冲突，则实际的高度决定的应用顺序是第一个 <xref:System.Windows.FrameworkElement.MinHeight%2A> 必须遵循，然后 <xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后，如果它在边界内，则为 <xref:System.Windows.FrameworkElement.Height%2A>。  
  
 如果此元素是某个其他元素内的子元素，则将此属性设置为值实际上只是一个建议值。 布局系统以及父元素的特定布局逻辑在布局过程中将使用该值作为非绑定的输入。 在实际情况下，<xref:System.Windows.FrameworkElement> 几乎始终是其他内容的子元素;即使在 <xref:System.Windows.Window>上设置 <xref:System.Windows.FrameworkElement.Height%2A> 也是如此。 （对于 <xref:System.Windows.Window>，当基础应用程序模型建立创建承载应用程序的 Hwnd 的基本呈现假设时，使用该值。）  
  
 除了可接受的 <xref:System.Double> 值外，还可以 <xref:System.Double.NaN?displayProperty=nameWithType>此属性。 这是在代码中指定自动调整大小行为的方式。 在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 将值设置为字符串 "Auto" （不区分大小写）以启用自动调整大小行为。 自动调整大小行为表示元素将填充其可用的高度。 但请注意，特定控件通常通过其默认主题样式来提供默认值，这些默认主题样式将禁用自动调整大小行为，除非专门重新启用。  
  
 此属性的返回值始终与任何设置为它的值相同。 相反，<xref:System.Windows.FrameworkElement.ActualHeight%2A> 的值可能会有所不同。 这可能是静态发生的，因为布局由于某种原因而拒绝建议大小，或者暂时发生。 布局系统本身的工作方式相对于属性系统的 <xref:System.Windows.FrameworkElement.Height%2A> 集，可能尚未处理过特定大小调整属性更改的情况。  
  
 <xref:System.Double> 值的值限制由 <xref:System.Windows.ValidateValueCallback> 机制强制执行。 如果尝试设置一个无效值，则会引发运行时异常。  
  
 除了验证检查，对于布局系统强制执行的 <xref:System.Windows.FrameworkElement.Height%2A> 还有一个不确定的上限值（这是一个非常大的数字，大于 <xref:System.Single.MaxValue?displayProperty=nameWithType> 但小于 <xref:System.Double.MaxValue?displayProperty=nameWithType>）。 如果超出此限制，元素将不会呈现，并且不会引发异常。 不要将 <xref:System.Windows.FrameworkElement.Height%2A> 设置为远远大于任何可能的视觉对象显示大小的最大大小的值，否则可能会超出此不确定性的上限。  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml
<object Height="double"/>  
```

-或-

```xaml
<object Height="qualifiedDouble"/>  
```

-或-

```xaml
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 请参阅“备注”以了解上限信息。 此值被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
 **Auto**  
 启用自动调整行为。 请参阅“备注”。  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Height" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在父元素(如 Panel 或项控件)中组合此元素时所应用的水平对齐特征。</summary>
        <value>水平对齐设置，它是一个枚举值。 默认为 <see cref="F:System.Windows.HorizontalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素上显式设置 <xref:System.Windows.FrameworkElement.Height%2A> 和 <xref:System.Windows.FrameworkElement.Width%2A> 属性时，这些度量值会在布局中获得更高的引用单元格，并取消将 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 设置为 <xref:System.Windows.HorizontalAlignment.Stretch>的典型效果。  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 是 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 属性访问器，对于实际上是依赖属性。 这个特定依赖属性在子类元素（特别是控件）中以不同的方式设置其外观。 这通常采用以下两种方式之一：依赖属性重新注册到特定子类，但使用不同的元数据设置其默认值;否则，将应用默认样式来设置该依赖属性值的不同值。 例如，<xref:System.Windows.Controls.Label> 控件的 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 的外观 "默认" 将 <xref:System.Windows.HorizontalAlignment.Left>，即使 <xref:System.Windows.Controls.Label> 从 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> 继承 <xref:System.Windows.FrameworkElement>直接。 这是因为此值在样式的控件模板内 <xref:System.Windows.Controls.Label>默认样式中重置。  
  
 <xref:System.Windows.Controls.Canvas> 在编写布局时不使用 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>，因为 <xref:System.Windows.Controls.Canvas> 基于绝对定位。  
  
 当由 <xref:System.Windows.Controls.Label> 或派生类继承时，<xref:System.Windows.Controls.Label> 将此依赖项属性的默认值重定义为 "<xref:System.Windows.HorizontalAlignment.Left>"。  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置属性值继承、资源键查找和RelativeSource FindAncestor 查找的范围限制。</summary>
        <value>枚举的一个值。 默认为 <see cref="F:System.Windows.InheritanceBehavior.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素树中的某些边界 <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> 来特意限制继承行为的范围、强制资源查找检查应用程序资源，或防止 RelativeSource FindAncestor 查找查询当前元素或其他元素。 当绑定使用 <xref:System.Windows.Data.RelativeSource.Mode%2A> 属性设置为 <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> 值的 <xref:System.Windows.Data.RelativeSource> 时，将发生 RelativeSource FindAncestor 查找。  
  
 如果希望派生类设置此属性，则应在静态构造函数或其他初始化例程中执行此操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化此 <see cref="T:System.Windows.FrameworkElement" /> 时发生。 此事件与 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 属性的值从 <see langword="false" />（或未定义）更改为 <see langword="true" /> 的情况相符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用 <xref:System.Windows.FrameworkElement.EndInit%2A> 或 <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> 方法时，将引发此事件。 对任一方法的调用都可以来自应用程序代码，或在处理 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 页时通过 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 处理器行为。  
  
 是否选择处理 <xref:System.Windows.FrameworkElement.Loaded> 或 <xref:System.Windows.FrameworkElement.Initialized> 取决于你的要求。 如果不需要读取元素属性，而想要重置属性，并且不需要任何布局信息，<xref:System.Windows.FrameworkElement.Initialized> 可能是要采取的更好事件。 如果需要元素的所有属性均可供使用，并且要设置可能重置布局的属性，<xref:System.Windows.FrameworkElement.Loaded> 可能是要执行操作的更好事件。 如果处理程序重置由布局系统解释的任何属性，以表示需要新的布局传递，请注意重入。 （如果您不确定哪些属性在更改时需要新的布局传递，则您可能需要检查属性的 <xref:System.Windows.FrameworkPropertyMetadata> 值。）  
  
 有关 <xref:System.Windows.FrameworkElement>的对象事件顺序以及多个相关应用程序和元素类的详细信息，请参阅[对象生存期事件](/dotnet/framework/wpf/advanced/object-lifetime-events)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Windows.FrameworkElement" /> 使用的输入的上下文。</summary>
        <value>解释输入范围，在该输入范围内修改从其他输入法输入的方式。 默认值为 <see langword="null" />（这将导致对命令的默认处理）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖属性继承属性值。 如果有子元素没有通过本地值或样式建立的 <xref:System.Windows.FrameworkElement.InputScope%2A> 的其他值，则属性系统会将该值设置为已分配此值的最近上级元素的 <xref:System.Windows.FrameworkElement.InputScope%2A> 值。  
  
 尽管列出了 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法用法并且在语法上是允许的，但在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 中设置此属性并不常见。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.InputScope" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值表示该元素是否在由 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器进行处理时，或者通过显式调用其 <see cref="M:System.Windows.FrameworkElement.EndInit" /> 方法被初始化。</summary>
        <value>如果该元素按照前面提到的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理或者方法调用已被初始化，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素已在逻辑树中移动，以使其具有新的父元素，并因此再次加载，则此属性也可能 `true`。  
  
 如果还在使用 <xref:System.Windows.FrameworkElement.BeginInit%2A> 和 <xref:System.Windows.FrameworkElement.EndInit%2A>，则此属性很有用。 可以确保初始化由 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器加载的逻辑树中的元素。 调用 <xref:System.Windows.FrameworkElement.EndInit%2A> 时，将初始化不在逻辑树中的元素。 如果没有任何特定的 <xref:System.Windows.FrameworkElement.BeginInit%2A> 和 <xref:System.Windows.FrameworkElement.EndInit%2A>处理，则在构造函数返回初始化的结果后，就会发生这种情况。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已加载此元素以供呈现。</summary>
        <value>如果当前元素被附加到元素树，则为 <see langword="true" />；如果该元素从未附加到所加载的元素树，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从新构造的 <xref:System.Windows.FrameworkElement>中，此属性将在设置为 `true`后开始 `false`，并保持 `true`，即使该元素随后通过代码从连接的逻辑树中删除也是如此。 当元素加载到表示引擎时，`true` 状态由常规表示逻辑设置。  
  
 通常情况下，将呈现加载的元素，但不是所有 <xref:System.Windows.FrameworkElement> 派生类都有演示，其他属性（如 <xref:System.Windows.UIElement.Visibility%2A>）可能会影响演示。  
  
   
  
## Examples  
 下面的示例实现了两个处理程序：一个处理程序正在处理根元素的 <xref:System.Windows.FrameworkElement.Loaded> 事件，因此，因为这是事件的重要性，所以请确保加载页面根元素。 其他处理程序与用户控件挂钩，并调用 <xref:System.Windows.FrameworkElement.IsLoaded%2A> 以确保完全加载根元素。 这两个处理程序调用将用新数据填充子元素的相同函数（未显示）。  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用于某个元素的本地化/全球化语言信息。</summary>
        <value>此元素的语言信息。 默认值为 <see cref="T:System.Windows.Markup.XmlLanguage" />，它的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值设置为字符串 "zh-CN"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串格式遵循 RFC 3066 标准。 例如，美国英语为 "en-us"。 有关值和格式的详细信息，请参阅 <xref:System.Windows.Markup.XmlLanguage>。  
  
 此依赖属性继承属性值。 如果有子元素没有通过本地值或样式建立 <xref:System.Windows.FrameworkElement.Language%2A> 的其他值，则属性系统会将该值设置为已分配此值的最近上级元素的 <xref:System.Windows.FrameworkElement.Language%2A> 值。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 定义 `xml:lang` 特性的一般含义。 <xref:System.Windows.FrameworkElement.Language%2A> 实质上是将此属性的含义公开为依赖属性。 可以通过编程方式调整 <xref:System.Windows.FrameworkElement.Language%2A>，并以与 `xml:lang` 属性可以继承到 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]中的子元素范围相同的方式参与属性系统值继承。 如果设置 <xref:System.Windows.FrameworkElement.Language%2A>，该值将成为 `xml:lang` 并覆盖以前的任何值。 有关详细信息，请参阅[XAML 中的 xml： Lang 处理](/dotnet/framework/xaml-services/xml-lang-handling-in-xaml)。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Language" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在执行布局时应该应用于此元素的图形转换方式。</summary>
        <value>此元素应该使用的转换。 默认为 <see cref="P:System.Windows.Media.Transform.Identity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与 <xref:System.Windows.UIElement.RenderTransform%2A>相比，<xref:System.Windows.FrameworkElement.LayoutTransform%2A> 将影响布局的结果。  
  
 设置转换可提供缩放和旋转的强大功能。 但 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 将忽略 <xref:System.Windows.Media.TranslateTransform> 操作。 这是因为的子 <xref:System.Windows.FrameworkElement> 元素的布局系统行为会自动校正到已缩放或旋转元素位置的任何偏移量，以作为父元素的布局和坐标系统。  
  
 如果在不需要布局系统进行完全传递的方案中调用，<xref:System.Windows.FrameworkElement.LayoutTransform%2A> 可能导致应用程序性能下降。 将 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 应用到 <xref:System.Windows.Controls.Panel>的 <xref:System.Windows.Controls.Panel.Children%2A> 集合时，它会触发布局系统的新传递，并强制值和重新排列所有屏幕对象。 如果要更新 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]的完整应用程序，则此功能可能正是您所需要的。 但是，如果不需要完全布局处理过程，请使用 <xref:System.Windows.UIElement.RenderTransform%2A> 属性，该属性不会调用布局系统，因此通常是此方案的更好选择。  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 有用的示例方案包括：将元素（如菜单组件）从水平旋转到垂直，反之亦然，缩放元素（放大）焦点，提供编辑行为，等等。  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例演示如何将 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 应用到元素。 该示例创建一个 <xref:System.Windows.Controls.Button> 实例，并将其托管在父 <xref:System.Windows.Controls.Grid>内。 它还使用 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> 属性将 <xref:System.Windows.Media.RotateTransform> 应用到 <xref:System.Windows.Controls.Button>。  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">二维转换示例</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.LayoutTransform" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当对元素进行布局、呈现，且可将其用于交互时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> 通常是在元素初始化序列中引发的最后一个事件。 它将始终在 <xref:System.Windows.FrameworkElement.Initialized>后引发。 是否选择处理 <xref:System.Windows.FrameworkElement.Loaded> 或 <xref:System.Windows.FrameworkElement.Initialized> 取决于你的要求。 如果不需要读取元素属性，而想要重置属性，并且不需要任何布局信息，<xref:System.Windows.FrameworkElement.Initialized> 可能是要采取的更好事件。 如果需要元素的所有属性均可供使用，并且要设置可能重置布局的属性，<xref:System.Windows.FrameworkElement.Loaded> 可能是要执行操作的更好事件。 如果处理程序重置由布局系统解释的任何属性，以表示需要新的布局传递，请注意重入。 （如果您不确定哪些属性在更改时需要新的布局传递，则您可能需要检查属性的 <xref:System.Windows.FrameworkPropertyMetadata> 值。）  
  
 有关 <xref:System.Windows.FrameworkElement>的对象事件顺序以及多个相关应用程序和元素类的详细信息，请参阅[对象生存期事件](/dotnet/framework/wpf/advanced/object-lifetime-events)。  
  
 直接路由事件不遵循路由，它们只能在引发它们的同一元素内进行处理。 直接路由事件支持其他路由事件行为：它们支持可访问的处理程序集合，并且可用作样式中的 <xref:System.Windows.EventTrigger>。  
  
 由于用户启动的系统主题更改，<xref:System.Windows.FrameworkElement.Loaded> 和 <xref:System.Windows.FrameworkElement.Unloaded> 可能会在控件上引发。 主题更改会导致控件模板和包含的可视化树失效，这进而导致整个控件被卸载和重新加载。 因此 <xref:System.Windows.FrameworkElement.Loaded> 无法假定仅在第一次通过导航到页面时才会发生。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.Loaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑子元素的一个枚举器。</summary>
        <value>此元素的逻辑子元素的一个枚举数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 允许遍历子元素。 这适用于可能不具有已定义专用集合但仍包含多个子元素（特别是 <xref:System.Windows.FrameworkContentElement> 子元素）的元素。  
  
 有关如何使用 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> 和 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>的详细信息，请参阅[WPF 中的树](/dotnet/framework/wpf/advanced/trees-in-wpf)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array 标记扩展</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的外边距。</summary>
        <value>提供元素的边距值。 默认值是所有属性都等于 0（零）的 <see cref="T:System.Windows.Thickness" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 边距是在布局创建 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]时此元素和其他将相邻的元素之间的空间。 共享的元素可能是对等元素（例如公共父控件的集合中的其他元素），也可能是此元素的父级。  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> 设置为 <xref:System.Windows.Thickness> 结构而不是一个数字，以便可以以非对称方式设置边距。 <xref:System.Windows.Thickness> 结构本身支持字符串类型转换，因此，也可以 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 特性语法指定非对称 <xref:System.Windows.FrameworkElement.Margin%2A>。  
  
 非零边距在元素布局的 <xref:System.Windows.FrameworkElement.ActualWidth%2A> 和 <xref:System.Windows.FrameworkElement.ActualHeight%2A>之外应用空间。  
  
 对于布局中的同级元素，边距是累加的;例如，如果两个相邻的元素在相邻边缘上都设置为30，则它们之间的空间间距将为60。  
  
 如果为边距和元素内容区域分配的矩形空间不够大，则具有边距设置的元素通常不会限制指定 <xref:System.Windows.FrameworkElement.Margin%2A> 的大小。 当计算布局时，元素内容区域将受到约束。 如果内容已被约束为零，则只会对边距进行约束。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml  
<object Margin="left,top,right,bottom"/>  
```

-或-

```xaml
<object Margin="left,top"/>  
```

-或-  

```xaml
<object Margin="thicknessReference"/>  
```

<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *左、上、右、下*  
 介于0和 <xref:System.Double.PositiveInfinity> 之间的数值，用于指定 <xref:System.Windows.Thickness> 结构的四个可能的维度属性。  
  
 属性用法还会接受以对称方式和逻辑方式应用的顺序应用的缩略值。 例如，`Margin="20"` 将被解释为表示 <xref:System.Windows.Thickness> 并将所有属性设置为20。 `Margin="20,50"` 将被解释为表示 <xref:System.Windows.Thickness.Left%2A> 和 <xref:System.Windows.Thickness.Right%2A> 的 <xref:System.Windows.Thickness> 设置为20，<xref:System.Windows.Thickness.Top%2A> 和 <xref:System.Windows.Thickness.Bottom%2A> 设置为50。  
  
 <xref:System.Windows.Thickness> 度量值的默认单位为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]。 还可以通过将单元类型字符串追加到任何度量值 `cm`、`in`或 `pt` 来指定其他单位。  
  
 作为 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 属性提供的数字值不需要指定小数点（0是可接受的，无需作为0.0 提供）。 有关 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 用法的详细信息，请参阅 <xref:System.Windows.Thickness>。  
  
 *thicknessReference*  
 对现有 <xref:System.Windows.Thickness>的对象引用。 这可能是 `}`、或 `}` 引用。 有关 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 用法的详细信息，请参阅 <xref:System.Windows.Thickness>。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Margin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最大高度约束。</summary>
        <value>元素的最大高度（以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 为单位）。 默认值是 <see cref="F:System.Double.PositiveInfinity" />。 该值可以是等于或大于 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也是有效的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是 <xref:System.Windows.FrameworkElement> 中指定高度信息的三个属性之一。 另外两个 <xref:System.Windows.FrameworkElement.MinHeight%2A> 和 <xref:System.Windows.FrameworkElement.Height%2A>。  如果这两个值之间存在冲突，则必须先使用应用程序的实际顺序确定，然后 <xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后，如果其中每个 <xref:System.Windows.FrameworkElement.MinHeight%2A> 都在界限内，<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 <xref:System.Double> 值的值限制由 <xref:System.Windows.ValidateValueCallback> 机制强制执行。 如果尝试设置无效的值，则会引发运行时异常。  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml  
<object MaxHeight="double"/>  
```

-或-

```xaml
<object MaxHeight ="qualifiedDouble"/>  
```

<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 这被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 与属性值部分中提到的 <xref:System.Double> 范围限制相同，不同之处在于，如果需要显式设置要 <xref:System.Double.PositiveInfinity>的值，则必须使用[X:Static 标记扩展](/dotnet/framework/xaml-services/x-static-markup-extension)。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MaxHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最大宽度约束。</summary>
        <value>元素的最大宽度，单位是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值是 <see cref="F:System.Double.PositiveInfinity" />。 该值可以是等于或大于 0.0 的任何值。 <see cref="F:System.Double.PositiveInfinity" /> 也是有效的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是 <xref:System.Windows.FrameworkElement> 中指定宽度信息的三个属性之一。 另外两个 <xref:System.Windows.FrameworkElement.MinWidth%2A> 和 <xref:System.Windows.FrameworkElement.Width%2A>。 如果这两个值之间存在冲突，则必须先执行实际的宽度确定的应用程序顺序，然后 <xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后，如果其中每个 <xref:System.Windows.FrameworkElement.MinWidth%2A> 都在界限内，<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 <xref:System.Double> 值的值限制由 <xref:System.Windows.ValidateValueCallback> 机制强制执行。 如果尝试设置一个无效值，则会引发运行时异常。  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml 
<object MaxWidth="double"/>  
```

-或-

```xaml
<object MaxWidth="qualifiedDouble"/>  
```

<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 这被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 与属性值部分中提到的 <xref:System.Double> 范围限制相同，不同之处在于必须使用[X:Static 标记扩展](/dotnet/framework/xaml-services/x-static-markup-extension)将值设置为 <xref:System.Double.PositiveInfinity>。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MaxWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">父元素可以赋予子元素的可用大小。</param>
        <summary>实现 <see cref="T:System.Windows.FrameworkElement" /> 的基本度量传递布局系统行为。</summary>
        <returns>此元素在布局中的所需大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将重写 <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>，以连接 WPF 核心级和 WPF 框架级布局度量实现。 <xref:System.Windows.FrameworkElement> 实现会密封方法。 若要调整在 WPF 框架级别上生成的任何元素的度量值传递布局行为，请改为重写 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>。 若要调整特意不在 WPF 框架级别或使用 <xref:System.Windows.FrameworkElement>上生成的元素的度量值传递布局行为，请重写 <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">此元素可提供给子元素的可用大小。 可指定无穷大作为一个值，该值指示元素将调整到适应内容的大小。</param>
        <summary>在派生类中重写时，测量子元素在布局中所需的大小，并确定由 <see cref="T:System.Windows.FrameworkElement" /> 派生的类的大小。</summary>
        <returns>此元素基于其对子元素大小的计算确定它在布局期间所需要的大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> 以实现元素在 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 布局系统中的自定义布局大小调整行为。 你的实现应执行以下操作：  
  
1.  循环访问作为布局一部分的元素的特定子集合，对每个子元素调用 <xref:System.Windows.UIElement.Measure%2A>。  
  
2.  立即获取子级的 <xref:System.Windows.UIElement.DesiredSize%2A> （在调用 <xref:System.Windows.UIElement.Measure%2A> 后，此设置为属性）。  
  
3.  根据子元素的度量计算父级所需的净大小。  
  
 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> 的返回值应为元素自己所需的大小，该大小随后将成为当前元素的父元素的度量输入。 此过程将一直通过布局系统，直到到达页面的根元素。  
  
 在此过程中，子元素返回的 <xref:System.Windows.UIElement.DesiredSize%2A> 大小可能大于初始 `availableSize`，以指示子元素需要更多空间。 这可以在自己的实现中进行处理，方法是引入一个可滚动区域，通过调整父控件的大小，通过建立一些堆叠顺序或任意数量的解决方案来测量或排列内容。  
  
> [!IMPORTANT]
>  在此过程中，元素应在每个子元素上调用 <xref:System.Windows.UIElement.Measure%2A>，否则，将不会正确调整或排列子元素的大小。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>下面的非编译代码显示了此实现模式。  <c>VisualChildren</c>表示你自己的元素应定义的子元素的可枚举集合属性。 属性可以命名为任意名称。 <c>VisualChildren</c>是占位符名称。在此示例中， <c>VisualChildren</c>不是 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 或命名模式的一部分提供的 API。 
  
[！ code-csharp[CorePseudocode # FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)][！ code-vb[CorePseudocode # FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最小高度约束。</summary>
        <value>在 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 中，元素的最小高度。 默认值为 0.0。 该值可以是等于或大于 0.0 的任何值。 但是，<see cref="F:System.Double.PositiveInfinity" /> 无效，<see cref="F:System.Double.NaN" /> 也无效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是 <xref:System.Windows.FrameworkElement> 中指定高度信息的三个属性之一。  另外两个 <xref:System.Windows.FrameworkElement.Height%2A> 和 <xref:System.Windows.FrameworkElement.MaxHeight%2A>。 如果这两个值之间存在冲突，则必须先使用应用程序的实际顺序确定，然后 <xref:System.Windows.FrameworkElement.MaxHeight%2A>，最后，如果其中每个 <xref:System.Windows.FrameworkElement.MinHeight%2A> 都在界限内，<xref:System.Windows.FrameworkElement.Height%2A>。  
  
 <xref:System.Double> 值的值限制由 <xref:System.Windows.ValidateValueCallback> 机制强制执行。 如果尝试设置一个无效值，则会引发运行时异常。  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml
<object MinHeight="double"/>  
```

-或-

```xaml
<object MinHeight="qualifiedDouble"/>  
```

<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 这被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 "属性值" 一节中提到的 <xref:System.Double> 范围限制相同。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MinHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的最小宽度约束。</summary>
        <value>元素的最小宽度，单位是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]。 默认值为 0.0。 该值可以是等于或大于 0.0 的任何值。 但是，<see cref="F:System.Double.PositiveInfinity" /> 无效，<see cref="F:System.Double.NaN" /> 也无效。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是 <xref:System.Windows.FrameworkElement> 中指定宽度信息的三个属性之一。  另外两个 <xref:System.Windows.FrameworkElement.Width%2A> 和 <xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果这两个值之间存在冲突，则必须先执行实际的宽度确定的应用程序顺序，然后 <xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后，如果其中每个 <xref:System.Windows.FrameworkElement.MinWidth%2A> 都在界限内，<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 <xref:System.Double> 值的值限制由 <xref:System.Windows.ValidateValueCallback> 机制强制执行。 如果尝试设置一个无效值，则会引发运行时异常。  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml 
<object MinWidth="double"/>  
```

-或-

```xaml
<object MinWidth="qualifiedDouble"/>  
```
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 这被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 "属性值" 一节中提到的 <xref:System.Double> 范围限制相同。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.MinWidth" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">焦点要移动的方向，作为一个枚举值。</param>
        <summary>以提供的遍历方向将键盘焦点从此元素移到其他元素上。</summary>
        <returns>如果焦点移动成功，则返回 <see langword="true" />；如果指定方向上不存在目标元素，或者未能将键盘焦点移到目标元素上，则返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现将重写 <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> 并密封方法。  
  
   
  
## Examples  
 下面的示例实现处理几个可能的按钮输入的处理程序。 每个按钮都表示一个可能的 <xref:System.Windows.Input.FocusNavigationDirection>。 处理程序使用当前的键盘焦点跟踪元素，并通过将相应的 <xref:System.Windows.Input.FocusNavigationDirection> 指定为提供的 <xref:System.Windows.Input.TraversalRequest> 类型参数的初始化，对该元素调用 <xref:System.Windows.FrameworkElement.MoveFocus%2A>。  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的标识名称。 该名称提供引用，以便代码隐藏（如事件处理程序代码）可以引用标记元素（在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 处理器的处理过程中构造该元素之后）。</summary>
        <value>元素的名称。 默认值为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性最常见的用法是将 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 元素名称指定为标记中的属性。  
  
 此属性实质上提供了一个 WPF 框架级别的方便属性来设置 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X：Name 指令](/dotnet/framework/xaml-services/x-name-directive)。  
  
 名称在名称范围内必须是唯一的。 有关详细信息，请参阅 [WPF XAML Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes)。  
  
 如果你在代码中创建元素不常用，则获取 <xref:System.Windows.FrameworkElement.Name%2A>。 如果已在代码中正确引用，则只需调用元素引用的方法和属性，通常不需要 <xref:System.Windows.FrameworkElement.Name%2A>。 这种情况的一个例外是，如果 <xref:System.Windows.FrameworkElement.Name%2A> 字符串具有一些重载含义（例如，如果在 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]中显示该名称很有用）。 如果也不建议从标记设置原始 <xref:System.Windows.FrameworkElement.Name%2A>，则从代码隐藏设置 <xref:System.Windows.FrameworkElement.Name%2A>，并且在加载 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 后更改属性将不会更改原始对象引用。 仅当在分析期间显式创建了基础名称范围时，才会创建对象引用。 必须专门调用 <xref:System.Windows.FrameworkElement.RegisterName%2A>，才能对已加载元素的 <xref:System.Windows.FrameworkElement.Name%2A> 属性进行有效更改。  
  
 从代码中设置 <xref:System.Windows.FrameworkElement.Name%2A> 很重要的一种情况是，为演示图板将针对其运行的元素注册名称，以便可以在运行时引用它们。 注册名称之前，可能还需要实例化并分配一个 <xref:System.Windows.NameScope> 实例。 请参阅 "示例" 部分或[情节提要概述](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview)。  
  
 从代码设置 <xref:System.Windows.FrameworkElement.Name%2A> 具有有限的应用程序，但通过 <xref:System.Windows.FrameworkElement.Name%2A> 获取元素更常见。 一种特殊情况是，如果您的应用程序支持将页面重新加载到应用程序中的导航模型，并且运行时代码不一定要为该页定义代码隐藏。 实用工具方法 <xref:System.Windows.FrameworkElement.FindName%2A>（可从任何 <xref:System.Windows.FrameworkElement>获取）可以在该元素的逻辑树中 <xref:System.Windows.FrameworkElement.Name%2A> 来查找任何元素，并根据需要递归搜索树。 或者，您可以使用 <xref:System.Windows.LogicalTreeHelper>的 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 静态方法，该方法也采用 <xref:System.Windows.FrameworkElement.Name%2A> 字符串作为参数。  
  
 通常使用的根元素（例如<xref:System.Windows.Window>）实现接口 <xref:System.Windows.Controls.Page>，<xref:System.Windows.Markup.INameScope>。 此接口的实现应强制要求名称在其范围内明确。 定义此接口的根元素还定义所有相关 Api 的名称范围行为边界。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> 属性还作为其他进程的标识符。 例如，[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 自动化模型将使用与客户端和提供程序的 AutomationId <xref:System.Windows.FrameworkElement.Name%2A>。  
  
 用于 <xref:System.Windows.FrameworkElement.Name%2A> 的字符串值具有某些限制，这是由 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 规范定义的基础[X：Name 指令](/dotnet/framework/xaml-services/x-name-directive)施加的。 最值得注意的是，<xref:System.Windows.FrameworkElement.Name%2A> 必须以字母或下划线字符（_）开头，并且必须仅包含字母、数字或下划线。 有关详细信息，请参阅 [WPF XAML Namescopes](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes)。  
  
 <xref:System.Windows.FrameworkElement.Name%2A> 是不能进行动画处理的几个依赖项属性之一（<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 在元数据中 `true`），因为该名称本身对于目标为动画是至关重要的。 数据绑定 <xref:System.Windows.FrameworkElement.Name%2A> 在技术上是可行的，但这种情况非常少见，因为数据绑定 <xref:System.Windows.FrameworkElement.Name%2A> 无法提供属性的主要预期用途：为代码隐藏提供标识符连接点。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.NameProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 下面的示例在代码中设置 <xref:System.Windows.FrameworkElement.Name%2A> 属性，然后通过调用 <xref:System.Windows.FrameworkElement.RegisterName%2A>将该名称注册到新创建的 <xref:System.Windows.NameScope> 中。 此处所示的技术是使用情节提要进行动画处理的一项要求，因为情节提要需要 <xref:System.Windows.FrameworkElement.Name%2A>目标，并且不能以对象引用为目标。  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Name" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，每当应用程序代码或内部进程调用 <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />，都将调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。  
  
 模板是元素完成的可视化树的一部分，它来自应用于该元素的 <xref:System.Windows.Style> 的模板属性。 有关详细信息，请参阅[样式设置和模板化](/dotnet/framework/wpf/controls/styling-and-templating)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkElement" /> 的派生类可以使用此方法作为各种可能方案的通知： 
-您可以调用自己的代码实现，以生成元素可视化树的其余部分。  
  
-您可以运行依赖于已应用的模板的可视化树的代码，例如获取模板中命名元素的引用。  
  
-您可以引入仅在模板中的可视树完成后存在的服务。  
  
-可以设置模板中依赖于其他因素的元素的状态和属性。 例如，属性值只能通过知道父元素或特定派生类使用通用模板来发现。  
  
实施者应始终在其自身实现之前调用基实现。 <see cref="T:System.Windows.FrameworkElement" /> 本身没有默认实现，但干预类可能。  
  
 <see cref="T:System.Windows.Controls.Control" /> 提供了类似的替代，<see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 如果继承中的中间类已经实现了此方法，则仍应调用基实现。  
  
 此方法的目的有些类似于 * 方法上 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：它提供了用类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可能是由子元素（而不是将调用处理程序的元素）引发的，因此，您的实现需要将事件参数的源属性考虑（并且在大多数情况下不应尝试重新引发事件）。 当沿路由收到事件时，<xref:System.Windows.FrameworkElement> 的子类可以选择调用私有类处理程序方法。 一种可能的情况是采用事件的参数，并特意将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 如果继承中的中间类已经实现了此方法，则仍应调用基实现。  
  
 此方法的目的有些类似于 * 方法上 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：它提供了用类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可能是由子元素（而不是将调用处理程序的元素）引发的，因此，您的实现需要将事件参数的源属性考虑（并且在大多数情况下不应尝试重新引发事件）。 当沿路由收到事件时，<xref:System.Windows.FrameworkElement> 的子类可以选择调用私有类处理程序方法。 一种可能的情况是采用事件的参数，并特意将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.UIElement.GotFocus" /> 事件在其路由中到达此元素时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与基元素公开的其他 On * 方法不同，<xref:System.Windows.FrameworkElement.OnGotFocus%2A> 具有默认实现。 具体而言，它具有一个实现，该实现替代下一级基本元素中的 null 实现，<xref:System.Windows.UIElement.OnGotFocus%2A>。 调用时，如果由于键盘焦点导致事件源自当前元素，则 <xref:System.Windows.FrameworkElement.OnGotFocus%2A> 在此元素上设置相应的焦点行为。 即使将焦点设置为当前元素，<xref:System.Windows.FrameworkElement.OnGotFocus%2A> 处理程序也不会将事件参数标记为已处理。 如果事件的源是树中的另一个元素（而不是当前元素），则处理程序不执行任何操作。  
  
 您可以重写此方法以更改元素上的默认焦点行为，但是请注意，通过这种方式更改焦点行为可能会更好，因为根本不允许元素获得焦点（请参阅 <xref:System.Windows.UIElement.Focusable%2A>）。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果打算在参数中将事件标记为已处理，则应注意元素树中其他父元素中事件处理的结果。 由于此处理程序使用冒泡路由处理事件，因此，根据事件参数将焦点设置为当前 <paramref name="sender" /> 可能不合适。 焦点可能需要转到复合子元素或父元素，具体取决于特定控件的组合。 因此，仅建议将焦点事件标记为 "已处理"，前提是该事件要路由到的整个可视化树都是您创作的控件组合的一部分。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.FrameworkElement.Initialized" /> 事件。 每当在内部将 <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> 设置为 <see langword="true" /> 时调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此特定于 * 方法不是类处理程序挂钩。 它也不会完全遵循建立的 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] On * 方法约定，可以通过重写此方法而不调用基实现来取消匹配的事件。  
  
 请注意，<xref:System.Windows.FrameworkElement.IsInitialized%2A> 属性是只读的，因此无法将 <xref:System.Windows.FrameworkElement.IsInitialized%2A> 设置为强制初始化行为。 设置初始化状态仅适用于 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 框架。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此虚方法的默认实现将引发上述事件。 重写应调用基实现来保留此行为。 如果无法调用基实现，则不仅会像 <see cref="T:System.Windows.FrameworkElement" /> 派生类那样通常引发 <see cref="E:System.Windows.FrameworkElement.Initialized" /> 事件，还会取消此基实现实现的两个重要样式和主题样式初始化操作。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">描述已更改的属性的事件数据（包括旧值和新值）。</param>
        <summary>每当更新此 <see cref="T:System.Windows.FrameworkElement" /> 的任何依赖属性的有效值时调用。 将在实参形参中报告已更改的特定依赖属性。 重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法并不用于通常检测属性更改或失效。 它用于在了解有关属性的广泛分类的特定信息时进行常规失效模式的修改。  
  
 在对象的整个生存期内，可能会多次调用此方法。 因此，如果你重写特定属性的元数据，然后为单个属性附加 <xref:System.Windows.CoerceValueCallback> 或 <xref:System.Windows.PropertyChangedCallback> 函数，则可以获得更好的性能。 但是，如果 <xref:System.Windows.FrameworkElement> 包含大量与值相关的依赖项属性，则可以使用此方法，或者，如果包含的是必须重新运行的逻辑（如属性失效的几个相关案例），则应使用此方法。  
  
 请注意，有一个名称相同的 `OnPropertyChanged` 方法，该方法具有不同的签名（参数类型为 <xref:System.ComponentModel.PropertyChangedEventArgs>），该方法可出现在多个类中。 该 `OnPropertyChanged` 用于数据对象通知，并且属于 <xref:System.ComponentModel.INotifyPropertyChanged>的协定的一部分。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>始终调用基实现，作为实现中的第一个操作。 否则，将明显禁用整个 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统，从而导致报告错误的值。 特定 <see cref="T:System.Windows.FrameworkElement" /> 实现还负责为影响可见用户界面的各种属性维护适当的状态。 这包括在适当的时间基于样式的更改使可视化树失效。</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">更改中所涉及新旧大小的详细信息。</param>
        <summary>引发 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 事件，将指定的信息用作最终事件数据的一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>。 如果调用此方法，则将重置 <xref:System.Windows.FrameworkElement.ActualWidth%2A> 属性、<xref:System.Windows.FrameworkElement.ActualHeight%2A> 属性，或同时重置这两种方法，具体取决于在所提供的参数中指定为已更改的内容，并将始终引发事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>不要为典型布局方案重写此方法。 布局系统以特意异步的方式运行，以确保考虑所有可能的布局排列和度量事例。 布局系统替代方法 <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> 和 <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> 通常足以满足任何所需的布局自定义。 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> 公开为虚拟。 您可以重写 <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> 以便更正与在响应中与控件重新组合相关的输入事件相关的运行时行为更改的异常情况。  
  
你仍可以在派生类中重写此方法（它是受保护的但不是密封的）。 始终调用基实现以保留上面提到的行为，除非您有很具体的原因要禁用默认的 WPF 框架级呈现行为。 如果使用标准的 WPF 框架级别布局系统实现，则未能引发 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 事件将导致非标准布局行为。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">旧样式。</param>
        <param name="newStyle">新样式。</param>
        <summary>当此元素上使用的样式更改时（将使布局失效）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有一个默认实现，该实现用于设置说明样式更改条件的内部标志。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>通常不应重写此方法。 涉及度量值或排列更改的样式的任何更改都将触发另一个呈现周期，假设 <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />的典型实现  / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />或默认值。 如果 <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> / <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> 实现有意优化或支持部分更新，但仍希望更直接地将更改应用于样式，则 <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> 的替代可能适用。 （部分更新会尝试避免对任何子元素上的 <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> 和 <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> 进行多次增量调用。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当未处理的 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 如果继承中的中间类已经实现了此方法，则仍应调用基实现。  
  
 此方法的目的有些类似于 * 方法上 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：它提供了用类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可能是由子元素（而不是将调用处理程序的元素）引发的，因此，您的实现需要将事件参数的源属性考虑（并且在大多数情况下不应尝试重新引发事件）。 当沿路由收到事件时，<xref:System.Windows.FrameworkElement> 的子类可以选择调用私有类处理程序方法。 一种可能的情况是采用事件的参数，并特意将事件标记为已处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法没有默认实现。 如果继承中的中间类已经实现了此方法，则仍应调用基实现。  
  
 此方法的目的有些类似于 * 方法上 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 事件模式：它提供了用类处理程序而不是实例处理程序来处理来自派生类的匹配事件的方法。 在这种情况下，匹配事件是路由事件。 对于路由事件，On * 方法的实现模式是不同的，因为路由事件可能是由子元素（而不是将调用处理程序的元素）引发的，因此，您的实现需要将事件参数的源属性考虑（并且在大多数情况下不应尝试重新引发事件）。 当沿路由收到事件时，<xref:System.Windows.FrameworkElement> 的子类可以选择调用私有类处理程序方法。 一种可能的情况是获取事件的参数，并特意将事件标记为已处理以缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">旧的父元素。 可能是 <see langword="null" />，指示元素之前没有可视父级。</param>
        <summary>当此元素父级在可视化树中发生更改时进行了调用。 重写 <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可视化树可能不同于逻辑树，因为它会忽略不以视觉方式呈现的元素（例如集合），并根据其主题和样式组合展开某些元素。 有关详细信息，请参见 [WPF 中的树](/dotnet/framework/wpf/advanced/trees-in-wpf)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此虚方法的默认实现将查询新父代，引发各种初始化事件，并根据需要设置有关 <see cref="T:System.Windows.FrameworkElement" /> 初始化状态的内部标志。 最后，它将调用由 <see cref="T:System.Windows.UIElement" />声明的后续基本实现，而后者又会在 <see cref="T:System.Windows.Media.Visual" />中调用其基础。 始终调用基实现以保留此行为，否则，如果声明为另一个元素的子元素，则此元素的元素树行为可能不符合预期。  
  
一些现有 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 类会重写此方法，例如： <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />，<see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />。 最常见的方案是强制新的父项必须是特定类型。 如果新父级未能通过某种方式进行类型测试，这可能涉及到引发异常。 此方案的专用版本存在于列表项和菜单项的实现中，这些列表项和菜单项在拥有适当集合以存储它们的父视觉对象之外没有任何意义。 请注意，这种情况并不一定会引发异常，因为可能存在依赖于重新设置父级元素的设计器方案，这些元素暂时没有 "常规" 父级。  
  
此方法也会在通常为根元素的某些元素（如 <see cref="T:System.Windows.Window" />）中重写。 另一种情况是元素，这些元素是标记中的元素，但会在编译的逻辑树中自动生成更大的基础结构（如 <see cref="T:System.Windows.Controls.Page" />）。 <see cref="T:System.Windows.Window" /> 和 <see cref="T:System.Windows.Controls.Page" /> 实现有意密封方法。</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素是否并入主题样式中的样式属性。</summary>
        <value>如果此元素不使用主题样式属性，则为 <see langword="true" />；所有源于样式的属性均来自本地应用程序样式，不会应用主题样式属性。 如果首先应用了应用程序样式，然后将主题样式应用于未在应用程序样式中专门设置的属性，则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性最常见的用法是在提供主题样式的样式的资源库中间接使用。  
  
> [!IMPORTANT]
>  如果将 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 设置为在控件上 `true`，则将禁止主题样式提供的默认控件模板。 该控件模板通常包括内容呈现器和其他为控件提供基本 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 功能和可视化的复合元素。 如果希望控件继续支持与默认主题样式相同的功能，则必须使用复制相同结构的控件模板提供替换样式。 有关详细信息，请参阅[控件创作概述](/dotnet/framework/wpf/controls/control-authoring-overview)。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑父元素。</summary>
        <value>此元素的逻辑父级。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在实例化了元素但未附加到最终连接到页面级别根元素或应用程序对象的任何逻辑树的情况下，可能会 `null` <xref:System.Windows.FrameworkElement.Parent%2A>。  
  
 请注意，根据应用程序的功能，元素的逻辑父级可能会发生更改，并且保持此属性的值将不会反映此更改。 通常应在需要之前立即获取值。  
  
 有关逻辑树遍历的详细信息以及使用 <xref:System.Windows.FrameworkElement.Parent%2A> 作为父元素发现技术的方案，请参阅[WPF 中的树](/dotnet/framework/wpf/advanced/trees-in-wpf)。  
  
 属性引擎在重新父级后可能会重新计算某个元素的所有属性值，因为某些属性通过逻辑树继承值。 当对元素进行重定父级时，适用于绑定的 <xref:System.Windows.FrameworkElement.DataContext%2A> 也会发生更改。  
  
 通常仅通过操作集合、使用专用的 add 或 remove 方法或通过设置元素的内容属性来更改元素的父元素。  
  
 使用 <xref:System.Windows.FrameworkElement.Parent%2A> 属性的最典型方案是获取引用，然后从父级获取各种 <xref:System.Windows.FrameworkElement> 属性值。 对于模板，模板 <xref:System.Windows.FrameworkElement.Parent%2A> 最终将 `null`。 若要过去此点并扩展到实际应用模板的逻辑树，请使用 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>。  
  
 请注意，在这种情况下，此属性不会报告 visual tree 父元素。 可视化树父项对于一般应用程序情况通常并不重要，但对于某些视觉对象级别的情况可能是所需的父元素。 请参阅 <xref:System.Windows.Media.VisualTreeHelper>。  
  
   
  
## Examples  
 下面的示例演示了用于检查元素父元素的代码，然后使用父元素的属性值设置要匹配的子元素的属性。 在这种情况下，这些是影响呈现大小的属性。  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">报告更改的子元素。</param>
        <summary>支持 <see cref="T:System.Windows.FrameworkElement" /> 的专用子类中的增量布局实现。 如果子元素包含无效属性，且该属性在元数据中标记为影响布局过程中父元素的测量或排列过程的因素，则调用 <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素有一个子元素，其中某些属性已失效，并且该属性在注册过程中被标记为 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 或 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 在属性元数据中，则调用此方法。 如果此元素支持布局的部分（增量）更新，则方法调用会通知父元素必须重新度量的特定子元素。  
  
 默认情况下，<xref:System.Windows.FrameworkElement> 不支持增量布局，而在 <xref:System.Windows.FrameworkElement> 类中，此方法没有默认实现。 如果需要重写此方法，则这种情况并不常见，因为这需要修改默认布局系统行为。  
  
 例如，如果某个类的可能的子元素的类型限制比 WPF 框架级别布局系统更严格，则可能会出现这种情况。 由于这些自定义元素的性质，实现某些自定义布局行为时，可以特意延迟属性更改。 例如，对于某些类型通常会导致另一布局处理的更改，测量/排列方法重写（尝试优化子元素呈现传递）可能会延迟。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">应确定其预期焦点更改的方向。</param>
        <summary>根据提供的焦点移动方向，确定在此元素之后接收焦点的下一个元素，但不实际移动焦点。</summary>
        <returns>如果实际遍历了焦点，则为焦点将要移到的下一个元素。 如果焦点不能按提供的方向相对于此元素移动，则可能返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 是实际移动焦点的相关方法。  
  
   
  
## Examples  
 下面的示例实现一个处理程序，该处理程序处理几个可能的按钮输入，每个按钮表示可能的 <xref:System.Windows.Input.FocusNavigationDirection>。 处理程序跟踪具有当前键盘焦点的元素，并对该元素调用 <xref:System.Windows.FrameworkElement.PredictFocus%2A>，并为提供的 <xref:System.Windows.Input.TraversalRequest> 类型参数指定适当的 <xref:System.Windows.Input.FocusNavigationDirection>。 处理程序不会像 <xref:System.Windows.FrameworkElement.MoveFocus%2A> 那样移动到该元素，而是出于可视化目的更改预测焦点目标的物理尺寸。  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定了以下方向之一：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 对于 <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 来说，这些方向是非法的（但对于 <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 来说是合法的）。</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要在指定的名称-对象映射中使用的名称。</param>
        <param name="scopedElement">映射的对象。</param>
        <summary>提供一个可简化对 <see cref="T:System.Windows.NameScope" /> 注册方法访问的访问器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用 <xref:System.Windows.NameScope.RegisterName%2A>的便捷方法。 该实现将检查后续的父元素，直到它找到适用的 <xref:System.Windows.NameScope> 实现（通过查找实现 <xref:System.Windows.Markup.INameScope>的元素找到）。 有关名称范围的详细信息，请参阅[WPF XAML 名称范围](/dotnet/framework/wpf/advanced/wpf-xaml-namescopes)。  
  
 若要在代码中创建应用程序时正确地挂钩应用程序的动画情节提要，则调用 <xref:System.Windows.FrameworkElement.RegisterName%2A> 是必需的。 这是因为 <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>中的一个关键情节提要属性使用了运行时名称查找，而不能引用目标元素。 即使可通过代码引用访问该元素，也是如此。 有关为何需要为情节提要目标注册名称的详细信息，请参阅[情节提要概述](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview)。  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要删除的元素。</param>
        <summary>从此元素的逻辑树中删除所提供的对象。 <see cref="T:System.Windows.FrameworkElement" /> 将更新受影响的逻辑树父指针，以便与此删除操作保持同步。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可实现表示元素的逻辑子级的对象上的集合。 这可以在属性 getter 或 setter、`Changed` 事件、构造函数或集合类型本身内的类处理程序中完成。  
  
 对于控件作者，不建议在此级别操作逻辑树，除非提供的基控件类的内容模型不适当。 请考虑在 <xref:System.Windows.Controls.ContentControl>、<xref:System.Windows.Controls.ItemsControl>和 <xref:System.Windows.Controls.HeaderedItemsControl>级别进行子类化。 这些类提供了一个内容模型，其中包含通过专用 Api 特定的逻辑子级强制，并支持在 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 控件中通常需要的其他功能，例如通过模板进行样式设置。  
  
   
  
## Examples  
 下面的示例实现自定义 <xref:System.Windows.FrameworkElement> 上的 `Child` 属性，该属性执行其自己的可视化层实现。 已设计属性的 setter，因此，如果值发生更改，则会从逻辑树中删除旧值以及类特定的视觉对象集合。 将缓存这些值，然后将新值添加到标准 WPF 框架级别的逻辑树和自定义视觉对象集合中。  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在此元素上调用 <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件指示在可滚动区域内，引发 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件的元素应在父 <xref:System.Windows.Controls.ScrollViewer> （或派生类）中可见。 然后，<xref:System.Windows.Controls.ScrollViewer> 使用事件的类处理将 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件标记为已处理。 通常 <xref:System.Windows.FrameworkElement.RequestBringIntoView> 事件数据不应由任何控制滚动区域的类或任何实例处理程序进行标记处理，因为这样做会影响调用 <xref:System.Windows.FrameworkElement.BringIntoView%2A>的元素的预期目标。  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置本地定义的资源字典。</summary>
        <value>资源中当前本地定义的字典，其中的每个资源均可通过键进行访问。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分地在 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 中定义的资源字典通常创建为属性元素，并且通常位于任何单个页面或应用程序的根元素上。 将资源字典置于此级别，可以更方便地从页面中的单个子元素（或应用程序用例中的任何页面）查找。 在大多数应用程序方案中，我们建议将样式定义为资源字典中的对象元素，或将其定义为外部资源，以便整个样式资源可以是独立的（这种方法可通过分隔需要编辑的物理文件来帮助将设计器责任与开发人员责任区分开来）。  
  
 请注意，此属性仅返回直接在该元素中声明的资源字典。 这不同于实际资源查找过程，其中，子元素可以访问每个父元素中定义的任何资源，并以递归方式向上搜索。  
  
 资源也可由该集合中的代码引用，但请注意，在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 中创建的资源在声明该字典的元素引发 <xref:System.Windows.FrameworkElement.Loaded> 之前将无法访问。 事实上，资源是异步分析的，即使 <xref:System.Windows.FrameworkElement.Loaded> 事件也不能确定 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定义的资源。 出于此原因，通常只应作为运行时代码的一部分或其他 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 技术（如属性值的样式或资源扩展引用）访问 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 定义的资源。 通过代码访问资源时，它实质上等效于从 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]进行的[DynamicResource](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension)引用。  
  
 基础 <xref:System.Windows.ResourceDictionary> 支持使用代码在集合中添加、删除或查询资源所需的方法。 可设置 <xref:System.Windows.FrameworkElement.Resources%2A> 属性，以支持将元素的资源集合完全替换为新的或不同的 <xref:System.Windows.ResourceDictionary>的方案。  
  
 请注意，所示的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 语法不包含 <xref:System.Windows.ResourceDictionary>的元素。 这是隐式集合语法的示例;可以省略表示集合元素的标记。 改为指定作为项添加到集合中的元素。 有关隐式集合和 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]的详细信息，请参阅[XAML 语法详述](/dotnet/framework/wpf/advanced/xaml-syntax-in-detail)。 如果要引入合并字典，则仍以元素形式显式指定 <xref:System.Windows.ResourceDictionary> 的一种情况是，这种情况下通常不会有该 <xref:System.Windows.ResourceDictionary>的子元素。 有关详细信息，请参阅[合并资源字典](/dotnet/framework/wpf/advanced/merged-resource-dictionaries)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一个或多个对象元素，每个元素都定义一个资源。 每个 <xref:System.Windows.ResourceDictionary> 中的每个资源属性元素必须具有 " [x：Key" 指令](/dotnet/framework/xaml-services/x-key-directive)的唯一值，当从 <xref:System.Windows.ResourceDictionary>中检索值时，该指令用作唯一键。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">X：Key 特性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的依赖属性向此元素附加一个绑定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">标识应该建立绑定的目标属性。</param>
        <param name="path">源属性名称或用于绑定的属性的路径。</param>
        <summary>将提供的源属性名作为数据源的路径限定，从而将绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是一种便捷方法，用于调用 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，该方法将当前实例作为 <xref:System.Windows.DependencyObject>传递，并基于提供的 `path` 参数创建新的 <xref:System.Windows.Data.Binding>。 如果要建立简单的默认绑定，此签名更方便。 如果需要指定任何非默认条件的绑定属性，或者要使用 <xref:System.Windows.Data.MultiBinding> 或 <xref:System.Windows.Data.PriorityBinding>，则应使用 <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> 签名。  
  
   
  
## Examples  
 下面的示例使用特定路径设置绑定。  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">标识应在其中建立绑定的属性。</param>
        <param name="binding">表示数据绑定的详细信息。</param>
        <summary>基于已提供的绑定对象将一个绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是一种便捷方法，用于调用 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，后者将当前实例作为 <xref:System.Windows.DependencyObject>传递。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">指定流方向的元素。</param>
        <param name="value">一个枚举值，用于指定方向。</param>
        <summary>设置所提供元素的 <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> 附加属性的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法支持 <xref:System.Windows.FrameworkElement.FlowDirection%2A> 属性的附加属性语法，因此允许所提供 <xref:System.Windows.FrameworkElement> 的子元素指定其父元素中的排列方向。 若要设置当前 <xref:System.Windows.FrameworkElement>上的值，请使用 "直接 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 访问器 <xref:System.Windows.FrameworkElement.FlowDirection%2A>"。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">资源绑定到的属性。</param>
        <param name="name">资源的名称。</param>
        <summary>搜索具有指定名称的资源，并且为指定的属性设置一个指向该资源的资源引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 资源引用类似于在标记中使用[DynamicResource 标记扩展](/dotnet/framework/wpf/advanced/dynamicresource-markup-extension)。 资源引用创建一个在运行时延迟时提供指定属性值的内部表达式。 每当资源字典通过内部事件指示已更改的值时，或者当重定当前元素的父级（父项更改将更改字典查找路径）时，将重新计算表达式。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Resources" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Resources" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只要本地 <xref:System.Windows.FrameworkElement.Resources%2A>中至少有一个键控资源，这就会返回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Style" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Style" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Windows.Style> 是本地设置的，则会返回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示序列化过程是否应该序列化 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.FrameworkElement.Triggers" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果本地设置了 <xref:System.Windows.FrameworkElement.Triggers%2A> 属性，则此方法将返回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的 <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> 或 <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> 属性的值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由事件不遵循路由，它们只能在引发它们的同一元素内进行处理。 直接路由事件支持其他路由事件行为：它们支持可访问的处理程序集合，并且可用作样式中的 <xref:System.Windows.EventTrigger>。  
  
 布局系统在此事件的 <xref:System.Windows.SizeChangedEventArgs> 自变量类中读取属性，以确定是否应将所报告的大小更改视为重要更改。 这使得布局系统或特定于控件的布局实现可以避免由于新旧的高度或宽度值之间视觉让的差异而强制执行布局更改。 让差异可能是由于浮点数据类型的舍入或相同结果计算造成的。  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的任何现有属性绑定的源值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将为与此元素关联的任何 <xref:System.Windows.Data.Binding> 引发的 <xref:System.Windows.Data.Binding.SourceUpdated> 事件创建一个别名。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素呈现时所使用的样式。</summary>
        <value>若存在，则为此元素适用的非默认样式。 否则为 <see langword="null" />。 对于默认构造的 <see cref="T:System.Windows.FrameworkElement" />，其默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于控件，当前样式通常由控件主题中的默认样式提供，或者由通常按页或应用程序级别的资源应用于该类型控件的样式（隐式样式）提供。 此属性未设置或返回默认（主题）样式，但它确实返回了在元素上操作的隐式样式或显式样式。 对于隐式或显式样式，无论样式是指定为资源还是在本地定义，都不重要。  
  
 设置样式有一些限制。 可随时将整个 <xref:System.Windows.FrameworkElement.Style%2A> 属性重置为新 <xref:System.Windows.Style>，这将强制进行布局重新组合。 但是，一旦加载的元素使用该样式，就应将 <xref:System.Windows.Style> 视为已密封。 尝试对使用中样式的任何单个属性进行更改（如 <xref:System.Windows.Style.Setters%2A>集合中的任何内容）将导致引发异常。 如果在标记中定义的样式是从资源字典（对于资源）加载的，或者它包含在其中的页面加载（对于内联样式），则会将其视为已使用。  
  
 <xref:System.Windows.FrameworkElement.Style%2A> 是具有特殊优先级的依赖属性。 本地设置的样式通常在属性系统中具有最高的优先级。 如果此时 <xref:System.Windows.FrameworkElement.Style%2A> 为 null，则在加载过程中，属性系统会检查本地或应用程序资源中指定该类型的隐式样式。 如果在执行此步骤后样式仍然为 null，则用于演示的用途样式通常来自默认（主题）样式，但在 <xref:System.Windows.FrameworkElement.Style%2A> 属性值中不返回默认样式。 请参阅[依赖属性值优先级](/dotnet/framework/wpf/advanced/dependency-property-value-precedence)或[样式和模板化](/dotnet/framework/wpf/controls/styling-and-templating)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一：、或。 请参阅[XAML 资源](/dotnet/framework/wpf/advanced/xaml-resources)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 该键引用 <xref:System.Windows.ResourceDictionary>中的现有资源。  
  
> [!NOTE]
>  属性元素语法在技术上是可行的，但不建议用于大多数样式方案。 请参阅[内联样式和模板](/dotnet/framework/wpf/advanced/inline-styles-and-templates)。 也可以使用[TemplateBinding](/dotnet/framework/wpf/advanced/templatebinding-markup-extension)或 <xref:System.Windows.Data.Binding> 的绑定引用，但情况并不常见。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例定义资源字典中的样式。  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Style" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberSignature Language="F#" Value="abstract member System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool&#xA;override this.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable : string -&gt; bool" Usage="frameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable propertyName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>如果 <paramref name="propertyName" /> 可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员实现。 它只能在 <xref:System.Windows.FrameworkElement> 实例被强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置任意对象值，该值可用于存储关于此元素的自定义信息。</summary>
        <value>预期值。 此属性没有默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性类似于其他 Microsoft 编程模型中的标记属性，如 Visual Basic for Applications 或 Windows 窗体。 <xref:System.Windows.FrameworkElement.Tag%2A> 旨在提供预先存在的属性位置，你可以在其中存储有关任何 <xref:System.Windows.FrameworkElement> 的一些基本自定义信息，而无需为元素划分子类。  
  
 由于此属性采用对象，因此需要使用属性元素用法，以便将 XAML 中的 <xref:System.Windows.FrameworkElement.Tag%2A> 属性设置为具有已知的内置类型转换器的对象（如字符串）以外的任何对象。 以这种方式使用的对象通常不在标准 WPF 命名空间中，因此可能需要将命名空间映射到外部命名空间才能作为 XAML 元素引入。 有关详细信息，请参阅[WPF xaml 的 Xaml 命名空间和命名空间映射](/dotnet/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml)和[Wpf 的自定义类](/dotnet/framework/wpf/advanced/xaml-and-custom-classes-for-wpf)。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.TagProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Tag" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素上的任何属性绑定的目标值发生更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将为与此元素关联的任何 <xref:System.Windows.Data.Binding> 引发的 <xref:System.Windows.Data.Binding.TargetUpdated> 事件创建一个别名。 这通常意味着所涉及的绑定是一个双向绑定，而绑定依赖属性确认以前的属性值现在会根据属性或数据源支持的任何验证或缓存方案无效。  
  
 使用 <xref:System.Windows.FrameworkElement.TargetUpdated> 事件的事件数据来确定报告目标值更新的特定属性。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此元素的模板父级的引用。 如果该元素不是通过模板创建的，则此属性无关。</summary>
        <value>元素的 <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> 导致要创建此元素。 此值通常为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于在应用程序标记或代码中创建的对象，<xref:System.Windows.FrameworkElement.TemplatedParent%2A> 经常 `null`。 这是因为你直接而不是通过模板创建这些对象。 通过从根遍历逻辑树或通过典型名称引用获取的对象引用不是来自模板。  
  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 可能不 `null` 的情况包括：命中测试、特定低级输入事件的事件处理、使用 <xref:System.Windows.Media.VisualTreeHelper>遍历可视化树或使用枚举器，这可能会返回来自模板的元素。 另一种情况是，如果对现有 <xref:System.Windows.FrameworkTemplate> 特别调用 <xref:System.Windows.FrameworkTemplate.FindName%2A>，并使用返回的对象。  
  
 模板实际上是共享对象，模板的内容仅创建一次。 因此，如果您获取对来自模板的元素的对象引用，则可能会发现明显的逻辑树不会到达页根。 为了将此类模板引用连接到页面的逻辑树，您应该获取 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 值，并根据需要继续导航该元素树。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中为此元素显示的工具提示对象。</summary>
        <value>工具提示对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值为 <xref:System.Windows.Controls.ToolTip>类型，则该值是将在 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]中使用的工具提示。  如果值为任何其他类型，则该值将用作由系统提供（构造） <xref:System.Windows.Controls.ToolTip> 的*内容*。 有关详细信息，请参阅 <xref:System.Windows.Controls.ToolTipService>。 服务类提供附加属性，这些属性可用于进一步自定义 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```xaml 
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>
```

-或-

```xaml
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 一个字符串，该字符串将成为 <xref:System.Windows.FrameworkElement.ToolTip%2A>的显示文本。  
  
 *toolTipObjectContent*  
 某些对象（以对象元素形式提供）应用作 <xref:System.Windows.FrameworkElement>的内容。 通常，这将是 <xref:System.Windows.FrameworkElement> 或为 <xref:System.Windows.FrameworkElement.ToolTip%2A>创建布局组合的其他元素，最终包含组合内的文本内容。 在此用法中，将从分析的 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]隐式创建 <xref:System.Windows.Controls.ToolTip> 元素，并将*toolTipObjectContent*内容设置为其 <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> 属性。  
  
 <`ToolTip` .../>  
 请参阅 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例在代码中创建 <xref:System.Windows.Controls.ToolTip>，然后设置 <xref:System.Windows.Controls.Primitives.StatusBar> 控件上的 <xref:System.Windows.FrameworkElement.ToolTip%2A> 属性。  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.Windows.FrameworkElement.ToolTipClosing> 事件标记为 "已处理" 不会取消关闭工具提示。 显示工具提示后，关闭工具提示只是为了响应用户与 UI 的交互。  
  
 此事件不能是样式中的 <xref:System.Windows.EventTrigger>。 这是因为此事件的 "标识符" 字段会重新使用服务中的实现，该实现不会公开服务级别事件的 add/remove 事件方法。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   重写 <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了防止工具提示在 UI 中显示，<xref:System.Windows.FrameworkElement.ToolTipOpening> 的处理程序可以将处理的 <xref:System.Windows.Controls.ToolTipEventArgs> 事件数据标记为已处理。 否则，将显示工具提示，并使用 <xref:System.Windows.FrameworkElement.ToolTip%2A> 属性的值作为工具提示内容。 另一种可能的情况是，您可以编写一个处理程序，用于在显示工具提示之前重置作为事件源的元素的 <xref:System.Windows.FrameworkElement.ToolTip%2A> 属性的值。  
  
 如果 <xref:System.Windows.FrameworkElement.ToolTip%2A> 的值 `null` 或未设置，则不会引发 <xref:System.Windows.FrameworkElement.ToolTipOpening>。 在工具提示打开或打开时，不要特意将 <xref:System.Windows.FrameworkElement.ToolTip%2A> 设置为 `null`;这不会影响关闭工具提示，而是在 UI 中创建不需要的视觉对象。  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> 事件不能是样式中 <xref:System.Windows.EventTrigger>。 这是因为此事件的 "标识符" 字段会重新使用服务中的实现，该实现不会公开服务级别事件的 add/remove 事件方法。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   重写 <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> 在派生类中实现此事件的类处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.ToolTip" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取直接在此元素上或在子元素中建立的触发器的集合。</summary>
        <value><see cref="T:System.Windows.Trigger" /> 对象的强类型集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此属性只能通过显示的集合语法 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 设置，或者通过访问集合对象并使用它的各种方法（如 Add）来设置。 用于访问集合对象本身的属性是只读的，集合本身是可读写的。 此属性仅存在于根元素上;尝试查找该文件或将其设置到其他位置将导致引发异常。  
  
 此属性不允许您检查作为此元素上使用的样式的一部分而存在的触发器。 它仅报告在标记或代码中真正添加到集合中的触发器的集合。 默认情况下，元素通常不存在此类元素（通过实例的模板）;更常见的情况是，来自控件组合的触发器是在样式中建立的。  
  
 就行为而言（并且试图确定哪个效果来自 <xref:System.Windows.FrameworkElement.Triggers%2A> 集合中声明的元素），触发条件和触发器效果都可能在此元素上，或可能在逻辑树中的子元素上。 请注意，如果使用生存期事件（例如 <xref:System.Windows.FrameworkElement.Loaded>）来获取此集合，则可能尚未完全加载子元素的触发器，并且集合将比它在运行时真正的小。  
  
 请注意，在元素上建立的触发器集合仅支持 <xref:System.Windows.EventTrigger>，而不支持属性触发器（<xref:System.Windows.Trigger>）。 如果需要属性触发器，则必须将其放在样式或模板中，然后直接通过 <xref:System.Windows.FrameworkElement.Style%2A> 属性将该样式或模板分配给该元素，或通过隐式样式引用间接将其分配给该元素。  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreTriggers*  
 一个或多个定义 <xref:System.Windows.EventTrigger> 元素。 每个此类触发器都应该包含有效的情节提要操作和引用。 请注意，只能在页面的根元素上建立此集合。 有关详细信息，请参阅[情节提要概述](/dotnet/framework/wpf/graphics-multimedia/storyboards-overview)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找到，则返回该资源。</summary>
        <returns>找到的资源；如果未找到具有所提供 <paramref name="key" /> 的资源，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在调用元素上找不到该资源，则会通过逻辑树向上搜索父资源树，其方式与在运行时键请求资源时搜索树的方式相同。 仅当调用 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 时，此方法将仅在资源树中的任何位置不存在该键的任何资源时返回 `null`。  
  
 通常，您会立即将返回值强制转换为您尝试通过返回的资源值设置的属性的类型。  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> 方法的行为类似，不同之处在于，如果未返回具有所提供键的资源，则会引发异常。  
  
   
  
## Examples  
 下面的示例是作为按钮处理程序实现的，在该按钮处理程序中，单击的按钮会将其背景设置为通过对其自身调用 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 获取的资源定义画笔。 这会遍历元素树并查找资源（资源本身在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 中定义，并且不会显示）。  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从加载的元素的元素树中移除元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由事件不遵循路由，它们只能在引发它们的同一元素内进行处理。 直接路由事件支持其他路由事件行为：它们支持可访问的处理程序集合，并且可用作样式中的 <xref:System.Windows.EventTrigger>。  
  
 由于用户启动的系统主题更改，<xref:System.Windows.FrameworkElement.Loaded> 和 <xref:System.Windows.FrameworkElement.Unloaded> 可能会在控件上引发。 主题更改会导致控件模板和包含的可视化树失效，这进而导致整个控件被卸载和重新加载。 因此，不能假定 <xref:System.Windows.FrameworkElement.Unloaded> 仅在离开页面时才会发生。  
  
 请注意，在应用程序开始关闭后，不会引发 <xref:System.Windows.FrameworkElement.Unloaded> 事件。 当发生由 <xref:System.Windows.Application.ShutdownMode%2A> 属性定义的条件时，将发生应用程序关闭。 如果将清理代码放在 <xref:System.Windows.FrameworkElement.Unloaded> 事件的处理程序中（例如 <xref:System.Windows.Window> 或 <xref:System.Windows.Controls.UserControl>），则可能无法按预期方式调用。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkElement.Unloaded" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要从当前范围中移除的名称-对象对的名称。</param>
        <summary>简化对 <see cref="T:System.Windows.NameScope" /> 注销方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果打算用同一名称重新注册另一个元素，则只需取消注册名称。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认样式重新应用至当前 <see cref="T:System.Windows.FrameworkElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应向此元素的大小和位置布局应用布局舍入。</summary>
        <value>如果应用了布局舍入，则为 <see langword="true" />，否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 `true`元素的 <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> 属性时，在 <xref:System.Windows.UIElement.Measure%2A> 和 <xref:System.Windows.UIElement.Arrange%2A> 传递过程中计算的所有非整数像素值都将舍入为整个像素值。  
  
 此属性由子元素继承。  
  
> [!NOTE]
>  应将 <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> 设置为根元素 `true`。 布局系统会将子坐标添加到父坐标;因此，如果父坐标不在像素边界上，则子坐标也不在像素边界上。 如果无法在根处设置 <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A>，请将子级上的 <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> 设置为获得所需的效果。  
  
 当边缘落在设备像素的中间时，在像素边界上绘制对象可消除由抗锯齿功能生成的半透明边缘。 下图显示了位于设备像素中间的单个像素宽度线条的输出。 左侧的行不使用布局舍入，并且具有抗锯齿。 右侧线条使用布局舍入。  
  
 ![相对&#45;于一条像素线的抗锯齿线条。](~/add/media/pixelsnaplinecompare.PNG "抗锯齿的线与单像素线的比较。")  
  
 使用布局舍入和 <xref:System.Windows.GridUnitType.Star> 大小调整时，布局系统将在列或行度量值中创建较小的变体，以避免子像素呈现。 例如，如果网格的总宽度为100，其中每个 size <xref:System.Windows.GridUnitType.Star>大小为3列，而不是创建三个宽度均为33.3 的列，则布局系统将创建2个宽度为33、宽度为34的列。  
  
> [!NOTE]
>  在 .NET 4.6 中，对布局舍入进行了更改，以减少带边框的控件中的剪辑实例。 默认情况下，如果目标框架 .NET Framework 4.6 或更高版本，则会启用此功能。 面向更早版本的框架的应用程序可以通过将以下设置添加到 app.config 文件来选择加入新行为： `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` 设置仅在应用程序在 .NET Framework 4.6 上运行时才会生效。  
  
   
  
## Examples  
 下面的示例演示 <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> 属性对单个像素宽度线条的影响。 左侧线条不使用布局舍入，右侧线条使用布局舍入。 如果慢慢调整窗口的大小，可以看到布局舍入所产生的差异。  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在父元素（如面板或项控件）中组合此元素时所应用的垂直对齐特征。</summary>
        <value>垂直对齐设置。 默认为 <see cref="F:System.Windows.VerticalAlignment.Stretch" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素上显式设置 <xref:System.Windows.FrameworkElement.Height%2A> 和 <xref:System.Windows.FrameworkElement.Width%2A> 属性时，这些度量将采用布局引用单元格，并取消将此属性设置为 <xref:System.Windows.VerticalAlignment.Stretch>的常规效果。  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 是 [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] 属性访问器，对于实际上是依赖属性。 在派生元素类（特别是控件）中，此特定依赖项属性非常频繁地以不同的方式设置其外观 "默认" 值。 这通常采用以下两种方式之一：依赖属性重新注册到特定的派生类，但使用不同的元数据设置其默认值;否则，将应用默认样式来设置该依赖属性值的不同值。 例如，<xref:System.Windows.Controls.ComboBoxItem> 控件的 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 的外观 "默认" 将 <xref:System.Windows.VerticalAlignment.Center>，即使 <xref:System.Windows.Controls.ComboBoxItem> 从 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> 继承 <xref:System.Windows.FrameworkElement>直接。 这是因为此值在样式的控件模板内 <xref:System.Windows.Controls.ComboBoxItem>默认样式中重置。  
  
 <xref:System.Windows.Controls.Canvas> 在编写布局时不使用 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>，因为 <xref:System.Windows.Controls.Canvas> 基于绝对定位。  
  
 当由 <xref:System.Windows.Controls.ComboBoxItem> 或任何派生类继承时，<xref:System.Windows.Controls.ComboBoxItem> 将此属性的默认值重定义为 "<xref:System.Windows.VerticalAlignment.Center>"。  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素内可视子元素的数目。</summary>
        <value>此元素内可视子元素的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> 的 <xref:System.Windows.FrameworkElement> 实现始终返回零个或一个。 维护可能超过一个的视觉对象集合的类必须重写此属性和 <xref:System.Windows.FrameworkElement.GetVisualChild%2A>。  
  
 此属性通常用于出于实现布局重写（<xref:System.Windows.FrameworkElement.MeasureOverride%2A>、<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>）的目的确定当前子集合的上限。  
  
   
  
## Examples  
 下面的示例演示自定义装饰器如何使用它为多个视觉对象维护的 <xref:System.Windows.Media.VisualCollection> 所声明的值，并通过 <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> 和 <xref:System.Windows.FrameworkElement.GetVisualChild%2A>的重写来报告这些值。  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果你的类支持子元素集合中的多个视觉对象，请重写此属性以返回该集合中的元素计数。 即使集合对象本身返回计数，也必须执行此操作。 WPF 框架级别的元素布局逻辑假定所有元素都将通过其 <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> 属性返回有效计数。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的宽度。</summary>
        <value>元素的宽度（以 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] 为单位）。 默认值是 <see cref="F:System.Double.NaN" />。 此值必须等于或大于 0.0。 请参阅“备注”以了解上限信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是 <xref:System.Windows.FrameworkElement> 中指定宽度信息的三个属性之一。  另外两个 <xref:System.Windows.FrameworkElement.MinWidth%2A> 和 <xref:System.Windows.FrameworkElement.MaxWidth%2A>。  如果这两个值之间存在冲突，则必须先执行实际的宽度确定的应用程序顺序，然后 <xref:System.Windows.FrameworkElement.MaxWidth%2A>，最后，如果其中每个 <xref:System.Windows.FrameworkElement.MinWidth%2A> 都在界限内，<xref:System.Windows.FrameworkElement.Width%2A>。  
  
 此属性的返回值始终与任何设置为它的值相同。 相反，<xref:System.Windows.FrameworkElement.ActualWidth%2A> 的值可能会有所不同。 出于某种原因，布局可能已拒绝建议的大小。 此外，布局系统本身相对于 <xref:System.Windows.FrameworkElement.Width%2A> 的属性系统集以异步方式运行，并且可能尚未处理特定大小调整属性的更改。  
  
 除了可接受的 <xref:System.Double> 值外，还可以 <xref:System.Double.NaN?displayProperty=nameWithType>此属性。 这是指定自动调整大小行为的方式。 在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 将值设置为字符串 "Auto" （不区分大小写）以启用自动调整大小行为。 自动调整大小行为表示元素将填充其可用的宽度。 但请注意，特定控件经常以默认样式提供默认值，这些默认值将禁用自动调整大小行为，除非专门重新启用。  
  
 除了验证检查，对于布局系统强制执行的 <xref:System.Windows.FrameworkElement.Width%2A> 还有一个不确定的上限值（这是一个非常大的数字，大于 <xref:System.Single.MaxValue?displayProperty=nameWithType> 但小于 <xref:System.Double.MaxValue?displayProperty=nameWithType>）。 如果超出此限制，元素将不会呈现，并且不会引发异常。 不要将 <xref:System.Windows.FrameworkElement.Width%2A> 设置为远远大于任何可能的视觉对象显示大小的最大大小的值，否则可能会超出此不确定性的上限。  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>XAML 特性用法  
  
```xaml 
<object Width="double"/>  
```

-或-

```xaml
<object Width ="qualifiedDouble"/>  
```

-或-

```xaml
<object Width ="Auto"/>  
```  

<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 大于或等于 0.0 <xref:System.Double> 值的字符串表示形式。 请参阅“备注”以了解上限信息。 此值被解释为 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 度量。 字符串不需要显式包含小数点。 例如，`1` 的值是可接受的。  
  
 *qualifiedDouble*  
 如上所述的*双精度*值，后跟以下单元声明字符串之一： `px`、`in`、`cm``pt`。  
  
 `px` （默认值）为 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 为英寸;1in = = 96px  
  
 `cm` 是厘米;1cm = = （96/2.54） px  
  
 `pt` 为点;1pt = = （96/72） px  
  
 `Auto`  
 启用自动调整行为。 请参阅“备注”。  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkElement.Width" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
