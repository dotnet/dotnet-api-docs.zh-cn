<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c703891c7a4ebdf7f78b5a40a7746c8ac071f701" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73391017" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用作 Web 部件控件集的中心类，管理所有 Web 部件控件、功能和网页上发生的事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件充当 Web 部件应用程序的中心或控制中心。 使用 Web 部件控件的每一页上都必须有一个--和一个<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件实例。 与 Web 部件应用程序的大多数方面一样，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件仅适用于经过身份验证的用户。 此外，其功能几乎完全适用于驻留在继承自 <xref:System.Web.UI.WebControls.WebParts.WebZone> 类 Web 部件区域中的服务器控件。 驻留在这些区域之外的页上的服务器控件的 Web 部件功能或与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的交互可能非常小。  
  
 作为页面上 Web 部件功能的中心，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件执行下表中所述的任务类型。  
  
|任务类别|控件的作用|  
|-------------------|---------------------------|  
|跟踪 Web 部件控件|跟踪页面上许多不同类型的控件，这些控件提供 Web 部件功能，包括 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、连接、区域等。|  
|添加和删除 Web 部件控件|提供用于在页上添加、删除和关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的方法。|  
|管理连接|在控件之间创建连接，并监视连接以及添加和删除这些连接的过程。|  
|个性化控件和页面|使用户能够将控件移动到页面上的不同位置，并启动用户可以在其中编辑控件外观、属性和行为的视图。 维护每个页面上的特定于用户的个性化设置。|  
|在不同的页面视图之间切换|在页面的不同专用视图之间切换页面，以便用户可以执行某些任务，如更改页面布局或编辑控件。|  
|引发 Web 部件生命周期事件|定义、引发并使开发人员能够处理 Web 部件控件的生命周期事件，例如，在添加、移动、连接或删除控件时。|  
|启用控件的导入和导出|导出包含 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的属性状态的 XML 流，并允许用户导入文件，以便于在其他页面或站点中个性化复杂控件。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类具有一组大量的属性。 与跟踪其他控件的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 角色一致，它具有许多属性，可引用 Web 部件控件或其他特殊 Web 部件对象的集合。 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>"、"<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>" 和 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>" 属性都是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件用于跟踪和其他管理任务的所有集合。  
  
 另一组属性包含可自定义的警告，这些警告适用于在 Web 部件应用程序中出现的某些方案。 其中包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类将重写它的一些基继承属性，这些属性由许多 Web 服务器控件使用。 其中包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 属性。  
  
 最后，有一组属性可用于访问应用程序的当前状态。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性指示页面所在的当前显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 属性指示是否允许控件呈现客户端脚本，这在以下情况下适用：用户可能具有具有不同功能的浏览器或已关闭脚本。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 属性可用于引用包含对扩展性事例使用的很多重要 Web 部件方法调用的实用工具类。 通过在单独的类（<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 类）中隐藏对这些方法的调用，简化了 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类的 API。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性提供对存储用户个性化设置并将该数据保存到永久存储的个性化对象的访问。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 属性指示用户或应用程序当前选择的页上的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性指示 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上的自定义个性化设置数据是否已更改。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件包含五种内置的显示模式或网页的视图。 开发人员可以扩展此功能，通过扩展 <xref:System.Web.UI.WebControls.WebParts.WebZone> 类或 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 类等类型来创建自定义显示模式。 如果页面上存在对应于给定显示模式的适当类型的控件，则用户可以将页面切换到各种显示模式。  
  
> [!NOTE]
>  可以扩展此功能，以便用户可以切换到自定义显示模式，而无需在页面上放置相应的区域。 但是，默认行为是显示模式与区域相对应。  
  
 标准显示模式由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类中的公共字段表示。 下表汇总了字段及其引用的显示模式。 正如前文所述，页面的当前显示模式始终在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性中引用，在特定页面上可能的显示模式集是在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性中包含的，特定页面上可能存在的一组显示模式。  
  
|字段|显示模式详细信息|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|网页的普通用户视图;默认和最常见的显示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|用户可以重新排列或删除控件以更改页面布局的视图。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|编辑用户界面（UI）变为可见的视图;用户可以编辑在正常浏览模式下可见控件的外观、属性和行为。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|目录 UI 变为可见的视图;用户可以将控件从可用控件的目录添加到页面。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|连接 UI 将在其中可见的视图;用户可以连接、管理或断开控件之间的连接。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件还包含大量事件，这些事件在 Web 部件页和控件的生命周期内非常重要。 这些事件提供对 Web 部件控件的行为的精确编程控制。 大多数方法直接与 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（或放置在 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中的其他服务器或用户控件相关，以便它们可以作为 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件）。 但有些事件涉及页面的状态或页面上的连接。 下表列出了可用的事件并汇总了其用途。  
  
> [!NOTE]
>  在下表中的所有情况下，"控件" 一词是指 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件或驻留在某个区域中的任何服务器控件，并在运行时使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象进行包装。  
  
|事件|说明|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|恰好在将控件添加到页面之前发生，以验证它是否已获授权。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在页面上的所有连接都已激活之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|恰好在激活页上的所有连接的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|在页的当前显示模式更改之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|恰好在更改页的显示模式的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|在取消选定控件后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|恰好在取消选择控件之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|在将控件添加到区域之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|恰好在将控件添加到区域的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|在控件关闭（从页中移除）后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|恰好在关闭控件的进程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|在永久删除动态控件（以编程方式创建或从目录中添加的控件）的实例之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|恰好在删除动态控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控件在其区域内移动或移动到另一个区域后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|恰好在移动控件的进程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|在为连接选择的两个控件已建立连接之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|恰好在连接两个控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|在两个连接的控件断开连接之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|恰好在断开两个控件的连接过程之前发生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件提供多种方法来管理 Web 部件页面。 此处未列出的一大组方法是其名称采用的形式为 On*事件*名称的方法。 这些方法通常会引发其关联的事件，并使用 <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>类型的处理程序来提供事件。 其中的大多数方法都可以由继承自 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类的开发人员重写。 此外，页开发人员还可以为与这些方法关联的事件提供自定义处理程序。 例如，在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 事件的情况下，页面开发人员可以将 `OnWebPartAdded` 属性添加到网页标记中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，以便为事件提供自定义处理。 特性对应于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 方法，此基本模式事件处理适用于大多数 Web 部件事件及其关联方法。  
  
 此外，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件具有特定于管理 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（以及用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的服务器控件或用户控件）的任务的方法。 这些方法包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 另一组方法专用于连接。 这包括诸如 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>的方法。  
  
 最后，某些 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法侧重于个性化设置功能。 它们包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 有关可通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 属性访问的其他 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法的详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 类的文档。  
  
   
  
## Examples  
 下面的代码示例演示 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的声明性和编程使用。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 用户控件具有一个下拉列表控件，该控件在给定页面上存在的 Web 部件控件的情况下，显示页面上可能的显示模式。 在此代码示例的网页中，此用户控件刚好在页面标记中的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 元素的正下方，并且在网页顶部附近有一个 `Register` 指令用于注册控件。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅[演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 网页的声明性标记包含用户控件和自定义控件 `Register` 指令。 存在 `<asp:webpartmanager>` 元素、包含自定义控件的 `<asp:webpartzone>` 元素和 `<asp:connectionszone>` 元素。 该页还包含一些用于处理 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的与连接相关的事件的内联代码;连接和断开连接控件时，可以看到此代码的效果。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 请注意，有一个名为 `IZipCode`的接口，此接口是在 `ZipCodeWebPart` 类中实现的。 此类具有一个名为 `ProvideIZipCode` 的特殊回调方法，该方法用作提供程序。 名为 `WeatherWebPart`的另一种类型也使用名为 `GetIZipCode`的特殊方法来实现，该方法使控件能够充当其他控件的使用者。  
  
 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此代码示例假定已将源编译为程序集，网页中的 `Register` 指令引用程序集名称。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 显示连接 UI 后，单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**"，然后单击 "**连接**" 以完成两个控件的连接。 单击 "**关闭**"，然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 您可以输入邮政编码，并使用您输入的值更新使用者控件。 由于 `ZipCode` 属性在源代码中使用 `Personalizable` 属性进行标记，因此此属性值将在浏览器会话之间保持不变，从而保存用户输入的值。 更复杂的使用者控件可以采用邮政编码信息，根据代码查找天气信息，并将其显示给用户。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件旨在进行扩展。 由于这是 Web 部件应用程序的中心，因此，当你想要在 Web 部件控件集中扩展某些特定类型或控件时，在许多情况下，你还必须扩展 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类，因为它可能具有一些需要的属性或方法才能使你的自定义类型在 Web 部件应用程序的上下文中工作。 Web 部件参考文档（请参阅 <see cref="N:System.Web.UI.WebControls.WebParts" />），讨论如何扩展 Web 部件类型时，通常会提到还需要执行哪些操作来扩展 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类，或者在代码示例中演示如何对其进行扩展。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> 构造函数将初始化 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件所使用的几个重要的变量。 一个直接影响所有 Web 部件页面的分配是默认页面显示模式设置为浏览模式（<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>）这一事实。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活网页上当前所有非活动连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将对页的每个请求调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 方法，以激活 <xref:System.Web.UI.WebControls.WebParts.WebPart> 与位于 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中的其他服务器控件之间的现有连接。 在某些情况下，例如，如果要激活的连接中存在冲突，则此方法将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法以结束有问题的连接。 在断开连接过程中，会引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。 通常，开发人员可以取消此事件，但在这种情况下，不能取消这种连接，因为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件需要解决冲突才能完成激活连接的过程。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要添加至网页或在页上打开的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或服务器或用户控件）。</param>
        <param name="zone">向其添加 <paramref name="webPart" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，表示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中占用的序号位置（相对于 <paramref name="zone" /> 中的其他控件）。</param>
        <summary>提供向网页添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的标准编程方法。</summary>
        <returns>添加到页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法用于将新的动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件添加到页面，并重新打开先前在页面上关闭的静态控件或动态控件。 调用方法添加新的控件时，实际上会创建一个在 `webPart` 参数中引用的控件的副本。 为控件的副本生成新的 ID，因此开发人员应引用从方法返回的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件以获取新的 ID 值。 调用方法以重新打开先前关闭的控件时，它将返回对由 `webPart` 参数引用的控件的直接引用。  
  
> [!IMPORTANT]
>  应始终使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法，而不是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> 属性所引用的控件集合的 <xref:System.Web.UI.ControlCollection.Add%2A> 方法，以编程方式将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件添加到页面，因为使用 <xref:System.Web.UI.ControlCollection.Add%2A> 方法会引发异常。 若要添加一个不是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的控件（即，将在运行时使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件进行包装的服务器控件），则应首先调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法来创建该控件，然后调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法以添加控件. 有关此方法的演示，请参阅 "示例" 部分。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法以编程方式将服务器控件添加到页中。 页面标记包含一个空的 `<asp:webpartzone>` 元素和一个 `<asp:webpartmanager>` 元素。 第一次单击 "**添加日历**" 按钮时，事件处理程序中的代码会创建一个 <xref:System.Web.UI.WebControls.Calendar> 的控件，并将其作为 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象添加到区域，同时调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
或 
 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> 没有在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的区域集合中注册。  
  
或 
 <paramref name="webPart" /> 已存在于 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 的值小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当调用 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法以确定 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件是否能够添加到页中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每当将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件添加到页中时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件发生。 在许多常见情况下，可以将控件添加到页面中。 有关这些内容的完整说明，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法的 "备注" 部分。 添加控件时，必须对其进行检查，以查看是否已设置其 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性，如果是，则必须检查控件是否有权添加到页面中。  
  
 开发人员可以为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件创建事件处理程序，以提供控件的筛选。 如果控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性值不符合事件处理程序代码中的条件，则不会将该控件添加到页面中。  
  
   
  
## Examples  
 下面的代码示例演示如何为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件设置自定义事件处理程序，该事件处理程序会自动覆盖默认的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法。  
  
 `mgr1_AuthorizeWebPart` 方法中的代码检查页上的控件是否将其各自的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性值设置为 `user`，如果是，则返回 `true`，这意味着将对其进行授权并将其添加到页面中。 这假定默认方法是允许用户在用户个性化设置范围内查看页面中的控件。 但请注意，在该示例中，其中一个控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性值设置为 `admin`。 开发人员可能会将此筛选器置于专用控件上，此控件仅供管理用户查看。 此控件将无法在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件期间进行授权检查，且不会显示。 请注意，也将显示未设置属性的控件;假设它们不属于筛选方案，因为未设置其 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合，这些对象可用于在服务器控件之间创建 Web 部件连接。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> 方法来创建集合。 默认情况下，它从应用程序配置文件中读取可用的转换器。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web 部件连接概述</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正为其建立连接的控件。</param>
        <summary>开始连接两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 方法，以便在不同的阶段中形成控制连接的过程，使开发人员可以更好地控制连接过程。 方法执行一组初始检查以确保 `webPart` 处于可合法形成连接的状态。 如果 `webPart` 通过了所有检查，则会将其设置为当前选定的控件（请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 属性），连接进程可以继续。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
或 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <block subset="none" type="overrides"><para>需要扩展 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法，然后添加一些附加的自定义处理;或者，您可能希望完全自定义在控件之间启动连接的过程。 例如，你可能想要在创建连接之前验证某些数据是否可用。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要编辑的控件。</param>
        <summary>开始 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的编辑过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 方法，使得编辑控件的过程可以在不同的阶段完成，使开发人员可以更好地控制进程。 方法执行一组初始检查以确保 `webPart` 处于可编辑的状态。 如果 `webPart` 通过了所有检查，则会将其设置为当前选定的控件（请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 属性），编辑过程也可以继续。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
或 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 部件控件的页的默认显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 字段引用由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建和包含的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。 因为这是一个静态对象，所以可以直接通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类引用它，而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时，默认情况下它处于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> （浏览模式）。 当用户只是在正常网页上浏览时，该页面仍处于浏览模式。 如果用户想要对页面的布局、控件、外观或行为进行个性化设置，则必须将页面切换到通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性提供的专用显示模式之一。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 字段。 此代码使用受支持的显示模式（在本例中为 "浏览" 和 "设计"）填充下拉列表。 请注意，在 `Page_PreRender` 方法中，代码会检查当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性是否设置为 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>"。 如果是这样，`Label1` 将可见，如果不是，则将隐藏 `Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后，默认情况下处于浏览模式。 请注意页面上的标签，指示你处于浏览模式。 使用下拉列表控件将页面切换到设计模式。 请注意，由于 `Page_PreRender` 方法中的代码，该标签现在处于隐藏状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定它们是否能够被连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法用于确定是否可以连接两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 方法通常在调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法之前用作条件检查。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法检查在两个控件可以形成连接之前必须满足的条件数。 以下列表汇总了建立连接的主要标准。 如果满足所有这些条件（以及其他一些内部条件），该方法将返回 `true`，这意味着控件可以连接：  
  
-   不能 `null`提供程序和使用者控件，它们必须包含在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性所引用的控件的集合中。  
  
-   提供程序和使用者不能为同一个控件。 换句话说，<xref:System.Web.UI.WebControls.WebParts.WebPart> 控件无法连接到其自身。  
  
-   不能 `null`提供程序和使用者的 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> 对象（连接点）。  
  
-   无法关闭提供程序和使用者（控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> 属性都无法 `true`）。  
  
-   连接点控件的 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> 属性必须与使用者和提供者的控件类型匹配。  
  
-   必须同时启用连接点（它们的 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> 方法必须同时返回 `true`）。  
  
-   每个连接点不能尝试建立比自己 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> 属性中所指定内容更多的连接。  
  
-   如果连接不兼容的控件需要 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象（转换器），则不能 `null`该对象。 但是，如果控件已兼容，则必须 `null`转换器。  
  
-   转换器（如果使用）必须在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> 集合中引用。  
  
-   转换器（如果使用）必须具有与提供程序和使用者兼容的接口，以便它能够在两个控件之间转换数据。 使用者和提供程序的辅助接口也必须兼容。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">使 <paramref name="provider" /> 能够参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <summary>当使用者和提供者控件有兼容接口且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象时，请检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控件，以确定它们是否能够被连接。</summary>
        <returns>一个布尔值，指示是否能连接 <paramref name="provider" /> 和 <paramref name="consumer" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于在两个控件都具有兼容的连接点类型时连接 `provider` 和 `consumer`，因此不需要 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象。 您可能想要使用此方法来验证两个控件是否可以连接，然后再调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 来创建编程连接。  
  
 此重载使用与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 方法重载相同的实现，唯一的例外是此重载不需要转换器。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、一个 `<asp:webpartmanager>` 元素以及一些使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法创建连接的事件处理代码。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含用户控件和自定义控件 `Register` 指令。 存在 `<asp:webpartmanager>` 元素、包含自定义控件的 `<asp:webpartzone>` 元素和 `<asp:connectionszone>` 元素。 请注意，在 `Page_Load` 方法中，代码检查是否可以建立连接，如果是，则定义一个提供程序、一个使用者及其各自的连接点，然后将新连接添加到由引用的静态连接集 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>知识产权.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 它包含一个接口和两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，一个充当提供程序，另一个作为使用者。 由于它们具有兼容的连接点（这两个连接点识别 `IZipCode` 接口），因此不需要使用转换器来建立连接。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 连接用户界面（UI）出现后，请注意，连接已由 `Page_Load` 方法中包含的代码创建。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="provider" /> 可以参与连接。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它使不兼容的 <paramref name="provider" /> 和 <paramref name="consumer" /> 能够进行连接。</param>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定这些控件是否能够连接，并使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在不兼容的使用者和提供者之间创建连接。</summary>
        <returns>一个布尔值，它指示 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以形成连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于在两个控件都具有不兼容的连接点类型时连接 `provider` 和 `consumer`，因此需要 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象。 您可能想要使用此方法来验证两个控件是否可以连接，然后再调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 来创建编程连接。  
  
 此重载使用与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 方法重载相同的实现，唯一的例外是此重载需要转换器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于从控件目录向网页添加服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 字段引用由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建和包含的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。 因为这是一个静态对象，所以可以直接通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类引用它，而无需控件的实例。  
  
 当用户想要将控件添加到页面时，如果服务器控件的目录可用，则可以将页面切换到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> （目录模式），并且将显示目录用户界面（UI）。 Web 部件目录的 UI 由 <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> 区域控件提供。 开发人员在设计时将此区域添加到页面，然后将服务器控件添加到区域，以便用户能够在运行时将这些控件添加到页面中。 开发人员添加这些控件后，目录模式将在页面上变为受支持的显示模式，因为必要的控件可用于启用目录模式。  
  
 当用户将页面切换到目录模式时，区域以及添加到其中的所有服务器控件都变为可见，用户可以从目录中选择要添加到页面的控件，或者从页面中删除控件。 将控件添加到页面后，它们将以正常的浏览模式显示，并更新页面。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 字段。 此代码使用页面支持的显示模式填充下拉列表，在此示例中为 "浏览"、"设计" 和 "目录"。 由于网页中的 `<asp:CatalogZone>` 元素及其子元素，目录模式可用。 请注意，在 `Page_PreRender` 方法中，代码会检查当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性是否设置为 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>"。 如果是这样，`Label1` 将可见，如果不是，则将隐藏 `Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后，默认情况下处于浏览模式。 请注意，页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到目录模式。 请注意，由于 `Page_PreRender` 方法中的代码，标签现在可见。 可以在目录中选择控件，并将其添加到页面上两个区域中的任意一个。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查发出请求的浏览器的功能，并检查 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 属性的值，以确定是否呈现客户端脚本。</summary>
        <returns>一个布尔值，指示是否呈现客户端脚本。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个警告，用户关闭在连接中充当其他控件的提供者的控件时，会显示该警告。</summary>
        <value>一个包含警告消息的字符串。 默认值是一条由 .NET Framework 提供的、特定于区域性的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件时，通常不会显示任何消息。 有关关闭控件的方法的详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 但是，当控件连接到其他控件并作为数据的提供程序时，当用户尝试关闭控件时，将显示默认警告消息。 消息告知用户提供程序控件即将关闭，这意味着以使用者身份连接到此提供程序的控件将不再具有任何要使用的数据。 利用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 属性，开发人员可以自定义向用户显示的警告消息。  
  
 如果页面开发人员将空或空字符串值分配给此属性，则当用户关闭作为提供者的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件时，将不会显示任何警告消息框。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 属性向用户显示自定义警告。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要为上述自定义控件提供自定义用户控件和源代码。 从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分获取这两个项。  
  
 以下网页代码演示了如何将自定义警告消息分配给 `<asp:webpartmanager>` 元素中声明性标记中的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 连接用户界面（UI）出现后，单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**"，然后单击 "**连接**" 完成两个控件的连接。 单击 "**关闭**"，然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 最后，单击**邮政编码**控件的谓词菜单（在本例中为提供程序控件），然后选择 "**关闭**"。 将显示您分配给 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 属性的自定义消息。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中关闭的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件。</param>
        <summary>以不在网页上呈现，但可以重新打开的方式关闭 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法将删除 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件，使其不会在最初包含它的网页中呈现。 将关闭的控件添加到 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 对象中，该对象维护对已关闭控件的引用，并使控件可以还原到页面。 关闭的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件仍会出现在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性所引用的集合中。  
  
 关闭控件不同于删除控件。 关闭的控件仍可还原到页面，但已删除的控件实例将被永久删除且永远无法还原。 不管 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件是静态的（在页的标记中声明）还是动态的（以编程方式或通过 Web 部件目录中的用户添加），都可以在页面上关闭和重新打开。  
  
 通常，用户可以通过单击其动词菜单并选择 "关闭" 谓词来关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 还可以通过直接调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法并向其传递对 `webPart`的引用来关闭控件。  
  
 在已关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的页上，如果开发人员声明一个 `<asp:catalogzone>` 元素，在该元素中添加一个 `<asp:pagecatalogpart>` 元素，则它将为用户提供一个简单的用户界面（UI），以便用户能够在运行时将关闭的控件还原到页面。 用户可以将页面切换到目录显示模式，而关闭的控件将显示在页目录中。 用户可以选择 "已关闭" 的控件并将其添加回页面所需的任何位置，然后将所选控件还原到页面并呈现为正常。  
  
 调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法时，它会引发几个事件： <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> （如果有多个控件）和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> （如果有连接的控件）。 通常，开发人员可以取消这些事件，但在某些情况下，不可能取消这些事件。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件的文档。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 此代码示例包含四个部分：  
  
-   允许您更改页面显示模式的用户控件。  
  
-   自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。  
  
-   网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此代码示例的第二部分是自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此示例使用动态编译方法;因此，此控件在网页顶部的 `Register` 指令中没有 `Assembly` 特性。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 此代码示例的第三部分是网页。 页面包含一个 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域，其中声明了 `<asp:pagecatalogpart>` 元素。 这是将包含已关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件并允许用户将其添加回页面的内容。 `Button1_Click` 方法直接调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法来关闭自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，但用户也可以通过谓词菜单关闭控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 在浏览器中加载页面后，单击控件标题中的谓词菜单（箭头符号），然后单击 "**关闭**"，以关闭 "自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart>" 控件。 现在，通过在 "**显示模式**" 下拉列表控件中选择 "**目录**"，将页面更改为目录模式。 页面目录显示为关闭的控件。 选中关闭的控件旁边的复选框，单击 "**添加**" 将其添加到页面，然后单击 "**关闭**" 以将该页返回到浏览模式。 控件将还原到页面。 现在，单击 "**关闭 WebPart** " 按钮，此时将其关闭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
或 
 <paramref name="webPart" /> 是共享控件，并已被另一个用户关闭。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于显示特殊用户界面 (UI) 以便用户管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 字段引用由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建和包含的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。 因为这是一个静态对象，所以可以直接通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类引用它，而无需控件的实例。  
  
 当用户想要管理网页上 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件之间的连接时，如果已在页面上声明了 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 区域，则可以将页面切换到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 模式。 "连接" 显示模式显示用于管理连接的特殊 UI，其中包括连接控件或断开连接的功能，以及编辑现有连接的详细信息。  
  
 如果希望为用户提供管理 Web 部件控件集提供的 UI 的连接的功能，则必须在页面的标记中声明一个 `<asp:connectionszone>` 元素。 与其他类型的 <xref:System.Web.UI.WebControls.WebParts.WebZone> 区域的元素不同，无需在此元素中添加任何其他标记;只需自行声明元素。  
  
   
  
## Examples  
 下面的代码示例演示 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 模式的用法。  
  
 此代码示例包含三个部分：  
  
-   一个源文件，其中包含可形成连接的接口和自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。  
  
-   提供连接 UI 并演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 模式的网页。  
  
-   有关如何运行该示例的说明。  
  
 此代码示例的第一部分是包含一个接口和两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的源文件，这些控件设计为可以连接。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 该示例的第二部分是承载自定义控件的网页。 在服务器的 "服务器 `<script>` 标记" 中，需要使用页面上可用的显示模式填充下拉列表的几种方法。 用户可以从下拉列表中进行选择，以更改页面的显示模式。 可用的显示模式之一是连接显示模式，因为在页面的标记中声明了 `<asp:connectionszone>` 元素。 请注意，此元素不包含任何其他子元素;它只是为了为用户启用连接管理 UI。  
  
 在此示例中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 模式显示在两个位置。 首先，在 `Page_Init` 方法中，将连接显示模式添加到显示模式的下拉列表中，因为代码会遍历 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性中引用的集合。 其次，`Page_PreRender` 方法检查页上当前的显示模式，并且如果当前模式为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>，则 <xref:System.Web.UI.WebControls.Label> 控件中将显示一条消息。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 在浏览器中加载页面后，单击下拉列表，然后选择 "**连接**"，将页面切换到 "连接" 显示模式。 请注意，会显示一条消息，告知你该页处于连接显示模式。 现在，单击其中一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的标题栏中的谓词菜单（箭头符号），然后在谓词菜单中单击 "**连接**"。 显示连接 UI 后，单击该链接以创建连接。 使用 "连接" UI 中显示的下拉列表，选择将参与连接的其他控件，并单击 "**连接**" 按钮。 建立连接。 单击 "**关闭**" 按钮，然后使用页面顶部的下拉列表返回页面以浏览显示模式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有当前连接的集合的引用。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 属性提供了一种方法来访问页面上的当前连接集。 集合本身是只读的，并且想要从集合中操作特定连接的开发人员应使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法，如 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。  
  
   
  
## Examples  
 下面的代码示例演示 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的声明性和编程使用。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要为上述自定义控件提供自定义用户控件和源代码。 从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分获取这两个项。  
  
 以下网页代码演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 属性来获取页面上当前连接的计数。 请注意，在 `<script>` 标记部分，处理 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的两个事件的代码将访问 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 属性以获取计数。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 显示连接用户界面（UI）后，单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**"，然后单击 "**连接**" 完成两个控件的连接。 单击 "**关闭**"，然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 请注意，标签现在显示连接数和 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件数。 如果你现在返回到连接模式并断开两个控件的连接，则当你返回到浏览模式时，应更新标签的内容，并且不应建立任何连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在页上的所有当前 Web 部件连接不仅已经连接，而且已经开始在每个连接所涉及的使用者控件和提供者控件之间共享数据之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在连接的生命周期中，此事件在页面完成其加载过程之后发生。 它还在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件之后发生，该事件只指示特定连接中涉及的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件已成功连接。 如果页面上有多个连接，则 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 方法表明页面上所有有效的 Web 部件连接现在都处于活动状态，并且能够共享数据。 了解所有连接都是活动的，开发人员可以执行任意数量的任务，包括向用户通知所有连接的状态，通知使用者控件处理和显示来自其提供程序的数据等。  
  
 此事件与引发事件并允许开发人员为事件创建自定义处理程序的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 方法相关联。  
  
 页面开发人员可以通过将 `OnConnectionsActivated` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，来为事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在激活网页上所有已建立的 Web 部件连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在连接的生命周期中，此事件在页面完成其加载过程之后，就在调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 方法之前发生。 它与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 事件不同，后者涉及 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件之间的特定连接。 当页面上的所有可能的连接都已连接并且即将激活时，将发生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 事件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 事件与引发事件的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 方法相关联。 要扩展可添加到页面的连接类型的控件开发人员可能会重写受保护的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 方法，并激活其他类型的连接。  
  
 页面开发人员可以通过将 `OnConnectionsActivating` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，来为事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或其他能建立连接的服务器控件）之间创建一个连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法构成可以连接的任意两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件之间的连接。 在调用此方法创建连接之前，您可能还需要在条件检查中调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法，以确保控件满足建立连接的要求。  
  
> [!NOTE]
>  还可以在不 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的两个服务器控件之间创建连接。 通常，这两个控件必须是自定义服务器控件（例如，从 <xref:System.Web.UI.WebControls.WebControl> 或现有 ASP.NET 服务器控件继承的控件），以便您可以添加所需的成员。 这些控件还必须满足下面指定的要求。  
  
 两个控件之间的任何连接方案类型都必须满足以下要求才能进行连接：  
  
-   每个控件都位于 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中（不必是同一区域）。  
  
-   在 Web 部件控件集中实现时，连接中的提供程序控件以公共方法的形式实现接口，该方法充当提供程序的回调，并在方法上具有 `ConnectionProvider` 的元数据特性，以将其标识为提供程序连接点。 由于检索提供程序连接点的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法是虚拟的，因此派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件不必使用相同的元数据特性。  
  
-   在 Web 部件控件集中实现时，连接中的使用者控件还具有一种特殊方法，使其能够获取对提供程序的回调方法中公开的接口的引用，而使用 `ConnectionConsumer` 者在方法将其标识为使用者连接点。 由于检索使用者连接点的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法是虚拟的，因此派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件不必使用相同的元数据特性。  
  
-   回调方法必须兼容，因为使用者可以使用提供程序的回调方法中提供的接口类型（意味着使用者和提供者可以直接共享数据），或者开发人员必须使用 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象进行转换从提供程序到使用者可以使用的形式的数据。  
  
    > [!IMPORTANT]
    >  如果不需要转换器，请使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 方法重载。 如果需要转换器，请使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 方法重载。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责向另一个连接控件提供数据。</param>
        <param name="providerConnectionPoint">用作连接回调方法的方法。 与 Web 部件控件集中实现的一样，这是 <paramref name="provider" /> 中以 <see langword="ConnectionProvider" /> 元数据特性标记的一个公共方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责接收来自 <paramref name="provider" /> 的数据，然后处理或显示接收到的数据。</param>
        <param name="consumerConnectionPoint">与 <paramref name="providerConnectionPoint" /> 连接的方法，它接收连接的数据。 与 Web 部件控件集中实现的一样，这是 <paramref name="consumer" /> 中以 <see langword="ConnectionConsumer" /> 元数据特性标记的一个公共方法。</param>
        <summary>只使用对控件的引用和控件所指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象在两个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含连接所需的提供者和使用者的各种信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于在其连接点完全兼容的情况下连接控件，而无需使用 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象即可进行连接。 调用方法的此重载时，它只是将调用传递到该方法的其他重载版本，并为需要 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象的参数传递 `null`。  
  
 尝试以编程方式连接两个控件时，可以在条件检查中使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法来确定控件是否可以直接连接。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法以编程方式创建连接。 有关运行此示例所需的完整代码，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分。 从该示例中，您将需要用户控件的源代码，该源代码允许您更改页面上的显示模式，以及两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的源代码。  
  
 接下来的两个控件的网页的代码如下所示。 该页使用顶部 `Register` 指令来声明用户控件和自定义控件。 然后，在 `<asp:webpartzone>` 元素中以声明方式引用自定义控件。 处理 `Button1_Click` 方法的代码通过使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法在控件之间创建连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，请单击 "**连接" WebPart 控件**按钮以建立连接。 然后，您可以在文本框中输入一些数据，然后单击 "**输入5位数字的邮政编码**" 按钮以演示控件已连接，并且在第二个控件中输入的数据将在第二个控件中更新。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态集合的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件集合是只读的。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它的角色是为另一个连接的控件提供数据。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> 中的一个公共方法，它标有 <see langword="ConnectionProvider" /> 元数据特性，并用作连接的回调方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它担任从 <paramref name="provider" /> 或 <paramref name="transformer" /> 中接收数据然后对数据进行处理和显示的角色。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> 中的一个公共方法，它标有 <see langword="ConnectionConsumer" /> 元数据特性，并与 <paramref name="providerConnectionPoint" /> 连接以接收连接的数据。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它通过将数据从 <paramref name="provider" /> 转换为 <paramref name="consumer" /> 可以处理的格式来实现两个控件之间的连接。</param>
        <summary>使用对两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的引用、它们的指定 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 对象和一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在这两个控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，它包含有关提供者、使用者以及连接所需的转换器的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当控件的连接点不兼容时，此重载用于连接控件。 当 `consumer` 实现的接口不同于 `provider` 作为其连接点时，会发生不兼容的情况。 转换器将数据转换为可由 `consumer`理解的类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">连接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中激活。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在网页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中并由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件管理的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、服务器或用户控件的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.ControlCollection" />，包含由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的所有控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> 属性不引用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件引用的其他控件，如各种区域控件、<xref:System.Web.UI.WebControls.WebParts.EditorPart> 或 <xref:System.Web.UI.WebControls.WebParts.CatalogPart> 控件等。  
  
 此属性由 Web 部件控件集使用，在大多数开发环境中，它不应从代码中调用。 出于此原因，虽然属性是公共的，但它在 IntelliSense 中是隐藏的。 要访问 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件的集合的开发人员应使用其 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要复制的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>由 Web 部件控件集用来创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的副本，以向网页中添加该控件。</summary>
        <returns>要添加到页中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能直接从代码中调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 方法。 此方法由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件在内部调用，作为向页面添加新的动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件的过程的一部分。 动态控件以编程方式或通过 Web 部件用户界面（UI）添加到页面，例如，用户从控件目录添加控件，而不是静态控件（直接在页面的标记中声明）。  
  
> [!NOTE]
>  如果开发人员希望使方法能够处理其他控件复制方案，则可以在派生类中重写方法。 有关详细信息，请参阅对继承者的说明部分。  
  
 添加新的动态控件时，如果它是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，则 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 方法返回控件的新实例。 如果要添加的控件是其他类型的服务器控件（例如用户控件、自定义控件或 ASP.NET 控件），则控件将已由 Web 部件控件集通过 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象进行包装。 当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 方法遇到 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 的控件时，它会返回 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件的一个新实例，其中包含一个换行的子控件的新实例。  
  
 当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 方法创建要返回的控件的新副本时，它还会将所有属性的值重置为其默认值。 请注意，如果想要保留可个性化属性的值并将其复制到新的控件实例，还应调用 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> 方法。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 方法执行的最后一步是调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> 方法来获取控件的新 ID。  
  
> [!NOTE]
>  由于方法获取已复制控件的新 ID，因此不应依赖于通过其原始 ID 添加到页的动态控件。 应改为引用由方法返回的控件的新实例。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>方法被声明为 <see langword="virtual" />，以便开发人员可以从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承，重写方法，并提供可创建控件副本的其他方案。 例如，方法可以选择以输入的形式接收已序列化为 XML 文件的控件。 方法可以反序列化 XML （如果存在），然后调用基方法来处理现有事例并返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的新实例。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一组在网站配置文件中指定的转换器，并将它们添加到 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 属性所引用的转换器的集合。</summary>
        <returns>网站的配置文件中指定的转换器的集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>可以重写此方法，以添加应用程序可使用的附加转换器。 例如，可以编写方法，从 Web 服务检索可用转换器的列表。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有控件的集合。 此类不能被继承。</summary>
        <returns>一个 <see cref="T:System.Web.UI.ControlCollection" />，由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有 Web 部件控件组成。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>由于此方法是受保护的，因此它对从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承的类可见，但不能重写。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 Web 部件应用程序创建由所有可能的显示模式组成的显示模式集。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有受支持的显示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会创建所有可能的显示模式的列表，而不只是特定页面上支持的显示模式。 有关支持的显示模式的详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性。  
  
 默认情况下，Web 部件控件集会创建以下一组显示模式，用于 Web 部件页：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 开发人员可以创建自定义的显示模式，无论是附带还是不附带派生自 <xref:System.Web.UI.WebControls.WebParts.WebZone> 或 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 类的自定义区域。 若要创建自定义显示模式，你必须从 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 类继承，若要在页面上将显示模式添加为受支持模式，你必须从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类继承并重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 当您使用 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> 方法添加显示模式时，应按照您希望它们显示在任何用户界面（UI）控件（如 <xref:System.Web.UI.WebControls.ListBox> 控件）中的顺序添加它们，使用户能够在页面上显示可能的显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 此代码示例包含五个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   承载其他控件的网页。  
  
-   驻留在网页上的 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域中的用户控件，可用于在标签中输入和显示文本。  
  
-   包含两个控件的源代码文件。 一个是自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件，另一个是要添加到页面的默认显示模式的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是网页。 它包含两个 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 控件：用户控件和自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件。 请注意页面顶部的 `Register` 指令，以引用已编译控件的用户控件和命名空间。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 该示例的第三部分是用户控件，用于输入和显示文本。 它使用 <xref:System.Web.UI.WebControls.MultiView> 控件来创建用户界面的多个视图。 其中一个视图显示有 "`Button1`" 按钮，而另一个没有。 请注意，在重写的 `OnPreRender` 方法中，代码将进行检查以确定页面当前是否处于自定义显示模式，如果是，则显示 "用户" 控件的第一个视图，其中包含按钮。 如果页面不在自定义显示模式下，例如，如果页面处于浏览或设计模式，则隐藏按钮。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 该示例的第四部分是两个自定义类的源文件。 请注意，自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类将重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法，并且它首先调用基方法以添加所有默认显示模式，然后添加自定义显示模式。 自定义显示模式类 `InLineEditDisplayMode`只是从 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>继承，它在构造函数中设置显示模式的名称，并覆盖一些基属性以建立自定义显示的特征。  
  
 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要运行此代码示例，请在浏览器中加载此页。 请注意，页面目前处于浏览模式，并且没有按钮可见。 使用 "**显示模式**" 下拉列表控件，将页面更改为**内联编辑显示**模式，请注意，现在 "`Button1`" 按钮在低级用户控件中可见。 添加一些文本，然后单击按钮以更新控件。 请注意，页面显示将返回到浏览模式，此时将显示您输入的文本，并且该按钮再次隐藏，因为该页面不再处于自定义显示模式。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：在 Web 部件页上更改显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个唯一值，用于充当动态连接的 ID。</summary>
        <returns>一个包含连接的唯一 ID 的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> 方法将生成一个 GUID 值，并将其转换为字符串，以用作连接的唯一 ID。 每次创建动态连接时都将调用方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在派生的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中重写此方法，以更改实现以生成唯一 ID。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">为其生成 ID 的控件的 <see cref="T:System.Type" />。</param>
        <summary>为动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件生成唯一 ID。</summary>
        <returns>一个字符串，包含控件的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件添加到网页时，它们可以是静态的（这意味着控件是在页标记中声明的）或动态的（这意味着以编程方式添加）。 在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建要添加到页面的新动态控件的任何情况下，它将调用此方法来生成唯一 ID。  
  
 方法是虚拟的，因此，如果开发人员希望提供用于生成 ID 的自定义实现，则可以重写此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">作为失败控件 ID 的字符串。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该 ID 为其子服务器控件的 ID。</param>
        <param name="originalTypeName">字符串，失败控件的 <see cref="T:System.Type" /> 名称。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该类型名称是其子服务器控件的类型。</param>
        <param name="originalPath">包含用户控件路径的字符串（如果失败涉及包含子用户控件的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />）。</param>
        <param name="genericWebPartID">返回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> ID 的字符串（如果加载或创建控件的失败涉及该类型的控件）。</param>
        <param name="errorMessage">包含要在页中显示的错误消息的字符串。</param>
        <summary>当加载或创建动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的尝试因某种原因失败时，创建插入页中并向最终用户显示的特殊控件。</summary>
        <returns>插入页中以替代未能加载或创建的控件的 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 Web 部件控件集尝试加载或创建动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件的实例时，将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 方法，但出于某种原因而失败。 方法创建一个 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 对象，向其分配错误消息并返回该对象。 插入 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 控件来代替失败的控件，并在页面上显示其错误消息。  
  
 不能直接从代码中调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 方法。 但是，可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类继承并扩展方法。 有关详细信息，请参阅对继承者的说明部分。  
  
 最终用户可以在页中使用 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 控件，就像是正常的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 若要删除错误消息，可以通过单击关闭谓词关闭控件，此时，控件将添加到 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 的对象，就像任何其他关闭的控件一样。 如果最终用户删除 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 控件，则无法加载的服务器控件也将从页中删除。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果要自定义在 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 控件中返回的信息，则可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> 方法，调用基方法，为传递到基方法的参数分配不同的值，然后返回生成的 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 控件。 例如，如果您不希望最终用户看到 <paramref name="originalPath" /> 值（这会显示用户控件的虚拟目录路径），则当您调用基方法时，可以为该参数传递空字符串（""）。  
  
你还可以通过从其继承来自定义 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 控件本身的行为。 例如，你可能想要重写其 <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> 属性。</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个个性化设置对象，该对象包含当前网页的用户个性化设置数据。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含用户的个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> 方法返回一个对象，该对象包含并管理当前页的用户个性化设置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理此对象。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化概述</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的服务器控件。</param>
        <summary>用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象包装一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的服务器控件，以使该控件能具有 Web 部件的功能。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，包装 <paramref name="control" /> 并使其功能与真正的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件一样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法是启用不 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的服务器控件的主要机制，以使其与 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件具有相同的功能，从而完全参与 Web 部件应用程序。 通过使用此方法，开发人员大大扩展了在 Web 部件应用程序中可以使用的服务器控件数，因为几乎任何类型的服务器控件（标准 ASP.NET 控件、用户控件和自定义控件）都可以使用。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件还在两个其他方案中使用此方法，以将服务器控件与 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象进行包装。 当用户通过使用 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 控件将服务器控件添加到页面时，如果导入的控件不是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，则将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法。 此外，当服务器控件在网页上的 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域内以持久性格式进行声明时，将为不 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的任何控件调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法。  
  
 以编程方式将服务器控件添加到区域时，一种典型的方法是使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法，使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象包装控件，然后调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 方法将控件添加到页面上所有 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的集合中。，由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性引用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法。 在 `Button2_Click method`中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 方法用于在将 <xref:System.Web.UI.WebControls.Calendar> 控件添加到区域之前，使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象将该控件包装。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>可以重写此方法，以使用派生 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 类，而不是 Web 部件控制集提供的基类。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个自定义警告消息，当最终用户删除一个控件时，将显示该消息。</summary>
        <value>包含警告消息文本的字符串。 默认值是经本地化的警告消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户删除 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件时，通常会显示默认警告消息。 它会警告用户，在删除控件的此实例时，删除是永久性的。 页面开发人员可以向用户提供一种方法，用于向页面添加控件的新实例（例如通过目录 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件或通过某些编程方式），但删除的控件的当前实例将被永久删除。 如果需要，显示警告的对话框包含用户用于取消删除的按钮。  
  
 利用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 属性，开发人员可以设置向用户显示的警告消息。  
  
 如果页面开发人员将空字符串（""）值分配到此属性，则当用户删除 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件时，将不会显示任何警告消息对话框。  
  
> [!NOTE]
>  静态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和服务器控件的情况下不会显示 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 属性。 静态控件是在网页的标记内的 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中声明的服务器控件。 由于此类控件是静态的，因此无法将其删除，因此在这种情况下，永远不会显示删除警告消息。 静态控件可以由用户关闭，但会将已关闭的控件添加到页目录中，用户可以将其添加回页面，而不能恢复已删除的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何以声明方式和编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 属性。  
  
 此代码示例分为四个部分：  
  
-   允许您更改页面显示模式的用户控件。  
  
-   自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。  
  
-   网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 此代码示例的第二部分是自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此示例使用动态编译方法;因此，此控件在网页顶部的 `Register` 指令中没有 `Assembly` 特性。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 此代码示例的第三部分是网页。 页面包含一个 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域，其中自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件在区域中声明，因此用户可以在运行时将其添加到页面中。 请注意，只能从页中删除动态控件（以编程方式或从此类的目录添加到页面的控件）。 静态控件（在页的标记中的 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中声明的控件）可以关闭，但不能删除。 `<asp:webpartmanager>` 元素使用 `DeleteWarning` 属性为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 属性声明一个自定义值。 `Button1_Click` 方法向 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 属性分配另一个自定义值。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 在浏览器中加载页面后，需要将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件添加到页面。 使用 "**显示模式**" 下拉列表控件选择 "目录模式"。 当目录出现时，选中自定义控件旁边的复选框，单击 "**添加**" 将其添加到页面，然后单击 "**关闭**" 以将该页返回到浏览模式。 控件可见后，可以将其删除。 再次使用 "**显示模式**" 控件，将页面切换到设计模式（页面处于浏览模式时无法删除控件）。 单击 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件标题中的谓词菜单（箭头符号），然后选择 "**删除**"。 此时将显示您在 `DeleteWarning` 属性上设置的警告。 单击“取消”。 现在，单击标签为 "**更改删除警告**" 的按钮，这将以编程方式更改属性值。 从控件上的谓词菜单中，再次选择 "**删除**"，并注意到这次出现其他警告消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要删除的服务器控件。</param>
        <summary>永久地从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的动态实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法将从页中永久删除 `webPart` 参数所表示的控件。 与已添加到 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 控件并且可添加回页面的关闭的控件不同，已删除的控件实例永远无法添加回页面。  
  
> [!NOTE]
>  按照 Web 部件控件集的实现，用户删除动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的能力取决于用户以及控件添加到页面中的个性化设置范围。 如果在页处于共享范围中时添加控件（由具有权限的用户），则当该页处于用户范围中时，不能由单个用户删除该控件。  
  
 只能删除动态控件。 动态控件以编程方式或从目录添加控件的用户添加到页面中。 静态控件按标记或持久性格式添加到页中。 由于声明性标记永久存在于标记中，因此永远无法删除静态控件，但可以关闭和重新打开静态控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次单击 "**添加日历**" 按钮时，事件处理程序中的代码会创建一个 <xref:System.Web.UI.WebControls.Calendar> 控件，并将其作为 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象添加到区域。 由于控件是以编程方式添加的，因此它是一个动态控件，因此可以将其删除。 当用户单击 "**删除日历**" 按钮时，代码确保控件存在，然后通过调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法将其删除。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于更改包含 Web 部件控件的网页布局的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 字段引用由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建和包含的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。 因为这是一个静态对象，所以可以直接通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类引用它，而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时，默认情况下它处于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> （浏览模式）。 如果用户想要通过将控件移到不同的区域或当前区域中来更改页面布局，则必须先将页面切换到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> （设计模式）。 在设计模式下，将显示各个区域的用户界面（UI），然后用户可以拖动控件来更改布局。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 字段。 此代码使用页面支持的显示模式（在本例中为 "浏览" 和 "设计"）填充下拉列表。 请注意，在 `Page_PreRender` 方法中，代码会检查当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性是否设置为 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>"。 如果是这样，`Label1` 将可见，如果不是，则将隐藏 `Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后，默认情况下处于浏览模式。 请注意，页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到设计模式。 请注意，由于 `Page_PreRender` 方法中的代码，标签现在可见。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要断开连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</param>
        <summary>移除要关闭或要从其所参与的连接中删除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当控件在页上关闭或从页中删除时，Web 部件控件集会在内部调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 在这种情况下，将调用方法，以将控件从任何连接（其中包含为使用者或提供者）中删除。 如果从任何连接中删除该控件，则此方法还会调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法来结束涉及 `webPart` 的任何连接。  
  
 调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法时，它会引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。 通常可以取消此事件，但在两种情况下，不能取消此事件。 当调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 方法时，会在对页面的请求期间发生一种情况。 如果现有连接之间存在冲突，则将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法来关闭其中一个冲突的连接，在此实例中，无法取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件，因为必须解决冲突。  
  
 另一种情况是：当前连接的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件已关闭或已被删除。 在这种情况下，由于正在从页面中删除控件，因此还需要终止其连接，因此，设计时无法取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件来中断结束连接的过程。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 使用两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，可以通过单击一个按钮在控件之间创建连接，而使用另一个按钮可以断开控件的连接。 如果在页处于浏览模式并且控件已连接时关闭其中一个控件，则 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法的重写会断开关闭的控件、结束连接并显示一条消息。  
  
 此代码示例包含四个部分：  
  
-   用于更改显示模式的用户控件。  
  
-   包含自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的源文件。  
  
-   用于承载控件的网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是包含要连接的两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件以及自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的源代码的文件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此示例使用动态编译，因此在网页顶部声明了引用这些组件的 `Register` 指令。 有关演示如何编译选项的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 在源代码中，请注意覆盖 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法的继承的控件 `MyWebPartManager`。 此方法检查页中的每个连接，以查看关闭的控件是否参与连接，如果是，则调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法以结束连接。 这与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件中的方法的基实现完全相同。 然后，重写的方法通过将消息写入页面来自定义基实现。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，在顶部附近，它包含用于注册用户控件的 `Register` 指令，以及包含 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的动态编译的程序集。 此页具有两种主要方法。 `Button1_Click` 方法在控件之间创建连接，而 `Button2_Click` 方法断开控件的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，单击 "**连接**" 按钮以连接控件。 然后单击其中一个控件中的谓词菜单（控件标题中的向下箭头），然后从谓词菜单中选择 "**关闭**"。 尝试关闭控件时，将调用重写的方法，连接将结束，并且消息将写入页面。 如果要重置页面以还原关闭的控件并尝试其他选项，请单击 "**重置用户状态**" 链接以删除个性化设置数据并还原页面的原始状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">表示服务器控件之间的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>执行断开网页中连接的服务器控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你向其传递 `connection` 参数时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法将执行结束 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件之间的连接的整个过程。  
  
 当您将 `<asp:connectionszone>` 元素放置在网页中时，此方法用于断开控件的连接，以提供用于管理连接的用户界面（UI）。 当某个页面处于连接显示模式（<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>）并且存在当前连接时，用户可以单击一个按钮来调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法以结束连接。  
  
 如果要以编程方式断开控件连接，而无需将 `<asp:connectionszone>` 元素添加到页面，还可以直接从代码调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 使用两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，可以通过单击一个按钮在控件之间创建连接，而使用另一个按钮可以断开控件的连接。  
  
 此代码示例包含四个部分：  
  
-   用于更改显示模式的用户控件。  
  
-   包含自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的源文件。  
  
-   用于承载控件的网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是一个文件，其中包含要连接的两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的源代码。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此示例使用动态编译，因此在网页顶部声明了引用这些组件的 `Register` 指令。 有关演示如何编译选项的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，在顶部附近，它包含 `Register` 指令来向 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件注册用户控件和动态编译的程序集。 此页具有两种主要方法。 `Button1_Click` 方法在控件之间创建连接，`Button2_Click` 方法断开控件的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，可以单击 "**连接**" 按钮连接控件。 如果在 "文本框" 控件中输入一些文本，然后单击 "**输入**" 按钮，则该文本将显示在连接的控件中（如果控件已断开连接，则不会显示）。 如果单击 "**断开连接**" 按钮，控件将断开连接。 您可以通过使用 "**显示模式**" 下拉列表控件来验证控件的连接状态，以将页面切换到**连接**模式。 完成此操作后，单击其中一个控件的标题栏中的谓词菜单（表示为箭头），然后选择 "**连接**" 项。 显示连接 UI;它可用，因为在页面中声明了 `<asp:connectionszone>` 元素。 你还可以通过此 UI 连接和断开控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 为只读。  
  
或 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 断开。  
  
或 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 为只读。  
  
或 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 断开。</exception>
        <block subset="none" type="overrides"><para>如果要更改断开 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的默认实现，可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> 方法。 如果确实要重写方法，而只是想要向现有方法添加一些实现，则可以在执行自己的代码之前调用基方法。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含 Web 部件控件的网页的活动显示模式。</summary>
        <value>确定页显示模式的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含 Web 部件控件的页始终处于多种可能的显示模式之一。 有关显示模式的详细信息，请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类创建网页的显示模式。 使用 base <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 类，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建多个标准显示模式对象，这些对象可用于包含 Web 部件控件的页面。 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 类概述中介绍了这些标准显示模式。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件还管理使用 Web 部件控件的页面的显示模式。 使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件可保留对页面上当前显示模式的引用。 你还可以使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性将页面切换到不同的显示模式。 有关在使用 Web 部件控件的页上更改显示模式的示例，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 作为管理显示模式的一部分，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件还提供与显示模式相关的事件和事件处理程序，如 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 方法和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 方法。 这些方法提供了一种机制，用于自定义页面的行为，甚至用于添加自定义显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性。 在浏览器中加载页面后，可以使用页面底部附近的按钮来切换显示模式。 默认情况下，在加载时，该页处于浏览模式。 如果切换到设计模式，则可以将服务器控件从一个区域拖动到另一个区域，或在一个区域中排列两个控件。 如果切换到编辑模式，则可以单击任一服务器控件标头中的谓词菜单，选择 "**编辑**"，然后使用提供的编辑用户界面（UI）编辑控件。  
  
> [!NOTE]
>  在 Web 部件应用程序中切换显示模式很常见，你可能希望在包含 Web 部件控件的所有页面上提供一致、可重复使用的方法来执行此操作。 有关更改显示模式并可在多页上重复使用的用户控件的示例，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象不是受支持的显示模式。  
  
或 
赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象已禁用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：在 Web 部件页上更改显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 Web 部件页上的当前显示模式更改之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的一部分。 当用户切换到网页上的不同显示模式时，该页面通常会采用不同的外观，这取决于新的显示模式的用途。 在显示模式发生更改后，您可能希望在用户界面（UI）中进行某些更改，如隐藏或显示某些控件、更改所选 UI 元素的外观等。  
  
> [!NOTE]
>  有关显示模式的详细信息，请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击网页上的谓词以启动不同显示模式之间的更改过程之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的一部分。 当用户切换到网页上的不同显示模式时，该页面通常会采用不同的外观，这取决于新的显示模式的用途。 用户启动通过单击谓词更改为新的显示模式的过程后，你可能想要在用户界面（UI）中进行某些更改，方法是使用 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> 属性来确定新的显示模式将是什么，然后更改各种 UI 元素 accordingly. 实现此目的的一种有用方法是重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 方法以自定义 UI。  
  
> [!NOTE]
>  有关显示模式的详细信息，请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件关联的所有显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 属性引用所有关联的显示模式，与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性相反，后者只引用当前页上可用的（受支持的）显示模式。  
  
 页面上始终支持两个提供的显示模式： "浏览" 和 "设计"。 仅当页面具有特定显示模式所需的相应类型的区域时，才支持其他三种显示模式： "编辑"、"目录" 和 "连接"。 例如，如果页不包含 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 区域，则编辑显示模式将显示在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 属性所引用的集合中，但不会出现在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性所引用的集合中。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 属性。 该代码使用此属性来填充列表，其中包含 Web 部件控件集中可用的所有显示模式，甚至是当前页上不支持的显示模式。 在这种情况下，目录和连接显示模式不受支持，因为其相应的所需区域不在页面上。  
  
 其他三种显示模式--在页面上支持 "浏览"、"设计" 和 "编辑"。 支持编辑模式，因为页面包含 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 区域，并且始终支持浏览和设计模式。  
  
 在浏览器中加载页面后，可以使用下拉列表控件将页面从浏览模式切换到设计模式，然后切换到编辑模式。 在编辑模式下，可以单击其中一个服务器控件标头中的下拉谓词菜单，然后选择 "**编辑**" 以编辑控件。 请注意，如果在下拉列表中选择 "**目录**" 或 "**连接**"，则会生成错误页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：在 Web 部件页上更改显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取网页上当前存在的所有动态连接的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含对页上所有动态连接的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态连接是以编程方式创建的连接，而不是静态的。 通过在 Web 窗体页的标记中声明静态连接来创建静态连接。 动态连接可通过编程方式或使用连接用户界面（UI）创建连接的用户形成。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 集合（尽管它是只读的，不能更改其内容）提供了对每个动态连接对象的编程访问。  
  
> [!NOTE]
>  若要执行诸如连接或断开 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件等常见操作，开发人员应使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类上的公共方法，如 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而不是尝试直接修改 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 中的连接对象。集合.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示最终用户可在其中编辑和修改服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 字段引用由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建和包含的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 对象。 因为这是一个静态对象，所以可以直接通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类引用它，而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时，默认情况下它处于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> （浏览模式）。 当用户想要编辑或修改服务器控件时，必须先将该页面切换到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> （编辑模式）。 其次，它们必须选择要编辑的特定服务器控件，方法是单击该控件标题中谓词菜单上的 "编辑" 谓词。 控件处于编辑模式后，将显示编辑用户界面（UI）以编辑选定的控件。  
  
 若要在页面上启用编辑模式，页面必须包含至少一个 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 区域，其中包含一个或多个所提供的编辑控件，如 <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> 控件或自定义编辑控件。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 字段。 此代码使用页面支持的显示模式填充下拉列表，在本例中为 "浏览"、"设计" 和 "编辑"。 若要支持编辑，请在页面中 `<asp:EditorZone>` 元素。 请注意，在 `Page_PreRender` 方法中，代码会检查当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 属性是否设置为 "<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>"。 如果是这样，`Label1` 将可见，如果不是，则将隐藏 `Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后，默认情况下处于浏览模式。 请注意，页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到编辑模式。 请注意，由于 `Page_PreRender` 方法中的代码，标签现在可见。 单击其中一个控件的谓词菜单中的 "**编辑**" 谓词，以启用对该特定控件的编辑。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定在包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的网页上是否启用了客户端脚本。</summary>
        <value>一个布尔值，指示页上是否可以运行客户端脚本。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 属性为开发人员提供了一种禁用客户端脚本的方法。 出于安全目的，您可能希望禁用客户端脚本，或确保某个页面的所有用户都具有类似的用户体验，即使他们使用不同的浏览器也是如此。  
  
 可以通过将 `EnableClientScript` 特性添加到网页上的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 元素来禁用客户端脚本，如以下声明性代码行所示：  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外，开发人员还可以通过从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类继承并将默认值设置为 `false`来消除此属性。  
  
 Web 部件控件集使用客户端脚本来提供一些客户端用户界面（UI）和个性化功能。 如果禁用客户端脚本，则 Web 部件控件仍然有效，但某些功能处于禁用状态。 禁用将控件拖放到不同区域的功能，以及在控件标题栏的下拉谓词菜单中呈现谓词的功能（谓词改为显示为控件标题栏中的链接）。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示网页启用了主题。</summary>
        <value>一个布尔值，指示是否启用了主题。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件重写基 <xref:System.Web.UI.Control.EnableTheming%2A> 属性，以确保它始终返回 `true`的值。 这样做是因为 Web 部件控件集需要使用主题来呈现 Web 部件控件，这些控件是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的子控件，并构成网页的用户界面（UI）。 例如，主题用于呈现不同的区域以及驻留在区域中的控件，包括各种类型的部件控件（继承自 <xref:System.Web.UI.WebControls.WebParts.Part> 类的控件）、用户控件、ASP.NET 服务器控件和自定义服务器控件。  
  
 尽管重写的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> 属性根据其基本属性实现为读/写属性，但无法设置属性，因为设计它必须始终返回值为 `true`。 如果尝试设置该属性，则会引发 <xref:System.NotSupportedException> 异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件连接到另一个控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 方法完成将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件连接到其他控件的过程。 它与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 方法是对应的。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 方法确保 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性引用的个性化对象是可修改的，这是必需的，因为构建连接本身就是一种个性化类型。 然后，方法确保未 `null`<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 对象，并最终调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>需要扩展 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者您可能需要完全自定义完成控件之间的连接的整个过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成编辑 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 方法完成编辑 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的过程。 它与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 方法是对应的。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 方法确保 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性引用的个性化对象是可修改的，这是必需的，因为编辑控件是需要进行个性化更改的进程。 然后，该方法确保不 `null`<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 对象，以便当前选定的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件可以更改，并最终调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>需要扩展 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者您可能需要完全自定义完成控件编辑的整个过程。 例如，在重写方法中，你可以先调用基方法，然后添加一些代码来确定进行了哪些编辑更改，并显示返回给最终用户的更改列表作为确认。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在用户尝试从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件导出敏感状态数据时显示的警告消息的文本。</summary>
        <value>一个包含警告消息的字符串。 默认消息是由 .NET Framework 提供的、特定于区域性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户尝试从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件中导出敏感状态数据时，如果导出的任何数据来自源代码中标记为 "敏感" 的成员，则会在消息框中向用户显示一条警告消息。，告诉他们正在导出敏感数据，并提供取消导出的机会。 开发人员可以通过将 `[Personalizable]` 特性的 `isSensitive` 参数设置为成员上的 `true`，将特定成员的数据标记为敏感。 有关此特性和参数的详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> 类。  
  
> [!IMPORTANT]
>  使用 Web 部件的导出功能时，敏感数据可能会导出到未经授权的用户。 有关如何防范此威胁的详细信息，请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每当用户尝试导出时，都会显示默认消息。 但是，通过将值分配给 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 属性，可以提供自定义警告消息。  
  
   
  
## Examples  
 下面的代码示例演示了 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 属性的声明性用法。  
  
 以下网页的代码使用标准 <xref:System.Web.UI.WebControls.BulletedList> 控件，并将其放在区域中。 控件将在运行时使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件进行包装，使其可用作真正的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 若要将控件设置为可导出，请将 `ExportMode` 特性添加到 `<asp:bulletedlist>` 元素，并将属性值设置为 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>，这意味着可以导出敏感数据和非敏感数据。 另请注意，在 `<asp:webpartmanager>` 元素中，将为 `ExportSensitiveDataWarning` 属性分配自定义值。  
  
 请注意，若要使代码示例正常运行，必须在 web.config 文件中添加一个设置，才能导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在 `<system.web>` 部分中，请确保存在一个 `<webParts>` 元素，其 `enableExport` 特性设置为 `true`，如以下标记所示。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 在浏览器中加载页面后，单击包含链接的控件的标题栏中的谓词菜单（由向下箭头表示）。 在谓词菜单中，选择 "**导出**"，并注意出现带有自定义警告的消息框。 如果要继续导出，请单击 **"确定**"，这将允许你使用有关控件的所有数据保存 XML 说明文件的本地副本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">将从中导出数据的控件。</param>
        <param name="writer">一个 <see cref="T:System.Xml.XmlWriter" />，它将导出的数据从 <paramref name="webPart" /> 写入 XML 说明文件。</param>
        <summary>创建包含服务器控件的状态和属性数据的 XML 说明文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 方法将各种状态和属性数据从 `webPart` 汇编到 XML 文件中。 数据包括有关控件本身的信息，包括其程序集、状态数据和属性数据。 启动导出的用户可将 XML 文件保存到本地计算机或网络上的磁盘。 然后，其他用户可以将该描述文件导入到另一个页面或网站，并将状态和属性数据应用于不同 `webPart`的实例。 这为用户提供了一种快速而方便的机制，用于在服务器控件上共享和重用其设置，还为开发人员提供了一种控制导出和导入控件的外观和行为的方法。  
  
 默认情况下，不会导出 `webPart` 上的属性。 若要启用某一属性的导出，必须在源代码中使用 `[Personalizable]` 特性标记它。 您还可以选择通过将 `[Personalizable]` 特性的 `isSensitive` 参数设置为 `true`，来标记包含敏感数据的可导出属性。 默认情况下，`isSensitive` `false`。 开发人员可以将参数设置为 `true`，以指示数据是敏感的。  
  
 若要启用要导出的 `webPart`，开发人员可将其 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 属性值设置为 "<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>" （包括所有可个性化的和敏感属性），或设置为 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>，这将导出敏感属性以外的所有内容。  
  
> [!IMPORTANT]
>  允许用户从控件中导出数据，并将数据导入到其他控件中，这会带来一些安全风险。 开发人员应使用上面所述的方法来保护敏感数据，如果他们想要避免完全公开数据的风险，则它们根本不应启用 `webPart` 导出。 有关 Web 部件安全问题的详细信息，请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
或 
 <paramref name="writer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所引用的控件集合中。  
  
或 
<paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 属性设置为值 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />，该值表明对 <paramref name="webPart" /> 禁用导出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页面</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>被重写以防止将焦点设置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件上，因为该控件没有用户界面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> 方法将重写基 <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> 方法，并在调用方调用方法时引发异常。 由于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件没有 UI，并且对于用户从不可见，因此它永远不允许在其自身上设置焦点。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">调用方尝试调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，该方法在没有用户界面的控件中不受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的使用者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 对象的集合，这些对象可以作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的使用者。</summary>
        <returns>包含使用者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接始终只涉及两个控件，一个充当数据的提供者，另一个用作数据的使用者。 每个控件都必须具有一个或多个定义为连接点的方法。 对于使用者控件，其连接点为 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 对象。 若要构建 Web 部件连接，必须检索使用者连接点。  
  
 使用者必须始终至少有一个连接点才能建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法检查使用者控件并检索其所有连接点的集合。 如果 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件没有连接点，则该方法将返回一个空集合。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅主题[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含用户控件和自定义控件 `Register` 指令。 存在 `<asp:webpartmanager>` 元素、包含自定义控件的 `<asp:webpartzone>` 元素和 `<asp:connectionszone>` 元素。 请注意，在 `Page_Load` 方法中，代码将进行检查以确定连接是否已存在，如果不存在，则定义一个提供程序、一个使用者及其各自的连接点，然后将新连接添加到 @no__t 引用的静态连接集中。_1_ 属性。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 请注意，通过使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法检索的 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> 对象将被传递到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法，以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分获取此代码以及用于编译该代码的说明。  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 连接用户界面（UI）出现后，请注意，连接已由 `Page_Load` 方法中包含的代码创建。 如果在后续浏览器会话中返回到此页，则已建立此静态连接，并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的实例的网页。</param>
        <summary>检索对页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的当前实例的引用。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，引用该控件在页上的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当要检索对当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的引用的上下文中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法非常有用。 出现这种情况的常见情况是，如果您正在编写一个自定义控件，而该控件在开发过程中无法识别，则其页上 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的 ID 将为。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法是静态的，因此可以直接调用该方法而无需 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的实例。  
  
 Web 部件控件集中的某些控件（如 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件）具有 <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> 属性，该属性可检索对当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的引用。 因此，使用此类控件时，应使用此属性来检索引用。  
  
 如果要在知道 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件 ID 的上下文（例如，在网页中编写内联代码）中进行编码，则使用 ID 直接引用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件是最简单且最有效的方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 该示例包含两个部分：一个自定义服务器控件和一个承载控件的网页。  
  
 自定义 <xref:System.Web.UI.WebControls.Label> 控件使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法检索当前页上 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的 ID，然后显示该 ID。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下面的代码示例提供了承载 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域中的控件的网页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 在浏览器中加载页面后，请注意当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的 ID 显示在自定义 <xref:System.Web.UI.WebControls.Label> 控件中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">此方法返回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值的控件。</param>
        <summary>获取一个字符串，其中包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的值。</summary>
        <returns>一个字符串，包含 <paramref name="webPart" /> 的计算得出的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取 `webPart`的 <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> 属性的计算值。 当开发人员未向 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的 <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> 属性赋值时，此方法将生成要显示为标题的值。 "无标题" 控件的计算值包含一个追加到字符串的数字，该数字指示控件在当前区域中的序列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides"><para>可以重写此方法，以更改如何计算默认显示标题。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在导出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>获取当用户尝试导出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件时包含在请求中的相对虚拟路径和查询字符串。</summary>
        <returns>一个字符串，其中包含共同形成导出控件请求的相对虚拟路径和查询字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 方法返回的值是指向包含控件的页面的服务器位置的相对虚拟路径，以及构成提交给服务器的导出请求的追加查询字符串值。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 方法在允许提交请求之前对字符串进行编码，以防止恶意脚本攻击。  
  
> [!NOTE]
>  有关保护 Web 部件应用程序安全的详细信息，请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个服务器控件，它存在于 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 中，并在运行时被包装为 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控件。</param>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的实例的引用，该实例包含一个服务器控件。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，将 <paramref name="control" /> 包装为子控件。 如果 <paramref name="control" /> 未包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，开发人员将两类控件放在 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中以参与 Web 部件应用程序： <xref:System.Web.UI.WebControls.WebParts.WebPart> 从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 基类继承的控件，以及其他服务器控件，这些控件可以是标准 ASP.NET 控件、自定义控件或用户控件。 当这些控件中的任一控件置于 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中时，它将采用 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的功能。 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件原本就具有此功能，但其他类型的服务器控件则不能。 若要使其他服务器控件在被放置到 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域时作为 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，ASP.NET 使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件进行包装。 由于 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件直接继承自 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类，因此它提供具有 true Web 部件功能的子控件。  
  
 通常在运行时，页开发人员可能希望获取对包含区域中的服务器控件之一的 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件的引用。 使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 方法可以检索对 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 方法。 此代码示例包含在 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域中声明 <xref:System.Web.UI.WebControls.Calendar> 控件。 `Button1_Click` 方法首先将 <xref:System.Web.UI.WebControls.Calendar> 控件的 ID 打印到标签，然后使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 方法检索对包装日历的 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件的引用。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件的 ID 及其子控件（即 <xref:System.Web.UI.WebControls.Calendar> 控件）的 ID 都打印到第二个标签。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的提供者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 对象的集合，这些对象可作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的提供者。</summary>
        <returns>包含提供者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接始终只涉及两个控件，一个充当数据的提供者，另一个用作数据的使用者。 每个控件都必须具有一个或多个定义为连接点的方法。 在提供程序控件的情况下，其连接点 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 对象上。  
  
 提供程序必须始终至少有一个连接点才能建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法检查提供程序控件，并检索其所有连接点的集合。 检索提供程序连接点是建立 Web 部件连接的必需步骤。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 该示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含用户控件和自定义控件 `Register` 指令。 存在 `<asp:webpartmanager>` 元素、包含自定义控件的 `<asp:webpartzone>` 元素和 `<asp:connectionszone>` 元素。 请注意，在 `Page_Load` 方法中，代码将进行检查以确定连接是否已存在，如果不存在，则定义一个提供程序、一个使用者及其各自的连接点，然后将新连接添加到 @no__t 引用的静态连接集中。_1_ 属性。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 请注意，通过使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法检索的 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> 对象将被传递到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法，以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分获取此代码以及用于编译该代码的说明。  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 连接用户界面（UI）出现后，请注意，连接已由 `Page_Load` 方法中包含的代码创建。 如果在后续浏览器会话中返回到此页，则已建立此静态连接，并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">一个 <see cref="T:System.Xml.XmlReader" />，它从导入的 XML 说明文件中读取状态和属性数据。</param>
        <param name="errorMessage">在导入过程中遇到错误时将向用户显示的 <see cref="T:System.String" />。</param>
        <summary>导入包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的状态和属性数据的 XML 说明文件，并将这些数据应用于控件。</summary>
        <returns>在导入的 XML 说明文件中引用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或由 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包装并因此被视为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 的服务器控件）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 方法将导入由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 方法为服务器控件创建的 XML 说明文件。 它不是实际导入的服务器控件，而只是包含有关控件的状态和属性数据的说明文件。 说明文件中引用的控件和程序集必须已在用户尝试导入说明文件的服务器上可用。  
  
 若要启用导入控件，开发人员需要在将启用导入的页面上添加一个 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 控件。 在区域内，必须添加 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 控件。 此控件提供一个文件对话框，该对话框允许用户浏览并找到要导入的描述文件。  
  
 用户查找说明文件并开始导入后，将使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 方法读取说明文件。 如果没有错误并且找到程序集和控件，则将服务器控件添加到 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 控件中的目录，并将说明文件中指定的各种属性和状态数据应用于控件。 然后，用户可以选择控件，并将其添加到页面中。  
  
> [!IMPORTANT]
>  与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 方法一样，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 方法可能会导致安全风险。 由于它涉及到将数据导入到网站，因此恶意用户可能会尝试将错误的数据甚至脚本代码插入到导入的描述文件中。 然后，错误数据可能出现在页面或数据库中，或者插入的脚本可以运行。 有关与导入说明文件相关的潜在风险的概述，以及避免这些风险的方法，请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> 未能读取文件。  
  
或 
 需要 <paramref name="reader" /> 来显示导入错误消息，但在文件中未找到。  
  
或 
 <paramref name="reader" /> 已到达文件末尾，但未找到包含导出数据的 XML 元素。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页面</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 类的引用，该类用于合并和拆分实际在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中实现的，但通常对控件开发人员很有用的一组方法。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 通过它可引用已拆分为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各种方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 属性公开了 Api 以调入一组 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法，这些方法主要用于扩展性情况。  
  
 使用这些内部方法的设计方式是通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 属性访问它们。 由于属性是受保护的，因此只能通过从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类继承，来访问并调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 类的实例中的方法。  
  
> [!NOTE]
>  [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]中的 IntelliSense 隐藏了此属性。 但是，在派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类中，你仍然可以访问属性及其各种成员。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定能否将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件添加到页中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件功能的一个灵活性，就是在运行时将服务器控件添加到网页中。 在许多常见情况下，可以添加服务器控件（可以是自定义的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、自定义服务器控件、用户控件或 ASP.NET 控件）。  
  
 在下面的常见方案中，Web 部件控件集尝试将服务器控件添加到页面，并调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法对其进行授权：  
  
-   在添加服务器控件时，通过在 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域内的网页的标记中对其进行声明。  
  
-   以编程方式将服务器控件添加到区域。  
  
-   用户将服务器控件导入到 Web 部件的控件目录中。  
  
-   从个性化设置数据存储区加载现有服务器控件时。  
  
-   将服务器控件添加到 <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> 控件时，使其在服务器控件的目录中可用。  
  
 在添加控件的每个方案中，将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法，以确保已满足所有授权条件，以允许添加控件。 当控件获得授权时，它将以正常方式添加（如果没有筛选方案）。 当控件未获得授权时，Web 部件控件集可以通过多种方式进行响应，具体取决于上下文。 控件集可以在无提示的情况下添加未经授权的部分（如果无需通知用户），它可以显示错误消息，也可以将 <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> 类的实例添加为占位符。 此占位符对象在页面上不可见，但在页源代码中可见，表示排除了未经授权的控件。  
  
 控制是否获得授权的决定是授权筛选器。 授权筛选器是 Web 部件控件集中的一项功能，它使开发人员可以从页中排除不满足指定条件的任何控件。  
  
 若要创建筛选方案，开发人员必须执行两项操作。 首先，必须将字符串值（值可以是任意值）分配给它们计划在方案中使用的每个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性。 它们还可以为不 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的其他类型的服务器控件指定此属性的值，因为如果它们位于 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中，则在运行时将此类控件与 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件一起包装，并且此控件继承 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>知识产权.  
  
 创建筛选方案的第二个必要步骤是重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 方法，或为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件创建事件处理程序。 在这些方法中，开发人员可以检查 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性，如果该值指示该控件不应获得授权，开发人员可确保 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法返回 `false`的值。  
  
> [!NOTE]
>  有关代码示例和如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法设置自定义筛选方案的说明，请参阅该方法的重载主题。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在接受授权检查的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <summary>执行确定控件是否被授权添加到页中的初始步骤。</summary>
        <returns>一个布尔值，指示能否将 <paramref name="webPart" /> 添加到页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法是 Web 部件控件集调用的初始方法，以检查 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的授权。 它接受 `webPart` 作为参数，并开始最终确定是否将控件添加到页面的进程。 需要确定给定控件是否已获得授权时，直接从代码调用此方法。  
  
 此方法执行初始任务，这些任务确定控件是从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类继承还是继承 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 控件，如果是，则执行它包含的子控件的类型。 若要完成授权任务，它将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载方法。  
  
   
  
## Examples  
 下面的代码示例演示如何从代码中调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 方法，以确定是否有权将控件添加到页面中。  
  
 此代码示例包含三个部分：  
  
-   重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件。  
  
-   为 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件创建筛选器的网页。  
  
-   有关如何运行代码示例的说明。  
  
 此代码示例使用一个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件，该控件重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载方法以提供 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性的自定义处理。 此控件检查 `admin` 的属性值，如果值存在，则授权控件。 如果控件具有不同的值，则不会获得授权;不具有属性值的控件也会获得授权，因为它们不是筛选方案的一部分。  
  
 若要运行此代码示例，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 此代码示例的第二部分创建可能排除控件的筛选器。 以下网页包含 `<asp:webpartzone>` 元素中的三个 ASP.NET 服务器控件。 请注意，第一个和第二个控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性设置为不同的值，而第三个控件未分配属性。 此授权值可在运行时检查，如果筛选器与开发人员设置的条件匹配，则可以将控件添加到页面。 另请注意，在 `Page_Load` 方法中，代码调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 方法来确定每个控件是否获得授权，如果是，则设置每个控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 请注意，若要使代码示例正常运行，必须在 web.config 文件中添加一个设置，以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在 `<system.web>` 部分中，请确保存在一个 `<webParts>` 元素，其 `enableExport` 特性设置为 `true`，如以下标记所示。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 在浏览器中加载页面后，请注意，将显示第一个控件，因为它与重写的方法中的条件相匹配。 不会将第二个控件添加到页面中，因为它已被筛选器排除。 另外，还添加了第三个控件，因为它没有 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 的属性集。 请注意，如果单击任一控件的标题栏中的谓词菜单图标，则可以导出它们，因为它们各自的 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 属性值已分配。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此方法是从代码中直接调用的。 如果要对授权过程进行更多的编程控制，可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> 重载方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">被检查授权情况的控件的 <see cref="T:System.Type" />。</param>
        <param name="path">被授权的控件的源文件的相对应用程序路径（如果该控件为用户控件）。</param>
        <param name="authorizationFilter">赋予 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的任意字符串值，用于授权是否可将控件添加至页中。</param>
        <param name="isShared">指示被检查授权情况的控件是否为共享控件，共享意味着它对应用程序的许多用户或所有用户可见，并且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 属性值设为 <see langword="true" />。</param>
        <summary>执行确定控件是否已经过授权可添加至页的最后步骤。</summary>
        <returns>一个布尔值，指示控件是否已经过授权可添加至页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载方法执行确定是否有权将控件添加到页面的最后一个步骤。 方法确保 `type` 是有效的类型，并且仅当要检查的控件是用户控件时，`path` 才具有值。 然后，它会调用关键性 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法，该方法将引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件。  
  
   
  
## Examples  
 下面的代码示例演示如何重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法，以确定是否有权将控件添加到页中。  
  
 第一步是创建可能排除控件的筛选器。 以下网页包含 `<asp:webpartzone>` 元素中的三个 ASP.NET 服务器控件。 请注意，第一个和第二个控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性设置为不同的值，而第三个控件未分配属性。 此授权值可在运行时检查，如果筛选器与开发人员设置的条件匹配，则可以将控件添加到页面。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二步是重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 方法，并为授权筛选器创建自定义处理。 请注意，代码首先检查属性是否具有值，以便自动添加未分配 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性的任何控件。 如果控件具有筛选器，则仅当筛选器值等于 `admin`时，代码才返回 `true`。 这说明了一种简单的机制，可用于根据特定用户的角色向某些用户显示特定控件。 尽管使用角色的完整示例超出了本主题的范围，但你可以使用与此代码示例中的重写方法相同的逻辑，但你可以检查当前用户是否在与授权筛选器值匹配的角色中。，然后仅为该用户添加控件。 这使您能够创建一些用户将看到所有控件的页面，而其他用户将只看到选定的控件。 这就是使用角色检查筛选器的逻辑的方式：  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 在浏览器中加载页面后，请注意，将显示第一个控件，因为它与重写的方法中的条件相匹配。 不会将第二个控件添加到页面，因为它的筛选器值已排除。 添加第三个控件，因为它没有其 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性集。 如果在第二个控件上将属性值更改为与第一个控件的属性值相匹配，然后再次运行该页，则还将添加第二个控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 为用户控件，且 <paramref name="path" /> 为 <see langword="null" /> 或空字符串 ("")。  
  
或 
 <paramref name="type" /> 不是用户控件，且 <paramref name="path" /> 已赋值。</exception>
        <block subset="none" type="overrides"><para>如果要在检查授权时提供其他处理，可以通过从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承来重写此方法。 你可能想要重写方法以检查 <paramref name="authorizationFilter" /> 参数中的某些值，并根据值返回一个布尔值，该值确定是否将控件添加到页中。  
  
对于还希望检查授权筛选器并提供自定义处理的页开发人员，可以选择在 .aspx 页或代码隐藏文件中执行此操作，而无需从任何类继承。 可以在页中为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 方法声明备用事件处理程序。 有关更多详细信息和示例，请参阅 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已进行了个性化设置更改，这些更改影响 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所控制的页级别个性化设置详细信息。</summary>
        <value>一个布尔值，指示是否已进行了个性化设置更改。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件在内部使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 属性来跟踪它所管理的任何页面级别的个性化设置数据是否已更改。 当用户在页面级别执行各种个性化设置操作（例如，添加或删除 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、连接或断开控件、通过移动控件更改页的布局以及其他操作）时，个性化设置数据会发生更改。  
  
> [!NOTE]
>  用户还可以在控件级别执行个性化设置，这意味着它们对特定控件进行个性化更改，而更改只影响该控件。 例如，将编辑该控件并更改其标题文本或其背景色。 控件级别的个性化设置不会影响由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件跟踪的页级别的个性化设置数据，因此，在发生控件级别的个性化设置时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 属性值不会更改为 `true`。  
  
 尽管方法是受保护的，并且不能由调用方直接访问，但 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性可由调用方直接访问，它将返回此属性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要加载的保留的状态数据。</param>
        <summary>加载从前一个页请求保存并需要在后续请求上还原的控件状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> 方法对于还原应在页的回发之间保留的属性数据非常有用，即使在 <xref:System.Web.UI.Control.EnableViewState%2A> 属性设置为 `false`时也是如此。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>存储由个性化对象传递给 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化数据，稍后会将其用于初始化过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 方法以 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 对象的形式提供保存的状态数据。 此数据最终用于将个性化设置数据加载到 Web 部件控件中并执行其他初始化任务。  
  
> [!NOTE]
>  此方法由一系列方法调用，此方法在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> 方法最初请求关联的 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 对象以向 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件提供个性化数据时开始。  
  
 不能直接从代码中调用此方法。 但是，您可以直接调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> 方法，该方法本身调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 方法并返回个性化数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以覆盖派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 方法。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</summary>
        <value>仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Security.PermissionSet> 对象在类型反序列化期间使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</summary>
        <value>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在导入过程中，此属性返回的 <xref:System.Security.PermissionSet> 对象用于类型反序列化之外的所有内容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要移动的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <param name="zone"><paramref name="webPart" /> 要移动到的目标 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，指示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中相对于其他控件的索引。</param>
        <summary>将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件从一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域移动到另一个区域，或移动到相同区域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法将 `webPart` 移到同一区域或不同区域中的新位置。 您可以直接从代码调用此方法，并且在用户使用 Web 部件用户界面（UI）中的各种选项将控件移动到新位置时也会调用此方法。  
  
 必须满足一些条件，才能移动 `webPart`，其中的大部分条件由本主题的 "异常" 一节中列出的项指示。 如果 `webPart` 不包含在要开始的 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中，则不能将其移动到区域中。  
  
 满足条件后，将发生以下操作序列 `webPart`：  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  将从其当前区域（如有必要）中删除 `webPart`，并将其添加到其新区域或其当前区域内的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  源区域和目标区域中的每个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的 `zoneIndex` 都将重置，以反映已移动的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何直接从代码调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法，将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件从一个区域移到另一个区域。  
  
 此代码示例包含三个部分：  
  
-   用于更改显示模式的用户控件。  
  
-   用于承载控件的网页。  
  
-   有关如何运行代码示例的说明。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是包含两个区域的网页，其中每个区域包含两个服务器控件。 当用户单击页面上的 "**移动 Web 部件**" 按钮时，`Button1_Click` 方法中的代码会将一个控件从第一个区域移动到第二个区域中的新位置。 请注意，代码优先必须调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 方法才能检索包装 `list1` 控件的 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象。 这是必需的，因为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法的第一个参数需要 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，而 `list1` 是 ASP.NET 服务器控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 页面加载后，请单击 "**移动" "Web 部件**" 按钮，并注意包含链接的控件将移到第二个区域中的中间位置。 控件的这一移动是通过调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法以编程方式完成的。 你还可以使用 "**显示模式**" 下拉列表控件将页面切换到设计模式，并且在设计模式下，可以将控件拖动到不同的区域或其区域中的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件也调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法来处理此类用户启动的移动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
或 
 <paramref name="zone" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
或 
<paramref name="webPart" /> 控件的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 属性所引用的区域为 <see langword="null" />，意味着 <paramref name="webPart" /> 当前未包含在任何区域中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 或 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件并调用该事件的处理程序（如果存在）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当检查 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件是否有权添加到页面时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法会调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法。 调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法时，它会引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件，如果事件有处理程序方法，则会调用该处理程序。  
  
 授权 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的过程是一项重要的 Web 部件功能。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件添加到区域的每个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件都将通过授权过程来确定是否可以添加控件。 默认情况下，Web 部件控件集不提供任何筛选条件来阻止将控件添加到区域。 但控制集确实为开发人员提供了创建其自己的筛选条件所需的机制。 通过使用这些机制，你可以创建自定义筛选方案。 例如，你可以创建一个筛选器，以便在用户为管理员角色的情况下，在呈现页面时将某些控件添加到区域，如果用户处于用户角色中，则不会添加这些控件。  
  
 在授权过程中筛选控件的机制是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法以及 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 控件上的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 事件。  
  
 若要创建筛选方案，实质上有两个任务。 首先，将字符串分配给每个要筛选的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性。 这些字符串值可以是任意的，但它们应该包含要筛选的条件。 例如，如果希望仅当管理员用户正在查看页面时才将给定控件添加到区域，则可以将 `admin` 的字符串值分配给属性。 然后，可以使用 ASP.NET 角色功能，并将站点的所有用户添加到各种角色，如管理员、管理人员和用户。 加载页面时，筛选代码将检查用户所在的角色，并将其与要检查的控件上的授权筛选器值进行比较，如果（例如）用户处于管理员角色中，并且已将控件的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 值设置为 `admin`，则可以添加控件。  
  
 创建筛选方案的第二步是编写代码来检查 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性值，并确定在将每个控件添加到其区域之前是否对其进行了授权。 有两个选项可用于放置此筛选代码。 第一个选项是页面开发人员的首选选项。 您可以创建一个方法来直接在网页服务器脚本代码或代码分离文件中处理 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件。 通过在页中将 `OnAuthorizeWebPart` 特性添加到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的标记中，将方法与事件相关联，如下面的标记代码示例所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 所有自定义方法都必须检查每个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的筛选条件，然后根据结果，为 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> 对象的 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> 属性指定一个布尔值，以指示是否可以添加 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 "示例" 部分中的代码演示如何执行此操作。  
  
 用于放置筛选代码的第二个选项是从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类继承，并重写方法以检查筛选条件。 可以重写的两个方法是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 方法或 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法。 尽管这两种方法都可正常运行，但在大多数情况下，最好重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法，因为它提供了对整个授权过程的更强的编程控制，而 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法只执行一项特定任务，即引发事件并检查处理程序。 有关重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 方法的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类的代码示例，请参阅方法的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 重载。  
  
   
  
## Examples  
 下面的代码示例演示如何为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 事件设置自定义事件处理程序，以便处理程序可以为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 方法提供自定义筛选代码。 此示例是一种典型的方法，供页面开发人员提供筛选方案和授权 <xref:System.Web.UI.WebControls.WebParts.WebPart> 要添加到页面的控件。  
  
 请注意，在网页中，`<asp:webpartmanager>` 元素具有分配给它的事件处理程序的名称的 `OnAuthorizeWebPart` 属性。 方法检查页上的控件是否将其各自的 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性值设置为 `admin`，如果是，则返回 `true`，这意味着将对其进行授权并将其添加到页面中。  
  
> [!NOTE]
>  请注意，没有任何分配给 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 属性的值的控件也会添加，因为它们被假定不是筛选方案的一部分。 这种方法在筛选方案中是一种常见的方法：筛选某些控件，而其他控件则不是，因为假定这些控件可供所有用户使用。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 由于在角色中设置用户超出了本主题的范围，此代码示例不检查筛选中的用户角色。 但是，根据用户角色筛选控件的方案可能是此筛选功能的最常见用途之一。 如果在网站上拥有角色，并且想要检查此方法中的用户角色以筛选控件，则该方法将类似于下面的代码块（与前面的代码示例中不使用角色的更简单方法不同）。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件以指示已加载页及其控件，并且已激活页上的连接，可以开始共享数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当页面完成加载过程后，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 方法将引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 事件。 方法提供了一种为事件添加处理程序的方法。  
  
 页面开发人员可以通过将 `OnConnectionsActivated` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为事件添加自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以覆盖派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> 方法。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件以指示已加载页及其控件，可以开始激活连接的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 事件，该事件为开发人员提供了一种机制，用于以编程方式自定义激活连接的过程。  
  
 页面开发人员可以通过将 `OnConnectionsActivating` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为事件添加自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以覆盖派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> 方法。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含与更改后的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上已完成从一种显示模式切换到另一种显示模式的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其基窗体中的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 方法只引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> 事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> 方法。 例如，在显示模式发生更改后，您可能需要根据 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> 属性中包含的显示模式，在用户界面（UI）的外观中更改某些内容。 或者，您可能希望隐藏某些内容，或显示某个控件。  
  
重写方法时，通常应调用基方法作为重写方法的最后一步，以便先运行自定义代码，最后引发事件，这表示模式更改已完成。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.EventArgs" />，包含与正在更改的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上正处于从一种显示模式切换到另一种显示模式的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其基窗体中的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 方法只引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> 事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> 方法。 例如，当显示模式发生变化时，您可能需要检查新显示模式将是什么（通过使用 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> 属性），并根据新的显示模式将在用户界面（UI）中更改某些内容。 如果有自定义的显示模式，则在自定义模式要为新的显示模式时，您可能希望使某些控件可见。  
  
重写此方法时，通常应调用基方法作为重写方法的第一步，以便引发事件以指示显示模式正在开始更改。 然后，在实际显示新的显示模式之前，您的自定义代码可以在用户界面（UI）中进行更改。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件，该事件是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件生命周期中的第一个事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 方法调用基方法（该基方法为控件引发 <xref:System.Web.UI.Control.Init> 事件），然后执行几个准备步骤，如确保页上只有一个 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件实例，并加载个性化设置数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">页上还有另一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，该事件恰好在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件被呈现在网页上之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> 方法调用基方法（该基方法为控件引发 <xref:System.Web.UI.Control.PreRender> 事件），然后注册包含 Web 部件控件的页上所需的多个客户端脚本。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，该事件在新选择了某个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件或清除对它的选择之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 事件，这通常是开发人员可能需要更改用户界面（UI）外观的时间点。 例如，选择新的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件时，Web 部件控件集会更改新选定控件的呈现方式。 清除控件的选定内容后，呈现将恢复为正常。  
  
 用户选择特定 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件进行编辑后，将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法。 当用户完成对控件的编辑并将其关闭时，如果已清除该控件的选定内容，将再次调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件有几个相关选项，使开发人员可以自定义在所选控件更改后发生的呈现。 在声明性代码中，可以在 <see langword="&lt;asp:webpartmanager&gt;" /> 元素中设置 <see langword="OnSelectedWebPartChanged" /> 特性，并为其分配自定义方法的名称。 在自定义方法中，可以在事件发生时修改所选控件的呈现。 另一种方法是从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承并重写方法。 第三种方法是在区域级别自定义呈现;例如，你可以从 <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> 类继承并重写其 <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> 方法，以自定义在编辑过程中选定和清除的控件的呈现。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，该事件在更改当前选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 事件，该事件在更改当前选定的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的过程中发生。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件使用此方法和关联的事件来提供取消所选控件更改的进程的机会。 例如，在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 方法中以及在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 方法中调用方法，以便提供取消该过程的方法。 如果用户在正在编辑的控件上单击取消谓词，则不再选择该控件并且不保存任何编辑更改，因为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 方法可以取消编辑更改。  
  
> [!NOTE]
>  在开始和结束将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件连接到另一控件的过程的方法中，可通过类似方式调用方法来启用取消该进程。  
  
 页面开发人员可以通过在声明性页标记中将 `OnSelectedWebPartChanging` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法的名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">与控件的移除相关联的事件数据。</param>
        <summary>引发基 <see cref="E:System.Web.UI.Control.Unload" /> 事件，并从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被添加到某个页之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 方法是在将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（或添加到 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域的其他服务器控件）添加到页的过程中调用的。  
  
 页面开发人员可以通过将 `OnWebPartAdded` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，该事件将在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 事件，以指示控件正在添加。 方法还提供了用于取消添加过程的选项。 如果成功添加了控件，则将执行 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 事件。  
  
 页面开发人员可以通过将 `OnWebPartAdding` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件以表明控件已从页中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件，以指示 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（或其他服务器或用户控件）在页上已成功关闭。  
  
 若要关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 的控件，请将其从页中移除，使其不会呈现，还会将其放在称为页目录的特殊的控股对象中。 与 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 控件对应的页目录将保留对每个页的关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的引用。 如果 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 控件在 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域内的某个页面上声明，则用户可以将页面切换到目录显示模式，然后再将其添加回页面。  
  
 使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 方法，开发人员可以为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件创建自定义处理程序。 页面开发人员可以通过将 `OnWebPartClosed` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为事件添加自定义处理程序。 开发人员在此方法中可能执行的一项有用任务是：显示占位符来代替关闭的控件，并使用工具提示完成，通知用户如何将控件添加回页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，该事件将在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件，以指示控件正在关闭或已从页中删除。 方法还提供了取消关闭进程的选项。 如果已成功从页面中删除该控件，则会出现 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件。  
  
 页面开发人员可以通过将 `OnWebPartClosing` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，该事件在从页中永久删除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在从页中删除 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（或添加到 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域的其他服务器控件）的过程中，将调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 方法。  
  
 页面开发人员可以通过将 `OnWebPartDeleted` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，该事件指示动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中包含的服务器控件或用户控件）正处于被删除的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件可以删除，当控件被删除时，该控件实例将从页中永久删除且无法还原。 动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件是以编程方式添加的控件，或从 Web 部件目录中添加的控件，而不是在网页标记中声明的静态控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 事件，以指示控件从其区域中被永久删除。 方法还提供了取消删除过程的机会。 如果已成功从页面中删除控件，则会出现 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 事件。  
  
 页面开发人员可以通过将 `OnWebPartDeleting` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被移动到页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法的最末尾引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件，这可以确保在事件处理程序中的任何代码运行之前，移动控件的过程已完成。  
  
 当控件在其当前区域内移动或移动到另一个区域时，将引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件，而不管是以编程方式还是由用户拖动控件来完成移动。  
  
 页面开发人员可以通过将 `OnWebPartMoved` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />、服务器控件或用户控件正处于移动过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件，该事件在 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件在其区域内移动或在另一个区域内移动时发生。 方法还提供了取消移动过程的机会。 如果移动成功完成，则会执行 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
 页面开发人员可以通过将 `OnWebPartMoving` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间建立了连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 方法在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法的最末尾引发其相应的事件，这可确保在事件处理程序中的任何代码运行之前完成连接两个控件所需的步骤。  
  
 方法提供了对创建连接过程的编程控制，关联的事件是更新用户界面（UI）或通知用户已建立连接的便利点。  
  
 页面开发人员可以通过将 `OnWebPartsConnected` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，该事件发生于在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域内包含的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件之间建立连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 事件，该事件在两个控件尝试建立连接时发生。 方法提供了取消连接尝试的机会。 如果连接成功，则以下 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件。  
  
 页面开发人员可以通过将 `OnWebPartsConnecting` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 方法在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法的最末尾引发其相应的事件，该方法执行终止两个控件之间的连接的过程。  
  
 方法提供对结束连接的过程的编程控制，使开发人员可以通知用户、更改用户界面（UI）或对应用程序进行其他更改。  
  
 页面开发人员可以通过将 `OnWebPartsDisconnected` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件正处于结束连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件，该事件在两个控件结束连接时发生。 方法提供了取消断开连接过程的机会。 如果成功地删除了连接，将遵循 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 事件。  
  
 页面开发人员可以通过将 `OnWebPartsDisconnecting` 特性添加到网页上的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为关联的事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的开发人员可以重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对包含网页个性化设置数据的对象的引用。</summary>
        <value>包含个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性提供了一种通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件访问与页关联的 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 对象的方法。 使用此属性，你可以访问个性化对象的各种成员。 例如，可以使用 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 方法将页的个性化设置范围从 "共享" 切换到 "用户" 范围，反之亦然。 你还可以查看页面的当前个性化设置范围、是否甚至在页面上启用了个性化设置，以及要将哪些提供程序用于个性化设置数据等。  
  
 请注意，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性引用的数据只是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件所跟踪的页面级个性化数据。 特定于控件的个性化设置数据（如 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上可个性化属性的值）不是 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性的组成部分。  
  
> [!NOTE]
>  有关 Web 部件个性化的详细信息，请参阅[Web 部件个性化概述](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性。  
  
 以下网页允许用户进入编辑模式，以编辑 <xref:System.Web.UI.WebControls.Calendar> 控件的某些方面。 "**切换范围**" 按钮将页面切换为 "用户" 或 "共享" 个性化设置范围。 每个 "**编辑模式**" 和 "**浏览" 模式**按钮都将页面切换到适当的显示模式。 请注意，在文件的 `<script>` 标记部分，处理事件的两个方法都使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性访问基础对象的有用成员。 具体而言，这些方法使用 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 方法和通过 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 属性访问的对象上的 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要运行该代码示例，还必须使用户或用户能够对共享作用域中的页面进行个性化设置。 将条目添加到 web.config 文件中的 "`<system.web>`" 部分，其外观类似于以下标记。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 在浏览器中加载页面后，单击 "**切换范围**" 按钮，此时会显示该页已共享。 单击 "**编辑模式**" 以更改显示模式，单击可见控件上的谓词菜单，然后从菜单中选择 "**编辑**"。 请注意，将显示两个编辑控件的用户界面（UI）。 现在，单击 "**浏览" 模式**返回到正常浏览。 如果该页显示处于共享作用域中，请再次单击 "**切换范围**" 以确保该页处于用户范围内。 接下来，请执行相同的步骤来再次编辑控件，但请注意，现在在编辑 UI 中，<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> 控件不会出现。 这是因为，此控件仅在页位于共享个性化设置范围中时才起作用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化概述</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件能够发出用于各种个性化设置功能（例如，在网页中拖动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件）的客户端脚本。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个 <see cref="T:System.Web.UI.HtmlTextWriter" />，它接收控件的内容以写入页。</param>
        <summary>重写以防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件呈现任何内容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的状态数据，以便在将来请求包含该控件的网页时可以还原这些数据。</summary>
        <returns>一个 <see cref="T:System.Object" />，它包含控件的已保存的状态数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> 方法保存应在页回发之间保留的属性的状态数据，即使在 <xref:System.Web.UI.Control.EnableViewState%2A> 属性设置为 `false`时也是如此。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件维护的自定义个性化设置状态数据，以便重新加载该页时可以重新加载此数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> 方法在个性化设置过程中至关重要，因为它允许存储个性化的用户设置以供将来浏览器会话和对页面的访问。 方法保存自定义个性化设置状态数据，其中包含如下所示的项：已添加到页面或从页面中删除的动态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件;已移动到页面上的控件;已创建或删除的动态连接。  
  
 不能直接从代码中调用此方法。 但是，可以调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 方法，该方法本身会调用此方法来保存个性化设置数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在派生的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中重写此方法，以自定义保存个性化设置数据的过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对当前选择的用于编辑或用于创建与另一个控件的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件的引用。</summary>
        <value>当前选择的用于编辑或建立连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 属性返回对 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件的引用，此服务器控件当前已选定用于编辑或创建与其他控件的连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件提供了几个有用的方法和事件来处理选择控件的过程。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 事件恰好在选定控件后发生，但在进行任何更改之前发生。 若要在选定控件后对其执行某些操作，请重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 方法。 例如，你可能想要更改已选中但尚未更改的控件的外观，以直观地强调选择了哪个控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 事件恰好在选定控件更改后发生。 若要在控件发生更改后对其执行某些操作，请重写 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的选择已经发生更改并被移动到网页上的另一个控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法结合使用，以更改所选控件的用户界面（UI）。 例如，如果用户将页面切换到设计模式（<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>），然后选择一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，并将其拖动到新位置，则通常更改所选控件的呈现方式（例如，通过更改其边框或 ba 的颜色）。选择 ckground。  
  
> [!NOTE]
>  有关使用事件的详细信息，请参阅[如何：在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改网页上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件当前的选定状态的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 方法结合使用。 页面开发人员可以通过将 `OnSelectedWebPartChanging` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并将该属性的值设置为将处理事件的自定义方法的名称，在其代码中创建事件处理程序。  
  
 此事件在开始或结束控件之间的连接的过程中，以及在开始和结束控件编辑时引发。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 方法。  
  
 通常，当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 事件由于用户操作更改所选控件的直接结果而引发时，可以取消该事件。 但是，在某些情况下无法取消事件。 如果删除了 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 的控件，则它包含的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件必须全部关闭，否则它们将是孤立控件。 在这种情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件将关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，而不是用户，并且它必须确定当前选择了哪个控件以及何时在没有任何中断的情况下更改选择，使其能够完成清除所有控件. 因此，按设计，在此方案中不能取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 方法。 有关可取消的相关事件，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>设置一个标志，该标志指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化设置数据已更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 方法将设置一个标志，该标志最终会使 Web 部件控件集中的个性化设置组件保存更新的个性化数据。 有关可能导致由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件跟踪的个性化设置数据发生更改的方案的详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性。  
  
 不能从你的代码中直接调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 方法，因此不能重写，因为它由 Web 部件控件集在内部由 Web 部件个性化功能的一部分使用。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类可以调用方法。 如果要自定义 Web 部件控件集的个性化组件，并因此需要控制设置个性化数据标志的过程，这将很有用。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">已被选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>将 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性值设置为等于当前选定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 方法在开始或结束对 `webPart` 参数指定的控件的处理过程中调用，后者用于开始或结束包含 `webPart`的连接。  
  
 在编辑和连接过程开始时，`webPart` 是已选中要编辑或输入连接的控件。  
  
 在编辑和连接进程结束时，`null` 传递到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 方法，这将导致当前选定的控件不再处于选中状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个空字符串 ("")，使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件不能应用任何外观。</summary>
        <value>一个空字符串，该字符串防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件使用指定给它的外观。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> 属性重写继承的 <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> 属性，以防止 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件（这是一个不可见的控件）从使用外观。 属性的实现会阻止从 `get` 访问器返回一个空字符串，并在尝试在 `set` 访问器中设置值时，始终引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有定义为静态连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的集合的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含页上的所有静态连接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 属性来跟踪和管理页面上的所有静态连接。 与动态连接相比，静态连接无需在每次呈现页面时添加到页面中。  
  
 此属性引用的集合包含页上存在的所有静态连接，无论它们是以编程方式创建，还是使用页标记中的 `<asp:webpartconnection>` 元素指定的。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 属性。  
  
 此代码示例包含四个部分：  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和自定义接口的源代码文件。  
  
-   一个网页，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件和一个 `<asp:webpartmanager>` 元素。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分获取该示例的前两个部分（自定义用户控件和自定义控件和接口的源代码）。 本主题还介绍了用于编译 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的选项。  
  
 此代码示例的第三部分是网页。 页的声明性标记包含用户控件和自定义控件 `Register` 指令。 存在 `<asp:webpartmanager>` 元素、包含自定义控件的 `<asp:webpartzone>` 元素和 `<asp:connectionszone>` 元素。 请注意，在 `Page_Load` 方法中，代码将进行检查以确定连接是否已存在，如果不存在，则定义一个提供程序、一个使用者及其各自的连接点，然后将新连接添加到 @no__t 引用的静态连接集中。_1_ 属性。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后，请单击 "**显示模式**" 下拉列表控件，然后选择 "**连接**"，将页面切换到连接模式。 连接模式使用 `<asp:connectionszone>` 元素使您能够在控件之间创建连接。 在连接模式下，单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单，然后单击 "**连接**"。 连接用户界面（UI）出现后，请注意，连接已由 `Page_Load` 方法中包含的代码创建。 如果在后续浏览器会话中返回到此页，则已建立此静态连接，并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取特定网页上所有可用显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定网页上的可用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在给定页面上存在的区域控件类型的情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性仅包含页上实际可用的显示模式。  
  
> [!NOTE]
>  可以禁用显示模式; 当显示模式处于禁用状态时，它不会添加到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 集合，即使在页面上存在支持该显示模式的相应类型的区域时也是如此。  
  
 始终支持浏览模式和设计模式。 可能变化的显示模式包括编辑、目录和连接模式。 其中每个显示模式都与特定的 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 控件类型相关联。 这就是在网页上存在一种特殊类型的区域，导致特定显示模式添加到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性所引用的集合中。 例如，如果网页包含 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 区域而不是 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域，则编辑显示模式为该页面上支持的模式之一，但不支持目录显示模式。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性不同于 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 属性，该属性引用包含当前 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件可用的所有显示模式的集合，甚至包括特定页面上不支持的显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 属性。 此代码使用此属性来填充列表，该列表仅包含当前网页中可用的显示模式。  
  
 此页上有三种受支持的显示模式： "浏览"、"设计" 和 "编辑"。 前两个始终可用，并且编辑模式在此代码示例中可用，因为该页面包含一个 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 控件。 不显示目录和连接显示模式，因为其相应的区域不在此页上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 在浏览器中加载页面后，可以使用下拉列表控件将页面从浏览模式切换到设计模式，然后切换到编辑模式。 在编辑模式下，可以单击其中一个服务器控件标头中的下拉谓词菜单，然后选择 "**编辑**" 以编辑控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据是否已在网页上更改。</summary>
        <value>一个布尔值，指示个性化设置状态数据是否已更改。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性提供了一种方法，供调用方确定由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理的个性化设置状态数据是否已更改。 当用户个性化页级别的详细信息（例如，通过更改页布局、创建或删除连接以及添加或删除控件）时，由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理的个性化设置数据会更改。 这是一个传递方法，它将受保护的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 属性的值返回给调用方，而调用方无法直接访问这些值。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性不指示可个性化属性值或影响单个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件外观的各个属性是否已更改。 为每个控件单独跟踪控制级别的个性化设置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性仅指示页级别的个性化设置数据是否已由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件进行了更改。  
  
 下面的列表描述了一些常见的个性化设置，这些实例将导致 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性返回值为 `true`，指示 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件具有一些已更改的个性化数据：  
  
-   关闭页上的静态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件（或服务器控件或用户控件）。  
  
-   将已关闭的静态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件从页目录还原回页面。  
  
-   将控件移动到其区域内或移动到另一个区域。  
  
-   从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件的目录中添加控件，或以编程方式添加控件。  
  
-   使用连接用户界面（UI）以编程方式或通过使用连接用户界面（UI）在两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件之间创建连接。  
  
-   以编程方式或通过使用连接 UI 删除两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件之间的连接。  
  
 若要访问此属性值，必须将 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件实例强制转换为 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 接口;然后，可以读取 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 属性值。  
  
   
  
## Examples  
 下面的代码示例演示了 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 属性的简单用法，用于指示导致 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件的个性化设置数据更改的一些常见页面个性化设置实例。  
  
 此代码示例包含四个部分：  
  
-   允许您在包含 Web 部件控件的页上更改显示模式的用户控件。  
  
-   一个源文件，其中包含两个可以连接的自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的代码和一个接口。  
  
-   承载所有控件的网页。  
  
-   对代码示例的工作方式的说明。  
  
 此代码示例的第一部分是用户控件，用于更改显示模式。 可以从 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 类概述的 "示例" 部分中获取用户控件的源代码。 有关显示模式和用户控件工作方式的信息，请参阅[演练：更改 Web 部件页上的显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是包含自定义控件和接口的源文件。 请注意，`IZipCode` 接口公开了一种方法，在自定义 `ZipCodeWebPart` 控件中实现的此方法用作回调方法，以便在连接方案中充当提供程序的 `ZipCodeWebPart`。 另一个控件 `WeatherWebPart`在连接中充当使用者控件;它可以使用 `ZipCodeWebPart`提供的特定接口。 在实际应用程序中，`WeatherWebPart` 可能会从提供程序使用个性化的邮政编码值，然后向用户提供图形天气信息。  
  
 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，你可以将源代码放在站点的 App_Code 文件夹中，在此文件夹中，它将在运行时动态编译。 此代码示例使用动态编译;因此，请注意，网页顶部的此组件的 `Register` 指令只包含 `TagPrefix` 和 `Namespace` 特性，没有 `Assembly` 特性。 有关演示如何编译的演练，请参阅[演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，它包含两个 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域，其中第一个区域包含两个自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 还有一个 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域，其中包含用户可添加到页面的标准 <xref:System.Web.UI.WebControls.Calendar> 控件。 `<asp:connectionszone>` 元素提供了一个连接用户界面，使用户能够在控件之间创建连接。 请注意，在 `Page_PreRender` 方法中，它将检查个性化设置数据是否已更改，如果已更改，则更新 `Label1`的文本。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 在浏览器中加载页面后，尝试创建本主题的 "备注" 部分中列出的一些方案，这些方案将更改个性化数据。 进行各种更改时，当更改涉及到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件所跟踪的个性化设置方案之一时，将显示 `Label1` 控件的文本，指示个性化设置数据已更改。 例如，你可以：  
  
-   单击 "**连接" Web 部件控件**按钮，在控件之间创建连接。  
  
-   使用 "**显示模式**" 下拉列表控件将页面切换到目录模式，然后将 "我的**日历**" 控件添加到第二个 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域。  
  
-   将页面更改回 "浏览" 模式，在 "**我的日历**" 控件上单击谓词菜单（在标题栏中显示箭头符号），然后选择 "**关闭**" 以关闭它并将其添加到页面目录。  
  
-   将页面返回到目录模式，然后将 "**我的日历**" 控件添加回页面。  
  
-   使用 "**显示模式**" 控件将页面切换到设计模式，并通过将控件的一个或多个位置拖动到另一个区域，或在同一区域中的其他位置来重新排列控件的布局。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>返回先前保存的需要加载到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> 方法的实现，该方法提供了一种方法，使 Web 部件控件集直接访问受保护的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> 方法。 调用此方法时，它将存储由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理的自定义个性化数据，并且之前保存在永久性数据存储中以供以后在初始化过程中使用。  
  
> [!NOTE]
>  在大多数情况下，页面和控件开发人员代码不需要调用此方法，因为它主要由 Web 部件控件集用于检索个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员使用此方法的一种情况是，他们要开发一个自定义的个性化框架，用来代替 Web 部件控件集提供的个性化框架。 在这种情况下，开发人员可从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承并重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 方法以返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 对象的自定义实现。 自定义 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 对象将在适当的时间调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 方法的实现以加载自定义个性化设置数据。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含待保存的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 方法是 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> 方法的实现，它为 Web 部件控件集提供了一种直接访问受保护的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> 方法的方法。 调用此方法时，它会将 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件管理的所有个性化数据保存到为 Web 部件应用程序配置的永久数据存储区。  
  
> [!NOTE]
>  在大多数情况下，页面和控件开发人员代码不需要调用此方法，因为它主要由 Web 部件控件集用于保存个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员使用此方法的一种情况是，他们要开发一个自定义的个性化框架，用来代替 Web 部件控件集提供的个性化框架。 在这种情况下，开发人员可从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类继承并重写 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 方法以返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 对象的自定义实现。 自定义 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 对象将在适当的时间调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 方法的实现以保存自定义个性化设置数据。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将个性化设置状态数据应用到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件，调用基方法以便能够跟踪对控件视图状态数据的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对视图状态数据的更改存储在 <xref:System.Web.UI.StateBag> 对象中，并可通过控件的 <xref:System.Web.UI.Control.ViewState%2A> 属性进行访问。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值可使子控件可见。</summary>
        <value>一个布尔值，指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件及其子控件是否可见。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件重写基 <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> 属性，以始终为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 属性返回值 `true`。 尽管 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件本身不可见，但 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 属性需要设置为 `true` 以便默认显示其所有子控件。  
  
 如果尝试设置 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 属性的值，则它始终会生成错误，因为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件已经重写了基属性行为，并阻止为属性赋值。  
  
 此属性在可视化设计器中不可绑定，但在运行时是可绑定的。 有关详细信息，请参阅 <xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试向该属性指定一个值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已被添加到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域之后发生，以指示已成功添加了控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 事件适用于指示动态控件（以编程方式添加的控件，而不是在页标记中声明）已成功添加到区域。 与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 方法结合使用时，该事件为开发人员提供了一种方法来更新用户界面（UI），或通知用户已成功添加控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在开始将控件添加到区域的过程后，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 方法会引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 事件。 此事件提供在进程完成之前取消该过程的机会。 如果添加进程成功，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 事件。  
  
 页面开发人员可以通过将 `OnWebPartAdding` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件指示控件已成功关闭，无论是由用户还是以编程方式。 若要关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 的控件，请将其从页中移除，使其不会呈现，还会将其放在称为页目录的特殊的控股对象中。 与 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 控件对应的页目录将保留对每个页的关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的引用。 如果在 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 区域内的某个页面上声明了 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 控件，则用户可以将页面切换到目录显示模式，然后将其重新添加到页上以前关闭的任何控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 方法关联，这两个方法都引发事件并为其提供处理程序。  
  
 页面开发人员可以通过将 `OnWebPartClosed` 特性添加到页面中的 `<asp:webpartmanager>` 元素，然后将自定义方法名称分配给该属性，为事件添加自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件位于关闭控件的过程中时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 方法将引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件。 如果成功删除了控件，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件。  
  
 页面开发人员可以为事件提供自定义处理程序，方法是将 `OnWebPartClosed` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并将自定义方法名称分配给该属性。  
  
 通常，当用户关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的直接结果引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件时，可以取消该事件。 但是，在某些情况下无法取消事件。 如果删除了 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 的控件，则它包含的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件必须全部关闭，否则它们将是孤立控件。 在这种情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件将关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，而不是用户。 如果 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件正在调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法来关闭每个控件，并引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件，则无法取消事件（通过设计），因为 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 需要完成清除所有区域控件的任务。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域删除之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 事件适用于指示动态控件（以编程方式添加的控件，而不是在页标记中声明的）已成功从区域中删除。 与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 方法结合使用时，该事件为开发人员提供了一种方法来更新用户界面（UI），或以其他方式通知用户控件已成功删除。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中永久删除动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的实例的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 事件是在删除动态控件（以编程方式或通过用户界面由 Web 部件用户添加的）过程中的 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 方法引发的。 事件提供了在进程完成之前取消进程的机会。 如果删除进程已成功完成，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 事件。  
  
 页面开发人员可以通过将 `OnWebPartDeleting` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件已被移动到网页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件适用于静态（在网页的标记中声明）和动态控件。 它与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法相关联。 由于事件是在移动完成后引发的，因此开发人员可以包含事件处理程序，以向用户提供某些通知、某些验证或一些其他操作。 若要添加一个事件处理程序，你可以将 `OnWebPartMoved` 特性添加到页中的 `<asp:webpartmanager>` 元素，并将自定义方法的名称分配给该特性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中包含的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件在其自己的区域内移动或移到另一个区域时，将引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。 当用户拖动控件时，以及当发生编程移动时，会发生这种情况。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发，它提供了在完成移动过程之前取消该过程的机会。 如果移动完成并且控件置于新位置，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
 页面开发人员可以通过将 `OnWebPartMoving` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件所跟踪的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含对一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性来跟踪页面上 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中包含的所有 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 尽管该集合是只读的，但你可以通过集合访问单个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件并以编程方式对其进行更改。  
  
> [!NOTE]
>  可以将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件放置在 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域外的页上，这会导致该控件不会被 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件跟踪或在其 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 集合中被引用。 不过，几乎不需要在区域外使用 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，因为它会丢失其 Web 部件功能并作为正常的服务器控件。  
  
 可在区域中放置的任何类型的控件、自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、标准 ASP.NET 控件、用户控件或自定义服务器控件是否可在运行时被视为 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 如果不是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件的控件放置在 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域中，则在运行时 ASP.NET 使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象包装控件，使控件可以作为真正的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 因此，通过使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件可以跟踪任意类型的服务器控件，而不管它是否从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类派生。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性访问单个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 请注意，在网页的声明性标记中，在 `<asp:webpartzone>` 元素中有两个标准 ASP.NET 服务器控件。 尽管这些不从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类继承，但它们在区域中，它们会在运行时使用 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 对象进行包装，因此将包含在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性所引用的集合中。 你还可以在此区域中添加自定义 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件、用户控件或自定义服务器控件，并以相同的方式处理它们。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 请注意，若要使代码示例正常运行，必须在 web.config 文件中添加一个设置，以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在 `<system.web>` 部分中，请确保存在一个 `<webParts>` 元素，其 `enableExport` 特性设置为 `true`，如以下标记所示。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 将页面加载到浏览器后，如果单击 " **Web 部件计数**" 按钮，代码将使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 属性返回集合中的控件计数。 如果单击 "**隐藏日历标题**" 按钮，则代码会更改日历，使其仅使用边框而不是标题进行呈现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或者服务器或用户控件）之间已建立特定连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 方法相关联。 此事件非常有用，因为在知道连接完成后，您可能希望通知用户事实，甚至更改页面的用户界面（UI）。 例如，您可能希望显示一些图形图像，该图像在两个控件之间建议成功连接，或显示简短消息，然后将页面显示模式改回为浏览模式。  
  
 页面开发人员可以通过将 `OnWebPartsConnected` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，将自定义事件处理程序与此事件相关联。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或放置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中的服务器控件或用户控件）之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 事件由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 方法引发，它指示连接进程已开始（例如，用户已选择了一个控件并单击了连接谓词），但尚未完成。 事件提供了在连接完成前取消连接的机会。 如果连接成功完成，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件。  
  
 页面开发人员可以通过将 `OnWebPartsConnecting` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为事件添加自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 事件与 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 方法相关联。 此事件非常有用，因为在知道连接终止后，你可能希望通知用户，在代码中执行一些清理操作，或者在用户界面（UI）中进行其他更改。  
  
 页面开发人员可以通过将 `OnWebPartsDisConnected` 特性添加到页面中的 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，将自定义事件处理程序与此事件相关联。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在结束以前连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 方法引发，它指示用户单击了断开连接谓词，或 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法已被调用。 事件提供了一种方法，可在连接完成前取消结束连接的过程。 如果连接成功结束，则此事件后跟 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 事件。  
  
 页面开发人员可以通过将 `OnWebPartsDisconnecting` 特性添加到 `<asp:webpartmanager>` 元素，并为属性分配自定义方法名称，为事件添加自定义处理程序。  
  
 通常，当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件作为结束连接的用户操作的直接结果引发时，可以取消该事件。 但是，在某些情况下，无法取消事件。 第一种情况是，如果删除 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 的控件，则它包含的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件必须全部关闭，否则它们将是孤立的。 在这种情况下，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件将关闭 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，而不是用户，并且它还必须能够终止任何连接控件的连接，而不会发生任何中断，因此它可以完成清理并关闭所有控件. 因此，按设计，在此方案中不能取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 方法。 有关可取消的相关事件，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 事件。  
  
 不能取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件的第二种情况是调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 方法时（例如，在对页的每个请求期间调用此方法），而页面上的现有连接中存在某种类型的冲突。 例如，用户可能会将 control x 连接到 control y，但共享用户将 control x 连接到 control z，但不允许 control x 建立多个连接。 在这种情况下，将优先使用单个用户的连接设置，<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件通过调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法并结束特定用户的 x 和 z 之间的连接来解决冲突。 由于此断开连接对于解决冲突至关重要，因此，设计 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件在此方案中不能取消。  
  
 不能取消 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 方法的第三种情况是：当前连接的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或服务器控件被删除或关闭。 由于控件确实要从页中移除，因此，删除其连接是一种合乎逻辑的必要性。 因此，当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法，而该方法反过来引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件时，设计将无法取消该事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域的集合的引用。</summary>
        <value>引用一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 区域的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 属性由 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件用于在网页上跟踪 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域。 请注意，属性不引用所有类型的区域;它仅引用派生自 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 类的区域，包括 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 区域。  
  
 尽管属性引用的集合是只读的，但你可以使用它来访问集合中的各个对象并以编程方式使用它们。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 属性访问单个 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域控件。 请注意，在网页的声明性标记中，有两个 `<asp:webpartzone>` 元素，每个元素都包含一个服务器控件。 在该页的 "`<script>`" 部分，代码使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 属性访问单个区域，列出所有区域 Id，然后更改第二个区域的背景色。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 请注意，若要使代码示例正常运行，必须在 web.config 文件中添加一个设置，以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在 `<system.web>` 部分中，请确保存在一个 `<webParts>` 元素，其 `enableExport` 特性设置为 `true`，如以下标记所示。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 将页面加载到浏览器中后，如果单击 "**列出区域 id** " 按钮，则代码将使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 属性列出集合中所有区域的 id。 如果单击 "**更改区域背景色**" 按钮，则代码会更改第二个区域的背景色。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
