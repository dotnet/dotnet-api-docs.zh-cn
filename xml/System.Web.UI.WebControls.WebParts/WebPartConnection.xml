<Type Name="WebPartConnection" FullName="System.Web.UI.WebControls.WebParts.WebPartConnection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c7f6c3f4395b55ea04359758e9b18926c72a9c3e" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86628132" /></Metadata><TypeSignature Language="C#" Value="public sealed class WebPartConnection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WebPartConnection extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebPartConnection" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartConnection sealed" />
  <TypeSignature Language="F#" Value="type WebPartConnection = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Web.UI.ParseChildren(true, "Transformers")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Web.UI.ParseChildren(true, "Transformers")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一个对象，该对象可使两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件形成连接。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Web 部件控件集中，连接是两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> (或其他服务器或用户) 控件之间的链接或关联，使其能够共享数据。 这种共享数据的功能允许使用连接的控件，以超出独立控件提供的功能。 例如，如果一个控件提供了邮政编码数据，另一个控件可以读取该数据，并根据邮政编码提供本地天气信息，则这两个控件的连接功能为用户提供了更多价值。 若要扩展此示例，还可以创建其他控件，该控件还可以基于邮政编码显示信息（例如具有指向本地新闻的链接的控件），并且所有可以使用邮政编码数据的控件可以与提供邮政编码的单个控件共享数据。 Web 部件应用程序的最终用户可以直接从 Web 浏览器创建和管理所有此类兼容控件之间的连接，方法是使用控件提供的标准连接用户界面 (UI) <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> ，或者使用开发人员提供的自定义 UI。  
  
 此 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 类概述是有关创建连接的基本详细信息的一般说明。 有关创建连接所涉及的特定组件和要求的详细信息，请参阅 [Web 部件连接概述](https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100))，或参阅以下讨论中提到的引用类和代码示例。 Web 部件连接有几个基本方面：  
  
-   两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件。 每个 Web 部件连接都包含两个控件。 控件可以同时参与多个连接，但每个单一连接只包含两个控件。 控件可以直接派生自 <xref:System.Web.UI.WebControls.WebParts.WebPart> 基类，也可以是其他服务器控件，包括 ASP.NET 控件、自定义服务器控件和用户控件。 不是从类派生的控件 <xref:System.Web.UI.WebControls.WebParts.WebPart> （如果置于 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中）将 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 在运行时自动使用对象进行包装，这使它们可以从 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类继承并作为运行时 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件运行。  
  
-   位于区域中的控件 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 。 <xref:System.Web.UI.WebControls.WebParts.WebPart>控件和任何其他类型的服务器控件都必须驻留在某个 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 区域中，以便能够参与 Web 部件连接 (和大多数其他 Web 部件功能) 。  
  
-   使用者和提供者。 在每个 Web 部件连接中，有两个控件：数据提供程序和数据使用者。 提供程序通过指定的回调方法将数据 furnishes 到使用者，该方法以接口的形式返回数据。  (有关如何创建和指定回调方法的示例，请参阅本主题的 "示例" 部分。 ) 此回调方法被称为提供程序连接点。 此连接点的详细信息 (其 "友好" 名称、ID 和返回接口) 的类型包含在 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 与提供程序控件关联的对象中。 使用者通过可接受接口实例的指定方法接收数据。 此方法称为使用者连接点，连接点 (名称、ID 和) 接口类型的详细信息都包含在 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 与使用者控件关联的对象中。  
  
-   兼容的控件或有效的转换器。 要使连接正常运行，使用者和提供程序必须兼容 (意味着它们的指定连接点方法可以使用相同类型的接口) ，或者必须有一个对象可以将 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 提供程序提供的类型转换为使用者识别的类型。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象。 若要连接到存在，必须有一个类的实例， <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 该类包含对提供者和使用者控件的引用以及其连接点的详细信息。 如果提供程序和使用者不兼容，而是使用 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象进行连接，则连接将引用转换器。  
  
-   建立连接的方式。 在兼容的使用者和提供者控件已经正确地使用连接点方法设计并将其放置在某个区域中并且 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象可用时，最后一个必要的基本步骤是启动连接。 这种情况的一种方法是让用户通过 UI 创建连接。 如果在 `<asp:connectionszone>` 页面上放置一个元素，并且连接的其他必需组件已就位，则在运行时，用户可以将页面切换为连接显示模式，单击提供者或使用者的谓词菜单上的连接谓词，然后将显示一个基于控件) 的连接 UI (<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 。 通过此 UI，用户可以启动连接。 发起连接的另一种方法是以编程方式执行此操作。 无论是通过 UI 还是以编程方式，启动连接的基础方法都是相同的。 应用程序 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (或方法调用方法 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> （如果对控件使用转换器) ，并 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 向其传递提供程序、使用者及其各自的连接点对象），并且方法将返回 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类定义一个对象，该对象封装两个控件之间的连接的基本详细信息 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 类几乎完全由与特定连接的详细信息相关的属性组成。 多个属性涉及连接中的使用者控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性引用使用者控件本身， <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A> 属性引用使用者的 ID。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象（包含使用者的连接点的详细信息）由使用者的 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A> 属性引用。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性引用对象的 ID <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 。 所有这些使用者相关的连接属性必须分配有值才能创建连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类还具有几个与连接中的提供程序控件相关的属性，这些属性对应于使用者的属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性引用提供程序控件本身，而 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A> 属性引用其 ID。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性引用 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 对象， <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 属性引用提供程序的连接点的 ID。  
  
 几个属性涉及连接状态。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性指示连接是否处于活动状态 (当前正在交换数据) 或非活动 (仍处于连接状态，但未主动共享数据) 。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性指示连接是否为页面) 或特定于用户的连接的所有用户可用的共享 (; <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 属性指示控件是否为静态 (在页标记中声明，从而以编程方式创建永久) 或动态 (，这意味着可将其) 删除。  
  
   
  
## Examples  
 下面的代码示例演示如何创建两个控件之间的简单连接 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 该示例演示了形成连接的三种方式：以声明方式将连接的标记放置在网页的标记中;通过以编程方式在代码中创建连接;通过 UI，通过将 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 控件置于页面上，使用户能够建立连接。  
  
 此代码示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Overview#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_Overview#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口和控件的源代码。 源文件包含一个名为的简单接口 `IZipCode` 。 还有一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 名为的类 `ZipCodeWebPart` ，该类实现接口并充当提供程序控件。 它 `ProvideIZipCode` 的方法是实现接口的唯一成员的回调方法。 方法只返回接口的实例。 请注意，该方法 `ConnectionProvider` 在其元数据中用特性标记。 这是将方法标识为提供程序连接点的回调方法的机制。 其他 <xref:System.Web.UI.WebControls.WebParts.WebPart> 类命名为 `WeatherWebPart` ，它充当连接的使用者。 此类具有一个名为 `GetZipCode` 的方法，该方法 `IZipCode` 从提供程序控件获取接口的实例。 请注意，此方法 `ConnectionConsumer` 在其元数据中被标记为使用者的连接点方法和属性。  
  
 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 顶部附近是 `Register` 用户控件和自定义控件的指令 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 由于本示例假定控件的动态编译，因此控件的源代码应位于 App_Code 子文件夹中; `Register` 页中的标记只引用任意标记前缀和控件的命名空间。 <xref:System.Web.UI.WebControls.WebParts.WebPart>提供程序和使用者)  (的自定义控件在网页的元素内的 `<asp:webpartzone>` 元素中声明 `<zonetemplate>` 。  
  
 页面提供了三种方式来形成自定义控件之间的连接。 第一种方法是声明性的。 在该页的标记中，将 `<StaticConnections>` 声明一个元素，并在该元素中声明一个元素 `<asp:WebPartConnections>` ，其中包含指定为特性的连接的各种使用者和提供程序详细信息。 这是一种创建连接的方法，它是在网页中直接声明的，特别是在 `<asp:WebPartManager>` 元素中。 由于这种静态连接，因此在第一次加载页面时，将立即创建两个自定义控件之间的连接。  
  
 用于在控件之间形成连接的另一种方法由 `<asp:connectionszone>` 页中的元素提供。 如果用户在运行时将页面切换为连接显示模式，并在其中一个自定义控件上单击连接谓词，则 `<asp:connectionszone>` 元素会自动呈现用于创建连接的 UI。  
  
 此页还演示了创建连接的第三种方法，即以编程方式执行该连接。 在 `Button1_Click` 方法中，代码 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 为提供程序控件创建一个对象，并通过调用方法检索其连接点详细信息 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 。 它为使用者控件执行类似的任务，并调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。 最后，它 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 通过对控件调用方法来创建新的对象 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载网页后，第一个连接已存在，因为它是在元素中声明的 `<StaticConnections>` 。 在 **邮政编码提供程序** 控件中输入一些文本，该文本将显示在使用者控件中。 接下来，将两个控件断开连接。 使用 " **显示模式** " 下拉列表控件更改页面以连接显示模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 对于每个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件，请注意，每个控件都有一个 **连接** 选项。 这是一个连接谓词，仅当页面处于连接模式时，它才会出现在谓词菜单中。 单击其中一个控件上的连接谓词， <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 此时将显示控件提供的连接用户界面。 单击 " **断开连接** " 按钮以结束控件之间的静态连接。 使用 " **显示模式** " 控件将页面返回到浏览模式。 再次尝试在提供程序中输入一些新文本，请注意，由于控件已断开连接，因此无法在使用者控件中更新文本。  
  
 接下来，使用与上面相同的方法再次将页面切换到连接显示模式。 单击其中一个控件上的连接谓词。 单击 " **创建连接** " 链接，并使用控件提供的 UI 在 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 控件之间创建连接。 这是创建连接的第二种方法。 请注意，一旦建立连接，就会在提供程序控件中输入的最后一个字符串 (因为控件已断开连接) 突然出现在使用者中，因为该连接已重新创建。 单击 " **断开连接** " 按钮以结束刚才创建的当前连接。 将页返回到浏览模式。 在提供程序中输入一些新文本，以演示文本未更新并且控件再次断开连接。  
  
 返回页面以连接显示模式。 请单击 " **连接" Web 部件控件** 按钮，而不是单击连接谓词，其中显示了形成连接的第三种方法。 此方法在一个简单的步骤中以编程方式连接控件，而无需使用 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 控件。 请注意，在创建连接时，在提供程序中输入的最后一个字符串会突然出现在使用者控件中。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionsZone" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
    <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web 部件连接概述</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.%23ctor%2A>构造函数是公共的，以便在网页的标记中声明连接时，ASP.NET 分析器可以创建实例; 此构造函数不能在开发人员代码中使用。  
  
 如果要以 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 编程方式创建对象，则应使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A?displayProperty=nameWithType> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A?displayProperty=nameWithType> 控件中提供的或方法 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 。 这些方法处理创建连接的多个细节，并返回一个 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.%23ctor%2A>类的构造函数 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 将和属性的值设置 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 为 `true` 。 因此，新连接的默认状态将为静态 (这意味着它是在包含网页的标记中声明的) 并) 页面的所有用户都可以看到共享的 (。 在典型方案中添加连接时，会出现这种情况，方法是使用元素在页面的标记中声明连接 `<asp:webpartconnection>` 。 但在其他情况下，连接的这些属性的值将不同。 例如，当你通过在代码中创建连接对象来以编程方式添加连接，并且用户在默认用户个性化设置范围内查看该页时，连接将创建为动态的每用户 (仅对特定用户) 连接可见。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>和 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 属性是只读的，并且这些确定连接特性的属性是由控件在内部由控件设置的， <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 具体取决于如何在页标记中以声明方式创建连接 (，或以编程方式通过代码或用户界面) 。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Consumer">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart Consumer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart Consumer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Consumer As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ Consumer { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Consumer : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个作为连接中的使用者控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，表示作为连接中的使用者的 Web 部件控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 Web 部件连接包含共享数据的两个控件。 一个控件充当数据的提供程序，另一个控件作为使用者，接收和处理来自提供程序的数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性获取对 <xref:System.Web.UI.WebControls.WebParts.WebPart> 在连接关系中充当使用者的控件的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A> 属性。  
  
 此代码示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Consumer#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_Consumer#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 作为使用者和连接的提供程序的两个控件的源代码，以及用于连接点的接口。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Consumer#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Consumer#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是承载控件的网页的代码，并演示属性的用法 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A> 。 页面顶部附近是 `Register` 用户控件和自定义控件的指令。 由于本示例使用动态编译，因此 `Register` 源文件的指令不需要引用程序集名称; 它只包含控件的任意标记前缀和命名空间。 在 `Button2_Click` 方法中，代码通过控件访问连接对象 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ，并获取对使用者控件的引用。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Consumer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Consumer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，请使用 " **显示模式** " 下拉列表控件将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 使用 " **连接" WebPart 控件** 按钮或提供的连接用户界面 (UI) ，以创建两个控件之间的连接。 单击 " **显示使用者信息** " 按钮，以运行演示属性的代码 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID" /> 属性的长度为零。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConsumerConnectionPoint">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint ConsumerConnectionPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint ConsumerConnectionPoint" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConsumerConnectionPoint As ConsumerConnectionPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ ConsumerConnectionPoint { System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConsumerConnectionPoint : System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象作为连接中充当使用者的控件的连接点。</summary>
        <value>与连接中的使用者控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在两个控件之间创建连接所必需的步骤之一 <xref:System.Web.UI.WebControls.WebParts.WebPart> 是为每个控件创建连接点。 使用者连接点是一个对象，其中包含有关如何连接到作为使用者的控件的信息。 在使用者的源代码中，必须使用属性标识其中一种方法 `ConnectionConsumer` 。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>与使用者控件关联的对象包含有关方法和属性的详细信息，包括方法的 ID、用于在用户界面中使用的显示名称 (UI) ，以及该方法可以检索的接口类型。 这组有关使用者的信息、其建立连接的方法以及它理解的接口类型，共同形成了一个使用者连接点。  
  
 默认情况下， <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 对象一次只能连接到一个 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 对象。 使用者可能会将多个方法标识为可能的使用者连接点，但使用者只能作为使用者参与一个连接 (因此，一次只能有一个使用者连接点) 处于活动状态。 与此相反， <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 可以连接到任意数量的 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 对象。 可以通过重写属性上的属性来更改此默认行为 <xref:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute.AllowsMultipleConnections%2A> <xref:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute> 。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A> 属性。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 作为使用者和连接的提供程序的两个控件的源代码，以及用于连接点的接口。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是承载控件的网页的代码，并演示属性的用法 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A> 。 在 `Button1_Click` 方法中，创建建立连接所需的所有对象（包括 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 对象）。 这些对象都传递到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法以创建连接。 在 `Button2_Click` 方法中，代码访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A> 属性，并显示连接点的一些详细信息。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，请使用 " **显示模式** " 下拉列表控件将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 使用 " **连接" WebPart 控件** 按钮或提供的连接 UI 在两个控件之间创建连接。 单击 " **器详细信息** " 按钮以运行演示属性的代码 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConsumerConnectionPointID">
      <MemberSignature Language="C#" Value="public string ConsumerConnectionPointID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConsumerConnectionPointID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID" />
      <MemberSignature Language="VB.NET" Value="Public Property ConsumerConnectionPointID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConsumerConnectionPointID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConsumerConnectionPointID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("default")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("default")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的使用者连接点的对象的 ID。</summary>
        <value>包含使用者连接点的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于在网页的标记中声明的静态连接，开发人员可以通过为元素的特性指定值来指定将用于连接的使用者连接点 `ConsumerConnectionPointID` `<asp:webpartconnection>` 。 如果未将值分配给属性，则 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID> 使用属性值。  
  
 ) 连接创建动态 (编程时，通常不应设置属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 。 您可以只调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 控件上的方法 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ，将使用者和使用者连接点 (对象与) 的其他必需参数一起使用，并且该方法将确定要用于使用者连接点的正确 ID。 同样，在断开连接时，可以调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法，而无需指定 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 属性值。  
  
> [!NOTE]
>  当你将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件指定为使用者时，可以确定使用者的连接点的 ID。 必须标识使用者中的一个方法，该方法检索由提供程序控件或转换器提供的接口的实例。 若要标识该方法，请用 `ConnectionConsumer` code 特性标记它。 添加此属性时，可以添加一个可选的字符串值参数，该参数作为使用者对象的 ID <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 。 如果为可选 ID 参数提供一个值，该值将成为连接的属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 。 如果未提供 ID 值，则 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID> 使用属性值。  
  
   
  
## Examples  
 下面的代码示例演示了属性的声明性和编程使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，使用和元素在页标记中声明连接 `<StaticConnections>` `<asp:WebPartsConnection>` 。 连接声明包括必需的 `ConsumerConnectionPointID` 属性。 用于创建连接的另一种方法将在方法中显示， `Button1_Click` 其中，代码使用使用者控件中定义的连接点创建新连接。 然后，在 `Button2_Click` 方法中，代码访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，连接已存在，因为在页面中声明了静态连接。 在提供程序控件中输入一些文本，请注意，由于连接的原因，该文本将显示在使用者中。 接下来，断开控件的连接。 使用 " **显示模式** " 下拉列表控件，将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 单击 " **断开连接** " 按钮。 使用 " **连接" Web 部件控件** 按钮可以重新创建两个控件之间的连接。 单击 " **器详细信息** " 按钮以运行访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A> 属性值的代码。 值写出在控件下方的标签中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.ConnectionPoint.ID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConsumerID">
      <MemberSignature Language="C#" Value="public string ConsumerID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConsumerID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID" />
      <MemberSignature Language="VB.NET" Value="Public Property ConsumerID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConsumerID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConsumerID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的使用者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的 ID。</summary>
        <value>一个字符串，包含作为连接中的使用者的控件的 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A> 控件之间创建连接时，属性值是必需的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 如果未将值分配给属性，则当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件尝试激活连接时将引发异常。  
  
   
  
## Examples  
 下面的代码示例演示了属性的声明性和编程使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A> 。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，使用和元素在页标记中声明连接 `<StaticConnections>` `<asp:WebPartsConnection>` 。 连接声明包括必需的 `ConsumerID` 属性。 用于创建连接的另一种方法将在方法中显示， `Button1_Click` 其中，代码使用使用者控件中定义的连接点创建新连接。 然后，在 `Button2_Click` 方法中，代码将访问属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A> ，并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，连接已存在，因为在页面中声明了静态连接。 在提供程序控件中输入一些文本，请注意，由于连接的原因，该文本将显示在使用者中。 接下来，断开控件的连接。 使用 " **显示模式** " 下拉列表控件，将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 单击 " **断开连接** " 按钮。 使用 " **连接" Web 部件控件** 按钮可以重新创建两个控件之间的连接。 单击 " **使用者详细信息** " 按钮以运行访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A> 属性值的代码。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ID" />
      <MemberSignature Language="VB.NET" Value="Public Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的 ID。</summary>
        <value>包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象都有一个分配给其属性的唯一值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A> 。 这是为了确保有一种方法可以区分多个连接。  
  
 如果通过在网页中声明元素来创建静态连接， `<asp:webpartconnection>` 并且没有为 `ID` 连接的属性赋值，则当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件尝试激活连接时将引发异常。  
  
 当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件创建新的动态连接时，它会调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> 方法来生成连接的唯一 ID。  
  
   
  
## Examples  
 下面的代码示例演示了属性的声明性和编程使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A> 。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，使用和元素在页标记中声明连接 `<StaticConnections>` `<asp:WebPartsConnection>` 。 连接声明包括必需的 `ID` 属性。 用于创建连接的另一种方法将在方法中显示， `Button1_Click` 其中，代码使用使用者控件中定义的连接点创建新连接。 此处不需要 ID 属性，因为连接是动态的，并且 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件将 ID 分配到连接。 在 `Button2_Click` 方法中，代码将访问属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A> ，并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，连接已存在，因为在页面中声明了静态连接。 在提供程序控件中输入一些文本，请注意，由于连接的原因，该文本将显示在使用者中。 接下来，断开控件的连接。 使用 " **显示模式** " 下拉列表控件，将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 单击 " **断开连接** " 按钮。 使用 " **连接" Web 部件控件** 按钮可以重新创建两个控件之间的连接。 单击 " **连接详细信息** " 按钮以运行访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A> 属性值的代码。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象当前是否已经建立并且能够在其提供者和使用者控件之间交换数据。</summary>
        <value>如果连接处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性指示对象的状态 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 。 当连接处于此状态时，连接中的提供者和使用者控件将进行通信，并能够通过公共接口或对象交换数据 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 。  
  
 当用户查看在正常浏览模式下包含已建立连接的已呈现页面时，该连接通常为活动 (除非由于在页面加载) 时出现一些冲突或其他问题而无法激活。 在页面和控件生命周期的早期阶段，属性值为 `false` 。 该连接将在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 引发控件上的事件后立即激活 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 。 具体而言，在使用者从提供程序或对象检索指定接口的实例后，将激活连接 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 。  
  
 当某个页面上有多个连接时，知道连接是否处于活动状态是非常有用的。 例如，如果两个连接之间存在某种冲突，则 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件可以选择不激活某个连接来避免冲突。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A> 。  
  
 该示例包含三个部分：  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsActive#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsActive#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第二部分是网页。 顶部附近是一个 `Register` 指令，该指令引用两个动态编译的控件的源代码 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 静态连接在 `<StaticConnections>` 页面上的元素中声明。 元素中 `<script>` 包含四个事件处理程序。 每个事件处理程序将检查 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A> 静态连接上属性的值，并向控件写入一条消息， <xref:System.Web.UI.WebControls.Label> 指示连接在该页的该状态下是处于活动状态还是处于非活动状态以及控件生命周期。 这说明了连接在哪个点处于活动状态，并且它在页面呈现后保持活动状态。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsActive#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/CS/wpConnectIsActiveCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsActive#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/VB/wpConnectIsActiveVB.aspx#1)]  
  
 在浏览器中加载页面。 已创建静态连接，并且已将消息写入标签，这些标签显示连接在页面中的不同时间点是否处于活动状态以及控件生命周期。 单击 " **连接详细信息** " 按钮，请注意，该连接在该时间点处于不活动状态，但每次事件发生后会重新激活连接，并且该连接 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 仍处于活动状态， (，并将在 <xref:System.Web.UI.Control.PreRender> 页面出现后) 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsShared">
      <MemberSignature Language="C#" Value="public bool IsShared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsShared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsShared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsShared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsShared : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象是对所有用户可见还是仅对当前用户可见。</summary>
        <value>如果连接是共享的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与各个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件一样， <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象可以是共享或每个用户的实例。 共享实例表示连接对网页的所有用户可见，而每个用户实例则意味着连接仅对特定用户可见。  
  
 通常，连接添加到页面的方式确定连接是否共享。 如果在网页的标记中声明了连接，则连接将共享，并且 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 属性值为 `true` 。 此外，如果添加连接时网页位于共享的个性化设置范围内，则还会共享连接。 通常，当用户 `<asp:connectionszone>` (UI 中使用用户界面) 添加连接时，该页处于用户个性化设置范围内，因此不会共享连接，并且 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 属性值为 `false` 。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 属性。  
  
 此代码示例包含五个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   运行示例所需的 Web.config 文件中的条目。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsShared#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsShared#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsShared#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsShared#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 在 `Button2_Click` 方法中，它将检查 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 现有连接的属性，并在页面上显示结果。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsShared#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsShared#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 此代码示例的第四部分是 Web.config 文件中的一个条目，该用户帐户将运行此示例，以便能够在共享个性化设置范围中编辑页面。 若要启用此设置，你必须在与以下示例类似的部分中的 Web.config 文件中有一个条目 `<system.web>` 。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow users="UserAccount"  
             roles="admin"  
             verbs="enterSharedScope"/>  
    </authorization>            
  </personalization>  
</webParts>  
```  
  
 在浏览器中加载页面后，使用 " **显示模式** " 下拉列表控件切换页面以连接显示模式。 单击 " **连接" Web 部件控件** 按钮以建立连接。 接下来，单击 " **连接详细信息** " 按钮以显示连接是否共享。 如果在 "默认用户" 个性化设置范围中创建了与页面的连接，则该 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 属性的值应 `false` 为 "连接"。  
  
 在其中一个控件的谓词菜单上 <xref:System.Web.UI.WebControls.WebParts.WebPart> (标题栏) 中向下箭头指示），单击 "连接" 谓词。 连接 UI 出现时，单击 " **断开** 连接" 按钮以结束连接。 使用 " **显示模式** " 控件将页面返回到浏览模式。  
  
 在 " **显示模式** " 控件中，选择 " **共享** " 选项，将页面切换到共享的个性化设置范围。 按照上述步骤创建连接，然后再次单击 " **连接详细信息** " 按钮以显示连接是否共享。 在这种情况下，属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A> 应为 `true` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象是在网页的标记中声明的，还是以编程方式创建的。</summary>
        <value>如果连接是静态的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件控件之间的连接可以是静态的，也可以是动态的。 静态连接是使用元素在网页的标记中声明的 `<asp:WebPartConnection>` 。 动态连接是以编程方式创建的，或者当用户通过用户界面创建连接时 (UI) 由 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 控件定义。  
  
 静态连接是共享对象，这意味着它们可供网页的所有用户使用。 而且，它们实质上是永久性的，因为像静态 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件一样，它们不能被永久删除。  
  
> [!NOTE]
>  当无法永久删除静态连接对象时，它可能会永久断开连接。 在这种情况下，断开连接的对象将存在于服务器上，但最终用户永远不会意识到对象在页面中的存在。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 属性。  
  
 此代码示例包含三个部分：  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsStatic#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsStatic#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第二部分是网页。 顶部附近是一个 `Register` 指令，该指令引用两个动态编译的控件的源代码 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 静态连接在 `<StaticConnections>` 页面上的元素中声明。 `Button1_Click`方法访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 属性以检查连接是否为静态。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsStatic#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/CS/wpConnectIsStaticCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsStatic#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/VB/wpConnectIsStaticVB.aspx#1)]  
  
 在浏览器中加载页面。 已创建静态连接。 在提供程序控件中输入一些文本，并注意该文本显示在使用者控件中。 单击 " **连接详细信息** " 按钮以显示属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Provider As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ Provider { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Provider : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取作为 Web 部件连接中的提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <value>作为数据提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 Web 部件连接都包含两个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件--使用者和提供程序--并且 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A> 属性返回对连接中提供程序控件的引用。  
  
 与 (使用者控件) 连接中的对应项一样，提供程序控件是建立连接所必需的。 无论是以编程方式创建连接，还是以页持久性格式声明，都必须指定一个控件作为连接的访问接口。  
  
   
  
## Examples  
 下面的代码示例演示属性的用法 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A> 。  
  
 此代码示例包含三个部分：  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Provider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Provider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第二部分是网页。 顶部附近是一个 `Register` 指令，该指令引用两个动态编译的控件的源代码 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 静态连接在 `<StaticConnections>` 页面上的元素中声明。 请注意，在 `<asp:webpartconnection>` 元素中， `ProviderID` 属性具有分配给它的提供程序控件的 ID。 这是为静态连接标识提供程序所必需的。 `Button1_Click`方法访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A> 属性，并将其一些详细信息写入标签。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Provider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/CS/wpConnectProviderCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Provider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/VB/wpConnectProviderVB.aspx#1)]  
  
 在浏览器中加载页面。 已创建静态连接。 在提供程序控件中输入一些文本，并注意该文本显示在使用者控件中。 单击 " **提供程序详细信息** " 按钮可显示通过属性访问的某些属性值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A> 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" /> 属性值的长度为零。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ProviderConnectionPoint">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ProviderConnectionPoint ProviderConnectionPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint ProviderConnectionPoint" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProviderConnectionPoint As ProviderConnectionPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ ProviderConnectionPoint { System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProviderConnectionPoint : System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象作为充当连接提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的连接点。</summary>
        <value>与连接中的提供者控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在两个控件之间创建连接所必需的步骤之一 <xref:System.Web.UI.WebControls.WebParts.WebPart> 是为每个控件创建连接点。 提供程序连接点是一个对象，其中包含有关如何连接到用作提供者的控件的信息。 在提供程序的源代码中，其中一个方法必须用 `ConnectionProvider` 特性标识。 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>与提供程序控件关联的包含有关方法和属性的详细信息，包括方法的 ID、在用户界面中使用的显示名称 (UI) ，以及方法可以返回给使用者控件的接口实例的类型。 这组有关提供程序的信息、其建立连接的方法以及它所提供的接口类型共同构成了一个提供程序连接点。  
  
 默认情况下，一 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 次只能连接到一个 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 对象。 使用者可能会将多个方法标识为可能的使用者连接点，但使用者只能作为使用者参与一个连接 (因此，一次只能有一个使用者连接点) 处于活动状态。 与此相反， <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 默认情况下可以连接到任意数量的 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 对象。 例如，提供邮政编码的提供者控件可以连接到多个使用者控件，这些控件使用邮政编码创建各种类型的数据（如天气数据、新闻等）。 可以通过重写属性上的属性来更改此默认行为 <xref:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute.AllowsMultipleConnections%2A> <xref:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute> 。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A> 属性。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPoint#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是 <xref:System.Web.UI.WebControls.WebParts.WebPart> 作为使用者和连接的提供程序的两个控件的源代码，以及用于连接点的接口。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderConnectionPoint#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是承载控件的网页的代码，并演示属性的用法 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A> 。 在 `Button1_Click` 方法中，创建建立连接所需的所有对象（包括 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 对象）。 请注意 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 控件上对方法的调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 。 所有创建的对象都传递到 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 方法以创建连接。 在 `Button2_Click` 方法中，代码访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A> 属性，并显示连接点的一些详细信息。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPoint#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，请使用 " **显示模式** " 下拉列表控件将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 使用 " **连接" WebPart 控件** 按钮或提供的连接 UI 在两个控件之间创建连接。 单击 " **器详细信息** " 按钮以运行演示属性的代码 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A> 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ProviderConnectionPointID">
      <MemberSignature Language="C#" Value="public string ProviderConnectionPointID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderConnectionPointID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID" />
      <MemberSignature Language="VB.NET" Value="Public Property ProviderConnectionPointID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProviderConnectionPointID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProviderConnectionPointID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("default")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("default")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的提供者连接点的对象的 ID。</summary>
        <value>包含提供者连接点对象的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于在网页的标记中声明的静态连接，开发人员可以通过为元素的特性指定值来指定将用于连接的提供程序连接点 `ProviderConnectionPointID` `<asp:webpartconnection>` 。 如果未将值分配给属性，则 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID> 使用属性值。  
  
 ) 连接创建动态 (编程时，通常不应设置属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 。 您可以只调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 控件上的方法 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ，将提供程序和提供程序连接点对象与) 的其他必需参数一起 (，并且该方法确定要用于提供程序的连接点的正确 ID。 同样，在断开连接时，可以调用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法，而无需指定 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 属性值。  
  
> [!NOTE]
>  当您将 <xref:System.Web.UI.WebControls.WebParts.WebPart> 或其他服务器控件指定为提供程序时，可以确定提供程序的连接点的 ID。 必须标识提供程序中的回调方法，该方法为包含使用者的数据的接口的实例提供服务。 若要标识该方法，请用 `ConnectionProvider` code 特性标记它。 添加此属性时，可以添加一个可选的字符串值参数，该参数作为提供者对象的 ID <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 。 如果为可选 ID 参数提供一个值，该值将成为连接的属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 。 如果未提供 ID 值，则在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 创建对象时，控件将分配默认 id。  
  
   
  
## Examples  
 下面的代码示例演示了属性的声明性和编程使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPointID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderConnectionPointID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，使用和元素在页标记中声明连接 `<StaticConnections>` `<asp:WebPartsConnection>` 。 连接声明包括必需的 `ProviderConnectionPointID` 属性。 用于创建连接的另一种方法将在方法中显示， `Button1_Click` 其中，代码使用连接点 (，并在提供程序控件中定义) ID。 然后，在 `Button2_Click` 方法中，代码访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 属性。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPointID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，连接已存在，因为在页面中声明了静态连接。 在提供程序控件中输入一些文本，请注意，由于连接的原因，该文本将显示在使用者中。 接下来，断开控件的连接。 使用 " **显示模式** " 下拉列表控件，将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 单击 " **断开连接** " 按钮。 使用 " **连接" Web 部件控件** 按钮可以重新创建两个控件之间的连接。 单击 " **器详细信息** " 按钮以运行访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A> 属性值的代码。 值写出在控件下方的标签中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.ConnectionPoint.ID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ProviderID">
      <MemberSignature Language="C#" Value="public string ProviderID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" />
      <MemberSignature Language="VB.NET" Value="Public Property ProviderID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProviderID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProviderID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的 ID。</summary>
        <value>包含提供者控件的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>创建两个控件之间的连接时，属性值是必需的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 如果未将值分配给属性，则当 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 控件尝试激活连接时将引发异常。  
  
   
  
## Examples  
 下面的代码示例演示了属性的声明性和编程使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A> 。  
  
 该示例包含四个部分：  
  
-   允许您在页上更改 Web 部件显示模式的用户控件。  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载所有控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是用户控件，该控件使用户能够更改网页上的显示模式。 将以下源代码保存到 .ascx 文件，并为其提供分配给 `Src` 此用户控件的指令属性的文件名，该属性 `Register` 位于宿主网页的顶部附近。 有关显示模式的详细信息以及此控件中源代码的说明，请参阅 [演练：在 Web 部件页上更改显示模式](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/DisplayModeMenuVB.ascx#6)]  
  
 此代码示例的第二部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意，使用和元素在页标记中声明连接 `<StaticConnections>` `<asp:WebPartsConnection>` 。 连接声明包括必需的 `ProviderID` 属性。 用于创建连接的另一种方法将在方法中显示， `Button1_Click` 其中，代码使用使用者控件中定义的连接点创建新连接。 然后，在 `Button2_Click` 方法中，代码将访问属性的值 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A> ，并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后，连接已存在，因为在页面中声明了静态连接。 在提供程序控件中输入一些文本，请注意，由于连接的原因，该文本将显示在使用者中。 接下来，断开控件的连接。 为此，请使用 " **显示模式** " 下拉列表控件将页面切换到连接模式。 单击谓词菜单 (由标题栏中的向下箭头表示) 一个 <xref:System.Web.UI.WebControls.WebParts.WebPart> 控件上，然后单击 "连接" 谓词。 单击 " **断开连接** " 按钮，控件将断开连接。 接下来，使用 " **连接" WebPart 控件** 按钮重新创建两个控件之间的连接。 单击 " **使用者详细信息** " 按钮以运行访问 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A> 属性值的代码。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="webPartConnection.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重写继承的 <see cref="M:System.Object.ToString" /> 方法，并返回连接对象的类型的简称。</summary>
        <returns>一个字符串，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 的类型简称（非限定名称）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法主要用于控件设计器的便利。 它通过使用较短的类型名称（而不是完全限定的类型名称）来改善连接对象在设计视图中的显示方式。 但是，在你想要了解连接对象的类型名称的代码中的任何位置，都可以调用方法。  
  
   
  
## Examples  
 下面的代码示例演示如何调用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A> 方法以返回对象的短类型名称 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 。  
  
 此代码示例包含三个部分：  
  
-   接口的源代码和两个用作 <xref:System.Web.UI.WebControls.WebParts.WebPart> 连接的提供者和使用者的控件。  
  
-   承载控件并运行代码示例的网页。  
  
-   有关如何运行 "示例" 页的说明。  
  
 此代码示例的第一部分是接口的源代码和使用者控件和提供者控件。 要使代码示例运行，必须编译此源代码。 可以显式编译该程序集，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以将源代码放在站点的 App_Code 文件夹中，它将在运行时动态编译。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅 [演练：开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ToString#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ToString#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第二部分是网页。 顶部附近是一个 `Register` 指令，该指令引用两个动态编译的控件的源代码 <xref:System.Web.UI.WebControls.WebParts.WebPart> 。 静态连接在 `<StaticConnections>` 页面上的元素中声明。 `Button1_Click`方法调用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A> 方法来写入标签的连接的类型名称。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ToString#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/CS/wpConnectToStringCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/VB/wpConnectToStringVB.aspx#1)]  
  
 在浏览器中加载页面。 已创建静态连接。 在提供程序控件中输入一些文本，并注意该文本显示在使用者控件中。 单击 " **连接详细信息** " 按钮以执行 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A> 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Transformer">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartTransformer Transformer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartTransformer Transformer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transformer As WebPartTransformer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartTransformer ^ Transformer { System::Web::UI::WebControls::WebParts::WebPartTransformer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transformer : System.Web.UI.WebControls.WebParts.WebPartTransformer" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartTransformer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象，用于在 Web 部件连接中两个不兼容的连接点之间转换数据。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Web 部件连接中，连接中的提供者和使用者控件可以通过两种方式连接。 它们可以通过其各自的 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> 对象和两个控件都理解的接口类型来直接连接。 或者，如果它们不兼容，则它们可以使用 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 对象（该对象可将接口实例从提供程序转换为使用者识别的类型）间接连接。  
  
 当需要转换器作为连接的一部分时， <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer%2A> 属性提供对对象的引用 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 。 可以通过为自定义转换器添加标记来在网页的标记中以声明方式添加连接的转换器， (或在元素内的 Web 部件控件集) 提供的某个转换器 `<asp:WebPartConnection>` 。 还可以通过编程方式添加转换器，在代码中创建其实例，并在 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 控件上调用方法 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 来创建连接，并向其传递转换器对象和其他所需的参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Transformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartTransformerCollection Transformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartTransformerCollection Transformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transformers As WebPartTransformerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartTransformerCollection ^ Transformers { System::Web::UI::WebControls::WebParts::WebPartTransformerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transformers : System.Web.UI.WebControls.WebParts.WebPartTransformerCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerDefaultProperty)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerDefaultProperty)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartTransformerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 Web 部件控件集内部使用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合。</summary>
        <value>一个包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformerCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers%2A>属性绝不会供开发人员使用。 若要访问与连接关联的转换器，开发人员应始终使用 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer%2A> 属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers%2A>属性由 Web 部件控件集在内部使用，以使页面开发人员能够在网页标记中的元素内声明转换器元素 `<asp:webpartconnection>` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformerCollection" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
  </Members>
</Type>
