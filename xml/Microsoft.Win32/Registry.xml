<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6ac002b38883a57aed0ffa6673bbe7b1a5234e2c" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82435097" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <TypeSignature Language="C#" Value="public sealed class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Registry extends System.Object" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供表示 Windows 注册表中的根项的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象，并提供访问项/值对的 <see langword="static" /> 方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类提供在运行 Windows 的计算机上的注册表中找到的标准根密钥集。 注册表是存储设备，用于提供有关应用程序、用户和默认系统设置的信息。 例如，应用程序可以使用注册表存储需要在应用程序关闭后保留的信息，并在重新加载应用程序时访问相同的信息。 例如，你可以存储颜色首选项、屏幕位置或窗口大小。 可以通过将信息存储在注册表中的不同位置来控制每个用户的此数据。  
  
 由 `Registry` 类公开的 base 或 root <xref:Microsoft.Win32.RegistryKey> 实例描绘了注册表中子项和值的基本存储机制。 所有键都是只读的，因为注册表依赖于它们是否存在。 `Registry` 公开的密钥如下：  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 存储有关用户首选项的信息。  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 存储本地计算机的配置信息。  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 存储有关类型（和类）及其属性的信息。  
  
 <xref:Microsoft.Win32.Registry.Users>  
 存储有关默认用户配置的信息。  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 存储软件组件的性能信息。  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 存储非用户特定的硬件信息。  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 存储动态数据。  
  
 确定要在其下存储/检索注册表信息的根密钥后，可以使用 <xref:Microsoft.Win32.RegistryKey> 类来添加或删除子项，并为给定的键操作这些值。  
  
 硬件设备可以使用即插即用接口在注册表中自动放置信息。 用于安装设备驱动程序的软件可以通过写入标准 Api 将信息放入注册表。  
  
## <a name="static-methods-for-getting-and-setting-values"></a>用于获取和设置值的静态方法  
 在 .NET Framework 版本2.0 中，<xref:Microsoft.Win32.Registry> 类还包含 `static`<xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法来设置和检索注册表项中的值。 这些方法在每次使用注册表项时都将其打开和关闭，因此当你访问大量值时，它们不会在 <xref:Microsoft.Win32.RegistryKey> 类中执行和类似的方法。  
  
 <xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使用这些方法可以设置注册表项的 Windows 访问控制安全性，在检索值之前测试值的数据类型，以及删除键。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示了根键，第二个示例演示了 `static`<xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法。  
  
 示例 1  
  
 下面的代码示例演示如何检索 HKEY_USERS 项的子项，并将其名称打印到屏幕上。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 `RegistryKey` 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 示例 2  
  
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义文档的类型（或类）以及与那些类型关联的属性。 该字段读取 Windows 注册表基项 HKEY_CLASSES_ROOT。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 传统应用程序和 OLE 应用程序都使用此项下存储的数据。 此密钥还通过存储有关 DDE 和 OLE 支持的信息来提供与 Windows 3.1 注册数据库的向后兼容性。 文件查看器和用户界面扩展将其 OLE 类标识符存储在此注册表项中，并在此项中注册处理服务器。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关非用户特定的硬件的配置信息。 该字段读取 Windows 注册表基项 HKEY_CURRENT_CONFIG。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员映射到 <xref:Microsoft.Win32.Registry.LocalMachine>中的子项。  
  
 使用此成员的一个示例是应用程序，该应用程序根据系统是否连接到网络，为其数据存储不同的服务器名称。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关当前用户首选项的信息。 此字段读取 Windows 注册表基项 HKEY_CURRENT_USER。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此注册表项中存储的信息包括环境变量和有关程序组、颜色、打印机、网络连接和应用程序首选项的数据的设置。 此密钥便于建立当前用户的设置。 在此项中，软件供应商存储要在其应用程序中使用的当前用户特定首选项。 例如，microsoft 创建了 HKEY_CURRENT_USER \Software\Microsoft 密钥供其应用程序使用，每个应用程序在 Microsoft 密钥下创建其自己的子项。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含动态注册表数据。 该字段读取 Windows 注册表基项 HKEY_DYN_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me 注册表同时支持静态数据（存储在注册表中的磁盘上）和动态数据（这些数据经常更改，如性能统计信息）。 此动态数据区域是一种机制，允许虚拟设备驱动程序（Vxd）向可在本地运行的 Win32 应用程序提供实时数据。 它还允许系统监视器提供远程 Windows 98/Windows Me 系统的性能统计信息。  
  
 Vxd 并不仅限于性能数据。 它们可以提供要在不独占 CPU 的情况下有效地从0环到环形3的任何数据。 注册表通过存储指向返回值（或多个值）的函数的指针来支持动态数据。 当注册表调用查询与动态键关联的值时，将调用该函数以返回所需的值。  
  
> [!NOTE]
>  Microsoft Windows 95 中引入了动态密钥来处理动态注册表数据。 它们仅在 Windows 98/Windows Me 中受支持。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。 请注意，此示例可能不返回任何结果，因为可能没有动态数据可用，或者您可能没有运行 Windows 98/ME。 使用此密钥可能会导致其他系统出错。  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">操作系统不支持动态数据，即操作系统非 Windows 98、Windows 98 Second Edition 或 Windows Millennium Edition。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="defaultValue">当 <paramref name="valueName" /> 不存在时返回的值。</param>
        <summary>检索与指定的注册表项中的指定名称关联的值。 如果在指定的项中未找到该名称，则返回您提供的默认值；或者，如果指定的项不存在，则返回 <see langword="null" />。</summary>
        <returns>如果由 <paramref name="keyName" /> 指定的子项不存在，则返回 <see langword="null" />；否则，返回与 <paramref name="valueName" /> 关联的值；或者，如果未找到 <paramref name="defaultValue" />，则返回 <paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串 `valueName` 不区分大小写。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。 若要检索此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。  
  
 有效的根名称为 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 访问 HKEY_CURRENT_USER 根中子项 "MyTestKey" 的键/值对。  
  
 当 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法检索可扩充字符串值（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>）时，它将使用本地环境中的数据展开环境字符串。 如果包含对环境变量的可扩充引用的值存储为字符串（<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>），而不是作为可扩充字符串（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>）存储，则 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不会将其展开。 可以通过调用 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> 方法来扩展此类字符串。  
  
> [!NOTE]
>  从 HKEY_PERFORMANCE_DATA 检索数据的建议方法是使用 <xref:System.Diagnostics.PerformanceCounter> 类，而不是 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 方法。  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法在每次使用注册表项时都将其打开和关闭，因此在访问大量值时，它们不会执行，也不会执行 <xref:Microsoft.Win32.RegistryKey> 类的方法。  
  
 <xref:Microsoft.Win32.RegistryKey> 还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型，并删除键。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含本地计算机的配置数据。 该字段读取 Windows 注册表基项 HKEY_LOCAL_MACHINE。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` 包含五个密钥：  
  
 硬件  
 描述计算机的物理硬件、设备驱动程序使用该硬件的方式，以及将内核模式驱动程序与用户模式代码链接的映射和相关数据。 每次系统启动时，都将重新创建此密钥中的所有数据。 说明子项描述了实际的计算机硬件。 DeviceMap 子项包含特定于特定类驱动程序的格式的杂项数据。 Windows.applicationmodel.resources.core.resourcemap 子项说明哪些设备驱动程序声明了哪些硬件资源。 Windows NT 诊断程序（Winmsdp）可以通过易于阅读的形式报告其内容。  
  
 SAM  
 用户帐户和组帐户的安全信息的目录服务数据库，以及 Windows 2000 Server 中的域（SAM 是安全帐户管理器，称为目录服务数据库）。  
  
 安全性  
 包含本地安全策略，如特定的用户权限。 此密钥仅由 Windows 2000 安全子系统使用。  
  
 软件  
 每台计算机的软件数据库。 此密钥包含与本地计算机上安装的软件有关的数据，以及各种不同的配置数据。  
  
 System  
 控制系统启动、设备驱动程序加载、Windows 2000 服务和操作系统行为。  
  
 按照约定，如果 <xref:Microsoft.Win32.Registry.CurrentUser> 中存在类似的数据，并且在 <xref:Microsoft.Win32.Registry.LocalMachine>下，<xref:Microsoft.Win32.Registry.CurrentUser> 中的数据优先。 但是，此注册表项中的值还可以在 Registry 中扩展（而不是替换）数据。 此外，某些项（如设备驱动程序加载项）在注册表外发生时无意义。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含软件组件的性能信息。 该字段读取 Windows 注册表基项 HKEY_PERFORMANCE_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个软件组件都为其对象创建了密钥，安装了计数器，并在执行时写入计数器数据。 你可以像访问任何其他注册表数据一样使用 <xref:Microsoft.Win32.RegistryKey> 函数访问此数据。  
  
 尽管你使用注册表来收集性能数据，但数据并不存储在注册表数据库中。 改为通过此密钥访问注册表会导致系统从相应的系统对象管理器收集数据。  
  
 若要从本地系统获取性能数据，请使用 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法，并使用 PerformanceData 键。 第一次调用会打开密钥（无需首先显式打开密钥）。 但是，请务必在完成性能数据的获取后使用 <xref:Microsoft.Win32.RegistryKey.Close%2A> 方法关闭密钥的句柄。 如果软件组件的性能数据正在使用中，则用户无法安装或删除该软件组件。  
  
 若要从远程系统获取性能数据，则必须使用 <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> 方法，并使用远程系统的计算机名称和 PerformanceData 密钥。 此调用检索表示远程系统的性能数据的键。 若要检索数据，请使用此注册表项（而不是 PerformanceData 键）调用 <xref:Microsoft.Win32.RegistryKey.GetValue%2A>。  
  
> [!NOTE]
>  在 Windows Server 2003 上，用户至少必须属于性能监视器用户组才能访问此基准密钥的子项。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。 请注意，此示例通常不会返回任何结果，因为可能没有性能数据。  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置注册表项中的名称/值对的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <summary>设置指定的注册表项的指定名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，`valueName` 参数不再限制在最多255个字符之间;但 `keyName` 参数将继续具有255字符的限制。  
  
 由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。 若要设置此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。  
  
 如果密钥中不存在 `valueName`，则将创建该密钥，并将关联的值设置为 `value`。  
  
 如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 在 HKEY_CURRENT_USER 根中创建子项 "MyTestKey"。 字符串 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。  
  
 有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> 方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。 如果需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可能提供更好的性能。 <xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。  
  
 <xref:Microsoft.Win32.Registry.SetValue%2A> 的此重载将64位整数存储为字符串（<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>）。 若要将64位数字存储为 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 值，请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。  
  
 <xref:Microsoft.Win32.Registry.SetValue%2A> 的此重载将所有字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 对象，即使它们包含对环境变量的可展开引用。 若要将字符串值保存为可扩充字符串（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>），请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。  
  
 此重载等效于调用 <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>的 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition （Windows Me）上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。 对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。  
  
- 或 - 
 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入；例如，它是根级节点。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <param name="valueKind">在存储数据时使用的注册表数据类型。</param>
        <summary>通过使用指定的注册表数据类型，设置该指定的注册表项的名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，`valueName` 参数不再限制在最多255个字符之间;但 `keyName` 参数继续具有255字符的限制。  
  
 由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。  
  
> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。 若要设置此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。  
  
 如果密钥中不存在 `valueName`，则将创建该密钥，并将关联的值设置为 `value`。  
  
 如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 在 HKEY_CURRENT_USER 根中创建子项 "MyTestKey"。 字符串 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。  
  
 有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> 方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。 如果需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可能提供更好的性能。 <xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。  
  
 如果指定 `value` 的类型与指定的 `valueKind`不匹配，并且数据无法转换，则会引发 <xref:System.ArgumentException>。 例如，你可以将 <xref:System.Int64?displayProperty=nameWithType> 存储为 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但前提是它的值小于 <xref:System.Int32?displayProperty=nameWithType>的最大值。 不能将单个字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如果为 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> 或 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>传递装箱值，则将使用固定区域性完成转换。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition （Windows Me）上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。 对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。  
  
- 或 - 
 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。  
  
- 或 - 
<paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入（例如，它是根级节点，或者未用写访问权限打开该项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关默认用户配置的信息。 该字段读取 Windows 注册表基项 HKEY_USERS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此密钥包含计算机的每个用户的分支。 为本地计算机上的新用户提供默认配置，如果用户未更改首选项，则为默认的当前用户提供默认配置。 由于 Windows 98/ME 还支持注册表，因此，应用程序可以访问用户特定的信息，其方式与在 Windows 2000 中相同。 每个用户的信息存储在单独的文件中，该文件可以存储在本地或网络服务器上。 Windows 98/ME 可以将此文件复制到用户的当前系统，以便设置可以通过用户从一台计算机移动到另一台计算机。  
  
   
  
## Examples  
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
