<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0980327d9a86d0a4a50a79c69646f84ed20ae118" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78804211" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <TypeSignature Language="C#" Value="public sealed class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Registry extends System.Object" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6dd95-101">提供表示 Windows 注册表中的根项的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象，并提供访问项/值对的 <see langword="static" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="6dd95-101">Provides <see cref="T:Microsoft.Win32.RegistryKey" /> objects that represent the root keys in the Windows registry, and <see langword="static" /> methods to access key/value pairs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-102">此类提供在运行 Windows 的计算机上的注册表中找到的标准根密钥集。</span><span class="sxs-lookup"><span data-stu-id="6dd95-102">This class provides the set of standard root keys found in the registry on machines running Windows.</span></span> <span data-ttu-id="6dd95-103">注册表是存储设备，用于提供有关应用程序、用户和默认系统设置的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-103">The registry is a storage facility for information about applications, users, and default system settings.</span></span> <span data-ttu-id="6dd95-104">例如，应用程序可以使用注册表存储需要在应用程序关闭后保留的信息，并在重新加载应用程序时访问相同的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-104">For example, applications can use the registry for storing information that needs to be preserved after the application is closed, and access that same information when the application is reloaded.</span></span> <span data-ttu-id="6dd95-105">例如，你可以存储颜色首选项、屏幕位置或窗口大小。</span><span class="sxs-lookup"><span data-stu-id="6dd95-105">For instance, you can store color preferences, screen locations, or the size of the window.</span></span> <span data-ttu-id="6dd95-106">可以通过将信息存储在注册表中的不同位置来控制每个用户的此数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-106">You can control this data for each user by storing the information in a different location in the registry.</span></span>  
  
 <span data-ttu-id="6dd95-107">由 `Registry` 类公开的 base 或 root <xref:Microsoft.Win32.RegistryKey> 实例描绘了注册表中子项和值的基本存储机制。</span><span class="sxs-lookup"><span data-stu-id="6dd95-107">The base, or root <xref:Microsoft.Win32.RegistryKey> instances that are exposed by the `Registry` class delineate the basic storage mechanism for subkeys and values in the registry.</span></span> <span data-ttu-id="6dd95-108">所有键都是只读的，因为注册表依赖于它们是否存在。</span><span class="sxs-lookup"><span data-stu-id="6dd95-108">All keys are read-only because the registry depends on their existence.</span></span> <span data-ttu-id="6dd95-109">`Registry` 公开的密钥如下：</span><span class="sxs-lookup"><span data-stu-id="6dd95-109">The keys exposed by `Registry` are:</span></span>  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 <span data-ttu-id="6dd95-110">存储有关用户首选项的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-110">Stores information about user preferences.</span></span>  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 <span data-ttu-id="6dd95-111">存储本地计算机的配置信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-111">Stores configuration information for the local machine.</span></span>  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 <span data-ttu-id="6dd95-112">存储有关类型（和类）及其属性的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-112">Stores information about types (and classes) and their properties.</span></span>  
  
 <xref:Microsoft.Win32.Registry.Users>  
 <span data-ttu-id="6dd95-113">存储有关默认用户配置的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-113">Stores information about the default user configuration.</span></span>  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 <span data-ttu-id="6dd95-114">存储软件组件的性能信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-114">Stores performance information for software components.</span></span>  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 <span data-ttu-id="6dd95-115">存储非用户特定的硬件信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-115">Stores non-user-specific hardware information.</span></span>  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 <span data-ttu-id="6dd95-116">存储动态数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-116">Stores dynamic data.</span></span>  
  
 <span data-ttu-id="6dd95-117">确定要在其下存储/检索注册表信息的根密钥后，可以使用 <xref:Microsoft.Win32.RegistryKey> 类来添加或删除子项，并为给定的键操作这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-117">Once you have identified the root key under which you want to store/retrieve information from the registry, you can use the <xref:Microsoft.Win32.RegistryKey> class to add or remove subkeys, and manipulate the values for a given key.</span></span>  
  
 <span data-ttu-id="6dd95-118">硬件设备可以使用即插即用接口在注册表中自动放置信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-118">Hardware devices can place information in the registry automatically using the Plug and Play interface.</span></span> <span data-ttu-id="6dd95-119">用于安装设备驱动程序的软件可以通过写入标准 Api 将信息放入注册表。</span><span class="sxs-lookup"><span data-stu-id="6dd95-119">Software for installing device drivers can place information in the registry by writing to standard APIs.</span></span>  
  
## <a name="static-methods-for-getting-and-setting-values"></a><span data-ttu-id="6dd95-120">用于获取和设置值的静态方法</span><span class="sxs-lookup"><span data-stu-id="6dd95-120">Static Methods for Getting and Setting Values</span></span>  
 <span data-ttu-id="6dd95-121">在 .NET Framework 版本2.0 中，<xref:Microsoft.Win32.Registry> 类还包含 `static`<xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法来设置和检索注册表项中的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-121">In the .NET Framework version 2.0, the <xref:Microsoft.Win32.Registry> class also contains `static`<xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods for setting and retrieving values from registry keys.</span></span> <span data-ttu-id="6dd95-122">这些方法在每次使用注册表项时都将其打开和关闭，因此当你访问大量值时，它们不会在 <xref:Microsoft.Win32.RegistryKey> 类中执行和类似的方法。</span><span class="sxs-lookup"><span data-stu-id="6dd95-122">These methods open and close registry keys each time they are used, so they do not perform as well as analogous methods in the <xref:Microsoft.Win32.RegistryKey> class, when you access a large number of values.</span></span>  
  
 <span data-ttu-id="6dd95-123"><xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使用这些方法可以设置注册表项的 Windows 访问控制安全性，在检索值之前测试值的数据类型，以及删除键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-123">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to set Windows access control security for registry keys, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-124">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-124">This section contains two code examples.</span></span> <span data-ttu-id="6dd95-125">第一个示例演示了根键，第二个示例演示了 `static`<xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6dd95-125">The first example demonstrates root keys, and the second example demonstrates the `static`<xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods.</span></span>  
  
 <span data-ttu-id="6dd95-126">示例 1</span><span class="sxs-lookup"><span data-stu-id="6dd95-126">Example 1</span></span>  
  
 <span data-ttu-id="6dd95-127">下面的代码示例演示如何检索 HKEY_USERS 项的子项，并将其名称打印到屏幕上。</span><span class="sxs-lookup"><span data-stu-id="6dd95-127">The following code example demonstrates how to retrieve the subkeys of the HKEY_USERS key, and print their names to the screen.</span></span> <span data-ttu-id="6dd95-128">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-128">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-129">然后，可以使用 `RegistryKey` 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-129">You can then use other operations in `RegistryKey` to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 <span data-ttu-id="6dd95-130">示例 2</span><span class="sxs-lookup"><span data-stu-id="6dd95-130">Example 2</span></span>  
  
 <span data-ttu-id="6dd95-131">下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-131">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="6dd95-132">该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-132">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-133">定义文档的类型（或类）以及与那些类型关联的属性。</span><span class="sxs-lookup"><span data-stu-id="6dd95-133">Defines the types (or classes) of documents and the properties associated with those types.</span></span> <span data-ttu-id="6dd95-134">该字段读取 Windows 注册表基项 HKEY_CLASSES_ROOT。</span><span class="sxs-lookup"><span data-stu-id="6dd95-134">This field reads the Windows registry base key HKEY_CLASSES_ROOT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-135">传统应用程序和 OLE 应用程序都使用此项下存储的数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-135">Both conventional applications and OLE applications use data that is stored under this key.</span></span> <span data-ttu-id="6dd95-136">此密钥还通过存储有关 DDE 和 OLE 支持的信息来提供与 Windows 3.1 注册数据库的向后兼容性。</span><span class="sxs-lookup"><span data-stu-id="6dd95-136">This key also provides backward compatibility with the Windows 3.1 registration database by storing information for DDE and OLE support.</span></span> <span data-ttu-id="6dd95-137">文件查看器和用户界面扩展将其 OLE 类标识符存储在此注册表项中，并在此项中注册处理服务器。</span><span class="sxs-lookup"><span data-stu-id="6dd95-137">File viewers and user interface extensions store their OLE class identifiers in this key, and processing servers are registered in this key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-138">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-138">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-139">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-139">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-140">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-140">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-141">包含有关非用户特定的硬件的配置信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-141">Contains configuration information pertaining to the hardware that is not specific to the user.</span></span> <span data-ttu-id="6dd95-142">该字段读取 Windows 注册表基项 HKEY_CURRENT_CONFIG。</span><span class="sxs-lookup"><span data-stu-id="6dd95-142">This field reads the Windows registry base key HKEY_CURRENT_CONFIG.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-143">此成员映射到 <xref:Microsoft.Win32.Registry.LocalMachine>中的子项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-143">This member is mapped to a subkey within <xref:Microsoft.Win32.Registry.LocalMachine>.</span></span>  
  
 <span data-ttu-id="6dd95-144">使用此成员的一个示例是应用程序，该应用程序根据系统是否连接到网络，为其数据存储不同的服务器名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-144">An example of using this member is an application that stores a different server name for its data depending on whether the system is attached to a network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-145">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-145">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-146">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-146">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-147">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-147">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-148">包含有关当前用户首选项的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-148">Contains information about the current user preferences.</span></span> <span data-ttu-id="6dd95-149">此字段读取 Windows 注册表基项 HKEY_CURRENT_USER。</span><span class="sxs-lookup"><span data-stu-id="6dd95-149">This field reads the Windows registry base key HKEY_CURRENT_USER.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-150">此注册表项中存储的信息包括环境变量和有关程序组、颜色、打印机、网络连接和应用程序首选项的数据的设置。</span><span class="sxs-lookup"><span data-stu-id="6dd95-150">Information stored in this key includes the settings of environment variables and data about program groups, colors, printers, network connections, and application preferences.</span></span> <span data-ttu-id="6dd95-151">此密钥便于建立当前用户的设置。</span><span class="sxs-lookup"><span data-stu-id="6dd95-151">This key makes it easier to establish the current user's settings.</span></span> <span data-ttu-id="6dd95-152">在此项中，软件供应商存储要在其应用程序中使用的当前用户特定首选项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-152">In this key, software vendors store the current user-specific preferences to be used within their applications.</span></span> <span data-ttu-id="6dd95-153">例如，microsoft 创建了 HKEY_CURRENT_USER \Software\Microsoft 密钥供其应用程序使用，每个应用程序在 Microsoft 密钥下创建其自己的子项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-153">Microsoft, for example, creates the HKEY_CURRENT_USER\Software\Microsoft key for its applications to use, with each application creating its own subkey under the Microsoft key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-154">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-154">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-155">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-155">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-156">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-156">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-157">包含动态注册表数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-157">Contains dynamic registry data.</span></span> <span data-ttu-id="6dd95-158">该字段读取 Windows 注册表基项 HKEY_DYN_DATA。</span><span class="sxs-lookup"><span data-stu-id="6dd95-158">This field reads the Windows registry base key HKEY_DYN_DATA.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-159">Windows 98/Windows Me 注册表同时支持静态数据（存储在注册表中的磁盘上）和动态数据（这些数据经常更改，如性能统计信息）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-159">The Windows 98/Windows Me registry supports both static data (which is stored on disk in the registry) and dynamic data (which changes frequently, such as performance statistics).</span></span> <span data-ttu-id="6dd95-160">此动态数据区域是一种机制，允许虚拟设备驱动程序（Vxd）向可在本地运行的 Win32 应用程序提供实时数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-160">This dynamic data area is the mechanism that allows Virtual Device Drivers (VxDs) to provide real-time data to Win32 applications that can run remotely as well as locally.</span></span> <span data-ttu-id="6dd95-161">它还允许系统监视器提供远程 Windows 98/Windows Me 系统的性能统计信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-161">It also allows the system monitor to provide performance statistics on remote Windows 98/Windows Me systems.</span></span>  
  
 <span data-ttu-id="6dd95-162">Vxd 并不仅限于性能数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-162">VxDs are not limited to performance data.</span></span> <span data-ttu-id="6dd95-163">它们可以提供要在不独占 CPU 的情况下有效地从0环到环形3的任何数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-163">They can provide any data they want to pass from Ring 0 to Ring 3 efficiently without monopolizing the CPU.</span></span> <span data-ttu-id="6dd95-164">注册表通过存储指向返回值（或多个值）的函数的指针来支持动态数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-164">The registry supports dynamic data by storing a pointer to a function that returns a value (or many values).</span></span> <span data-ttu-id="6dd95-165">当注册表调用查询与动态键关联的值时，将调用该函数以返回所需的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-165">When a Registry call queries values associated with a dynamic key, that function is called to return the desired value or values.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-166">Microsoft Windows 95 中引入了动态密钥来处理动态注册表数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-166">Dynamic keys were introduced in Microsoft Windows 95 to handle dynamic Registry data.</span></span> <span data-ttu-id="6dd95-167">它们仅在 Windows 98/Windows Me 中受支持。</span><span class="sxs-lookup"><span data-stu-id="6dd95-167">They are supported only in Windows 98/Windows Me.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-168">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-168">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-169">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-169">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-170">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-170">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span> <span data-ttu-id="6dd95-171">请注意，此示例可能不返回任何结果，因为可能没有动态数据可用，或者您可能没有运行 Windows 98/ME。</span><span class="sxs-lookup"><span data-stu-id="6dd95-171">Note that this example can return no results, since there might not be dynamic data available, or you might not be running Windows 98/ME.</span></span> <span data-ttu-id="6dd95-172">使用此密钥可能会导致其他系统出错。</span><span class="sxs-lookup"><span data-stu-id="6dd95-172">Using this key may cause an error on other systems.</span></span>  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6dd95-173">操作系统不支持动态数据，即操作系统非 Windows 98、Windows 98 Second Edition 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="6dd95-173">The operating system does not support dynamic data; that is, it is not Windows 98, Windows 98 Second Edition, or Windows Millennium Edition (Windows Me).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="6dd95-174">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</span><span class="sxs-lookup"><span data-stu-id="6dd95-174">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="6dd95-175">名称/值对的名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-175">The name of the name/value pair.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="6dd95-176">当 <paramref name="valueName" /> 不存在时返回的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-176">The value to return if <paramref name="valueName" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="6dd95-177">检索与指定的注册表项中的指定名称关联的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-177">Retrieves the value associated with the specified name, in the specified registry key.</span></span> <span data-ttu-id="6dd95-178">如果在指定的项中未找到该名称，则返回您提供的默认值；或者，如果指定的项不存在，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6dd95-178">If the name is not found in the specified key, returns a default value that you provide, or <see langword="null" /> if the specified key does not exist.</span></span></summary>
        <returns><span data-ttu-id="6dd95-179">如果由 <paramref name="keyName" /> 指定的子项不存在，则返回 <see langword="null" />；否则，返回与 <paramref name="valueName" /> 关联的值；或者，如果未找到 <paramref name="defaultValue" />，则返回 <paramref name="valueName" />。</span><span class="sxs-lookup"><span data-stu-id="6dd95-179"><see langword="null" /> if the subkey specified by <paramref name="keyName" /> does not exist; otherwise, the value associated with <paramref name="valueName" />, or <paramref name="defaultValue" /> if <paramref name="valueName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-180">字符串 `valueName` 不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="6dd95-180">The string `valueName` is not case-sensitive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-181">注册表项可以包含一个不与任何名称关联的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-181">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="6dd95-182">在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-182">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="6dd95-183">若要检索此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-183">To retrieve this unnamed value, specify either `null` or the empty string ("") for `valueName`.</span></span>  
  
 <span data-ttu-id="6dd95-184">有效的根名称为 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。</span><span class="sxs-lookup"><span data-stu-id="6dd95-184">Valid root names are HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span> <span data-ttu-id="6dd95-185">例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 访问 HKEY_CURRENT_USER 根中子项 "MyTestKey" 的键/值对。</span><span class="sxs-lookup"><span data-stu-id="6dd95-185">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" accesses key/value pairs for the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span>  
  
 <span data-ttu-id="6dd95-186">当 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法检索可扩充字符串值（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>）时，它将使用本地环境中的数据展开环境字符串。</span><span class="sxs-lookup"><span data-stu-id="6dd95-186">When the <xref:Microsoft.Win32.RegistryKey.GetValue%2A> method retrieves expandable string values (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), it expands environment strings using data from the local environment.</span></span> <span data-ttu-id="6dd95-187">如果包含对环境变量的可扩充引用的值存储为字符串（<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>），而不是作为可扩充字符串（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>）存储，则 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不会将其展开。</span><span class="sxs-lookup"><span data-stu-id="6dd95-187">If a value containing expandable references to environment variables has been stored as a string (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), rather than as an expandable string (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> does not expand it.</span></span> <span data-ttu-id="6dd95-188">可以通过调用 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> 方法来扩展此类字符串。</span><span class="sxs-lookup"><span data-stu-id="6dd95-188">You can expand such a string after it has been retrieved by calling the <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-189">从 HKEY_PERFORMANCE_DATA 检索数据的建议方法是使用 <xref:System.Diagnostics.PerformanceCounter> 类，而不是 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6dd95-189">The recommended way to retrieve data from HKEY_PERFORMANCE_DATA is to use the <xref:System.Diagnostics.PerformanceCounter> class rather than the <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6dd95-190"><xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法在每次使用注册表项时都将其打开和关闭，因此在访问大量值时，它们不会执行，也不会执行 <xref:Microsoft.Win32.RegistryKey> 类的方法。</span><span class="sxs-lookup"><span data-stu-id="6dd95-190">The <xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods open and close registry keys each time they are used, so they do not perform as well as the methods of the <xref:Microsoft.Win32.RegistryKey> class if you access a large number of values.</span></span>  
  
 <span data-ttu-id="6dd95-191"><xref:Microsoft.Win32.RegistryKey> 还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型，并删除键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-191"><xref:Microsoft.Win32.RegistryKey> also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-192">下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-192">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="6dd95-193">该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-193">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="6dd95-194">该用户没有读取注册表项所需的权限。</span><span class="sxs-lookup"><span data-stu-id="6dd95-194">The user does not have the permissions required to read from the registry key.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6dd95-195">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</span><span class="sxs-lookup"><span data-stu-id="6dd95-195">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6dd95-196"><paramref name="keyName" /> 未以有效注册表根开头。</span><span class="sxs-lookup"><span data-stu-id="6dd95-196"><paramref name="keyName" /> does not begin with a valid registry root.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-197">包含本地计算机的配置数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-197">Contains the configuration data for the local machine.</span></span> <span data-ttu-id="6dd95-198">该字段读取 Windows 注册表基项 HKEY_LOCAL_MACHINE。</span><span class="sxs-lookup"><span data-stu-id="6dd95-198">This field reads the Windows registry base key HKEY_LOCAL_MACHINE.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-199">`LocalMachine` 包含五个密钥：</span><span class="sxs-lookup"><span data-stu-id="6dd95-199">`LocalMachine` contains five keys:</span></span>  
  
 <span data-ttu-id="6dd95-200">硬件</span><span class="sxs-lookup"><span data-stu-id="6dd95-200">Hardware</span></span>  
 <span data-ttu-id="6dd95-201">描述计算机的物理硬件、设备驱动程序使用该硬件的方式，以及将内核模式驱动程序与用户模式代码链接的映射和相关数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-201">Describes the physical hardware in the computer, the way device drivers use that hardware, and mappings and related data that link kernel-mode drivers with user-mode code.</span></span> <span data-ttu-id="6dd95-202">每次系统启动时，都将重新创建此密钥中的所有数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-202">All data in this key is recreated each time the system is started.</span></span> <span data-ttu-id="6dd95-203">说明子项描述了实际的计算机硬件。</span><span class="sxs-lookup"><span data-stu-id="6dd95-203">The Description subkey describes the actual computer hardware.</span></span> <span data-ttu-id="6dd95-204">DeviceMap 子项包含特定于特定类驱动程序的格式的杂项数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-204">The DeviceMap subkey contains miscellaneous data in formats specific to particular classes of drivers.</span></span> <span data-ttu-id="6dd95-205">Windows.applicationmodel.resources.core.resourcemap 子项说明哪些设备驱动程序声明了哪些硬件资源。</span><span class="sxs-lookup"><span data-stu-id="6dd95-205">The ResourceMap subkey describes which device drivers claim which hardware resources.</span></span> <span data-ttu-id="6dd95-206">Windows NT 诊断程序（Winmsdp）可以通过易于阅读的形式报告其内容。</span><span class="sxs-lookup"><span data-stu-id="6dd95-206">The Windows NT Diagnostics program (Winmsdp.exe) can report on its contents in an easy-to-read form.</span></span>  
  
 <span data-ttu-id="6dd95-207">SAM</span><span class="sxs-lookup"><span data-stu-id="6dd95-207">SAM</span></span>  
 <span data-ttu-id="6dd95-208">用户帐户和组帐户的安全信息的目录服务数据库，以及 Windows 2000 Server 中的域（SAM 是安全帐户管理器，称为目录服务数据库）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-208">The directory services database of security information for user and group accounts, and for the domains in Windows 2000 Server (SAM is the Security Account Manager, known as the directory services database).</span></span>  
  
 <span data-ttu-id="6dd95-209">安全性</span><span class="sxs-lookup"><span data-stu-id="6dd95-209">Security</span></span>  
 <span data-ttu-id="6dd95-210">包含本地安全策略，如特定的用户权限。</span><span class="sxs-lookup"><span data-stu-id="6dd95-210">Contains the local security policy, such as specific user rights.</span></span> <span data-ttu-id="6dd95-211">此密钥仅由 Windows 2000 安全子系统使用。</span><span class="sxs-lookup"><span data-stu-id="6dd95-211">This key is used only by the Windows 2000 security subsystem.</span></span>  
  
 <span data-ttu-id="6dd95-212">软件</span><span class="sxs-lookup"><span data-stu-id="6dd95-212">Software</span></span>  
 <span data-ttu-id="6dd95-213">每台计算机的软件数据库。</span><span class="sxs-lookup"><span data-stu-id="6dd95-213">The per-computer software database.</span></span> <span data-ttu-id="6dd95-214">此密钥包含与本地计算机上安装的软件有关的数据，以及各种不同的配置数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-214">This key contains data about software installed on the local computer, along with various items of miscellaneous configuration data.</span></span>  
  
 <span data-ttu-id="6dd95-215">System</span><span class="sxs-lookup"><span data-stu-id="6dd95-215">System</span></span>  
 <span data-ttu-id="6dd95-216">控制系统启动、设备驱动程序加载、Windows 2000 服务和操作系统行为。</span><span class="sxs-lookup"><span data-stu-id="6dd95-216">Controls system startup, device driver loading, Windows 2000 services, and operating system behavior.</span></span>  
  
 <span data-ttu-id="6dd95-217">按照约定，如果 <xref:Microsoft.Win32.Registry.CurrentUser> 中存在类似的数据，并且在 <xref:Microsoft.Win32.Registry.LocalMachine>下，<xref:Microsoft.Win32.Registry.CurrentUser> 中的数据优先。</span><span class="sxs-lookup"><span data-stu-id="6dd95-217">By convention, if similar data exists under <xref:Microsoft.Win32.Registry.CurrentUser> and under <xref:Microsoft.Win32.Registry.LocalMachine>, the data in <xref:Microsoft.Win32.Registry.CurrentUser> takes precedence.</span></span> <span data-ttu-id="6dd95-218">但是，此注册表项中的值还可以在 Registry 中扩展（而不是替换）数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-218">However, values in this key can also extend (rather than replace) data in Registry.LocalMachine.</span></span> <span data-ttu-id="6dd95-219">此外，某些项（如设备驱动程序加载项）在注册表外发生时无意义。</span><span class="sxs-lookup"><span data-stu-id="6dd95-219">Also, some items (such as device driver loading entries) are meaningless if they occur outside of Registry.LocalMachine.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-220">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-220">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-221">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-221">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-222">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-222">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-223">包含软件组件的性能信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-223">Contains performance information for software components.</span></span> <span data-ttu-id="6dd95-224">该字段读取 Windows 注册表基项 HKEY_PERFORMANCE_DATA。</span><span class="sxs-lookup"><span data-stu-id="6dd95-224">This field reads the Windows registry base key HKEY_PERFORMANCE_DATA.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-225">每个软件组件都为其对象创建了密钥，安装了计数器，并在执行时写入计数器数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-225">Each software component creates keys for its objects, counters when it is installed, and writes counter data while it is executing.</span></span> <span data-ttu-id="6dd95-226">你可以像访问任何其他注册表数据一样使用 <xref:Microsoft.Win32.RegistryKey> 函数访问此数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-226">You can access this data as you would access any other registry data, using the <xref:Microsoft.Win32.RegistryKey> functions.</span></span>  
  
 <span data-ttu-id="6dd95-227">尽管你使用注册表来收集性能数据，但数据并不存储在注册表数据库中。</span><span class="sxs-lookup"><span data-stu-id="6dd95-227">Although you use the registry to collect performance data, the data is not stored in the registry database.</span></span> <span data-ttu-id="6dd95-228">改为通过此密钥访问注册表会导致系统从相应的系统对象管理器收集数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-228">Instead, accessing the registry with this key causes the system to collect the data from the appropriate system object managers.</span></span>  
  
 <span data-ttu-id="6dd95-229">若要从本地系统获取性能数据，请使用 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法，并使用 PerformanceData 键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-229">To obtain performance data from the local system, use the <xref:Microsoft.Win32.RegistryKey.GetValue%2A> method, with the Registry.PerformanceData key.</span></span> <span data-ttu-id="6dd95-230">第一次调用会打开密钥（无需首先显式打开密钥）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-230">The first call opens the key (you do not need to explicitly open the key first).</span></span> <span data-ttu-id="6dd95-231">但是，请务必在完成性能数据的获取后使用 <xref:Microsoft.Win32.RegistryKey.Close%2A> 方法关闭密钥的句柄。</span><span class="sxs-lookup"><span data-stu-id="6dd95-231">However, be sure to use the <xref:Microsoft.Win32.RegistryKey.Close%2A> method to close the handle to the key when you are finished obtaining performance data.</span></span> <span data-ttu-id="6dd95-232">如果软件组件的性能数据正在使用中，则用户无法安装或删除该软件组件。</span><span class="sxs-lookup"><span data-stu-id="6dd95-232">The user cannot install or remove a software component while its performance data is in use.</span></span>  
  
 <span data-ttu-id="6dd95-233">若要从远程系统获取性能数据，则必须使用 <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> 方法，并使用远程系统的计算机名称和 PerformanceData 密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-233">To obtain performance data from a remote system, you must use the <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> method, with the computer name of the remote system and the Registry.PerformanceData key.</span></span> <span data-ttu-id="6dd95-234">此调用检索表示远程系统的性能数据的键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-234">This call retrieves a key representing the performance data for the remote system.</span></span> <span data-ttu-id="6dd95-235">若要检索数据，请使用此注册表项（而不是 PerformanceData 键）调用 <xref:Microsoft.Win32.RegistryKey.GetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="6dd95-235">To retrieve the data, call <xref:Microsoft.Win32.RegistryKey.GetValue%2A> using this key, rather than the Registry.PerformanceData key.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-236">在 Windows Server 2003 上，用户至少必须属于性能监视器用户组才能访问此基准密钥的子项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-236">On Windows Server 2003, a user must at least belong to the Performance Monitor Users group in order to access subkeys of this base key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-237">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-237">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-238">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-238">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-239">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-239">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span> <span data-ttu-id="6dd95-240">请注意，此示例通常不会返回任何结果，因为可能没有性能数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-240">Note that this example can often return no results, since there might be no performance data.</span></span>  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6dd95-241">设置注册表项中的名称/值对的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-241">Sets the value of a name/value pair in a registry key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6dd95-242">下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-242">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="6dd95-243">该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-243">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="6dd95-244">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</span><span class="sxs-lookup"><span data-stu-id="6dd95-244">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="6dd95-245">名称/值对的名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-245">The name of the name/value pair.</span></span></param>
        <param name="value"><span data-ttu-id="6dd95-246">要存储的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-246">The value to be stored.</span></span></param>
        <summary><span data-ttu-id="6dd95-247">设置指定的注册表项的指定名称/值对。</span><span class="sxs-lookup"><span data-stu-id="6dd95-247">Sets the specified name/value pair on the specified registry key.</span></span> <span data-ttu-id="6dd95-248">如果指定的项不存在，则创建该项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-248">If the specified key does not exist, it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-249">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，`valueName` 参数不再限制在最多255个字符之间;但 `keyName` 参数将继续具有255字符的限制。</span><span class="sxs-lookup"><span data-stu-id="6dd95-249">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues to have the 255-character restriction.</span></span>  
  
 <span data-ttu-id="6dd95-250">由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-250">Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-251">注册表项可以包含一个不与任何名称关联的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-251">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="6dd95-252">在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-252">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="6dd95-253">若要设置此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-253">To set this unnamed value, specify either `null` or the empty string ("") for `valueName`.</span></span>  
  
 <span data-ttu-id="6dd95-254">如果密钥中不存在 `valueName`，则将创建该密钥，并将关联的值设置为 `value`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-254">If `valueName` does not exist in the key, it is created and the associated value is set to `value`.</span></span>  
  
 <span data-ttu-id="6dd95-255">如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-255">If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root.</span></span> <span data-ttu-id="6dd95-256">例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 在 HKEY_CURRENT_USER 根中创建子项 "MyTestKey"。</span><span class="sxs-lookup"><span data-stu-id="6dd95-256">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" creates the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span> <span data-ttu-id="6dd95-257">字符串 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。</span><span class="sxs-lookup"><span data-stu-id="6dd95-257">The string "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" creates the nested subkeys "MyTestKey", "MyTestKey\Key2", and "MyTestKey\Key2\Key3".</span></span>  
  
 <span data-ttu-id="6dd95-258">有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。</span><span class="sxs-lookup"><span data-stu-id="6dd95-258">Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-259"><xref:Microsoft.Win32.Registry.SetValue%2A> 方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-259">The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called.</span></span> <span data-ttu-id="6dd95-260">如果需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可能提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="6dd95-260">If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> method might provide better performance.</span></span> <span data-ttu-id="6dd95-261"><xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-261">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
 <span data-ttu-id="6dd95-262"><xref:Microsoft.Win32.Registry.SetValue%2A> 的此重载将64位整数存储为字符串（<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-262">This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores 64-bit integers as strings (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>).</span></span> <span data-ttu-id="6dd95-263">若要将64位数字存储为 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 值，请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="6dd95-263">To store 64-bit numbers as <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> values, use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.</span></span>  
  
 <span data-ttu-id="6dd95-264"><xref:Microsoft.Win32.Registry.SetValue%2A> 的此重载将所有字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 对象，即使它们包含对环境变量的可展开引用。</span><span class="sxs-lookup"><span data-stu-id="6dd95-264">This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores all string values as <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> objects, even if they contain expandable references to environment variables.</span></span> <span data-ttu-id="6dd95-265">若要将字符串值保存为可扩充字符串（<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>），请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="6dd95-265">To save string values as expandable strings (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.</span></span>  
  
 <span data-ttu-id="6dd95-266">此重载等效于调用 <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>的 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="6dd95-266">This overload is equivalent to calling the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload with <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-267">在 Windows 98 和 Windows Millennium Edition （Windows Me）上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。</span><span class="sxs-lookup"><span data-stu-id="6dd95-267">On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages.</span></span> <span data-ttu-id="6dd95-268">对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-268">A Unicode character that is invalid for the current code page is replaced by the best available match.</span></span> <span data-ttu-id="6dd95-269">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="6dd95-269">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-270">下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-270">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="6dd95-271">该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-271">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6dd95-272"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6dd95-272"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6dd95-273"><paramref name="keyName" /> 未以有效注册表根开头。</span><span class="sxs-lookup"><span data-stu-id="6dd95-273"><paramref name="keyName" /> does not begin with a valid registry root.</span></span>  
  
<span data-ttu-id="6dd95-274">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6dd95-274">-or-</span></span> 
 <span data-ttu-id="6dd95-275"><paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-275"><paramref name="keyName" /> is longer than the maximum length allowed (255 characters).</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="6dd95-276"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入；例如，它是根级节点。</span><span class="sxs-lookup"><span data-stu-id="6dd95-276">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="6dd95-277">用户没有创建或修改注册表项所需的权限。</span><span class="sxs-lookup"><span data-stu-id="6dd95-277">The user does not have the permissions required to create or modify registry keys.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="6dd95-278">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</span><span class="sxs-lookup"><span data-stu-id="6dd95-278">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="6dd95-279">名称/值对的名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-279">The name of the name/value pair.</span></span></param>
        <param name="value"><span data-ttu-id="6dd95-280">要存储的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-280">The value to be stored.</span></span></param>
        <param name="valueKind"><span data-ttu-id="6dd95-281">在存储数据时使用的注册表数据类型。</span><span class="sxs-lookup"><span data-stu-id="6dd95-281">The registry data type to use when storing the data.</span></span></param>
        <summary><span data-ttu-id="6dd95-282">通过使用指定的注册表数据类型，设置该指定的注册表项的名称/值对。</span><span class="sxs-lookup"><span data-stu-id="6dd95-282">Sets the name/value pair on the specified registry key, using the specified registry data type.</span></span> <span data-ttu-id="6dd95-283">如果指定的项不存在，则创建该项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-283">If the specified key does not exist, it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-284">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，`valueName` 参数不再限制在最多255个字符之间;但 `keyName` 参数继续具有255字符的限制。</span><span class="sxs-lookup"><span data-stu-id="6dd95-284">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues have the 255-character restriction.</span></span>  
  
 <span data-ttu-id="6dd95-285">由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-285">Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-286">注册表项可以包含一个不与任何名称关联的值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-286">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="6dd95-287">在注册表编辑器中显示此未命名值时，将显示字符串 "（默认值）"，而不是名称。</span><span class="sxs-lookup"><span data-stu-id="6dd95-287">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="6dd95-288">若要设置此未命名值，请为 `valueName`指定 `null` 或空字符串（""）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-288">To set this unnamed value, specify either `null` or the empty string ("") for `valueName`.</span></span>  
  
 <span data-ttu-id="6dd95-289">如果密钥中不存在 `valueName`，则将创建该密钥，并将关联的值设置为 `value`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-289">If `valueName` does not exist in the key, it is created and the associated value is set to `value`.</span></span>  
  
 <span data-ttu-id="6dd95-290">如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-290">If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root.</span></span> <span data-ttu-id="6dd95-291">例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER \MyTestKey" 在 HKEY_CURRENT_USER 根中创建子项 "MyTestKey"。</span><span class="sxs-lookup"><span data-stu-id="6dd95-291">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" creates the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span> <span data-ttu-id="6dd95-292">字符串 "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。</span><span class="sxs-lookup"><span data-stu-id="6dd95-292">The string "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" creates the nested subkeys "MyTestKey", "MyTestKey\Key2", and "MyTestKey\Key2\Key3".</span></span>  
  
 <span data-ttu-id="6dd95-293">有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。</span><span class="sxs-lookup"><span data-stu-id="6dd95-293">Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-294"><xref:Microsoft.Win32.Registry.SetValue%2A> 方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-294">The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called.</span></span> <span data-ttu-id="6dd95-295">如果需要修改大量值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可能提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="6dd95-295">If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> method might provide better performance.</span></span> <span data-ttu-id="6dd95-296"><xref:Microsoft.Win32.RegistryKey> 类还提供了一些方法，使你可以将访问控制列表（ACL）添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。</span><span class="sxs-lookup"><span data-stu-id="6dd95-296">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
 <span data-ttu-id="6dd95-297">如果指定 `value` 的类型与指定的 `valueKind`不匹配，并且数据无法转换，则会引发 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="6dd95-297">If the type of the specified `value` does not match the specified `valueKind`, and the data cannot be converted, <xref:System.ArgumentException> is thrown.</span></span> <span data-ttu-id="6dd95-298">例如，你可以将 <xref:System.Int64?displayProperty=nameWithType> 存储为 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但前提是它的值小于 <xref:System.Int32?displayProperty=nameWithType>的最大值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-298">For example, you can store a <xref:System.Int64?displayProperty=nameWithType> as a <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, but only if its value is less than the maximum value of a <xref:System.Int32?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6dd95-299">不能将单个字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6dd95-299">You cannot store a single string value as a <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-300">如果为 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> 或 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>传递装箱值，则将使用固定区域性完成转换。</span><span class="sxs-lookup"><span data-stu-id="6dd95-300">If boxed values are passed for <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> or <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, the conversion is done using the invariant culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dd95-301">在 Windows 98 和 Windows Millennium Edition （Windows Me）上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。</span><span class="sxs-lookup"><span data-stu-id="6dd95-301">On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages.</span></span> <span data-ttu-id="6dd95-302">对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。</span><span class="sxs-lookup"><span data-stu-id="6dd95-302">A Unicode character that is invalid for the current code page is replaced by the best available match.</span></span> <span data-ttu-id="6dd95-303">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="6dd95-303">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-304">下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。</span><span class="sxs-lookup"><span data-stu-id="6dd95-304">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="6dd95-305">该示例演示了在名称/值对不存在时，存储和检索默认（无名称）名称/值对，并使用 `defaultValue`。</span><span class="sxs-lookup"><span data-stu-id="6dd95-305">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6dd95-306"><paramref name="value" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6dd95-306"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6dd95-307"><paramref name="keyName" /> 未以有效注册表根开头。</span><span class="sxs-lookup"><span data-stu-id="6dd95-307"><paramref name="keyName" /> does not begin with a valid registry root.</span></span>  
  
<span data-ttu-id="6dd95-308">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6dd95-308">-or-</span></span> 
 <span data-ttu-id="6dd95-309"><paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-309"><paramref name="keyName" /> is longer than the maximum length allowed (255 characters).</span></span>  
  
<span data-ttu-id="6dd95-310">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6dd95-310">-or-</span></span> 
<span data-ttu-id="6dd95-311"><paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</span><span class="sxs-lookup"><span data-stu-id="6dd95-311">The type of <paramref name="value" /> did not match the registry data type specified by <paramref name="valueKind" />, therefore the data could not be converted properly.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="6dd95-312"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入（例如，它是根级节点，或者未用写访问权限打开该项）。</span><span class="sxs-lookup"><span data-stu-id="6dd95-312">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node, or the key has not been opened with write access.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="6dd95-313">用户没有创建或修改注册表项所需的权限。</span><span class="sxs-lookup"><span data-stu-id="6dd95-313">The user does not have the permissions required to create or modify registry keys.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6dd95-314">包含有关默认用户配置的信息。</span><span class="sxs-lookup"><span data-stu-id="6dd95-314">Contains information about the default user configuration.</span></span> <span data-ttu-id="6dd95-315">该字段读取 Windows 注册表基项 HKEY_USERS。</span><span class="sxs-lookup"><span data-stu-id="6dd95-315">This field reads the Windows registry base key HKEY_USERS.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dd95-316">此密钥包含计算机的每个用户的分支。</span><span class="sxs-lookup"><span data-stu-id="6dd95-316">This key contains a branch for each user of the computer.</span></span> <span data-ttu-id="6dd95-317">为本地计算机上的新用户提供默认配置，如果用户未更改首选项，则为默认的当前用户提供默认配置。</span><span class="sxs-lookup"><span data-stu-id="6dd95-317">The default configuration is supplied for new users on the local computer and for the default current user if the user has not changed preferences.</span></span> <span data-ttu-id="6dd95-318">由于 Windows 98/ME 还支持注册表，因此，应用程序可以访问用户特定的信息，其方式与在 Windows 2000 中相同。</span><span class="sxs-lookup"><span data-stu-id="6dd95-318">Because Windows 98/ME also supports Registry.Users, applications can access the user-specific information the same way they do under Windows 2000.</span></span> <span data-ttu-id="6dd95-319">每个用户的信息存储在单独的文件中，该文件可以存储在本地或网络服务器上。</span><span class="sxs-lookup"><span data-stu-id="6dd95-319">Each user's information is stored in a separate file, which can be stored locally or on a network server.</span></span> <span data-ttu-id="6dd95-320">Windows 98/ME 可以将此文件复制到用户的当前系统，以便设置可以通过用户从一台计算机移动到另一台计算机。</span><span class="sxs-lookup"><span data-stu-id="6dd95-320">Windows 98/ME can copy this file to the user's current system so that settings can move from one computer to another with the user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dd95-321">下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。</span><span class="sxs-lookup"><span data-stu-id="6dd95-321">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="6dd95-322">使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。</span><span class="sxs-lookup"><span data-stu-id="6dd95-322">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="6dd95-323">然后，可以使用 <xref:Microsoft.Win32.RegistryKey> 中的其他操作来操作该密钥。</span><span class="sxs-lookup"><span data-stu-id="6dd95-323">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
