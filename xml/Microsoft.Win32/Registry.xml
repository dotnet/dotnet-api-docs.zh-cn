<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f57e412f366edd6ff005a88d402b79f140535391" /><Meta Name="ms.sourcegitcommit" Value="943c8cdbe5b47c6c296a6f4b73038bbd43da0dd2" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/12/2021" /><Meta Name="ms.locfileid" Value="100329474" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <TypeSignature Language="C#" Value="public sealed class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Registry extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Registry" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry sealed" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Registry extends System.Object" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="Microsoft.Win32.Registry" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供表示 Windows 注册表中的根项的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象，并提供访问项/值对的 <see langword="static" /> 方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 此类提供在运行 Windows 的计算机上的注册表中找到的标准根密钥集。 注册表是存储设备，用于提供有关应用程序、用户和默认系统设置的信息。 例如，应用程序可以使用注册表存储需要在应用程序关闭后保留的信息，并在重新加载应用程序时访问相同的信息。 例如，你可以存储颜色首选项、屏幕位置或窗口大小。 可以通过将信息存储在注册表中的不同位置来控制每个用户的此数据。

 <xref:Microsoft.Win32.RegistryKey>由类公开的基实例或根实例描绘了 `Registry` 注册表中子项和值的基本存储机制。 所有键都是只读的，因为注册表依赖于它们是否存在。 公开的密钥 `Registry` 为：

 <xref:Microsoft.Win32.Registry.CurrentUser> 存储有关用户首选项的信息。

 <xref:Microsoft.Win32.Registry.LocalMachine> 存储本地计算机的配置信息。

 <xref:Microsoft.Win32.Registry.ClassesRoot> 存储有关类型 (和类) 及其属性的信息。

 <xref:Microsoft.Win32.Registry.Users> 存储有关默认用户配置的信息。

 <xref:Microsoft.Win32.Registry.PerformanceData> 存储软件组件的性能信息。

 <xref:Microsoft.Win32.Registry.CurrentConfig> 存储非用户特定的硬件信息。

 <xref:Microsoft.Win32.Registry.DynData> 存储动态数据。

 确定要在其下存储/检索注册表信息的根密钥后，可以使用 <xref:Microsoft.Win32.RegistryKey> 类来添加或删除子项，并为给定键操作这些值。

 硬件设备可以使用即插即用接口在注册表中自动放置信息。 用于安装设备驱动程序的软件可以通过写入标准 Api 将信息放入注册表。

## <a name="static-methods-for-getting-and-setting-values"></a>用于获取和设置值的静态方法

<xref:Microsoft.Win32.Registry>类还包含 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> <xref:Microsoft.Win32.Registry.SetValue%2A> 用于设置和检索注册表项中的值的方法。 这些方法在每次使用注册表项时都将其打开和关闭，因此 <xref:Microsoft.Win32.RegistryKey> 当你访问大量值时，它们不会在类中执行和类似的方法。

 <xref:Microsoft.Win32.RegistryKey>类还提供了一些方法，使用这些方法可以设置注册表项的 Windows 访问控制安全性，在检索值之前测试值的数据类型，并删除键。

## Examples
 本部分包含两个代码示例。 第一个示例演示了根键，第二个示例演示了 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> 和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法。

 示例 1

 下面的代码示例演示如何检索 HKEY_USERS 项的子项，并将其名称打印到屏幕上。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 `RegistryKey` 来操作该密钥。

 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]

 示例 2

 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了如何在 `defaultValue` 名称/值对不存在的情况下，存储和检索默认 (无名称) 名称/值对以及使用。

 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]

 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义文档的类型（或类）以及与那些类型关联的属性。 该字段读取 Windows 注册表基项 HKEY_CLASSES_ROOT。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 传统应用程序和 OLE 应用程序都使用此项下存储的数据。 此密钥还通过存储有关 DDE 和 OLE 支持的信息来提供与 Windows 3.1 注册数据库的向后兼容性。 文件查看器和用户界面扩展将其 OLE 类标识符存储在此注册表项中，并在此项中注册处理服务器。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。

 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关非用户特定的硬件的配置信息。 该字段读取 Windows 注册表基项 HKEY_CURRENT_CONFIG。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员映射到中的子项 <xref:Microsoft.Win32.Registry.LocalMachine> 。

 使用此成员的一个示例是应用程序，该应用程序根据系统是否连接到网络，为其数据存储不同的服务器名称。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。

 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关当前用户首选项的信息。 此字段读取 Windows 注册表基项 HKEY_CURRENT_USER。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此注册表项中存储的信息包括环境变量和有关程序组、颜色、打印机、网络连接和应用程序首选项的数据的设置。 此密钥便于建立当前用户的设置。 在此项中，软件供应商存储要在其应用程序中使用的当前用户特定首选项。 例如，microsoft 创建要使用的应用程序 HKEY_CURRENT_USER\Software\Microsoft 密钥，每个应用程序在 Microsoft 密钥下创建其自己的子项。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。

 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use PerformanceData instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use PerformanceData instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含动态注册表数据。 该字段读取 Windows 注册表基项 HKEY_DYN_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Windows 98/Windows Me 注册表同时支持静态数据 (，该数据存储在注册表中的磁盘上) ，动态数据 (频繁更改，如性能统计信息) 。 此动态数据区域是一种机制，该机制允许 (Vxd) 的虚拟设备驱动程序向可在本地同时运行的 Win32 应用程序提供实时数据。 它还允许系统监视器提供远程 Windows 98/Windows Me 系统的性能统计信息。

 Vxd 并不仅限于性能数据。 它们可以提供要在不独占 CPU 的情况下有效地从0环到环形3的任何数据。 注册表支持动态数据，方法是存储一个指向函数的指针，该函数将返回值 (或多个值) 。 当注册表调用查询与动态键关联的值时，将调用该函数以返回所需的值。

> [!NOTE]
>  Microsoft Windows 95 中引入了动态密钥来处理动态注册表数据。 它们仅在 Windows 98/Windows Me 中受支持。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。 请注意，此示例可能不返回任何结果，因为可能没有动态数据可用，或者您可能没有运行 Windows 98/ME。 使用此密钥可能会导致其他系统出错。

 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">操作系统不支持动态数据，即操作系统非 Windows 98、Windows 98 Second Edition 或 Windows Millennium Edition。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberSignature Language="C#" Value="public static object? GetValue (string keyName, string? valueName, object? defaultValue);" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="defaultValue">当 <paramref name="valueName" /> 不存在时返回的值。</param>
        <summary>检索与指定的注册表项中的指定名称关联的值。 如果在指定的项中未找到该名称，则返回您提供的默认值；或者，如果指定的项不存在，则返回 <see langword="null" />。</summary>
        <returns>如果由 <paramref name="keyName" /> 指定的子项不存在，则返回 <see langword="null" />；否则，返回与 <paramref name="valueName" /> 关联的值；或者，如果未找到 <paramref name="defaultValue" />，则返回 <paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 字符串 `valueName` 不区分大小写。

> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示 " (默认) " 字符串而不是名称。 若要检索此未命名值，请 `null` 为指定或空字符串 ( "" ) `valueName` 。

 有效的根名称为 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER\MyTestKey" 访问 HKEY_CURRENT_USER 根中子项 "MyTestKey" 的键/值对。

 当 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法检索 () 的可扩展字符串值时 <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> ，它将使用本地环境中的数据展开环境字符串。 如果包含对环境变量的可扩充引用的值存储为字符串 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) ，而不是作为可扩充字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) ， <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 则不会将其展开。 您可以通过调用方法来扩展此类字符串 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> 。

> [!NOTE]
>  从 HKEY_PERFORMANCE_DATA 检索数据的建议方法是使用类，而不是 <xref:System.Diagnostics.PerformanceCounter> <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 方法。

 <xref:Microsoft.Win32.Registry.GetValue%2A>和 <xref:Microsoft.Win32.Registry.SetValue%2A> 方法在每次使用注册表项时都将其打开和关闭，因此， <xref:Microsoft.Win32.RegistryKey> 如果访问大量值，则和方法不会执行以及类的方法。

 <xref:Microsoft.Win32.RegistryKey> 还提供了一些方法，使你可以将访问控制列表 (ACL) 添加到注册表项，以便在检索值之前测试值的数据类型，并删除键。



## Examples
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了如何在 `defaultValue` 名称/值对不存在的情况下，存储和检索默认 (无名称) 名称/值对以及使用。

 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含本地计算机的配置数据。 该字段读取 Windows 注册表基项 HKEY_LOCAL_MACHINE。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `LocalMachine` 包含五个密钥：

 硬件描述了计算机的物理硬件、设备驱动程序使用该硬件的方式，以及将内核模式驱动程序与用户模式代码链接的映射和相关数据。 每次系统启动时，都将重新创建此密钥中的所有数据。 说明子项描述了实际的计算机硬件。 DeviceMap 子项包含特定于特定类驱动程序的格式的杂项数据。 Windows.applicationmodel.resources.core.resourcemap 子项说明哪些设备驱动程序声明了哪些硬件资源。  (Winmsdp.exe) 的 Windows NT 诊断程序，可以以易于阅读的形式报告其内容。

 SAM 是用户和组帐户的安全信息目录服务数据库，而对于 Windows 2000 Server (SAM 中的域，它是安全帐户管理器（称为目录服务数据库) ）。

 Security 包含本地安全策略，如特定的用户权限。 此密钥仅由 Windows 2000 安全子系统使用。

 软件每台计算机的软件数据库。 此密钥包含与本地计算机上安装的软件有关的数据，以及各种不同的配置数据。

 系统控制系统启动、设备驱动程序加载、Windows 2000 服务和操作系统行为。

 按照约定，如果在 <xref:Microsoft.Win32.Registry.CurrentUser> 和下存在类似数据 <xref:Microsoft.Win32.Registry.LocalMachine> ，则中的数据 <xref:Microsoft.Win32.Registry.CurrentUser> 优先。 但是，此键中的值还可以扩展 (而不是替换 Registry 中) 的数据。 此外，某些项 (如设备驱动程序加载项) 在 Registry 之外发生时无意义。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。

 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含软件组件的性能信息。 该字段读取 Windows 注册表基项 HKEY_PERFORMANCE_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每个软件组件都为其对象创建了密钥，安装了计数器，并在执行时写入计数器数据。 你可以像访问任何其他注册表数据一样使用函数访问此数据 <xref:Microsoft.Win32.RegistryKey> 。

 尽管你使用注册表来收集性能数据，但数据并不存储在注册表数据库中。 改为通过此密钥访问注册表会导致系统从相应的系统对象管理器收集数据。

 若要从本地系统获取性能数据，请使用 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 方法，并使用 PerformanceData 键。 第一次调用会打开密钥， (您无需首先显式打开密钥) 。 但是，请务必在 <xref:Microsoft.Win32.RegistryKey.Close%2A> 完成获取性能数据后，使用方法关闭密钥的句柄。 如果软件组件的性能数据正在使用中，则用户无法安装或删除该软件组件。

 若要从远程系统中获取性能数据，您必须使用 <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> 方法，同时使用远程系统的计算机名称和 PerformanceData 密钥。 此调用检索表示远程系统的性能数据的键。 若要检索数据，请 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 使用此键（而不是 PerformanceData 键）调用。

> [!NOTE]
>  在 Windows Server 2003 上，用户至少必须属于性能监视器用户组才能访问此基准密钥的子项。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。 请注意，此示例通常不会返回任何结果，因为可能没有性能数据。

 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置注册表项中的名称/值对的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了如何在 `defaultValue` 名称/值对不存在的情况下，存储和检索默认 (无名称) 名称/值对以及使用。

 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string? valueName, object value);" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <summary>设置指定的注册表项的指定名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ， `valueName` 参数不再限制在最多255个字符之间; 但是，该 `keyName` 参数将继续具有255个字符的限制。

 由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。

> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示 " (默认) " 字符串而不是名称。 若要设置此未命名值，请 `null` 为指定或空字符串 ( "" ) `valueName` 。

 如果 `valueName` 密钥中不存在，则将创建它并将关联的值设置为 `value` 。

 如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER\MyTestKey" 会在 HKEY_CURRENT_USER 根创建子项 "MyTestKey"。 字符串 "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。

 有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。

> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。 如果需要修改大量值， <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可以提供更好的性能。 <xref:Microsoft.Win32.RegistryKey>类还提供了一些方法，使你可以将访问控制列表 (ACL) 添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。

 此重载将 <xref:Microsoft.Win32.Registry.SetValue%2A> 64 位整数存储为 () 的字符串 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 。 若要将64位数字存储为 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 值，请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。

 此重载将 <xref:Microsoft.Win32.Registry.SetValue%2A> 所有字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 对象，即使它们包含对环境变量的可展开引用。 若要将字符串值保存为 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) 的可扩展字符串，请使用 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 方法重载。

 此重载等效于 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 通过调用方法重载 <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType> 。

> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me) 上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。 对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。 不会引发异常。



## Examples
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了如何在 `defaultValue` 名称/值对不存在的情况下，存储和检索默认 (无名称) 名称/值对以及使用。

 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。

- 或 -

 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入；例如，它是根级节点。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string? valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。</param>
        <param name="valueName">名称/值对的名称。</param>
        <param name="value">要存储的值。</param>
        <param name="valueKind">在存储数据时要使用的注册表数据类型。</param>
        <summary>通过使用指定的注册表数据类型，设置该指定的注册表项的名称/值对。 如果指定的项不存在，则创建该项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ， `valueName` 参数不再限制在最多255个字符之间; 但是，此 `keyName` 参数继续具有255个字符的限制。

 由于注册表中的每个键都可以存储许多值，因此必须使用 `valueName` 参数来指定要设置的特定值。

> [!NOTE]
>  注册表项可以包含一个不与任何名称关联的值。 在注册表编辑器中显示此未命名值时，将显示 " (默认) " 字符串而不是名称。 若要设置此未命名值，请 `null` 为指定或空字符串 ( "" ) `valueName` 。

 如果 `valueName` 密钥中不存在，则将创建它并将关联的值设置为 `value` 。

 如果 `keyName` 指定的子项不存在，则会在指定的根中创建该子项。 例如，在 Visual Basic 字符串 "HKEY_CURRENT_USER\MyTestKey" 会在 HKEY_CURRENT_USER 根创建子项 "MyTestKey"。 字符串 "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 创建嵌套子项 "MyTestKey"、"MyTestKey\Key2" 和 "MyTestKey\Key2\Key3"。

 有效的根名称包括 HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG 和 HKEY_DYN_DATA。

> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法打开一个注册表项，设置值，并在每次调用时关闭该密钥。 如果需要修改大量值， <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 方法可以提供更好的性能。 <xref:Microsoft.Win32.RegistryKey>类还提供了一些方法，使你可以将访问控制列表 (ACL) 添加到注册表项，以便在检索值之前测试值的数据类型以及删除键。

 如果指定的类型与指定的不 `value` 匹配 `valueKind` ，并且不能转换数据， <xref:System.ArgumentException> 则会引发。 例如，可以将存储 <xref:System.Int64?displayProperty=nameWithType> 为 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ，但前提是它的值小于的最大值 <xref:System.Int32?displayProperty=nameWithType> 。 不能将单个字符串值存储为 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType> 。

> [!NOTE]
>  如果为或传递装箱值 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> ，则将使用固定区域性完成转换。

> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me) 上，注册表不是 Unicode，并且并非所有 Unicode 字符对于所有代码页都有效。 对于当前代码页无效的 Unicode 字符被替换为最佳可用匹配项。 不会引发异常。



## Examples
 下面的代码示例将多个数据类型的值存储在一个示例键中，按其创建键，然后检索并显示这些值。 该示例演示了如何在 `defaultValue` 名称/值对不存在的情况下，存储和检索默认 (无名称) 名称/值对以及使用。

 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> 未以有效注册表根开头。

- 或 -

 <paramref name="keyName" /> 的长度超过了允许的最大长度（255 个字符）。

- 或 -

<paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> 是只读的，因此无法对其写入（例如，它是根级节点，或者未用写访问权限打开该项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有关默认用户配置的信息。 该字段读取 Windows 注册表基项 HKEY_USERS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此密钥包含计算机的每个用户的分支。 为本地计算机上的新用户提供默认配置，如果用户未更改首选项，则为默认的当前用户提供默认配置。 由于 Windows 98/ME 还支持注册表，因此，应用程序可以访问用户特定的信息，其方式与在 Windows 2000 中相同。 每个用户的信息存储在单独的文件中，该文件可以存储在本地或网络服务器上。 Windows 98/ME 可以将此文件复制到用户的当前系统，以便设置可以通过用户从一台计算机移动到另一台计算机。



## Examples
 下面的示例演示如何检索此项的子项，并将其名称打印到屏幕。 使用 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 方法可以创建感兴趣的特定子项的实例。 然后，可以使用中的其他操作 <xref:Microsoft.Win32.RegistryKey> 来操作该密钥。

 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
