<Type Name="CommunicationObject" FullName="System.ServiceModel.Channels.CommunicationObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="00a2e4c4267e88ee2abc0cb0d157a3e88fb757f9" /><Meta Name="ms.sourcegitcommit" Value="c982ad9e10a242d90f1e631b5981570f9e5d9f34" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/10/2020" /><Meta Name="ms.locfileid" Value="89925409" /></Metadata><TypeSignature Language="C#" Value="public abstract class CommunicationObject : System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CommunicationObject extends System.Object implements class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.CommunicationObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CommunicationObject&#xA;Implements ICommunicationObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class CommunicationObject abstract : System::ServiceModel::ICommunicationObject" />
  <TypeSignature Language="F#" Value="type CommunicationObject = class&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.7.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="4.6.0.0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="4.7.0.0" FrameworkAlternate="dotnet-plat-ext-3.1" />
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="5.0.0.0" FrameworkAlternate="dotnet-plat-ext-5.0" />
    <TypeForwarding From="System.ServiceModel" FromVersion="4.0.0.0" To="System.ServiceModel.Primitives" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.ICommunicationObject</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>为系统中所有面向通信的对象（包括通道、侦听器以及通道和侦听器工厂）公用的基本状态机提供通用的基实现。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject>类实现 <xref:System.ServiceModel.ICommunicationObject> WINDOWS COMMUNICATION FOUNDATION (WCF) 中的所有通信对象的接口。 此方法实现可处理参数验证，引发通知状态发生转换的事件，提供对其他处理和此状态转换进行关联的方法，并确保此状态更改得到协调。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CommunicationObject (object mutex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object mutex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (mutex As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CommunicationObject(System::Object ^ mutex);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.CommunicationObject : obj -&gt; System.ServiceModel.Channels.CommunicationObject" Usage="new System.ServiceModel.Channels.CommunicationObject mutex" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mutex" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mutex">在状态转换过程中保护类实例的相互排斥锁。</param>
        <summary>使用相互排斥锁初始化 <see cref="T:System.ServiceModel.Channels.CommunicationObject" /> 类的新实例可保护指定的状态转换。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Abort();" />
      <MemberSignature Language="F#" Value="abstract member Abort : unit -&gt; unit&#xA;override this.Abort : unit -&gt; unit" Usage="communicationObject.Abort " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Abort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使通信对象立即从其当前状态转换到正在关闭状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法指示在返回之前应忽略或意外终止任何未完成的工作。 <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> 方法可用于取消任何未处理的操作，包括对 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 的未处理的调用。  
  
 若要将 <xref:System.ServiceModel.Channels.CommunicationObject> 从除 <xref:System.ServiceModel.CommunicationState.Closed> 以外的任何状态正常转换为 <xref:System.ServiceModel.CommunicationState.Closed> 状态，请调用 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 或其异步版本之一 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginClose">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作以关闭通信对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginClose : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginClose : AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginClose (callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">接收异步关闭操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，它包含与异步关闭操作相关联的状态信息。</param>
        <summary>开始一个异步操作以关闭通信对象。</summary>
        <returns>引用异步关闭操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 在默认的时间间隔内从 <xref:System.ServiceModel.CommunicationState.Closed> 状态之外的任意状态正常转换到 <xref:System.ServiceModel.CommunicationState.Closed> 状态。 使用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 方法，可在返回之前完成所有未完成的工作。 例如，完成所有缓冲的消息的发送）。 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 状态，此方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginClose">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成关闭操作的时间。</param>
        <param name="callback">接收异步关闭操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，它包含与异步关闭操作相关联的状态信息。</param>
        <summary>开始一个异步操作以在指定超时内关闭通信对象。</summary>
        <returns>引用异步关闭操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 在指定时间间隔内从除 <xref:System.ServiceModel.CommunicationState.Closed> 状态之外的任意状态正常转换到 <xref:System.ServiceModel.CommunicationState.Closed> 状态。  使用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 方法，可在返回之前完成所有未完成的工作。 例如，完成所有缓冲的消息的发送）。 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 状态，此方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginOpen">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作以打开通信对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginOpen : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginOpen : AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginOpen (callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">接收异步打开操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，它包含与异步打开操作相关联的状态信息。</param>
        <summary>开始一个异步操作以打开通信对象。</summary>
        <returns>引用异步打开操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> 方法将调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 和 <xref:System.ServiceModel.CommunicationState.Created>。  
  
 在调用了同步 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 操作，从而引起通信对象转换为正在关闭状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginOpen">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.BeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.BeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成发送操作的时间。</param>
        <param name="callback">接收异步打开操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，它包含与异步打开操作相关联的状态信息。</param>
        <summary>开始一个异步操作以在指定时间间隔内打开通信对象。</summary>
        <returns>引用异步打开操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> 方法将调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 和 <xref:System.ServiceModel.CommunicationState.Created>。  
  
 在调用了同步 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 操作，从而引起通信对象转换为正在关闭状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使通信对象从其当前状态转换到关闭状态。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="communicationObject.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使通信对象从其当前状态转换到关闭状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 从除 <xref:System.ServiceModel.CommunicationState.Closed> 状态之外的任意状态正常转换到 <xref:System.ServiceModel.CommunicationState.Closed> 状态。 使用 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 方法，可在返回之前完成所有未完成的工作。 例如，完成所有缓冲消息的发送。  
  
 在调用 <xref:System.ServiceModel.Channels.CommunicationObject> 方法之后，<xref:System.ServiceModel.CommunicationState.Closing> 将进入并保持 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 状态，直到完成到 <xref:System.ServiceModel.CommunicationState.Closed> 状态的转换。 转换包括对 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> 的连续调用。  
  
 还有一个关闭方法的异步版本，可通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 来启动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Close(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Close : TimeSpan -&gt; unit&#xA;override this.Close : TimeSpan -&gt; unit" Usage="communicationObject.Close timeout" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Close(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成关闭操作的时间。</param>
        <summary>使通信对象在指定时间间隔内从当前状态转换到关闭状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 在指定时间间隔内从除 <xref:System.ServiceModel.CommunicationState.Closed> 状态之外的任意状态正常转换到 <xref:System.ServiceModel.CommunicationState.Closed> 状态。 使用 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 方法，可在返回之前完成所有未完成的工作。 例如，完成所有缓冲消息的发送。  
  
 在调用 <xref:System.ServiceModel.Channels.CommunicationObject> 方法之后，<xref:System.ServiceModel.CommunicationState.Closing> 将进入并保持 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 状态，直到完成到 <xref:System.ServiceModel.CommunicationState.Closed> 状态的转换。 转换包括对 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> 的连续调用。  
  
 还有一个关闭方法的异步版本，可通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 来启动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Closed As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当通信对象转换到已关闭状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Closed> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> 方法引发，该方法由 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A> 方法调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event EventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As EventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : EventHandler " Usage="member this.Closing : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Closing As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Closing</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当通信对象转换到正在关闭状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Closing> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> 方法引发，该方法由 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 方法调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected abstract TimeSpan DefaultCloseTimeout { get; }" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property DefaultCloseTimeout As TimeSpan" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout" />
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultCloseTimeout { get; }" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultCloseTimeout As TimeSpan" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取为完成关闭操作提供的默认时间间隔。</summary>
        <value>默认的 <see cref="T:System.TimeSpan" />，指定在超时前可用于完成关闭操作的时间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected abstract TimeSpan DefaultOpenTimeout { get; }" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property DefaultOpenTimeout As TimeSpan" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout" />
      <MemberSignature Language="C#" Value="protected internal abstract TimeSpan DefaultOpenTimeout { get; }" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property DefaultOpenTimeout As TimeSpan" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取为完成打开操作提供的默认时间间隔。</summary>
        <value>默认的 <see cref="T:System.TimeSpan" />，指定在超时前可用于完成打开操作的时间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndClose">
      <MemberSignature Language="C#" Value="public void EndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndClose : IAsyncResult -&gt; unit&#xA;override this.EndClose : IAsyncResult -&gt; unit" Usage="communicationObject.EndClose result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndClose(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" />，由对 <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" /> 方法的调用返回。</param>
        <summary>完成一个异步操作以关闭通信对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的同步版本由 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 方法提供。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndOpen">
      <MemberSignature Language="C#" Value="public void EndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.EndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndOpen : IAsyncResult -&gt; unit&#xA;override this.EndOpen : IAsyncResult -&gt; unit" Usage="communicationObject.EndOpen result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.EndOpen(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" />，由对 <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.BeginClose" /> 方法的调用返回。</param>
        <summary>完成一个异步操作以打开通信对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的同步版本由 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法提供。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fault">
      <MemberSignature Language="C#" Value="protected void Fault ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Fault() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Fault" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Fault ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Fault();" />
      <MemberSignature Language="F#" Value="member this.Fault : unit -&gt; unit" Usage="communicationObject.Fault " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使通信对象从其当前状态转换到出错状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> 方法引发，该方法是由 <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> 方法调用的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Faulted">
      <MemberSignature Language="C#" Value="public event EventHandler Faulted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Faulted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Faulted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Faulted As EventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Faulted;" />
      <MemberSignature Language="F#" Value="member this.Faulted : EventHandler " Usage="member this.Faulted : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Faulted As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Faulted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在通信对象转换到出错状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> 方法引发，该方法是由 <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> 方法调用的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommunicationObjectType">
      <MemberSignature Language="C#" Value="protected virtual Type GetCommunicationObjectType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetCommunicationObjectType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.GetCommunicationObjectType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCommunicationObjectType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetCommunicationObjectType();" />
      <MemberSignature Language="F#" Value="abstract member GetCommunicationObjectType : unit -&gt; Type&#xA;override this.GetCommunicationObjectType : unit -&gt; Type" Usage="communicationObject.GetCommunicationObjectType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取通信对象的类型。</summary>
        <returns>通信对象的类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="protected bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.ServiceModel.Channels.CommunicationObject.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示通信对象是否已被释放。</summary>
        <value>如果通信对象处于已关闭状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发生 <xref:System.ServiceModel.Channels.CommunicationObject.Closed> 事件时，对象被视为已释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected abstract void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnAbort();" />
      <MemberSignature Language="F#" Value="abstract member OnAbort : unit -&gt; unit" Usage="communicationObject.OnAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在调用了一个同步中止操作，从而引起通信对象转换为关闭状态的情况下，该方法插入对通信对象的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象尚未处于 <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A> 方法将调用 <xref:System.ServiceModel.CommunicationState.Closed>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.OnBeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成关闭操作的时间。</param>
        <param name="callback">接收关闭操作异步完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，它包含与异步关闭操作相关联的状态信息。</param>
        <summary>在调用了异步关闭操作，从而引起通信对象转换为正在关闭状态的情况下，该方法将插入处理。</summary>
        <returns>引用异步关闭操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A> 方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 在调用了同步 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 操作，从而引起通信对象转换为正在关闭状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%28System.TimeSpan%29> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="communicationObject.OnBeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成打开操作的时间。</param>
        <param name="callback">接收打开操作的异步完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个由应用程序指定的对象，包含与打开操作异步相关联的状态信息。</param>
        <summary>在调用了异步打开操作，从而引起通信对象转换为正在打开状态的情况下，该方法将插入处理。</summary>
        <returns>引用打开操作异步的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用了同步 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 操作，从而引起通信对象转换为正在打开状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected abstract void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnClose(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnClose : TimeSpan -&gt; unit" Usage="communicationObject.OnClose timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成关闭操作的时间。</param>
        <summary>在调用了一个同步关闭操作，从而引起通信对象转换为正在关闭状态的情况下，该方法插入对通信对象的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A> 方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 在调用了异步 <xref:System.ServiceModel.Channels.CommunicationObject.BeginClose%2A> 操作，从而引起通信对象转换为正在关闭状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginClose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">对处于 <see cref="Overload:System.ServiceModel.Channels.CommunicationObject.Close" /> 状态的对象调用了 <see cref="F:System.ServiceModel.CommunicationState.Faulted" />。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">关闭对象时发生通信错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed();" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : unit -&gt; unit&#xA;override this.OnClosed : unit -&gt; unit" Usage="communicationObject.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通信对象转换到正在关闭状态的过程中被调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> 方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 如果通信对象尚未处于 <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A> 方法将调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29> 和 <xref:System.ServiceModel.CommunicationState.Closed>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnClosing" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing();" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : unit -&gt; unit&#xA;override this.OnClosing : unit -&gt; unit" Usage="communicationObject.OnClosing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通信对象转换到正在关闭状态的过程中被调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A> 方法将调用 <xref:System.ServiceModel.CommunicationState.Opened>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected abstract void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndClose : IAsyncResult -&gt; unit" Usage="communicationObject.OnEndClose result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndClose(System.IAsyncResult)" /> 方法的调用返回。</param>
        <summary>在关闭通信对象时完成一个异步操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象尚未处于 <xref:System.ServiceModel.Channels.CommunicationObject.EndClose%28System.IAsyncResult%29> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnEndClose%28System.IAsyncResult%29> 方法将调用 <xref:System.ServiceModel.CommunicationState.Closed>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndOpen : IAsyncResult -&gt; unit" Usage="communicationObject.OnEndOpen result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.ServiceModel.Channels.CommunicationObject.OnEndOpen(System.IAsyncResult)" /> 方法的调用返回。</param>
        <summary>在打开通信对象时完成一个异步操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> 方法调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnEndOpen%2A>（以及 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>）。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnFaulted">
      <MemberSignature Language="C#" Value="protected virtual void OnFaulted ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFaulted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnFaulted" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFaulted ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFaulted();" />
      <MemberSignature Language="F#" Value="abstract member OnFaulted : unit -&gt; unit&#xA;override this.OnFaulted : unit -&gt; unit" Usage="communicationObject.OnFaulted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在调用了同步错误操作，从而引起通信对象转换为出错状态的情况下，该方法插入对通信对象的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A> 方法引发，该方法是由 <xref:System.ServiceModel.Channels.CommunicationObject.Fault%2A> 方法调用的。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected abstract void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnOpen(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnOpen : TimeSpan -&gt; unit" Usage="communicationObject.OnOpen timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成打开操作的时间。</param>
        <summary>在通信对象转换为打开状态（此过程必须在指定时间间隔内完成）后插入对通信对象的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象最初处于 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 状态，则 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%28System.TimeSpan%29> 方法将调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>（在调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> 之后，调用 <xref:System.ServiceModel.CommunicationState.Created> 之前）。  
  
 在调用了异步 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 操作，从而引起通信对象转换为正在打开状态的情况下，若要插入处理，请使用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected virtual void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpened();" />
      <MemberSignature Language="F#" Value="abstract member OnOpened : unit -&gt; unit&#xA;override this.OnOpened : unit -&gt; unit" Usage="communicationObject.OnOpened " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通信对象转换到已打开状态的过程中被调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将提供一种在被 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> 方法调用时添加处理的方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnOpening ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpening() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.OnOpening" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpening ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpening();" />
      <MemberSignature Language="F#" Value="abstract member OnOpening : unit -&gt; unit&#xA;override this.OnOpening : unit -&gt; unit" Usage="communicationObject.OnOpening " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在通信对象转换到正在打开状态的过程中被调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将提供一种在被 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> 方法调用时添加处理的方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使通信对象从已创建状态转换到已打开状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用时，<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 进入 <xref:System.ServiceModel.CommunicationState.Opening> 状态，并调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>、<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>。  <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> 方法通过将对象状态设置为 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 状态来完成 <xref:System.ServiceModel.CommunicationState.Opened> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open();" />
      <MemberSignature Language="F#" Value="abstract member Open : unit -&gt; unit&#xA;override this.Open : unit -&gt; unit" Usage="communicationObject.Open " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使通信对象从已创建状态转换到已打开状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例化 <xref:System.ServiceModel.Channels.CommunicationObject> 时，以 <xref:System.ServiceModel.CommunicationState.Created> 状态开始。 在处于 <xref:System.ServiceModel.CommunicationState.Created> 状态时，可以配置此对象（例如，可以设置属性或注册事件），但仍不能用此对象发送或接收消息。 调用时，<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 进入 <xref:System.ServiceModel.CommunicationState.Opening> 状态，并调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>、<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>。 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> 方法通过将对象状态设置为 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 状态来完成 <xref:System.ServiceModel.CommunicationState.Opened> 方法。  
  
 在  
  
 处于 <xref:System.ServiceModel.CommunicationState.Opened> 状态时，<xref:System.ServiceModel.Channels.CommunicationObject> 可用（例如，可以接收消息），但不能再对它进行配置。  
  
 还有一个打开方法的异步版本，该方法可通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 来启动并通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> 来完成。  
  
### <a name="credentials-capture-with-windows-authentication"></a>使用 Windows 身份验证捕获凭据  
 当使用 Windows 身份验证时，服务使用的凭据基于当前的上下文线程。 当调用 `Open` 方法时，会获取凭据。  
  
> [!NOTE]
>  对于异步调用，当调用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> 时，会获取凭据。 但无法保证实际凭据。 即，调用方凭据可能被转换为其他标识。 有关详细信息，请参阅 [Windows 客户端的消息安全性](/dotnet/framework/wcf/feature-details/message-security-with-a-windows-client)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
        <altmember cref="M:System.ServiceModel.Channels.CommunicationObject.BeginOpen(System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/wcf/feature-details/message-security-with-a-windows-client">Windows 客户端的消息安全</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Open(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.Open(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Open(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Open : TimeSpan -&gt; unit&#xA;override this.Open : TimeSpan -&gt; unit" Usage="communicationObject.Open timeout" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.ICommunicationObject.Open(System.TimeSpan)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，指定在超时前必须完成打开操作的时间。</param>
        <summary>使通信对象在指定时间间隔内从已创建状态转换到已打开状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例化 <xref:System.ServiceModel.Channels.CommunicationObject> 时，以 <xref:System.ServiceModel.CommunicationState.Created> 状态开始。 在处于 <xref:System.ServiceModel.CommunicationState.Created> 状态时，可以配置此对象（例如，可以设置属性或注册事件），但仍不能用此对象发送或接收消息。 调用时，<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 方法使 <xref:System.ServiceModel.Channels.CommunicationObject> 进入 <xref:System.ServiceModel.CommunicationState.Opening> 状态，并调用 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A>、<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A>。  <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A> 方法通过将对象状态设置为 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 状态来完成 <xref:System.ServiceModel.CommunicationState.Opened> 方法。  
  
 在  
  
 处于 <xref:System.ServiceModel.CommunicationState.Opened> 状态时，<xref:System.ServiceModel.Channels.CommunicationObject> 可用（例如，可以接收消息），但不能再对它进行配置。  
  
 还有一个打开方法的异步版本，该方法可通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> 来启动并通过调用 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> 来完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.TimeoutException">在操作完成之前超出了分配给该操作的默认时间间隔。</exception>
      </Docs>
    </Member>
    <Member MemberName="Opened">
      <MemberSignature Language="C#" Value="public event EventHandler Opened;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opened" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opened" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opened As EventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opened;" />
      <MemberSignature Language="F#" Value="member this.Opened : EventHandler " Usage="member this.Opened : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Opened As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opened</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当通信对象转换到已打开状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Opened> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> 方法引发，该方法由 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.EndOpen%2A> 方法调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opening">
      <MemberSignature Language="C#" Value="public event EventHandler Opening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Opening" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.CommunicationObject.Opening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opening As EventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Opening;" />
      <MemberSignature Language="F#" Value="member this.Opening : EventHandler " Usage="member this.Opening : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Opening As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ServiceModel.ICommunicationObject.Opening</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当通信对象转换到正在打开状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.CommunicationObject.Opening> 事件由 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A> 方法引发，该方法由 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnBeginOpen%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public System.ServiceModel.CommunicationState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.CommunicationState State" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.State" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property State As CommunicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::CommunicationState State { System::ServiceModel::CommunicationState get(); };" />
      <MemberSignature Language="F#" Value="member this.State : System.ServiceModel.CommunicationState" Usage="System.ServiceModel.Channels.CommunicationObject.State" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.ICommunicationObject.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.CommunicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示通信对象当前状态的值。</summary>
        <value><see cref="T:System.ServiceModel.CommunicationState" /> 枚举中的一个值，指示对象的当前状态。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThisLock">
      <MemberSignature Language="C#" Value="protected object ThisLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ThisLock" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CommunicationObject.ThisLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ThisLock As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ ThisLock { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ThisLock : obj" Usage="System.ServiceModel.Channels.CommunicationObject.ThisLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.7.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在状态转换过程中保护类实例的相互排斥锁。</summary>
        <value>在状态转换过程中保护类实例的相互排斥锁。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposed">
      <MemberSignature Language="C#" Value="protected internal void ThrowIfDisposed ();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ThrowIfDisposed() cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ThrowIfDisposed ()" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ThrowIfDisposed();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposed : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposed " />
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposed ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposed() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposed ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposed();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果通信对象已释放，则引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果通信对象处于 <xref:System.ServiceModel.CommunicationState.Created>、<xref:System.ServiceModel.CommunicationState.Opening> 或 <xref:System.ServiceModel.CommunicationState.Opened> 状态，则不引发异常。 如果对某通信对象调用 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A>，则立即释放该通信对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrImmutable">
      <MemberSignature Language="C#" Value="protected internal void ThrowIfDisposedOrImmutable ();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ThrowIfDisposedOrImmutable() cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ThrowIfDisposedOrImmutable ()" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ThrowIfDisposedOrImmutable();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposedOrImmutable : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposedOrImmutable " />
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrImmutable ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrImmutable() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrImmutable ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrImmutable();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果通信对象的 <see cref="P:System.ServiceModel.Channels.CommunicationObject.State" /> 属性未设置为 <see cref="F:System.ServiceModel.CommunicationState.Created" /> 状态，则引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于对对象调用 <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> 之后对象即不可变，所以 <xref:System.ServiceModel.CommunicationState.Created> 状态是唯一一个既可变又不被释放的状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 状态。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfDisposedOrNotOpen">
      <MemberSignature Language="C#" Value="protected internal void ThrowIfDisposedOrNotOpen ();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ThrowIfDisposedOrNotOpen() cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ThrowIfDisposedOrNotOpen ()" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ThrowIfDisposedOrNotOpen();" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ThrowIfDisposedOrNotOpen : unit -&gt; unit" Usage="communicationObject.ThrowIfDisposedOrNotOpen " />
      <MemberSignature Language="C#" Value="protected void ThrowIfDisposedOrNotOpen ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfDisposedOrNotOpen() cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfDisposedOrNotOpen ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfDisposedOrNotOpen();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Opened" /> 状态，则引发异常。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">通信对象未处于 <see cref="F:System.ServiceModel.CommunicationState.Created" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Opening" /> 状态，因此无法使用。</exception>
        <exception cref="T:System.ObjectDisposedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Closing" /> 或 <see cref="F:System.ServiceModel.CommunicationState.Closed" /> 状态，因此无法修改。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">通信对象处于 <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> 状态，因此无法修改。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
