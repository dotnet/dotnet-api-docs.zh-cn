<Type Name="MethodInfo" FullName="System.Reflection.MethodInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b9b018bbe6d2ddfe34176a9930d3834047fc9ee6" /><Meta Name="ms.sourcegitcommit" Value="f435d67b9edfed0109ec78c87b1cbec0b351dc1f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="09/24/2019" /><Meta Name="ms.locfileid" Value="71215927" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodInfo extends System.Reflection.MethodBase implements class System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodInfo&#xA;Inherits MethodBase&#xA;Implements _MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodInfo abstract : System::Reflection::MethodBase, System::Runtime::InteropServices::_MethodInfo" />
  <TypeSignature Language="F#" Value="type MethodInfo = class&#xA;    inherit MethodBase&#xA;    interface _MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="04e63-101">发现方法的属性并提供对方法元数据的访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-101">Discovers the attributes of a method and provides access to method metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-102"><xref:System.Reflection.MethodInfo>类表示类型的方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-102">The <xref:System.Reflection.MethodInfo> class represents a method of a type.</span></span> <span data-ttu-id="04e63-103">您可以使用<xref:System.Reflection.MethodInfo>对象获取有关对象所表示的方法的信息，以及调用方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-103">You can use a <xref:System.Reflection.MethodInfo> object to obtain information about the method that the object represents and to invoke the method.</span></span> <span data-ttu-id="04e63-104">例如:</span><span class="sxs-lookup"><span data-stu-id="04e63-104">For example:</span></span>  
  
-   <span data-ttu-id="04e63-105">可以通过检索<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>、 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>、 <xref:System.Reflection.MethodBase.IsPrivate%2A>和<xref:System.Reflection.MethodBase.IsPublic%2A>属性的值来确定该方法的可见性。</span><span class="sxs-lookup"><span data-stu-id="04e63-105">You can determine the method's visibility by retrieving the values of the <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, and <xref:System.Reflection.MethodBase.IsPublic%2A> properties.</span></span>  
  
-   <span data-ttu-id="04e63-106">可以通过检索<xref:System.Reflection.MethodBase.Attributes%2A>属性的值或<xref:System.Reflection.Assembly.GetCustomAttributes%2A>调用方法来发现应用于方法的特性。</span><span class="sxs-lookup"><span data-stu-id="04e63-106">You can discover what attributes are applied to the method by retrieving the value of the <xref:System.Reflection.MethodBase.Attributes%2A> property or calling the <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method.</span></span>  
  
-   <span data-ttu-id="04e63-107">通过检索<xref:System.Reflection.MethodBase.IsGenericMethod%2A>和<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>属性的值，可以确定方法是泛型方法、开放式构造泛型方法还是封闭式构造泛型方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-107">You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> properties.</span></span>  
  
-   <span data-ttu-id="04e63-108">可以从<xref:System.Reflection.MethodBase.GetParameters%2A>方法<xref:System.Reflection.MethodInfo.ReturnParameter%2A>和、 <xref:System.Reflection.MethodInfo.ReturnType%2A>和<xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A>属性获取有关方法的参数和返回类型的信息。</span><span class="sxs-lookup"><span data-stu-id="04e63-108">You can get information about the method's parameters and return type from the <xref:System.Reflection.MethodBase.GetParameters%2A> method and the <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, and <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> properties.</span></span>  
  
-   <span data-ttu-id="04e63-109">可以通过调用<xref:System.Reflection.MethodBase.Invoke%2A>方法对类实例执行方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-109">You can execute a method on a class instance by calling the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span>  
  
-   <span data-ttu-id="04e63-110"><xref:System.Reflection.MethodInfo> 通过<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>调用方法，可以实例化表示泛型方法定义的构造泛型方法的对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-110">You can instantiate a <xref:System.Reflection.MethodInfo> object that represents a constructed generic method from one that represents a generic method definition by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 <span data-ttu-id="04e63-111"><xref:System.Reflection.MethodInfo>可以通过<xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>调用或方法<xref:System.Type.GetMethod%2A?displayProperty=nameWithType>来实例化实例，也可以通过调用表示泛型方法定义的对象的方法来实例化实例。 <xref:System.Type.GetMethods%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="04e63-111">You can instantiate a <xref:System.Reflection.MethodInfo> instances by calling the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> or <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> method, or by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
 <span data-ttu-id="04e63-112">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodBase.IsGenericMethod%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-112">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="04e63-113">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-113">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="04e63-114">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="04e63-114">for full trust for inheritors.</span></span> <span data-ttu-id="04e63-115">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="04e63-115">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="04e63-116">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="04e63-116">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="04e63-117"><see cref="T:System.Reflection.MethodInfo" />当从继承时，必须重写<see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />、 <see cref="P:System.Reflection.MethodInfo.ReturnType" /> <see cref="M:System.Reflection.MethodBase.GetParameters" /> <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /> <see cref="P:System.Reflection.MethodBase.MethodHandle" /> 、、、<see cref="P:System.Reflection.MethodBase.Attributes" />、 、、<see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />、、、 <see cref="P:System.Reflection.MemberInfo.Name" /> <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /> <see cref="P:System.Reflection.MemberInfo.MemberType" /> <see cref="P:System.Reflection.MemberInfo.DeclaringType" />、 、<see cref="P:System.Reflection.MemberInfo.ReflectedType" /> 、和<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="04e63-117">When you inherit from <see cref="T:System.Reflection.MethodInfo" />, you must override <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
    <altmember cref="Overload:System.Type.GetMethods" />
    <altmember cref="Overload:System.Type.GetMethod" />
    <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodInfo ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodInfo();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-118">初始化 <see cref="T:System.Reflection.MethodInfo" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="04e63-118">Initializes a new instance of the <see cref="T:System.Reflection.MethodInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-119">获取一个值，该值指示泛型方法是否包含未分配的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-119">Gets a value that indicates whether a generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="04e63-120">如果当前 <see cref="T:System.Reflection.MethodInfo" /> 包含未分配的泛型类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-120"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodInfo" /> contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="04e63-121">若要调用泛型方法，在方法本身的类型参数中或在任何封闭类型中都不能有泛型类型定义或开放式构造类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-121">To invoke a generic method, there must be no generic type definitions or open constructed types in the type arguments of the method itself, or in any enclosing types.</span></span> <span data-ttu-id="04e63-122">进行递归确定可能很困难。</span><span class="sxs-lookup"><span data-stu-id="04e63-122">Making this recursive determination can be difficult.</span></span> <span data-ttu-id="04e63-123">为方便起见，若要减少出现错误`ContainsGenericParameters`的可能性，属性提供了一种标准方法来区分已关闭的构造方法（可以调用）和开放构造方法（不能）。</span><span class="sxs-lookup"><span data-stu-id="04e63-123">For convenience, and to reduce the chance of error, the `ContainsGenericParameters` property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="04e63-124">如果属性返回`true`，则不能调用该方法。 `ContainsGenericParameters`</span><span class="sxs-lookup"><span data-stu-id="04e63-124">If the `ContainsGenericParameters` property returns `true`, the method cannot be invoked.</span></span>

<span data-ttu-id="04e63-125">`ContainsGenericParameters`属性以递归方式搜索类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-125">The `ContainsGenericParameters` property searches recursively for type parameters.</span></span> <span data-ttu-id="04e63-126">例如，它为开放`true`类型`A<T>`中的任何方法返回，即使方法本身不是泛型也是如此。</span><span class="sxs-lookup"><span data-stu-id="04e63-126">For example, it returns `true` for any method in an open type `A<T>`, even though the method itself is not generic.</span></span>
<span data-ttu-id="04e63-127">将此与<xref:System.Reflection.MethodInfo.IsGenericMethod>属性的行为进行对比，这将`false`为此类方法返回。</span><span class="sxs-lookup"><span data-stu-id="04e63-127">Contrast this with the behavior of the <xref:System.Reflection.MethodInfo.IsGenericMethod> property, which returns `false` for such a method.</span></span>

<span data-ttu-id="04e63-128">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodInfo.IsGenericMethod>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-128">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span>
<span data-ttu-id="04e63-129">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-129">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e63-130">从此方法创建委托。</span><span class="sxs-lookup"><span data-stu-id="04e63-130">Creates a delegate from this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type -&gt; Delegate&#xA;override this.CreateDelegate : Type -&gt; Delegate" Usage="methodInfo.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="04e63-131">要创建的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-131">The type of the delegate to create.</span></span></param>
        <summary><span data-ttu-id="04e63-132">从此方法创建指定类型的委托。</span><span class="sxs-lookup"><span data-stu-id="04e63-132">Creates a delegate of the specified type from this method.</span></span></summary>
        <returns><span data-ttu-id="04e63-133">此方法的委托。</span><span class="sxs-lookup"><span data-stu-id="04e63-133">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type * obj -&gt; Delegate&#xA;override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="methodInfo.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="04e63-134">要创建的委托的类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-134">The type of the delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="04e63-135">代理以该对象为目标。</span><span class="sxs-lookup"><span data-stu-id="04e63-135">The object targeted by the delegate.</span></span></param>
        <summary><span data-ttu-id="04e63-136">从此方法创建具有指定目标的指定类型的委托。</span><span class="sxs-lookup"><span data-stu-id="04e63-136">Creates a delegate of the specified type with the specified target from this method.</span></span></summary>
        <returns><span data-ttu-id="04e63-137">此方法的委托。</span><span class="sxs-lookup"><span data-stu-id="04e63-137">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="04e63-138">与此实例进行比较的对象，或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-138">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="04e63-139">返回一个值，该值指示此实例是否与指定的对象相等。</span><span class="sxs-lookup"><span data-stu-id="04e63-139">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="04e63-140">如果 <see langword="true" /> 等于此实例的类型和值，则为 <paramref name="obj" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-140"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetBaseDefinition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-141">当在派生类中被重写时，为直接或间接的基类（用该实例表示的方法首先在此类中声明）上的方法返回 <see cref="T:System.Reflection.MethodInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-141">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</span></span></summary>
        <returns><span data-ttu-id="04e63-142">表示此方法第一个实现的 <see cref="T:System.Reflection.MethodInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-142">A <see cref="T:System.Reflection.MethodInfo" /> object for the first implementation of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-143"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法返回类层次结构中指定方法的第一个定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-143">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the first definition of the specified method in the class hierarchy.</span></span> <span data-ttu-id="04e63-144">您可以通过在返回<xref:System.Reflection.MemberInfo.DeclaringType%2A> <xref:System.Reflection.MethodInfo>的对象上检索属性的值来确定该方法的第一个定义的类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-144">You can determine the type on which the first definition of the method is found by retrieving the value of the <xref:System.Reflection.MemberInfo.DeclaringType%2A> property on the returned <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="04e63-145">方法<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>的行为如下所示：</span><span class="sxs-lookup"><span data-stu-id="04e63-145">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method behaves as follows:</span></span>  
  
-   <span data-ttu-id="04e63-146">如果当前<xref:System.Reflection.MethodInfo>对象表示接口实现，则<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法返回当前<xref:System.Reflection.MethodInfo>对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-146">If the current <xref:System.Reflection.MethodInfo> object represents an interface implementation, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="04e63-147">如果当前<xref:System.Reflection.MethodInfo>对象表示重写基类中的虚拟定义的方法，则该方法将<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>返回<xref:System.Reflection.MethodInfo>表示虚拟定义的对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-147">If the current <xref:System.Reflection.MethodInfo> object represents a method that overrides a virtual definition in a base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the virtual definition.</span></span>  
  
-   <span data-ttu-id="04e63-148">如果<xref:System.Reflection.MethodInfo>当前对象表示使用中`newslot` `Shadows` C#的`new`关键字指定的方法或 Visual Basic 中的关键字（如中所述，如[通用类型系统](~/docs/standard/base-types/common-type-system.md)中所述），则<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法返回当前<xref:System.Reflection.MethodInfo>对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-148">If the current <xref:System.Reflection.MethodInfo> object represents a method that is specified with the `new` keyword in C# or the `Shadows` keyword in Visual Basic (as in `newslot`, as described in [Common Type System](~/docs/standard/base-types/common-type-system.md)), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="04e63-149">如果当前<xref:System.Reflection.MethodInfo>的对象表示一个继承的方法（即当前方法不提供其自己的实现），则该<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法将返回一个<xref:System.Reflection.MethodInfo>对象，该对象表示类层次结构中的最小方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-149">If the current <xref:System.Reflection.MethodInfo> object represents an inherited method (that is, the current method does not provide its own implementation), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the lowest method in the class hierarchy.</span></span> <span data-ttu-id="04e63-150">例如，如果`Base.ToString`重写`Object.ToString` `Derived.ToString` `Base.ToString` <xref:System.Reflection.MethodInfo> 和重`Derived.ToString`写，则对表示的对象调用<xref:System.Reflection.MethodInfo> 方法将返回一个对象，该对象表示<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>`Object.ToString`.</span><span class="sxs-lookup"><span data-stu-id="04e63-150">For example, if `Base.ToString` overrides `Object.ToString`, and `Derived.ToString` overrides `Base.ToString`, calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method on a <xref:System.Reflection.MethodInfo> object that represents `Derived.ToString` returns a <xref:System.Reflection.MethodInfo> object that represents `Object.ToString`.</span></span>  
  
-   <span data-ttu-id="04e63-151">如果当前<xref:System.Reflection.MethodInfo>对象表示的方法不在任何基类中，则该<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法返回当前<xref:System.Reflection.MethodInfo>对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-151">If the current <xref:System.Reflection.MethodInfo> object represents a method that is not present in any base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="04e63-152">您可以通过调用<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法来确定当前方法是否重写基类中的方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-152">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span> <span data-ttu-id="04e63-153">下面的示例实现实现`IsOverride`此功能的方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-153">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
 <span data-ttu-id="04e63-154">调用`GetBaseDefinition`方法：</span><span class="sxs-lookup"><span data-stu-id="04e63-154">To call the `GetBaseDefinition` method:</span></span>  
  
1.  <span data-ttu-id="04e63-155">获取一个<xref:System.Type>对象，该对象表示包含属性的类型（类或结构）。</span><span class="sxs-lookup"><span data-stu-id="04e63-155">Get a <xref:System.Type> object that represents the type (the class or structure) that contains the property.</span></span> <span data-ttu-id="04e63-156">如果使用的是对象（类型的实例），可以调用其<xref:System.Object.GetType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-156">If you are working with an object (an instance of a type), you can call its <xref:System.Object.GetType%2A> method.</span></span> <span data-ttu-id="04e63-157">否则，可以使用C#运算符或 Visual Basic [GetType](~/docs/visual-basic/language-reference/operators/gettype-operator.md)运算符，如示例中所示。</span><span class="sxs-lookup"><span data-stu-id="04e63-157">Otherwise, you can use the C#  operator or the Visual Basic [GetType](~/docs/visual-basic/language-reference/operators/gettype-operator.md) operator, as the example illustrates.</span></span>  
  
2.  <span data-ttu-id="04e63-158">获取一个<xref:System.Reflection.MethodInfo>对象，该对象表示你感兴趣的方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-158">Get a <xref:System.Reflection.MethodInfo> object that represents the method in which you're interested.</span></span> <span data-ttu-id="04e63-159">为此，可以从<xref:System.Type.GetMethods%2A?displayProperty=nameWithType>方法获取所有方法的数组，然后循环访问数组中的元素，也可以通过调用<xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType>方法直接<xref:System.Reflection.MethodInfo>检索表示方法的对象，并指定方法名。</span><span class="sxs-lookup"><span data-stu-id="04e63-159">You can do this by getting an array of all methods from the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> method and then iterating the elements in the array, or you can retrieve the <xref:System.Reflection.MethodInfo> object that represents the method directly by calling the <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> method and specifying the method name.</span></span>  
  
3.  <span data-ttu-id="04e63-160">调用方法可获取表示基方法定义的<xref:System.Reflection.MethodInfo>对象的值。 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A></span><span class="sxs-lookup"><span data-stu-id="04e63-160">Call the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method to get the value of the <xref:System.Reflection.MethodInfo> object that represents the base method definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e63-161">下面的示例演示<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法的行为。</span><span class="sxs-lookup"><span data-stu-id="04e63-161">The following example demonstrates the behavior of the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/getbasedefinition1.cs#1)]
 [!code-vb[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/getbasedefinition1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/53c57c96-83e1-4ee3-9543-9ac832671a89"><span data-ttu-id="04e63-162">常规类型系统</span><span class="sxs-lookup"><span data-stu-id="04e63-162">Common Type System</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodInfo.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-163">返回 <see cref="T:System.Type" /> 对象的数组，这些对象表示泛型方法的类型实参或泛型方法定义的类型形参。</span><span class="sxs-lookup"><span data-stu-id="04e63-163">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="04e63-164"><see cref="T:System.Type" /> 对象的数组，这些对象表示泛型方法的类型变量或泛型方法定义的类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-164">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="04e63-165">如果当前方法不是泛型方法，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="04e63-165">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-166">返回数组的元素按它们出现在泛型方法的类型参数列表中的顺序排列。</span><span class="sxs-lookup"><span data-stu-id="04e63-166">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="04e63-167">如果当前方法是封闭式构造方法（即， <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>属性返回`false`），则<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法返回的数组包含已分配给泛型方法的泛型类型参数的类型。定义.</span><span class="sxs-lookup"><span data-stu-id="04e63-167">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="04e63-168">如果当前方法是泛型方法定义，则数组包含类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-168">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="04e63-169">如果当前方法是开放构造方法（即， <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>属性返回`true`），则表示已将特定类型分配给某些类型参数，而封闭泛型类型的类型参数已分配给其他类型参数，数组同时包含类型和类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-169">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="04e63-170"><xref:System.Type.IsGenericParameter%2A>使用属性将它们区分开来。</span><span class="sxs-lookup"><span data-stu-id="04e63-170">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="04e63-171">有关此方案的演示，请参阅<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>属性的代码示例。</span><span class="sxs-lookup"><span data-stu-id="04e63-171">For a demonstration of this scenario, see the code example for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="04e63-172">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodBase.IsGenericMethod%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-172">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="04e63-173">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-173">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
## Examples  
 <span data-ttu-id="04e63-174">下面的代码示例演示如何获取泛型方法的类型实参并显示它们。</span><span class="sxs-lookup"><span data-stu-id="04e63-174">The following code example shows how to get the type arguments of a generic method and display them.</span></span>  
  
 <span data-ttu-id="04e63-175">此示例摘自为<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法提供的一个更大的示例。</span><span class="sxs-lookup"><span data-stu-id="04e63-175">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#8](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#8)]
 [!code-csharp[MethodInfo.Generics#8](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#8)]
 [!code-vb[MethodInfo.Generics#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e63-176">不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-176">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="04e63-177">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="04e63-177">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="04e63-178">泛型介绍（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="04e63-178">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-179">返回一个 <see cref="T:System.Reflection.MethodInfo" /> 对象，该对象表示可从其构造当前方法的泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-179">Returns a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition from which the current method can be constructed.</span></span></summary>
        <returns><span data-ttu-id="04e63-180">一个 <see cref="T:System.Reflection.MethodInfo" /> 对象，表示可从其构造当前方法的泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-180">A <see cref="T:System.Reflection.MethodInfo" /> object representing a generic method definition from which the current method can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-181">泛型方法定义是可以从中构造方法的模板。</span><span class="sxs-lookup"><span data-stu-id="04e63-181">A generic method definition is a template from which methods can be constructed.</span></span> <span data-ttu-id="04e63-182">例如，从泛型方法定义`T M<T>(T t)` （用C#语法表示），在 Visual Basic）中，可以构造和调用方法`int M<int>(int t)` （`Function M(Of Integer)(ByVal tVal As Integer) As Integer`在 Visual Basic 中）。 `Function M(Of T)(ByVal tVal As T) As T`</span><span class="sxs-lookup"><span data-stu-id="04e63-182">For example, from the generic method definition `T M<T>(T t)` (expressed in C# syntax; `Function M(Of T)(ByVal tVal As T) As T` in Visual Basic) you can construct and invoke the method `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` in Visual Basic).</span></span> <span data-ttu-id="04e63-183">给定表示此构造方法的<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> 对象，方法返回泛型方法定义。<xref:System.Reflection.MethodInfo></span><span class="sxs-lookup"><span data-stu-id="04e63-183">Given a <xref:System.Reflection.MethodInfo> object representing this constructed method, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the generic method definition.</span></span>  
  
 <span data-ttu-id="04e63-184">如果两个构造方法是从同一个泛型方法定义创建的<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> ，则该方法<xref:System.Reflection.MethodInfo>将为这两个方法返回相同的对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-184">If two constructed methods are created from the same generic method definition, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the same <xref:System.Reflection.MethodInfo> object for both methods.</span></span>  
  
 <span data-ttu-id="04e63-185">如果在已<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A>表示泛型<xref:System.Reflection.MethodInfo>方法定义的上调用，则它将返回当前<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="04e63-185">If you call <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> on a <xref:System.Reflection.MethodInfo> that already represents a generic method definition, it returns the current <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="04e63-186">如果泛型方法定义包含声明类型的泛型参数，则会有特定于每个构造类型的泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-186">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="04e63-187">例如，请考虑以下C#内容，Visual Basic 和C++代码：</span><span class="sxs-lookup"><span data-stu-id="04e63-187">For example, consider the following C#, Visual Basic, and C++ code:</span></span>  
  
```  
class B<U,V> {}  
class C<T> { public B<T,S> M<S>() {...}}  
  
Class B(Of U, V)  
End Class  
Class C(Of T)  
    Public Function M(Of S)() As B(Of T, S)  
        ...  
    End Function  
End Class   
  
generic <typename U, typename V> ref class B {};  
generic <typename T> ref class C  
{  
public:  
    generic <typename S> B<T,S>^ M() {...};  
};  
```  
  
 <span data-ttu-id="04e63-188">在构造类型`C<int>` （`C(Of Integer)`在 Visual Basic）中，泛型方法`M`返回`B<int, S>`。</span><span class="sxs-lookup"><span data-stu-id="04e63-188">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method `M` returns `B<int, S>`.</span></span> <span data-ttu-id="04e63-189">在开放类型`C<T>`中， `M`返回`B<T, S>`。</span><span class="sxs-lookup"><span data-stu-id="04e63-189">In the open type `C<T>`, `M` returns `B<T, S>`.</span></span> <span data-ttu-id="04e63-190">在这两种情况<xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A>下， `true`属性将<xref:System.Reflection.MethodInfo>返回表示`M`的， <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>因此可以在两个<xref:System.Reflection.MethodInfo>对象上调用。</span><span class="sxs-lookup"><span data-stu-id="04e63-190">In both cases, the <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `true` for the <xref:System.Reflection.MethodInfo> that represents `M`, so <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> can be called on both <xref:System.Reflection.MethodInfo> objects.</span></span> <span data-ttu-id="04e63-191">对于构造类型，调用<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>的结果<xref:System.Reflection.MethodInfo>是可调用的。</span><span class="sxs-lookup"><span data-stu-id="04e63-191">In the case of the constructed type, the result of calling <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> is a <xref:System.Reflection.MethodInfo> that can be invoked.</span></span> <span data-ttu-id="04e63-192">对于开放类型， <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>无法调用返回的。</span><span class="sxs-lookup"><span data-stu-id="04e63-192">In the case of the open type, the <xref:System.Reflection.MethodInfo> returned by <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> cannot be invoked.</span></span>  
  
 <span data-ttu-id="04e63-193">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodBase.IsGenericMethod%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-193">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="04e63-194">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-194">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e63-195">下面的代码示例演示一个具有泛型方法的类和获取<xref:System.Reflection.MethodInfo>方法的所需的代码，将方法绑定到类型参数，并从绑定方法获取原始泛型类型定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-195">The following code example shows a class with a generic method and the code required to obtain a <xref:System.Reflection.MethodInfo> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</span></span>  
  
 <span data-ttu-id="04e63-196">此示例摘自为<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法提供的一个更大的示例。</span><span class="sxs-lookup"><span data-stu-id="04e63-196">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#2](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#2)]
 [!code-csharp[MethodInfo.Generics#2](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#2)]
 [!code-vb[MethodInfo.Generics#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#2)]  
[!code-cpp[MethodInfo.Generics#3](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#3)]
[!code-csharp[MethodInfo.Generics#3](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#3)]
[!code-vb[MethodInfo.Generics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#3)]  
[!code-cpp[MethodInfo.Generics#4](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#4)]
[!code-csharp[MethodInfo.Generics#4](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#4)]
[!code-vb[MethodInfo.Generics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e63-197">当前方法不是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-197">The current method is not a generic method.</span></span> <span data-ttu-id="04e63-198">也就是说，<see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-198">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e63-199">不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-199">This method is not supported.</span></span></exception>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="04e63-200">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="04e63-200">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="04e63-201">泛型介绍（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="04e63-201">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-202">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="04e63-202">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="04e63-203">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="04e63-203">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * obj[] -&gt; obj" Usage="methodInfo.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="parameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-204">获取一个值，该值指示当前方法是否为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-204">Gets a value indicating whether the current method is a generic method.</span></span></summary>
        <value><span data-ttu-id="04e63-205">如果当前方法是泛型方法，则为 true;否则为 false。</span><span class="sxs-lookup"><span data-stu-id="04e63-205">true if the current method is a generic method; otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-206">获取一个值，该值指示当前 <see cref="T:System.Reflection.MethodInfo" /> 是否表示泛型方法的定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-206">Gets a value indicating whether the current <see cref="T:System.Reflection.MethodInfo" /> represents the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="04e63-207">如果 <see cref="T:System.Reflection.MethodInfo" /> 对象表示泛型方法的定义，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-207"><see langword="true" /> if the <see cref="T:System.Reflection.MethodInfo" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="04e63-208">如果当前<xref:System.Reflection.MethodInfo>表示泛型方法定义，则：</span><span class="sxs-lookup"><span data-stu-id="04e63-208">If the current <xref:System.Reflection.MethodInfo> represents a generic method definition, then:</span></span>

  - <span data-ttu-id="04e63-209">`IsGenericMethodDefinition` 返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="04e63-209">`IsGenericMethodDefinition` returns `true`.</span></span>

  - <span data-ttu-id="04e63-210">对于该<xref:System.Type> <xref:System.Reflection.MethodInfo.GetGenericArguments>方法返回的数组中的每个对象：</span><span class="sxs-lookup"><span data-stu-id="04e63-210">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments> method:</span></span>

      - <span data-ttu-id="04e63-211"><xref:System.Type.IsGenericParameter?displayProperty=nameWithType> 属性返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="04e63-211">The <xref:System.Type.IsGenericParameter?displayProperty=nameWithType> property returns `true`.</span></span>

      - <span data-ttu-id="04e63-212"><xref:System.Type.DeclaringMethod?displayProperty=nameWithType>返回当前<xref:System.Reflection.MethodInfo>的。</span><span class="sxs-lookup"><span data-stu-id="04e63-212">The <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> returns the current <xref:System.Reflection.MethodInfo>.</span></span>

      - <span data-ttu-id="04e63-213">属性与<xref:System.Type>对象在数组中的位置相同。 <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="04e63-213">The <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>

<span data-ttu-id="04e63-214">`IsGenericMethodDefinition`使用属性可确定是否已将类型参数分配给泛型方法的类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-214">Use the `IsGenericMethodDefinition` property to determine whether type arguments have been assigned to the type parameters of a generic method.</span></span> <span data-ttu-id="04e63-215">如果已分配类型参数，即使某些`IsGenericMethodDefinition`类型参数是表示封闭类型的类型参数的对象<xref:System.Type> ，属性也会返回 false。</span><span class="sxs-lookup"><span data-stu-id="04e63-215">If type arguments have been assigned, the `IsGenericMethodDefinition` property returns false even if some of the type arguments are <xref:System.Type> objects that represent type parameters of enclosing types.</span></span> <span data-ttu-id="04e63-216">例如，请考虑以下 C\#、Visual Basic 和C++代码：</span><span class="sxs-lookup"><span data-stu-id="04e63-216">For example, consider the following C\#, Visual Basic, and C++ code:</span></span>

    ```cs
    class C
    {
        T N<T,U>(T t, U u) {...}
        public V M<V>(V v)
        {
            return N<V,int>(v, 42);
        }
    }
    ```

    ```vb
    Class C
        Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T
            ...
        End Function
        Public Function M(Of V)(ByVal va As V ) As V
            Return N(Of V, Integer)(va, 42)
        End Function
    End Class
    ```

    ```cpp
    ref class C
    {
    private:
        generic <typename T, typename U> T N(T t, U u) {...}
    public:
        generic <typename V> V M(V v)
        {
            return N<V, int>(v, 42);
        }
    };
    ```

<span data-ttu-id="04e63-217">M 的方法体包含对方法 N 的调用，该方法指定 M 的类型参数和类型<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="04e63-217">The method body of M contains a call to method N, specifying the type parameter of M and the type <xref:System.Int32>.</span></span> <span data-ttu-id="04e63-218">对于方法`N<V,int>`，属性返回 false。 `IsGenericMethodDefinition`</span><span class="sxs-lookup"><span data-stu-id="04e63-218">The `IsGenericMethodDefinition` property returns false for method `N<V,int>`.</span></span>

> [!NOTE]
> <span data-ttu-id="04e63-219">尽管在通过 c 类`N<V,int>`反射时未遇到开放构造方法，但必须使用<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>生成该方法才能将 C 作为动态类发出。</span><span class="sxs-lookup"><span data-stu-id="04e63-219">Although the open constructed method `N<V,int>` is not encountered when reflecting over class C, it must be generated using <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> in order to emit C as a dynamic class.</span></span>


<span data-ttu-id="04e63-220">如果泛型方法定义包含声明类型的泛型参数，则会有特定于每个构造类型的泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-220">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="04e63-221">例如，请考虑以下 C\#和 Visual Basic 代码：</span><span class="sxs-lookup"><span data-stu-id="04e63-221">For example, consider the following C\# and Visual Basic code:</span></span>

    ```csharp
    class B<U,V> {}
    class C<T> { public B<T,S> M<S>() {...}}
    ```

    ```vb
    Class B(Of U, V)
    End Class
    Class C(Of T)
        Public Function M(Of S)() As B(Of T, S)
            ...
        End Function
    End Class
    ```

    ```cpp
    generic <typename U, typename V> ref class B {};
    generic <typename T> ref class C
    {
    public:
        generic <typename S> B<T,S>^ M() {...};
    };
    ```

<span data-ttu-id="04e63-222">在构造类型`C<int>` （`C(Of Integer)`在 Visual Basic 中），泛型方法 M 返回`B<int, S>`。</span><span class="sxs-lookup"><span data-stu-id="04e63-222">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method M returns `B<int, S>`.</span></span> <span data-ttu-id="04e63-223">在 open 类型`C<T>`中，M 返回`B<T, S>`。</span><span class="sxs-lookup"><span data-stu-id="04e63-223">In the open type `C<T>`, M returns `B<T, S>`.</span></span> <span data-ttu-id="04e63-224">在这两种情况`IsGenericMethodDefinition`下， `true`属性将<xref:System.Reflection.MethodInfo>返回表示 M 的。</span><span class="sxs-lookup"><span data-stu-id="04e63-224">In both cases, the `IsGenericMethodDefinition` property returns `true` for the <xref:System.Reflection.MethodInfo> that represents M.</span></span>

<span data-ttu-id="04e63-225">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodInfo.IsGenericMethod>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-225">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="04e63-226">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-226">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="04e63-227">下面的代码示例使用`IsGenericMethodDefinition`属性来显示一条消息，指示<xref:System.Reflection.MethodInfo>是否表示泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-227">The following code example uses the `IsGenericMethodDefinition` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> represents a generic method definition.</span></span>

<span data-ttu-id="04e63-228">此示例摘自为<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法提供的一个更大的示例。</span><span class="sxs-lookup"><span data-stu-id="04e63-228">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Is this a generic method definition? {0}", _
    mi.IsGenericMethodDefinition)
```

```csharp
Console.WriteLine("\tIs this a generic method definition? {0}", 
    mi.IsGenericMethodDefinition);
```

```cpp
Console::WriteLine("\tIs this a generic method definition? {0}", 
    mi->IsGenericMethodDefinition);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="04e63-229">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="04e63-229">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="04e63-230">泛型介绍（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="04e63-230">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodInfo.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="04e63-231">要替换当前泛型方法定义的类型参数的类型数组。</span><span class="sxs-lookup"><span data-stu-id="04e63-231">An array of types to be substituted for the type parameters of the current generic method definition.</span></span></param>
        <summary><span data-ttu-id="04e63-232">用类型数组的元素替代当前泛型方法定义的类型参数，并返回表示结果构造方法的 <see cref="T:System.Reflection.MethodInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-232">Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo" /> object representing the resulting constructed method.</span></span></summary>
        <returns><span data-ttu-id="04e63-233">一个 <see cref="T:System.Reflection.MethodInfo" /> 对象，表示通过将当前泛型方法定义的类型参数替换为 <paramref name="typeArguments" /> 的元素生成的构造方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-233">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic method definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-234">使用<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法，可以编写将特定类型分配给泛型方法定义的类型参数的代码，从而<xref:System.Reflection.MethodInfo>创建表示特定构造方法的对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-234">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <xref:System.Reflection.MethodInfo> object that represents a particular constructed method.</span></span> <span data-ttu-id="04e63-235">如果此<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> <xref:System.Reflection.MethodInfo>对象的属性返回`true`，则可以使用它来调用方法或创建委托以调用方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-235">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property of this <xref:System.Reflection.MethodInfo> object returns `true`, you can use it to invoke the method or to create a delegate to invoke the method.</span></span>  
  
 <span data-ttu-id="04e63-236">用<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法构造的方法可以是开放的，也就是说，它们的某些类型参数可以是封闭泛型类型的类型参数。</span><span class="sxs-lookup"><span data-stu-id="04e63-236">Methods constructed with the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</span></span> <span data-ttu-id="04e63-237">生成动态程序集时，可以使用此类开放式构造方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-237">You might use such open constructed methods when you generate dynamic assemblies.</span></span> <span data-ttu-id="04e63-238">例如，请考虑以下C#Visual Basic 和C++代码。</span><span class="sxs-lookup"><span data-stu-id="04e63-238">For example, consider the following C#, Visual Basic, and C++ code.</span></span>  
  
```  
class C  
{  
    T N<T,U>(T t, U u) {...}  
    public V M<V>(V v)  
    {  
        return N<V,int>(v, 42);  
    }  
}  
  
Class C  
    Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T  
        ...  
    End Function  
    Public Function M(Of V)(ByVal va As V ) As V  
        Return N(Of V, Integer)(va, 42)  
    End Function  
End Class  
  
ref class C  
{  
private:  
    generic <typename T, typename U> T N(T t, U u) {...}  
public:  
    generic <typename V> V M(V v)  
    {  
        return N<V, int>(v, 42);  
    }  
};  
```  
  
 <span data-ttu-id="04e63-239">的方法体`M`包含对方法`N`的调用， `M`并指定类型的类型参数和类型<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="04e63-239">The method body of `M` contains a call to method `N`, specifying the type parameter of `M` and the type <xref:System.Int32>.</span></span> <span data-ttu-id="04e63-240">属性为`false` 方法`N<V,int>`返回。 <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A></span><span class="sxs-lookup"><span data-stu-id="04e63-240">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `false` for method `N<V,int>`.</span></span> <span data-ttu-id="04e63-241">属性返回`true`，因此无法调用`N<V,int>`方法。 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A></span><span class="sxs-lookup"><span data-stu-id="04e63-241">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, so method `N<V,int>` cannot be invoked.</span></span>  
  
 <span data-ttu-id="04e63-242">有关特定于泛型方法的术语的固定条件列表，请参见<xref:System.Reflection.MethodBase.IsGenericMethod%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-242">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="04e63-243">有关泛型反射中使用的其他术语的固定条件列表，请参见<xref:System.Type.IsGenericType%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-243">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e63-244">下面的代码示例演示了支持泛型方法的<xref:System.Reflection.MethodInfo>检查的属性和方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-244">The following code example demonstrates the properties and methods of <xref:System.Reflection.MethodInfo> that support the examination of generic methods.</span></span> <span data-ttu-id="04e63-245">该示例将执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="04e63-245">The example does the following:</span></span>  
  
-   <span data-ttu-id="04e63-246">定义具有泛型方法的类。</span><span class="sxs-lookup"><span data-stu-id="04e63-246">Defines a class that has a generic method.</span></span>  
  
-   <span data-ttu-id="04e63-247">创建一个<xref:System.Reflection.MethodInfo>表示泛型方法的。</span><span class="sxs-lookup"><span data-stu-id="04e63-247">Creates a <xref:System.Reflection.MethodInfo> that represents the generic method.</span></span>  
  
-   <span data-ttu-id="04e63-248">显示泛型方法定义的属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-248">Displays properties of the generic method definition.</span></span>  
  
-   <span data-ttu-id="04e63-249">将类型参数分配给的类型参数<xref:System.Reflection.MethodInfo>，并调用生成的构造泛型方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-249">Assigns type arguments to the type parameters of the <xref:System.Reflection.MethodInfo>, and invokes the resulting constructed generic method.</span></span>  
  
-   <span data-ttu-id="04e63-250">显示构造的泛型方法的属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-250">Displays properties of the constructed generic method.</span></span>  
  
-   <span data-ttu-id="04e63-251">从构造的方法中检索泛型方法定义，并将其与原始定义进行比较。</span><span class="sxs-lookup"><span data-stu-id="04e63-251">Retrieves the generic method definition from the constructed method and compares it to the original definition.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e63-252">当前 <see cref="T:System.Reflection.MethodInfo" /> 不表示一个泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="04e63-252">The current <see cref="T:System.Reflection.MethodInfo" /> does not represent a generic method definition.</span></span> <span data-ttu-id="04e63-253">也就是说，<see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> 返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-253">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e63-254"><paramref name="typeArguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-254"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e63-255">- 或 -</span><span class="sxs-lookup"><span data-stu-id="04e63-255">-or-</span></span> 
<span data-ttu-id="04e63-256"><paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-256">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e63-257"><paramref name="typeArguments" /> 中的元素数与当前泛型方法定义的类型参数的数目不同。</span><span class="sxs-lookup"><span data-stu-id="04e63-257">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic method definition.</span></span>  
  
<span data-ttu-id="04e63-258">或</span><span class="sxs-lookup"><span data-stu-id="04e63-258">-or-</span></span> 
<span data-ttu-id="04e63-259"><paramref name="typeArguments" /> 的元素不满足当前泛型方法定义的相应类型参数所指定的约束。</span><span class="sxs-lookup"><span data-stu-id="04e63-259">An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e63-260">不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-260">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="04e63-261">反射类型和泛型类型</span><span class="sxs-lookup"><span data-stu-id="04e63-261">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="04e63-262">泛型介绍（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="04e63-262">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.MethodInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-263">获取一个 <see cref="T:System.Reflection.MemberTypes" /> 值，该值指示此成员是方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-263">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></summary>
        <value><span data-ttu-id="04e63-264">一个 <see cref="T:System.Reflection.MemberTypes" /> 值，指示此成员是方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-264">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-265">此属性将<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>重写。</span><span class="sxs-lookup"><span data-stu-id="04e63-265">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04e63-266">因此， <xref:System.Reflection.MemberInfo>在检查一组对象时（例如，由<xref:System.Type.GetMembers%2A> <xref:System.Reflection.MemberInfo.MemberType%2A>返回的数组），仅当给定成员<xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType>为方法时，属性才会返回。</span><span class="sxs-lookup"><span data-stu-id="04e63-266">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> only when a given member is a method.</span></span>  
  
 <span data-ttu-id="04e63-267">若要获取`MemberType`属性，请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="04e63-267">To get the `MemberType` property, first get the class `Type`.</span></span> <span data-ttu-id="04e63-268">`Type`从中`MethodInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="04e63-268">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="04e63-269">`MethodInfo`从中`MemberType`获取。</span><span class="sxs-lookup"><span data-stu-id="04e63-269">From the `MethodInfo`, get the `MemberType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e63-270">下面的示例显示指定成员的类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-270">The following example displays the type of the specified member.</span></span>  
  
 [!code-cpp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="04e63-271">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-271">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="04e63-272">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-272">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="04e63-273">指示两个 <see cref="T:System.Reflection.MethodInfo" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="04e63-273">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="04e63-274">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-274"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="System.Reflection.MethodInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="04e63-275">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-275">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="04e63-276">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-276">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="04e63-277">指示两个 <see cref="T:System.Reflection.MethodInfo" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="04e63-277">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="04e63-278">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="04e63-278"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.MethodInfo.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-279">获取一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，该对象包含有关方法的返回类型的信息（例如返回类型是否具有自定义修饰符）。</span><span class="sxs-lookup"><span data-stu-id="04e63-279">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span></span></summary>
        <value><span data-ttu-id="04e63-280">一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象，包含有关返回类型的信息。</span><span class="sxs-lookup"><span data-stu-id="04e63-280">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-281">编译器设计器可以使用<xref:System.Reflection.ParameterInfo>此属性返回的对象来发现自定义修饰符（ <xref:Microsoft.VisualC.IsConstModifier>如）是否已应用于返回类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-281">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e63-282">未实现此方法。</span><span class="sxs-lookup"><span data-stu-id="04e63-282">This method is not implemented.</span></span></exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public virtual Type ReturnType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="C#" Value="public abstract Type ReturnType { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnType As Type" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ ReturnType { Type ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-283">获取此方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-283">Gets the return type of this method.</span></span></summary>
        <value><span data-ttu-id="04e63-284">此方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-284">The return type of this method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-285">若要获取返回类型属性，请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="04e63-285">To get the return type property, first get the class `Type`.</span></span> <span data-ttu-id="04e63-286">`Type`从中`MethodInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="04e63-286">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="04e63-287">`MethodInfo`从中`ReturnType`获取。</span><span class="sxs-lookup"><span data-stu-id="04e63-287">From the `MethodInfo`, get the `ReturnType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e63-288">下面的示例显示指定方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-288">The following example displays the return type of the specified method.</span></span>  
  
 [!code-cpp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnTypeCustomAttributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e63-289">获取返回类型的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="04e63-289">Gets the custom attributes for the return type.</span></span></summary>
        <value><span data-ttu-id="04e63-290">表示返回类型自定义属性的 <see langword="ICustomAttributeProvider" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-290">An <see langword="ICustomAttributeProvider" /> object representing the custom attributes for the return type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="04e63-291">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="04e63-291">Reserved for future use.</span></span> <span data-ttu-id="04e63-292">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="04e63-292">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="04e63-293">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="04e63-293">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="04e63-294">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="04e63-294">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e63-295">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="04e63-295">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="04e63-296">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="04e63-296">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="04e63-297">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="04e63-297">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-298">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="04e63-298">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e63-299">有关`IDispatch::GetIDsOfNames`的详细信息，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="04e63-299">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e63-300">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-300">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetType">
      <MemberSignature Language="C#" Value="Type _MethodInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodInfo.GetType() = System::Runtime::InteropServices::_MethodInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e63-301">提供从 COM 对 <see cref="M:System.Object.GetType" /> 方法的访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-301">Provides access to the <see cref="M:System.Object.GetType" /> method from COM.</span></span></summary>
        <returns><span data-ttu-id="04e63-302">一个 <see cref="T:System.Type" /> 对象，表示 <see cref="T:System.Reflection.MethodInfo" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="04e63-302">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.MethodInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="04e63-303">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="04e63-303">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e63-304">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="04e63-304">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="04e63-305">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="04e63-305">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="04e63-306">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="04e63-306">Retrieves the type information for an object, which can be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-307">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="04e63-307">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e63-308">有关`IDispatch::GetTypeInfo`的详细信息，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="04e63-308">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e63-309">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-309">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="04e63-310">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="04e63-310">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="04e63-311">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="04e63-311">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-312">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="04e63-312">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e63-313">有关`IDispatch::GetTypeInfoCount`的详细信息，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="04e63-313">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e63-314">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-314">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.Invoke">
      <MemberSignature Language="C#" Value="void _MethodInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="04e63-315">标识成员。</span><span class="sxs-lookup"><span data-stu-id="04e63-315">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="04e63-316">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="04e63-316">Reserved for future use.</span></span> <span data-ttu-id="04e63-317">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="04e63-317">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e63-318">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="04e63-318">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="04e63-319">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="04e63-319">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="04e63-320">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="04e63-320">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="04e63-321">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="04e63-321">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="04e63-322">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="04e63-322">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="04e63-323">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="04e63-323">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="04e63-324">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-324">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e63-325">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="04e63-325">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e63-326">有关`IDispatch::Invoke`的详细信息，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="04e63-326">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e63-327">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="04e63-327">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
