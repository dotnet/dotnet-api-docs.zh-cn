<Type Name="AssemblyName" FullName="System.Reflection.AssemblyName">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dd0821e02b9bb2728bdb9dfd6096613bc49b38b0" /><Meta Name="ms.sourcegitcommit" Value="9a0316374d19cc78674994106d073aa5ef1bd5f3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="11/10/2020" /><Meta Name="ms.locfileid" Value="94481665" /></Metadata><TypeSignature Language="C#" Value="public sealed class AssemblyName" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AssemblyName extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.AssemblyName" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AssemblyName" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyName sealed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type AssemblyName = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AssemblyName&#xA;Implements ICloneable, IDeserializationCallback, ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyName sealed : ICloneable, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="F#" Value="type AssemblyName = class&#xA;    interface ICloneable&#xA;    interface IDeserializationCallback&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type AssemblyName = class&#xA;    interface ICloneable&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" FrameworkAlternate="netcore-2.0;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AssemblyName&#xA;Implements _AssemblyName, ICloneable, IDeserializationCallback, ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyName sealed : ICloneable, System::Runtime::InteropServices::_AssemblyName, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type AssemblyName = class&#xA;    interface _AssemblyName&#xA;    interface ICloneable&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type AssemblyName = class&#xA;    interface ICloneable&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface _AssemblyName" FrameworkAlternate="xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Reflection" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Reflection" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Reflection" FromVersion="4.2.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Reflection" FromVersion="4.2.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Reflection" FromVersion="4.2.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.InteropServices._AssemblyName</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ceb7f-101">完整描述程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-101">Describes an assembly's unique identity in full.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-102"><xref:System.Reflection.AssemblyName>对象包含有关程序集的信息，您可以使用该程序集绑定到该程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-102">The <xref:System.Reflection.AssemblyName> object contains information about an assembly, which you can use to bind to that assembly.</span></span> <span data-ttu-id="ceb7f-103">程序集的标识由以下内容组成：</span><span class="sxs-lookup"><span data-stu-id="ceb7f-103">An assembly's identity consists of the following:</span></span>  
  
-   <span data-ttu-id="ceb7f-104">简单名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-104">Simple name.</span></span>  
  
-   <span data-ttu-id="ceb7f-105">版本号。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-105">Version number.</span></span>  
  
-   <span data-ttu-id="ceb7f-106">加密密钥对。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-106">Cryptographic key pair.</span></span>  
  
-   <span data-ttu-id="ceb7f-107">支持的区域性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-107">Supported culture.</span></span>  
  
 <span data-ttu-id="ceb7f-108">简单名称通常是清单文件的文件名，但不包含扩展名。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-108">The simple name is typically the file name for the manifest file without its extension.</span></span> <span data-ttu-id="ceb7f-109">密钥对包括公钥和私钥，用于为程序集创建强名称签名。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-109">The key pair includes a public and private key, used to create strong-name signatures for assemblies.</span></span>  
  
 <span data-ttu-id="ceb7f-110">所有支持公共语言运行时的编译器都将发出嵌套类的简单名称，并且在查询时，反射将按照以下约定构造错位的名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-110">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="ceb7f-111">分隔符</span><span class="sxs-lookup"><span data-stu-id="ceb7f-111">Delimiter</span></span>|<span data-ttu-id="ceb7f-112">含义</span><span class="sxs-lookup"><span data-stu-id="ceb7f-112">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="ceb7f-113">反斜杠 (\\)</span><span class="sxs-lookup"><span data-stu-id="ceb7f-113">Backslash (\\)</span></span>|<span data-ttu-id="ceb7f-114">转义符。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-114">Escape character.</span></span>|  
|<span data-ttu-id="ceb7f-115">逗号 (,)</span><span class="sxs-lookup"><span data-stu-id="ceb7f-115">Comma (,)</span></span>|<span data-ttu-id="ceb7f-116">在程序集名称之前。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-116">Precedes the assembly name.</span></span>|  
|<span data-ttu-id="ceb7f-117">加号 (+)</span><span class="sxs-lookup"><span data-stu-id="ceb7f-117">Plus sign (+)</span></span>|<span data-ttu-id="ceb7f-118">在嵌套类之前。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-118">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="ceb7f-119">例如，类的完全限定名称可能如下所示：</span><span class="sxs-lookup"><span data-stu-id="ceb7f-119">For example, the fully qualified name for a class might look like this:</span></span>  
  
 <span data-ttu-id="ceb7f-120">ContainingClass + NestedClass、MyAssembly</span><span class="sxs-lookup"><span data-stu-id="ceb7f-120">ContainingClass+NestedClass,MyAssembly</span></span>  
  
 <span data-ttu-id="ceb7f-121">"+ +" 变成 " \\ + \\ +"，而 " \\ " 变成 "" \\ \\ 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-121">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="ceb7f-122">此限定名称可以保留，以后用于加载 <xref:System.Type> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-122">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="ceb7f-123">若要搜索并加载 <xref:System.Type> ，请将 <xref:System.Type.GetType%2A> 与类型名称一起使用，或者使用带有程序集限定类型名称的。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-123">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="ceb7f-124"><xref:System.Type.GetType%2A> 只有类型名称才会 <xref:System.Type> 在调用方的程序集中查找，然后在系统程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-124"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="ceb7f-125"><xref:System.Type.GetType%2A> 具有程序集限定类型名称的将 <xref:System.Type> 在任何程序集中查找。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-125"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="ceb7f-126">完全指定的 <xref:System.Reflection.AssemblyName> 必须具有名称、区域性、公钥或公钥令牌、主版本、次版本、内部版本号和修订号参数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-126">A fully specified <xref:System.Reflection.AssemblyName> must have the name, culture, public key or public key token, major version, minor version, build number, and revision number parameters.</span></span> <span data-ttu-id="ceb7f-127">最后四个封装在类型中 <xref:System.Version> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-127">The last four are packaged in the <xref:System.Version> type.</span></span>  
  
 <span data-ttu-id="ceb7f-128">若要创建一个简单名称，请 <xref:System.Reflection.AssemblyName> 使用无参数构造函数创建一个对象，并设置 <xref:System.Reflection.AssemblyName.Name%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-128">To create a simple name, create an <xref:System.Reflection.AssemblyName> object using the parameterless constructor and set the <xref:System.Reflection.AssemblyName.Name%2A>.</span></span> <span data-ttu-id="ceb7f-129">其他属性是可选的。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-129">The other properties are optional.</span></span>  
  
 <span data-ttu-id="ceb7f-130">若要创建完整的强名称，请 <xref:System.Reflection.AssemblyName> 使用无参数构造函数创建一个对象，并设置 <xref:System.Reflection.AssemblyName.Name%2A> 和 <xref:System.Reflection.AssemblyName.KeyPair%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-130">To create a full strong name, create an <xref:System.Reflection.AssemblyName> object using the parameterless constructor and set the <xref:System.Reflection.AssemblyName.Name%2A> and <xref:System.Reflection.AssemblyName.KeyPair%2A>.</span></span> <span data-ttu-id="ceb7f-131">其他属性是可选的。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-131">The other properties are optional.</span></span> <span data-ttu-id="ceb7f-132">使用 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> 和 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 设置公钥和强名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-132">Use <xref:System.Reflection.AssemblyName.SetPublicKey%2A> and <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> to set the public key and the strong name.</span></span> <span data-ttu-id="ceb7f-133">强名称签名总是使用 <xref:System.Security.Cryptography.SHA1> 哈希算法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-133">The strong name signing always uses the <xref:System.Security.Cryptography.SHA1> hash algorithm.</span></span>  
  
 <span data-ttu-id="ceb7f-134">若要确保正确构造名称，请使用以下属性：</span><span class="sxs-lookup"><span data-stu-id="ceb7f-134">To ensure that the names are constructed correctly, use the following properties:</span></span>  
  
-   <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="ceb7f-135">还可以通过将 `/l` 选项与[Gacutil.exe (全局程序集缓存工具](/dotnet/framework/tools/gacutil-exe-gac-tool)结合使用来获取名称) </span><span class="sxs-lookup"><span data-stu-id="ceb7f-135">You can also get the name by using the `/l` option with the [Gacutil.exe (Global Assembly Cache Tool)](/dotnet/framework/tools/gacutil-exe-gac-tool)</span></span>  
  
 <span data-ttu-id="ceb7f-136">对于部分指定的强名称，请 <xref:System.Reflection.AssemblyName> 使用无参数构造函数创建一个对象，并设置名称和公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-136">For a partially specified strong name, create an <xref:System.Reflection.AssemblyName> object using the parameterless constructor and set the name and public key.</span></span> <span data-ttu-id="ceb7f-137"><xref:System.Reflection.AssemblyName>稍后可以使用程序集链接器 ( # A0) 为创建的程序集签名。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-137">An assembly created using such an <xref:System.Reflection.AssemblyName> can be signed later using the Assembly Linker (Al.exe).</span></span>  
  
 <span data-ttu-id="ceb7f-138">可以指定 <xref:System.Reflection.AssemblyName.KeyPair%2A> 具有不一致值的公钥和。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-138">It is possible to specify a public key and a <xref:System.Reflection.AssemblyName.KeyPair%2A> with inconsistent values.</span></span> <span data-ttu-id="ceb7f-139">这对于开发人员方案非常有用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-139">This can be useful in developer scenarios.</span></span> <span data-ttu-id="ceb7f-140">在这种情况下，使用检索到的公钥 <xref:System.Reflection.AssemblyName.GetPublicKey%2A> 指定了正确的公钥，而指定了在 <xref:System.Reflection.AssemblyName.KeyPair%2A> 开发过程中使用的公钥和私钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-140">In this case, the public key retrieved with <xref:System.Reflection.AssemblyName.GetPublicKey%2A> specifies the correct public key, while the <xref:System.Reflection.AssemblyName.KeyPair%2A> specifies the public and private keys used during development.</span></span> <span data-ttu-id="ceb7f-141">当运行时检测到与公钥不匹配时 <xref:System.Reflection.AssemblyName.KeyPair%2A> ，会在注册表中查找与公钥匹配的正确密钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-141">When the runtime detects a mismatch between the <xref:System.Reflection.AssemblyName.KeyPair%2A> and the public key, it looks up in the registry the correct key that matches the public key.</span></span>  
  
 <span data-ttu-id="ceb7f-142">显示名称的格式 <xref:System.Reflection.AssemblyName> 是以逗号分隔的以名称开头的 Unicode 字符串，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ceb7f-142">The format of the display name of an <xref:System.Reflection.AssemblyName> is a comma-delimited Unicode string that begins with the name, as follows:</span></span>  
  
 `Name <,Culture = CultureInfo> <,Version = Major.Minor.Build.Revision> <, StrongName> <,PublicKeyToken> '\0'`  
  
 <span data-ttu-id="ceb7f-143">`Name` 程序集的文本名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-143">`Name` is the textual name of the assembly.</span></span> <span data-ttu-id="ceb7f-144">`CultureInfo` 是 RFC1766 格式定义的区域性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-144">`CultureInfo` is the RFC1766-format-defined culture.</span></span> <span data-ttu-id="ceb7f-145">`Major`、 `Minor` 、 `Build` 和 `Revision` 是程序集的主版本、次版本、内部版本号和修订号。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-145">`Major`, `Minor`, `Build`, and `Revision` are the major version, minor version, build number, and revision number of the assembly.</span></span> <span data-ttu-id="ceb7f-146">`StrongName` 使用 SHA-1 哈希算法生成的公钥哈希值的十六进制编码低序位64位，以及由指定的公钥 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-146">`StrongName` is the hexadecimal-encoded low-order 64 bits of the hash value of the public key generated using the SHA-1 hashing algorithm and the public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>.</span></span> <span data-ttu-id="ceb7f-147">`PublicKeyToken` 由指定的十六进制编码的公钥 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-147">`PublicKeyToken` is the hexadecimal-encoded public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>.</span></span>  
  
 <span data-ttu-id="ceb7f-148">十六进制编码定义为二进制对象的每个字节转换为两个十六进制字符（从最小到最高有效字节）的转换。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-148">Hexadecimal encoding is defined as the conversion of each byte of a binary object to two hexadecimal characters, progressing from least to most significant byte.</span></span> <span data-ttu-id="ceb7f-149">将根据需要添加其他显示值。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-149">Additional display values will be added as deemed necessary.</span></span>  
  
 <span data-ttu-id="ceb7f-150">如果已知道完整的公钥，则可能会将 PublicKey 替换为 Stackexchange.redis.strongname。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-150">If the full public key is known, then PublicKey may be substituted for StrongName.</span></span>  
  
 <span data-ttu-id="ceb7f-151">另请注意，除 `Name` （必须首先出现）外，参数的词法顺序并不重要。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-151">Also note that except for `Name`, which must come first, the lexical order of parameters is unimportant.</span></span> <span data-ttu-id="ceb7f-152">但是， `Version` `Culture` 未专门设置的任何参数 (、 `StrongName` 或 `PublicKey`) 被认为是省略的，然后被 <xref:System.Reflection.AssemblyName> 视为 partial。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-152">However, any parameter (`Version`, `Culture`, `StrongName` or `PublicKey`) not specifically set is considered to be omitted, and the <xref:System.Reflection.AssemblyName> is then considered partial.</span></span> <span data-ttu-id="ceb7f-153">指定部分信息时，必须按照上述顺序指定名称参数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-153">When specifying partial information, Name parameters must be specified in the order described above.</span></span>  
  
 <span data-ttu-id="ceb7f-154">提供显示名称时，约定 `StrongName =null` 或 `PublicKey= null` 指示是否需要针对简单命名的程序集的绑定和匹配。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-154">When supplying a display name, the convention `StrongName =null` or `PublicKey= null` indicates that binding and matching against a simply named assembly is required.</span></span> <span data-ttu-id="ceb7f-155">此外，约定 `Culture= ""` (双引号表示空字符串) 指示与默认区域性匹配。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-155">Additionally, the convention `Culture= ""` (double quote representing an empty string) indicates matching against the default culture.</span></span>  
  
 <span data-ttu-id="ceb7f-156">下面的示例演示了一个 <xref:System.Reflection.AssemblyName> 具有默认区域性的简单命名的程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-156">The following example shows an <xref:System.Reflection.AssemblyName> for a simply named assembly with default culture.</span></span>  
  
```  
ExampleAssembly, Culture=""  
```  
  
 <span data-ttu-id="ceb7f-157">下面的示例演示区域性为“en”的强名称程序集的完全指定的引用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-157">The following example shows a fully specified reference for a strongly named assembly with culture "en".</span></span>  
  
```  
ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  
```  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-158">此示例演示如何使用各种反射类来分析包含在程序集中的元数据。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-158">This example shows how to use various reflection classes to analyze the metadata contained in an assembly.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Version" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKey" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
    <altmember cref="P:System.Type.FullName" />
    <altmember cref="M:System.Type.GetType" />
    <altmember cref="P:System.Type.AssemblyQualifiedName" />
    <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names"><span data-ttu-id="ceb7f-159">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="ceb7f-159">Specifying Fully Qualified Type Names</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ceb7f-160">初始化 <see cref="T:System.Reflection.AssemblyName" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-160">Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AssemblyName();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ceb7f-161">初始化 <see cref="T:System.Reflection.AssemblyName" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-161">Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ceb7f-162">下面的示例创建一个名为的动态程序集 `MyAssembly.exe` ，并将其保存到硬盘上。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-162">The following example creates a dynamic assembly named `MyAssembly.exe` and saves it to your hard disk.</span></span> <span data-ttu-id="ceb7f-163">运行该示例后，可以使用 [Ildasm.exe (IL 拆装器) ](/dotnet/framework/tools/ildasm-exe-il-disassembler) 来检查程序集元数据。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-163">After running the example, you can use the [Ildasm.exe (IL Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) to examine the assembly metadata.</span></span>  
  
 [!code-cpp[AssemblyName_Constructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#1)]
 [!code-csharp[AssemblyName_Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#1)]
 [!code-vb[AssemblyName_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (assemblyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="new System.Reflection.AssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="new System.Reflection.AssemblyName assemblyName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="ceb7f-164">程序集的显示名称，由 <see cref="P:System.Reflection.AssemblyName.FullName" /> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-164">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="ceb7f-165">使用指定的显示名称初始化 <see cref="T:System.Reflection.AssemblyName" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-165">Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class with the specified display name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-166">将分析提供的 `assemblyName` ，并 <xref:System.Reflection.AssemblyName> 通过显示名称中的值初始化新的相应字段。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-166">The supplied `assemblyName` is parsed, and the appropriate fields of the new <xref:System.Reflection.AssemblyName> are initialized with values from the display name.</span></span> <span data-ttu-id="ceb7f-167">这是分析显示名称的建议方法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-167">This is the recommended way of parsing display names.</span></span> <span data-ttu-id="ceb7f-168">建议不要编写自己的代码来分析显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-168">Writing your own code to parse display names is not recommended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-169">下面的示例从显示名称创建的一个实例 <xref:System.Reflection.AssemblyName> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-169">The following example creates an instance of <xref:System.Reflection.AssemblyName> from a display name.</span></span> <span data-ttu-id="ceb7f-170">显示名称的各个元素作为对象的属性输出到控制台 <xref:System.Reflection.AssemblyName> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-170">The individual elements of the display name are output to the console as properties of the <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-cpp[AssemblyName_Constructor_2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor_2/CPP/source.cpp#1)]
 [!code-csharp[AssemblyName_Constructor_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor_2/CS/source.cs#1)]
 [!code-vb[AssemblyName_Constructor_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor_2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ceb7f-171"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-171"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ceb7f-172"><paramref name="assemblyName" /> 是一个长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-172"><paramref name="assemblyName" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ceb7f-173">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-173">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ceb7f-174">无法找到或无法加载引用的程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-174">The referenced assembly could not be found, or could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="assemblyName.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ceb7f-175">制作此 <see cref="T:System.Reflection.AssemblyName" /> 对象的副本。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-175">Makes a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-176">作为 <see cref="T:System.Reflection.AssemblyName" /> 对象副本的对象。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-176">An object that is a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-177">创建一个新的对象，该对象与原始对象相同。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-177">A new object is created, identical to the original.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public string CodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CodeBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string with get, set" Usage="System.Reflection.AssemblyName.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-178">获取或设置程序集的 URL 位置。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-178">Gets or sets the location of the assembly as a URL.</span></span></summary>
        <value><span data-ttu-id="ceb7f-179">一个字符串，它是程序集的 URL 位置。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-179">A string that is the URL location of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-180">加载程序集时，还可以使用属性获取此值 <xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-180">When an assembly is loaded, this value can also be obtained using the <xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ceb7f-181">如果程序集作为字节数组加载，则此属性返回方法重载的调用方的位置 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29> ，而不是已加载的程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-181">If the assembly was loaded as a byte array, this property returns the location of the caller of the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29> method overload, not the location of the loaded assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ceb7f-182">不要使用 <xref:System.Reflection.AssemblyName> 只带有 <xref:System.Reflection.AssemblyName.CodeBase%2A> 属性集的。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-182">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="ceb7f-183"><xref:System.Reflection.AssemblyName.CodeBase%2A>属性不提供程序集标识 (（如名称或版本) ）的任何元素，因此，不会按照按标识规则加载规则进行加载，如方法所料 <xref:System.Reflection.Assembly.Load%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-183">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="ceb7f-184">而是使用加载 "规则" 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-184">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="ceb7f-185">有关使用加载源上下文的缺点的信息，请参阅 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> [程序集加载](/dotnet/framework/deployment/best-practices-for-assembly-loading)的方法重载或最佳做法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-185">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](/dotnet/framework/deployment/best-practices-for-assembly-loading).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-186">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-186">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-187">创建程序集后， <xref:System.Reflection.AssemblyName.CodeBase%2A> 属性用于指定保存程序集的目录。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-187">When the assembly is created, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to specify the directory where the assembly is saved.</span></span>  
  
 [!code-cpp[AssemblyName_CodeBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#1)]
 [!code-csharp[AssemblyName_CodeBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#1)]
 [!code-vb[AssemblyName_CodeBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyContentType ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyContentType ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As AssemblyContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::AssemblyContentType ContentType { System::Reflection::AssemblyContentType get(); void set(System::Reflection::AssemblyContentType value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : System.Reflection.AssemblyContentType with get, set" Usage="System.Reflection.AssemblyName.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyContentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-188">获取或设置指示程序集包含的内容类型的值。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-188">Gets or sets a value that indicates what type of content the assembly contains.</span></span></summary>
        <value><span data-ttu-id="ceb7f-189">指示程序集包含哪种内容类型的值。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-189">A value that indicates what type of content the assembly contains.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureInfo">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CultureInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CultureInfo" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property CultureInfo As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CultureInfo { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CultureInfo : System.Globalization.CultureInfo with get, set" Usage="System.Reflection.AssemblyName.CultureInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-190">获取或设置程序集支持的区域性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-190">Gets or sets the culture supported by the assembly.</span></span></summary>
        <value><span data-ttu-id="ceb7f-191">一个对象，它表示程序集支持的区域性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-191">An object that represents the culture supported by the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ceb7f-192">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-192">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-193">创建程序集后， <xref:System.Reflection.AssemblyName.CultureInfo%2A> 属性用于指定区域性，它是程序集显示名称的一部分。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-193">When the assembly is created, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property is used to specify the culture, which is part of the assembly's display name.</span></span>  
  
 [!code-cpp[AssemblyName_CodeBase#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#2)]
 [!code-csharp[AssemblyName_CodeBase#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#2)]
 [!code-vb[AssemblyName_CodeBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureName">
      <MemberSignature Language="C#" Value="public string CultureName { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string CultureName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureName" />
      <MemberSignature Language="VB.NET" Value="Public Property CultureName As String" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CultureName { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CultureName : string with get, set" Usage="System.Reflection.AssemblyName.CultureName" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public string CultureName { get; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CultureName As String" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CultureName { System::String ^ get(); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="F#" Value="member this.CultureName : string" Usage="System.Reflection.AssemblyName.CultureName" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-194">获取或设置与此程序集关联的区域性名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-194">Gets or sets the name of the culture associated with the assembly.</span></span></summary>
        <value><span data-ttu-id="ceb7f-195">区域性名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-195">The culture name.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-196">获取 URI，包括表示基本代码的转义符。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-196">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="ceb7f-197">带有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-197">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyNameFlags Flags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyNameFlags Flags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Property Flags As AssemblyNameFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::AssemblyNameFlags Flags { System::Reflection::AssemblyNameFlags get(); void set(System::Reflection::AssemblyNameFlags value); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Reflection.AssemblyNameFlags with get, set" Usage="System.Reflection.AssemblyName.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyNameFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-198">获取或设置该程序集的属性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-198">Gets or sets the attributes of the assembly.</span></span></summary>
        <value><span data-ttu-id="ceb7f-199">表示程序集特性的值。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-199">A value that represents the attributes of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ceb7f-200">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-200">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-201">创建程序集后， <xref:System.Reflection.AssemblyName.Flags%2A> 属性用于指定程序集具有公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-201">When the assembly is created, the <xref:System.Reflection.AssemblyName.Flags%2A> property is used to specify that the assembly has a public key.</span></span>  
  
 [!code-cpp[AssemblyName_KeyPair#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#4)]
 [!code-csharp[AssemblyName_KeyPair#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#4)]
 [!code-vb[AssemblyName_KeyPair#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.FullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.AssemblyName.FullName" />
      <MemberSignature Language="C#" Value="public string? FullName { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-202">获取程序集的全名（也称为显示名称）。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-202">Gets the full name of the assembly, also known as the display name.</span></span></summary>
        <value><span data-ttu-id="ceb7f-203">作为程序集的全名（也称为显示名称）的字符串。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-203">A string that is the full name of the assembly, also known as the display name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-204">显示名称通常由简单名称、版本号、支持的区域性和公钥组成。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-204">The display name typically consists of the simple name, version number, supported culture, and public key.</span></span> <span data-ttu-id="ceb7f-205">例如：</span><span class="sxs-lookup"><span data-stu-id="ceb7f-205">For example:</span></span>  
  
```  
mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  
```  
  
 <span data-ttu-id="ceb7f-206">建议不要编写自己的代码来分析显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-206">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="ceb7f-207">而是将显示名称传递到 <xref:System.Reflection.AssemblyName.%23ctor%2A> 构造函数，该构造函数对其进行分析，并填充新的相应字段 <xref:System.Reflection.AssemblyName> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-207">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="ceb7f-208">加载程序集时，还可以使用属性获取此值 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-208">When an assembly is loaded, this value can also be obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-209">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-209">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-210">创建程序集后，代码示例将设置 <xref:System.Reflection.AssemblyName.Name%2A> 、 <xref:System.Reflection.AssemblyName.Version%2A> 、 <xref:System.Reflection.AssemblyName.CultureInfo%2A> 和 <xref:System.Reflection.AssemblyName.KeyPair%2A> 属性，这些属性共同构成程序集的完整名称或显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-210">When the assembly is created, the code example sets the <xref:System.Reflection.AssemblyName.Name%2A>, <xref:System.Reflection.AssemblyName.Version%2A>, <xref:System.Reflection.AssemblyName.CultureInfo%2A>, and <xref:System.Reflection.AssemblyName.KeyPair%2A> properties, which together comprise an assembly's full name, or display name.</span></span> <span data-ttu-id="ceb7f-211"><xref:System.Reflection.AssemblyName.FullName%2A>然后，使用属性来检索显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-211">The <xref:System.Reflection.AssemblyName.FullName%2A> property is then used to retrieve the display name.</span></span>  
  
 [!code-cpp[AssemblyName_CodeBase#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#4)]
 [!code-csharp[AssemblyName_CodeBase#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#4)]
 [!code-vb[AssemblyName_CodeBase#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names"><span data-ttu-id="ceb7f-212">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="ceb7f-212">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyFile As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Reflection.AssemblyName.GetAssemblyName assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ceb7f-213">要返回其 <see cref="T:System.Reflection.AssemblyName" /> 的程序集的路径。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-213">The path for the assembly whose <see cref="T:System.Reflection.AssemblyName" /> is to be returned.</span></span></param>
        <summary><span data-ttu-id="ceb7f-214">获取给定文件的 <see cref="T:System.Reflection.AssemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-214">Gets the <see cref="T:System.Reflection.AssemblyName" /> for a given file.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-215">表示给定的程序集文件的对象。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-215">An object that represents the given assembly file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-216">仅当文件包含程序集清单时，此操作才有效。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-216">This will only work if the file contains an assembly manifest.</span></span> <span data-ttu-id="ceb7f-217">此方法会导致文件打开和关闭，但不会将程序集添加到此域中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-217">This method causes the file to be opened and closed, but the assembly is not added to this domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-218">下面的示例获取 <xref:System.Reflection.AssemblyName> 磁盘上的程序集的。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-218">The following example gets the <xref:System.Reflection.AssemblyName> for an assembly on disk.</span></span> <span data-ttu-id="ceb7f-219">除非您将字符串 "MyAssembly.exe" 替换为程序 (集的文件名（包括路径），否则它将不会运行，如硬盘上所需) 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-219">It will not run unless you replace the string "MyAssembly.exe" with the file name of an assembly (including the path, if necessary) on your hard disk.</span></span> <span data-ttu-id="ceb7f-220">或者，您可以将此示例编译为 "MyAssembly.exe"。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-220">Alternatively, you can compile this example as "MyAssembly.exe".</span></span>  
  
 [!code-cpp[AssemblyName_GetAssemblyName#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#1)]
 [!code-csharp[AssemblyName_GetAssemblyName#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#1)]
 [!code-vb[AssemblyName_GetAssemblyName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ceb7f-221"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-221"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ceb7f-222"><paramref name="assemblyFile" /> 无效，如包含无效区域性的程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-222"><paramref name="assemblyFile" /> is invalid, such as an assembly with an invalid culture.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ceb7f-223"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-223"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ceb7f-224">调用方没有路径发现权限。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-224">The caller does not have path discovery permission.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ceb7f-225"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-225"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ceb7f-226">一个程序集或模块用两个不同的证据集加载了两次。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-226">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assemblyName.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="ceb7f-227">用序列化信息填充的对象。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-227">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="ceb7f-228">序列化的目标上下文。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-228">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="ceb7f-229">获取序列化信息，其中包含重新创建此 <see langword="AssemblyName" /> 实例所需的所有数据。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-229">Gets serialization information with all the data needed to recreate an instance of this <see langword="AssemblyName" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ceb7f-230"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKey">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPublicKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetPublicKey();" />
      <MemberSignature Language="F#" Value="member this.GetPublicKey : unit -&gt; byte[]" Usage="assemblyName.GetPublicKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ceb7f-231">获取程序集的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-231">Gets the public key of the assembly.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-232">字节数组，包含程序集的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-232">A byte array that contains the public key of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ceb7f-233">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-233">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-234">创建程序集时， <xref:System.Reflection.AssemblyName.SetPublicKey%2A> 方法用于为程序集指定一个公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-234">When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKey%2A> method is used to give the assembly a public key.</span></span> <span data-ttu-id="ceb7f-235"><xref:System.Reflection.AssemblyName.GetPublicKey%2A>然后，使用方法来检索向控制台显示的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-235">The <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is then used to retrieve the public key, which is displayed to the console.</span></span>  
  
 [!code-cpp[AssemblyName_KeyPair#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#2)]
 [!code-csharp[AssemblyName_KeyPair#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#2)]
 [!code-vb[AssemblyName_KeyPair#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ceb7f-236">提供了公钥（例如使用 <see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" /> 方法），但未提供公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-236">A public key was provided (for example, by using the <see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" /> method), but no public key token was provided.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKeyToken">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKeyToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKeyToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPublicKeyToken () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetPublicKeyToken();" />
      <MemberSignature Language="F#" Value="member this.GetPublicKeyToken : unit -&gt; byte[]" Usage="assemblyName.GetPublicKeyToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ceb7f-237">获取公钥标记，该标记为应用程序或程序集签名时所用公钥的 SHA-1 哈希值的最后 8 个字节。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-237">Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-238">包含公钥调用的字节数组。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-238">A byte array that contains the public key token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ceb7f-239">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-239">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-240">创建程序集时， <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 方法用于设置程序集的公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-240">When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method is used to set the assembly's public key token.</span></span> <span data-ttu-id="ceb7f-241"><xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>然后，使用方法来检索向控制台显示的公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-241">The <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method is then used to retrieve the public key token, which is displayed to the console.</span></span>  
  
 [!code-cpp[AssemblyName_KeyPair#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#3)]
 [!code-csharp[AssemblyName_KeyPair#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#3)]
 [!code-vb[AssemblyName_KeyPair#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As AssemblyHashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::Assemblies::AssemblyHashAlgorithm HashAlgorithm { System::Configuration::Assemblies::AssemblyHashAlgorithm get(); void set(System::Configuration::Assemblies::AssemblyHashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Configuration.Assemblies.AssemblyHashAlgorithm with get, set" Usage="System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyHashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-242">获取或设置程序集清单使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-242">Gets or sets the hash algorithm used by the assembly manifest.</span></span></summary>
        <value><span data-ttu-id="ceb7f-243">程序集清单使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-243">The hash algorithm used by the assembly manifest.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ceb7f-244">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ， <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> <xref:System.Reflection.AssemblyName> 方法返回的对象的属性为，如果所 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType> <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> 引用的程序集没有哈希算法，或者枚举不标识所引用程序集的哈希算法，则为 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-244">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType> method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="ceb7f-245">在以前版本的 .NET Framework 中， <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> 此情况下返回了属性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-245">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-246">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-246">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-247">创建程序集后， <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 属性用于设置程序集清单的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-247">When the assembly is created, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property is used to set the hash algorithm for the assembly manifest.</span></span>  
  
 [!code-cpp[AssemblyName_CodeBase#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#3)]
 [!code-csharp[AssemblyName_CodeBase#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#3)]
 [!code-vb[AssemblyName_CodeBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPair">
      <MemberSignature Language="C#" Value="public System.Reflection.StrongNameKeyPair KeyPair { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.StrongNameKeyPair KeyPair" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.KeyPair" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPair As StrongNameKeyPair" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::StrongNameKeyPair ^ KeyPair { System::Reflection::StrongNameKeyPair ^ get(); void set(System::Reflection::StrongNameKeyPair ^ value); };" />
      <MemberSignature Language="F#" Value="member this.KeyPair : System.Reflection.StrongNameKeyPair with get, set" Usage="System.Reflection.AssemblyName.KeyPair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.StrongNameKeyPair</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-248">获取或设置用于为程序集创建强名称签名的加密公钥/私钥对。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-248">Gets or sets the public and private cryptographic key pair that is used to create a strong name signature for the assembly.</span></span></summary>
        <value><span data-ttu-id="ceb7f-249">要用于为程序集创建强名称的加密公钥/私钥对。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-249">The public and private cryptographic key pair to be used to create a strong name for the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-250">当运行时加载程序集时，它不设置 <xref:System.Reflection.AssemblyName.KeyPair%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-250">When the runtime loads an assembly, it does not set the <xref:System.Reflection.AssemblyName.KeyPair%2A> property.</span></span> <span data-ttu-id="ceb7f-251">仅当用户在使用 <xref:System.Reflection.AssemblyName> 对象创建动态程序集之前设置属性，并随后想要检索密钥对时，属性的 getter 才有用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-251">The getter for the property is only useful if the user set the property before using the <xref:System.Reflection.AssemblyName> object to create a dynamic assembly, and subsequently wants to retrieve the key pair.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-252">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-252">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-253">创建程序集后， <xref:System.Reflection.AssemblyName.KeyPair%2A> 属性用于设置程序集的公钥和私钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-253">When the assembly is created, the <xref:System.Reflection.AssemblyName.KeyPair%2A> property is used to set the assembly's public and private cryptographic keys.</span></span> <span data-ttu-id="ceb7f-254">.</span><span class="sxs-lookup"><span data-stu-id="ceb7f-254">.</span></span>  
  
 [!code-cpp[AssemblyName_KeyPair#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#1)]
 [!code-csharp[AssemblyName_KeyPair#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#1)]
 [!code-vb[AssemblyName_KeyPair#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Reflection.AssemblyName.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-255">获取或设置程序集的简单名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-255">Gets or sets the simple name of the assembly.</span></span> <span data-ttu-id="ceb7f-256">这通常（但不一定）是程序集的清单文件的文件名，不包括其扩展名。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-256">This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</span></span></summary>
        <value><span data-ttu-id="ceb7f-257">程序集的简单名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-257">The simple name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-258">清单文件是包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-258">The manifest file is the file that contains the assembly manifest.</span></span>  
  
 <span data-ttu-id="ceb7f-259">例如，名为 "MyAssembly.dll" 的单文件程序集的简单名称为 "MyAssembly"。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-259">For example, the simple name of a single-file assembly named "MyAssembly.dll" is "MyAssembly".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-260">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-260">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-261">创建程序集后， <xref:System.Reflection.AssemblyName.Name%2A> 属性用于设置动态程序集的简单名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-261">When the assembly is created, the <xref:System.Reflection.AssemblyName.Name%2A> property is used to set the simple name of the dynamic assembly.</span></span>  
  
 [!code-cpp[AssemblyName_Constructor#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#2)]
 [!code-csharp[AssemblyName_Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#2)]
 [!code-vb[AssemblyName_Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names"><span data-ttu-id="ceb7f-262">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="ceb7f-262">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="assemblyName.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="ceb7f-263">反序列化事件源。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-263">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="ceb7f-264">实现 <see cref="T:System.Runtime.Serialization.ISerializable" /> 接口，并在完成反序列化后由反序列化事件回调。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-264">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and is called back by the deserialization event when deserialization is complete.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorArchitecture">
      <MemberSignature Language="C#" Value="public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ProcessorArchitecture ProcessorArchitecture" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorArchitecture As ProcessorArchitecture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ProcessorArchitecture ProcessorArchitecture { System::Reflection::ProcessorArchitecture get(); void set(System::Reflection::ProcessorArchitecture value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorArchitecture : System.Reflection.ProcessorArchitecture with get, set" Usage="System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ProcessorArchitecture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-265">获取或设置一个值，该值标识可执行文件的目标平台的处理器和每字位数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-265">Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</span></span></summary>
        <value><span data-ttu-id="ceb7f-266">枚举值之一，标识可执行文件的目标平台的处理器和每字位数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-266">One of the enumeration values that identifies the processor and bits-per-word of the platform targeted by an executable.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-267">从开始 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ，此属性始终返回 <xref:System.Reflection.ProcessorArchitecture.None?displayProperty=nameWithType> 引用程序集。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-267">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this property always returns <xref:System.Reflection.ProcessorArchitecture.None?displayProperty=nameWithType> for reference assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      </Docs>
    </Member>
    <Member MemberName="ReferenceMatchesDefinition">
      <MemberSignature Language="C#" Value="public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceMatchesDefinition(class System.Reflection.AssemblyName reference, class System.Reflection.AssemblyName definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceMatchesDefinition (reference As AssemblyName, definition As AssemblyName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceMatchesDefinition(System::Reflection::AssemblyName ^ reference, System::Reflection::AssemblyName ^ definition);" />
      <MemberSignature Language="F#" Value="static member ReferenceMatchesDefinition : System.Reflection.AssemblyName * System.Reflection.AssemblyName -&gt; bool" Usage="System.Reflection.AssemblyName.ReferenceMatchesDefinition (reference, definition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="definition" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reference"><span data-ttu-id="ceb7f-268">引用程序集名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-268">The reference assembly name.</span></span></param>
        <param name="definition"><span data-ttu-id="ceb7f-269">与引用程序集进行比较的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-269">The assembly name that is compared to the reference assembly.</span></span></param>
        <summary><span data-ttu-id="ceb7f-270">返回指示两个程序集名称是否相同的值。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-270">Returns a value indicating whether two assembly names are the same.</span></span> <span data-ttu-id="ceb7f-271">该比较基于简单的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-271">The comparison is based on the simple assembly names.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-272">如果简单程序集名称相同，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-272"><see langword="true" /> if the simple assembly names are the same; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-273">比较仅依赖于简单的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-273">The comparison depends only on the simple assembly name.</span></span> <span data-ttu-id="ceb7f-274">它忽略版本、区域性和公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-274">It ignores version, culture, and public key token.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKey">
      <MemberSignature Language="C#" Value="public void SetPublicKey (byte[] publicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKey(unsigned int8[] publicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPublicKey (publicKey As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPublicKey(cli::array &lt;System::Byte&gt; ^ publicKey);" />
      <MemberSignature Language="F#" Value="member this.SetPublicKey : byte[] -&gt; unit" Usage="assemblyName.SetPublicKey publicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKey"><span data-ttu-id="ceb7f-275">字节数组，包含程序集的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-275">A byte array containing the public key of the assembly.</span></span></param>
        <summary><span data-ttu-id="ceb7f-276">设置用于标识程序集的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-276">Sets the public key identifying the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-277">还必须使用 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 方法来提供公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-277">You must also use the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method to provide a public key token.</span></span> <span data-ttu-id="ceb7f-278">否则，在 <xref:System.Security.SecurityException> 调用方法时引发 <xref:System.Reflection.AssemblyName.GetPublicKey%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-278">Otherwise, a <xref:System.Security.SecurityException> is thrown when the <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-279">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-279">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-280">创建程序集时， <xref:System.Reflection.AssemblyName.SetPublicKey%2A> 方法用于为程序集指定一个公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-280">When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKey%2A> method is used to give the assembly a public key.</span></span> <span data-ttu-id="ceb7f-281"><xref:System.Reflection.AssemblyName.GetPublicKey%2A>然后，使用方法来检索向控制台显示的公钥。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-281">The <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is then used to retrieve the public key, which is displayed to the console.</span></span>  
  
 [!code-cpp[AssemblyName_SetPublicKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#1)]
 [!code-csharp[AssemblyName_SetPublicKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#1)]
 [!code-vb[AssemblyName_SetPublicKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKeyToken">
      <MemberSignature Language="C#" Value="public void SetPublicKeyToken (byte[] publicKeyToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKeyToken(unsigned int8[] publicKeyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPublicKeyToken (publicKeyToken As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPublicKeyToken(cli::array &lt;System::Byte&gt; ^ publicKeyToken);" />
      <MemberSignature Language="F#" Value="member this.SetPublicKeyToken : byte[] -&gt; unit" Usage="assemblyName.SetPublicKeyToken publicKeyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKeyToken" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKeyToken"><span data-ttu-id="ceb7f-282">字节数组，包含程序集的公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-282">A byte array containing the public key token of the assembly.</span></span></param>
        <summary><span data-ttu-id="ceb7f-283">设置公钥标记，该标记为应用程序或程序集签名时所用公钥的 SHA-1 哈希值的最后 8 个字节。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-283">Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-284">通过调用方法设置公钥时 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> ，还必须使用 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 方法来提供公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-284">When you set the public key by calling the <xref:System.Reflection.AssemblyName.SetPublicKey%2A> method, you must also use the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method to provide a public key token.</span></span> <span data-ttu-id="ceb7f-285">否则，在 <xref:System.Security.SecurityException> 调用方法时引发 <xref:System.Reflection.AssemblyName.GetPublicKey%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-285">Otherwise, a <xref:System.Security.SecurityException> is thrown when the <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-286">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-286">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-287">创建程序集时， <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 方法用于设置程序集的公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-287">When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method is used to set the assembly's public key token.</span></span> <span data-ttu-id="ceb7f-288"><xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>然后，使用方法来检索向控制台显示的公钥标记。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-288">The <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method is then used to retrieve the public key token, which is displayed to the console.</span></span>  
  
 [!code-cpp[AssemblyName_SetPublicKey#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#2)]
 [!code-csharp[AssemblyName_SetPublicKey#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#2)]
 [!code-vb[AssemblyName_SetPublicKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AssemblyName.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_AssemblyName::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._AssemblyName.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._AssemblyName.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="assemblyName.System.Runtime.InteropServices._AssemblyName.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="ceb7f-289">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-289">Reserved for future use.</span></span> <span data-ttu-id="ceb7f-290">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-290">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="ceb7f-291">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-291">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="ceb7f-292">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-292">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="ceb7f-293">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-293">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="ceb7f-294">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-294">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="ceb7f-295">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-295">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-296">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-296">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ceb7f-297">有关的详细信息 `IDispatch::GetIDsOfNames` ，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-297">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ceb7f-298">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-298">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AssemblyName.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_AssemblyName::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._AssemblyName.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._AssemblyName.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="assemblyName.System.Runtime.InteropServices._AssemblyName.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="ceb7f-299">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-299">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="ceb7f-300">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-300">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="ceb7f-301">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-301">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="ceb7f-302">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-302">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-303">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-303">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ceb7f-304">有关的详细信息 `IDispatch::GetTypeInfo` ，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-304">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ceb7f-305">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-305">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AssemblyName.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_AssemblyName::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount : uint32 -&gt; unit" Usage="assemblyName.System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="ceb7f-306">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-306">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="ceb7f-307">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-307">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-308">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-308">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ceb7f-309">有关的详细信息 `IDispatch::GetTypeInfoCount` ，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-309">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ceb7f-310">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-310">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AssemblyName.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_AssemblyName::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._AssemblyName.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._AssemblyName.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="assemblyName.System.Runtime.InteropServices._AssemblyName.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="ceb7f-311">标识成员。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-311">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="ceb7f-312">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-312">Reserved for future use.</span></span> <span data-ttu-id="ceb7f-313">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-313">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="ceb7f-314">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-314">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="ceb7f-315">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-315">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="ceb7f-316">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DispID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-316">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="ceb7f-317">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-317">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="ceb7f-318">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-318">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="ceb7f-319">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-319">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="ceb7f-320">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-320">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-321">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-321">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ceb7f-322">有关的详细信息 `IDispatch::Invoke` ，请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-322">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ceb7f-323">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-323">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assemblyName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ceb7f-324">返回程序集的全名，即所谓的显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-324">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="ceb7f-325">程序集的全名；如果不能确定程序集的全名，则为类名。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-325">The full name of the assembly, or the class name if the full name cannot be determined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-326">请参阅的说明， <xref:System.Reflection.AssemblyName> 了解返回的字符串的格式。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-326">See the description of <xref:System.Reflection.AssemblyName> for the format of the returned string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-327">下面的示例获取 <xref:System.Reflection.AssemblyName> 假想程序集的对象 `MyAssembly.exe` ，然后使用 <xref:System.Reflection.AssemblyName.ToString%2A> 方法检索完整的程序集名称或显示名称。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-327">The following example gets an <xref:System.Reflection.AssemblyName> object for a hypothetical `MyAssembly.exe` assembly, and then uses the <xref:System.Reflection.AssemblyName.ToString%2A> method to retrieve the full assembly name, or display name.</span></span>  
  
 [!code-cpp[AssemblyName_GetAssemblyName#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#2)]
 [!code-csharp[AssemblyName_GetAssemblyName#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#2)]
 [!code-vb[AssemblyName_GetAssemblyName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Version" />
      <MemberSignature Language="VB.NET" Value="Public Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ Version { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version with get, set" Usage="System.Reflection.AssemblyName.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-328">获取或设置程序集的主版本号、次版本号、内部版本号和修订号。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-328">Gets or sets the major, minor, build, and revision numbers of the assembly.</span></span></summary>
        <value><span data-ttu-id="ceb7f-329">一个对象，表示程序集的主版本号、次版本号、内部版本号和修订号。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-329">An object that represents the major, minor, build, and revision numbers of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-330">版本的所有组件都必须是大于或等于零的整数。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-330">All components of the version must be integers greater than or equal to zero.</span></span> <span data-ttu-id="ceb7f-331">元数据将程序集的主要版本号、次要版本号、内部版本号和修订版本限制为最大值 <xref:System.UInt16.MaxValue?displayProperty=nameWithType> -1。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-331">Metadata restricts the major, minor, build, and revision components for an assembly to a maximum value of <xref:System.UInt16.MaxValue?displayProperty=nameWithType> - 1.</span></span> <span data-ttu-id="ceb7f-332">如果某个组件超出此值，则不会引发错误;但在动态程序集中，该组件为零。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-332">If a component exceeds this value, no error is thrown; however, in a dynamic assembly, that component is zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ceb7f-333">本部分包含两个示例。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-333">This section contains two examples.</span></span> <span data-ttu-id="ceb7f-334">第一个示例演示如何检索当前正在执行的程序集的版本。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-334">The first example shows how to retrieve the version of the currently executing assembly.</span></span> <span data-ttu-id="ceb7f-335">第二个示例演示如何使用 <xref:System.Reflection.AssemblyName.Version%2A> 属性在发出动态程序集时指定程序集版本。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-335">The second example shows how to use the <xref:System.Reflection.AssemblyName.Version%2A> property to specify the assembly version when you emit a dynamic assembly.</span></span>  
  
 <span data-ttu-id="ceb7f-336">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="ceb7f-336">**Example 1**</span></span>  
  
 <span data-ttu-id="ceb7f-337">下面的示例检索并显示当前正在执行的程序集和包含该类的程序集的版本号 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-337">The following example retrieves and displays the version numbers of the currently executing assembly and the assembly that contains the <xref:System.String> class.</span></span>  
  
 [!code-cpp[AssemblyName.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName.Version/cpp/Example.cpp#1)]
 [!code-csharp[AssemblyName.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName.Version/cs/Example.cs#1)]
 [!code-vb[AssemblyName.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName.Version/vb/Example.vb#1)]  
  
 <span data-ttu-id="ceb7f-338">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="ceb7f-338">**Example 2**</span></span>  
  
 <span data-ttu-id="ceb7f-339">下面的示例将发出一个动态程序集，并将其保存到当前目录中。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-339">The following example emits a dynamic assembly and saves it to the current directory.</span></span> <span data-ttu-id="ceb7f-340">创建程序集后， <xref:System.Reflection.AssemblyName.Version%2A> 属性用于指定程序集的版本信息。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-340">When the assembly is created, the <xref:System.Reflection.AssemblyName.Version%2A> property is used to specify version information for the assembly.</span></span>  
  
 [!code-cpp[AssemblyName_Constructor#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#3)]
 [!code-csharp[AssemblyName_Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#3)]
 [!code-vb[AssemblyName_Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionCompatibility">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Property VersionCompatibility As AssemblyVersionCompatibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::Assemblies::AssemblyVersionCompatibility VersionCompatibility { System::Configuration::Assemblies::AssemblyVersionCompatibility get(); void set(System::Configuration::Assemblies::AssemblyVersionCompatibility value); };" />
      <MemberSignature Language="F#" Value="member this.VersionCompatibility : System.Configuration.Assemblies.AssemblyVersionCompatibility with get, set" Usage="System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyVersionCompatibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ceb7f-341">获取或设置与程序集同其他程序集的兼容性相关的信息。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-341">Gets or sets the information related to the assembly's compatibility with other assemblies.</span></span></summary>
        <value><span data-ttu-id="ceb7f-342">一个值，表示有关程序集同其他程序集的兼容性的信息。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-342">A value that represents information about the assembly's compatibility with other assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ceb7f-343"><xref:System.Reflection.AssemblyName.VersionCompatibility%2A> 例如，指示程序集无法与其他版本并行执行，因为设备驱动程序发生冲突。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-343"><xref:System.Reflection.AssemblyName.VersionCompatibility%2A> information indicates, for example, that the assembly cannot execute side-by-side with other versions due to conflicts over a device driver.</span></span>  
  
 <span data-ttu-id="ceb7f-344">当前， <xref:System.Reflection.AssemblyName.VersionCompatibility%2A> 始终返回 <xref:System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine?displayProperty=nameWithType> ，且不由加载程序使用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-344">Currently, <xref:System.Reflection.AssemblyName.VersionCompatibility%2A> always returns <xref:System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine?displayProperty=nameWithType>, and is not used by the loader.</span></span> <span data-ttu-id="ceb7f-345">此属性保留供将来使用。</span><span class="sxs-lookup"><span data-stu-id="ceb7f-345">This property is reserved for a future feature.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
