<Type Name="TypeDelegator" FullName="System.Reflection.TypeDelegator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7fa283bee7a83dae94f8ed53ef205f90c5ed72d6" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86989022" /></Metadata><TypeSignature Language="C#" Value="public class TypeDelegator : System.Reflection.TypeInfo" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.TypeDelegator" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDelegator&#xA;Inherits TypeInfo" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDelegator : System::Reflection::TypeInfo" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type TypeDelegator = class&#xA;    inherit TypeInfo" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public class TypeDelegator : Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDelegator&#xA;Inherits Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDelegator : Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="F#" Value="type TypeDelegator = class&#xA;    inherit Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>包装 <see cref="T:System.Type" /> 对象并将所有方法委托给该 <see langword="Type" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从此类型派生并仅重写你必须提供自定义项的成员以及程序所需的所有成员，以及尚未实现的任何成员 <xref:System.Reflection.TypeDelegator> 。  
  
 <xref:System.Reflection.TypeDelegator> 派生自 <xref:System.Type?displayProperty=nameWithType> 并实现的大多数属性和方法 <xref:System.Type> 。 对于它实现的每个成员， <xref:System.Reflection.TypeDelegator> 会自动委托给内部对象的相应成员 <xref:System.Type> ，后者作为参数提供给构造函数。 此内部 <xref:System.Type> 对象公开用于按字段派生类 `protected` <xref:System.Reflection.TypeDelegator.typeImpl> 。  
  
> [!NOTE]
>  的某些成员 <xref:System.Reflection.TypeDelegator> 具有实现，即使成员本身只是从继承 <xref:System.Type> 。 在这些情况下，实现由 `protected` 名称以 "Impl" 结尾的重写方法提供。 例如，方法的所有重载的实现 <xref:System.Reflection.TypeDelegator.GetMethods%2A> 由重写的 <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> 方法提供。 被 <xref:System.Type.IsPublic%2A> <xref:System.Type.IsNestedAssembly%2A> 重写的方法提供了继承的属性（如和）的实现 <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> 。  
  
 派生类可以提供一个公共构造函数，该构造函数采用 <xref:System.Type> 对象作为其参数，只将该对象传递给 <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> 构造函数，也可以通过 <xref:System.Type> 其他方式设置内部对象。  
  
 如果派生类使用未由实现的成员 <xref:System.Reflection.TypeDelegator> ，则它必须重写该成员并提供实现。 最简单的实现是在由字段公开的内部对象上调用相应的成员 <xref:System.Type> <xref:System.Reflection.TypeDelegator.typeImpl> ，但你可以提供应用程序所需的任何实现。 如果你的应用程序或应用程序调用的库函数未使用这些成员，则不必重写它们 (例如，由 <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> 构造函数) 。  
  
 以下虚方法 `Overridable` 不是由实现 Visual Basic) 中 (方法 <xref:System.Type> <xref:System.Reflection.TypeDelegator> ： <xref:System.Type.MakeGenericType%2A> 、 <xref:System.Type.GetGenericTypeDefinition%2A> 、 <xref:System.Type.GetGenericArguments%2A> 、 <xref:System.Type.GetGenericParameterConstraints%2A> 、 <xref:System.Type.MakeArrayType%2A> <xref:System.Type.MakeByRefType%2A> <xref:System.Type.MakePointerType%2A> <xref:System.Type.GetEnumNames%2A> <xref:System.Type.GetEnumValues%2A> <xref:System.Type.GetEnumUnderlyingType%2A> <xref:System.Type.GetTypeCodeImpl%2A> <xref:System.Type.IsEnumDefined%2A> <xref:System.Type.IsEquivalentTo%2A> 、、、、、、、、。  
  
 以下虚拟属性 (`Overridable` Visual Basic) 中的属性 <xref:System.Type> 不是由以下项实现 <xref:System.Reflection.TypeDelegator> ： <xref:System.Type.IsGenericType%2A> 、 <xref:System.Type.IsGenericTypeDefinition%2A> 、 <xref:System.Type.IsGenericParameter%2A> 、 <xref:System.Type.ContainsGenericParameters%2A> 、 <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.GenericParameterAttributes%2A> <xref:System.Type.GenericParameterPosition%2A> <xref:System.Type.IsSecurityCritical%2A> <xref:System.Type.IsSecuritySafeCritical%2A> <xref:System.Type.IsSecurityTransparent%2A> 、、、、和。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDelegator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDelegator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用默认属性初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeDelegator (Type delegatingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type delegatingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delegatingType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeDelegator(Type ^ delegatingType);" />
      <MemberSignature Language="F#" Value="new System.Reflection.TypeDelegator : Type -&gt; System.Reflection.TypeDelegator" Usage="new System.Reflection.TypeDelegator delegatingType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="delegatingType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegatingType"><see cref="T:System.Type" /> 类的实例，它封装对对象方法的调用。</param>
        <summary>在指定封装实例的情况下，初始化 <see cref="T:System.Reflection.TypeDelegator" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数从类中调用，以根据 `Type` 定义方法的类的对象生成委托。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegatingType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.TypeDelegator.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已实现类型的程序集。</summary>
        <value>表示已实现类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集是公共语言运行时中的部署单元。 程序集建立用于解析请求的命名空间，并确定哪些资源在外部公开，哪些资源可从程序集内访问。 公共语言运行时可以为任何正在运行的对象确定和定位程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string? AssemblyQualifiedName { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取程序集的完全限定名。</summary>
        <value>包含程序集的完全限定名的 <see langword="String" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type? BaseType { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.TypeDelegator.BaseType" />
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前类型的基类型。</summary>
        <value>类型的基类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类型是此类型直接从中继承的类型。 由于 <xref:System.Object> 类类型是所有其他类型的最终基类，因此它是唯一没有基类型的类型。 在这种情况下， `null` 将作为类型的基类型返回 `Object` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string? FullName { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.TypeDelegator.FullName" />
      <MemberSignature Language="C#" Value="public override string FullName { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已实现类型的完全限定名。</summary>
        <value>包含类型的完全限定名的 <see langword="String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含当前的完全限定名的字符串 `TypeDelegator` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeDelegator.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取分配给 <see langword="TypeDelegator" /> 的属性。</summary>
        <returns>表示实现属性标志的 <see langword="TypeAttributes" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于确定 `TypeDelegator` 是抽象的、公共的，等等。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[]? types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetConstructorImpl (bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeDelegator.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</param>
        <param name="callConvention">调用约定。</param>
        <param name="types"><see langword="Type" /> 类型的数组，包含参数数量、顺序和类型的列表。 类型不能为 <see langword="null" />；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</param>
        <param name="modifiers"><see langword="ParameterModifier" /> 类型的数组，它与 <paramref name="types" /> 数组的长度相同，后者的元素表示与要获取的方法的参数关联的属性。</param>
        <summary>获取实现 <see langword="TypeDelegator" /> 的构造函数。</summary>
        <returns>此方法的匹配指定判据的 <see langword="ConstructorInfo" /> 对象；如果无法找到匹配项，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callConvention`参数指示入口点的调用约定。 如果未指定调用约定， <xref:System.Reflection.CallingConventions> 则使用的默认值 `Standard` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeDelegator.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，这些对象表示为当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型定义的构造函数。</summary>
        <returns><see langword="ConstructorInfo" /> 类型的数组，包含为此类定义的指定的构造函数。 如果未定义任何构造函数，则返回一个空数组。 根据指定参数的值，只返回公共构造函数或同时返回公共和非公共构造函数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类初始值设定项仅在 `GetMember` 、 `GetMembers` 、 `FindMembers` 和中可用 `GetConstructors` 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回为此类型定义的所有自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeDelegator.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">指定是否搜索此类型的继承链以查找这些属性。</param>
        <summary>返回为此类型定义的所有自定义属性，并指定是否搜索此类型的继承链。</summary>
        <returns>一个包含为此类型定义的所有自定义属性的对象数组。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">无法加载自定义属性类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeDelegator.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">由类型标识的自定义属性数组。</param>
        <param name="inherit">指定是否搜索此类型的继承链以查找这些属性。</param>
        <summary>返回由类型标识的自定义属性数组。</summary>
        <returns>一个对象数组，包含此类型中定义的与 <paramref name="attributeType" /> 参数匹配的自定义属性，并指定是否搜索此类型的继承链；如果在此类型上未定义自定义属性，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">无法加载自定义属性类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeDelegator.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由当前数组、指针或 ByRef 包含或引用的对象的 <see cref="T:System.Type" />。</summary>
        <returns>由当前数组、指针或 <see langword="ByRef" /> 包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see cref="T:System.Type" /> 不是数组、指针或 <see langword="null" />，则为 <see langword="ByRef" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo? GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeDelegator.GetEvent (name, bindingAttr)" />
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要获取的事件的名称。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回指定事件。</summary>
        <returns><see cref="T:System.Reflection.EventInfo" /> 对象，表示由此类型声明或继承的具有指定名称的事件。 如果未找到此类事件，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `bindingAttr` 为 <xref:System.Reflection.BindingFlags> `IgnoreCase` ，则忽略参数的大小写 `name` 。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，这些对象表示由当前 <see langword="TypeDelegator" /> 声明或继承的所有公共事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeDelegator.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Reflection.EventInfo" /> 对象的数组，这些对象表示由当前 <see langword="TypeDelegator" /> 声明或继承的所有公共事件。</summary>
        <returns>一个数组，其中包含当前类型声明或继承的所有事件。 如果没有事件，则返回空数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeDelegator.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <paramref name="bindingAttr" /> 中指定的由当前 <see langword="TypeDelegator" /> 声明或继承的事件。</summary>
        <returns><see langword="EventInfo" /> 类型的数组，包含 <paramref name="bindingAttr" /> 中指定的事件。 如果没有事件，则返回空数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo? GetField (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeDelegator.GetField (name, bindingAttr)" />
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要查找的字段的名称。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象，该对象表示具有指定名称的字段。</summary>
        <returns><see langword="FieldInfo" /> 对象，表示由此 <see langword="TypeDelegator" /> 声明或继承的具有指定名称的字段。 如果未找到这样的字段，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 `bindingAttr` 的 <xref:System.Reflection.BindingFlags> 。非公共，返回所有公共和非公共字段。 用于 `BindingFlags.IgnoreCase` 忽略字段的大小写，因为默认情况下搜索区分大小写。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeDelegator.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <see cref="T:System.Reflection.FieldInfo" /> 对象的数组，这些对象表示为当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型定义的数据字段。</summary>
        <returns><see langword="FieldInfo" /> 类型的数组，包含由当前 <see langword="TypeDelegator" /> 声明或继承的字段。 如果没有匹配的字段，则返回空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeDelegator.GetFields%2A>方法不按特定顺序（如字母顺序或声明顺序）返回字段。 你的代码不能依赖于字段的返回顺序，因为该顺序可能会有所不同。  
  
 使用 `bindingAttr` 的 <xref:System.Reflection.BindingFlags> 。非公共，返回所有公共和非公共字段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type? GetInterface (string name, bool ignoreCase);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeDelegator.GetInterface (name, ignoreCase)" />
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">由当前类实现的接口的完全限定名。</param>
        <param name="ignoreCase">如果忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>返回由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型实现的指定接口。</summary>
        <returns><see langword="Type" /> 对象，表示由当前类（直接或间接）实现的具有匹配指定名称的完全限定名的接口。 如果未找到匹配名称的接口，则返回 null。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeDelegator.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要检索其映射的接口的 <see cref="T:System.Type" />。</param>
        <summary>返回指定接口类型的接口映射。</summary>
        <returns>表示 <paramref name="interfaceType" /> 的接口映射的 <see cref="T:System.Reflection.InterfaceMapping" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接口映射表示接口如何映射到实现该接口的类上的实际方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeDelegator.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回在当前类及其基类上实现的所有接口。</summary>
        <returns><see langword="Type" /> 类型的数组，包含在当前类及其基类上实现的所有接口。 如果未定义任何内容，则返回一个空数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeDelegator.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">要获取的成员名称。</param>
        <param name="type">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <param name="bindingAttr">要获取的成员类型。</param>
        <summary>返回由给定的 <paramref name="name" />、<paramref name="type" /> 和 <paramref name="bindingAttr" /> 指定的成员（属性、方法、构造函数、字段、事件和嵌套类型）。</summary>
        <returns><see langword="MemberInfo" /> 类型的数组，包含当前类及其基类的符合指定条件的所有成员。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `bindingAttr` 为 <xref:System.Reflection.BindingFlags> 。非公共的，所有成员都将被视为。 如果没有匹配项，则返回空数组。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeDelegator.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回由 <paramref name="bindingAttr" /> 指定的成员。</summary>
        <returns><see langword="MemberInfo" /> 类型的数组，包含当前类及其基类的符合 <paramref name="bindingAttr" /> 筛选器的所有成员。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `bindingAttr` 为 <xref:System.Reflection.BindingFlags> 。非公共的，所有成员都将被视为。 如果没有匹配项，则返回空数组。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string? name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[]? types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetMethodImpl (name As String, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeDelegator.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">方法名称。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</param>
        <param name="callConvention">调用约定。</param>
        <param name="types"><see langword="Type" /> 类型的数组，包含参数数量、顺序和类型的列表。 类型不能为 <see langword="null" />；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</param>
        <param name="modifiers"><see langword="ParameterModifier" /> 类型的数组，它与 <paramref name="types" /> 数组的长度相同，后者的元素表示与要获取的方法的参数关联的属性。</param>
        <summary>用指定的绑定约束和指定的调用约定，搜索参数与指定的参数类型及修饰符相匹配的指定方法。</summary>
        <returns>匹配指定条件的实现方法的 <see langword="MethodInfoInfo" /> 对象；如果无法找到匹配项，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callConvention`参数指示入口点的调用约定。 如果未 <xref:System.Reflection.CallingConventions> 指定， `CallingConventions` 则使用的默认值 `Standard` 。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeDelegator.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <see cref="T:System.Reflection.MethodInfo" /> 对象的数组，这些对象表示由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型的指定方法。</summary>
        <returns><see langword="MethodInfo" /> 对象的数组，表示在此 <see langword="TypeDelegator" /> 上定义的方法。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type? GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeDelegator.GetNestedType (name, bindingAttr)" />
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">嵌套类型的名称。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回由 <paramref name="name" /> 指定的嵌套类型，并且该嵌套类型是在 <paramref name="bindingAttr" /> 中指定的、由当前 <see cref="T:System.Reflection.TypeDelegator" /> 表示的类型来声明或继承。</summary>
        <returns>表示嵌套类型的 <see langword="Type" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeDelegator.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回嵌套类型，这些嵌套类型是在 <paramref name="bindingAttr" /> 中指定的，并且由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型来声明或继承。</summary>
        <returns>包含嵌套类型的 <see langword="Type" /> 类型数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeDelegator.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <summary>返回 <see cref="T:System.Reflection.PropertyInfo" /> 对象的数组，这些对象表示由当前 <see cref="T:System.Reflection.TypeDelegator" /> 包装的类型的属性。</summary>
        <returns><see langword="PropertyInfo" /> 对象的数组，表示在此 <see langword="TypeDelegator" /> 上定义的属性。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string? name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[]? types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetPropertyImpl (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeDelegator.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">要获取的属性。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 该值是零个或多个来自 <see cref="T:System.Reflection.BindingFlags" /> 的位标志的组合。</param>
        <param name="binder">一个对象，它启用绑定、对自变量类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。 请参阅 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">参数类型的列表。 此列表表示参数的数目、顺序和类型。 类型不能为 null；使用相应的 <see langword="GetMethod" /> 方法或空数组搜索不带参数的方法。</param>
        <param name="modifiers">长度与 types 相同的数组，其元素表示与要获取的方法参数关联的属性。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的参数类型和修饰符匹配的指定属性。</summary>
        <returns>此属性的匹配指定条件的 <see cref="T:System.Reflection.PropertyInfo" /> 对象；如果无法找到匹配，则为 null。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.TypeDelegator.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已实现类型的 GUID（全局唯一标识符）。</summary>
        <value>一个 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID (全局唯一标识符) 是用于标识类或接口的128位唯一标识字符串。 它主要用于 Microsoft .NET 框架与 COM 之间的互操作性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeDelegator.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否包含或引用其他类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是 ByRef。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是数组、指针或 ByRef，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string? name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[]? namedParameters);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, namedParameters As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeDelegator.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">要调用的成员的名称。 这可能是一个构造函数、方法、属性或字段。 如果传递了空字符串 ("")，则调用默认成员。</param>
        <param name="invokeAttr">调用属性。 这必须是下列之一：<see cref="T:System.Reflection.BindingFlags" />、<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="Static" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。 必须指定合适的调用属性。 如果要调用静态成员，则必须设置 <see langword="Static" /> 标志。</param>
        <param name="binder">一个对象，它启用绑定、对自变量类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。 请参阅 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args"><see langword="Object" /> 类型的数组，包含要调用的成员参数的数目、顺序和类型。 如果 <paramref name="args" /> 包含未初始化的 <see langword="Object" />，则它被视为空，用默认联编程序可将它扩展为 0、0.0 或一个字符串。</param>
        <param name="modifiers"><see langword="ParameterModifier" /> 类型的数组，其长度与 <paramref name="args" /> 相同，其元素表示与要调用的成员参数关联的属性。 参数在成员的签名中有与其关联的属性。 对于 ByRef，请使用 <see langword="ParameterModifier.ByRef" />；对于空，请使用 <see langword="ParameterModifier.None" />。 默认联编程序执行与这些内容的精确匹配。 <see langword="In" /> 和 <see langword="InOut" /> 这样的属性不用于绑定，可以使用 <see langword="ParameterInfo" /> 查看它们。</param>
        <param name="culture">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。 类型强制在某些情况下是必要的，例如将表示 1000 的字符串转换为 <see cref="T:System.Double" /> 值，因为不同的区域性表示 1000 的方式不同。 如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" /> 的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="namedParameters">一个字符串数组，其中包含与数组匹配的参数名（从元素零开始） <paramref name="args" /> 。 数组中不能有空缺。 如果 <paramref name="args" />. <see langword="Length" /> 大于 <paramref name="namedParameters" />。 <see langword="Length" />，则按顺序填充剩余的参数。</param>
        <summary>调用指定的成员。 在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</summary>
        <returns>表示被调用成员的返回值的 <see langword="Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果以下两个条件均为 true，则将调用方法：  
  
-   方法声明中的参数数目等于指定参数列表中的参数数目 (除非在成员) 上定义默认参数。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于)  (、等请求的绑定类型 `BindingFlags.MethodInvoke` `BindingFlags.GetProperties` 。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后，将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法负责选择要调用的方法。 默认联编程序将选择最特定的匹配项。  
  
> [!NOTE]
>  对于完全受信任的代码，将忽略访问限制。 也就是说，只要代码完全受信任，就可以使用反射来访问和调用私有构造函数、方法、字段和属性。  
  
 目前， `InvokeMember` 对每种类型的对象执行 Microsoft .NET Framework 反射语义。  
  
 如果按名称指定的成员是数组，并且 `BindingFlags.GetField` 标志设置为 on `invokeAttr` ，则 `args` 数组指定要返回其值的元素。 例如，下面的通过对象调用 `Type` `t` 返回字符串数组 MyArray 的第一个元素的值，该元素是调用对象的成员：  
  
 `String ret = (String) t.InvokeMember ("MyArray", BindingFlags.GetField, null, this, new Variant[]{0});`  
  
 您可以使用 `InvokeMember` 来设置成员数组的一个或多个元素。 所有元素都设置为相同的值。 该 `args` 数组的格式必须如下所示：  
  
```  
{index1,  
    index2,, value}  
```  
  
 例如，若要设置上一示例中 MyArray 的第一个成员，则语法如下所示：  
  
```csharp  
t.InvokeMember ("MyArray", BindingFlags.SetField, null, this, new  
    Variant[]{0,"Updated"});  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeDelegator.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Type" /> 是否为数组。</summary>
        <returns>如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (typeInfo As TypeInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeDelegator.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeInfo">要检查的类型。</param>
        <summary>返回一个值，该值指示指定类型是否可分配给此类型。</summary>
        <returns>如果可以将指定类型分配给此类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeDelegator.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回指示 <see cref="T:System.Type" /> 是否由引用传递的值。</summary>
        <returns>如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public override bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.TypeDelegator.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此对象的 <see cref="F:System.Reflection.TypeDelegator.typeImpl" /> 的 <see cref="P:System.Reflection.MemberInfo.IsCollectible" /> 值，该值指示此对象（为一个 <see cref="T:System.Reflection.MemberInfo" /> 实现）是否是可回收 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 中保存的程序集的一部分。</summary>
        <value><see langword="true" /> 如果此对象是一个 <see cref="T:System.Reflection.MemberInfo" /> 实现，则它是保存在可回收程序集加载上下文中的程序集的一部分; 否则为 <see langword="false" /> 。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeDelegator.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <returns>如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示此对象是否表示构造的泛型类型的值。</summary>
        <value>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeDelegator.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">指定是否搜索此类型的继承链以查找这些属性。</param>
        <param name="inherit">由类型标识的自定义属性数组。</param>
        <summary>指示是否定义由 <paramref name="attributeType" /> 标识的自定义属性。</summary>
        <returns>如果定义由 <paramref name="attributeType" /> 标识的自定义属性，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">无法加载自定义特性类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeDelegator.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Type" /> 是否为指针。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeDelegator.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <returns>如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.TypeDelegator.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeDelegator.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示此类型是否为值类型（即不是类或接口）。</summary>
        <returns>如果该类型是值类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.TypeDelegator.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个标识元数据中的此实体的值。</summary>
        <value>一个值，与模块一起来唯一标识元数据中的此实体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性获取的令牌可传递给非托管反射 API。 有关详细信息，请参阅 [非托管反射 API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.TypeDelegator.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含已实现类型的模块。</summary>
        <value>表示已实现类型的模块的 <see cref="T:System.Reflection.Module" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 模块是一个可加载单元，它可以包含类型声明和实现。 模块包含的信息足以使公共语言运行时在模块加载时找到所有的实现位。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.TypeDelegator.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取移除了路径的已实现类型的名称。</summary>
        <value>包含类型的非限定名的 <see langword="String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含当前 `TypeDelegator` 名称的字符串。 仅返回简单名称，而不是完全限定名称。 若要获取名称和路径，请使用 <xref:System.Reflection.TypeDelegator.FullName%2A> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string? Namespace { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.TypeDelegator.Namespace" />
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已实现类型的命名空间。</summary>
        <value>包含类型的命名空间的 <see langword="String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性获取包含当前的命名空间的字符串 `TypeDelegator` 。 例如，如果 `TypeDelegator` 为 <xref:System.Reflection.TypeFilter> ，则返回的命名空间为 <xref:System.Reflection> 。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.TypeDelegator.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已实现类型的内部元数据表示形式的句柄。</summary>
        <value><see langword="RuntimeTypeHandle" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类型句柄是与每个类型相关联的唯一整数值。 该句柄在运行时中是唯一的。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.RuntimeTypeHandle" />
      </Docs>
    </Member>
    <Member MemberName="typeImpl">
      <MemberSignature Language="C#" Value="protected Type typeImpl;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type typeImpl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.TypeDelegator.typeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected typeImpl As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ typeImpl;" />
      <MemberSignature Language="F#" Value="val mutable typeImpl : Type" Usage="System.Reflection.TypeDelegator.typeImpl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>一个指示类型信息的值。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示已实现类型的基础 <see cref="T:System.Type" />。</summary>
        <value>基础类型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
